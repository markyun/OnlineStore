/*
 * Title: fish.js
 * Description: fish.js
 * Author: huang.xinghui
 * Created Date: 14-2-24 下午3:05
 * Copyright: Copyright 2013 ZTESOFT, Inc.
 */
/**
 * 全局静态对象，很多工具类挂在此对象下。
 * @singleton
 * @class fish.desktop.fish
 */
! function() {

    // //所有ajax请求都加上遮罩
    // $( document ).ajaxStart(function() {
    //     $.blockUI && $.blockUI();
    // });
    // $( document ).ajaxStop(function() {
    //     $.unblockUI && $.unblockUI();
    // });

    var fish = window.fish = {
        'version': '1.3.1',
        'language': 'en',
        'locale': {}, //国际化资源会在此文件后面加载
        /**
         * 获取资源文件
         * @method getResource
         * @param {String} key key
         * @return {String} 如果没有找到则返回'UNKNOWN_KEY_' + key
         */
        'getResource': function(key) {
            if (!key) return '';
            var result = this.locale[this.language];
            var keys = key.split('.');
            for (var i = 0, n = keys.length; i < n; i++) {
                result = result[keys[i]];
                if (!result) {
                    result = 'UNKNOWN_KEY_' + key;
                    break;
                }
            }
            return result;
        }
    };

    /**
     * fish封装的ajax方法,提供默认的遮罩和错误提示;局部遮罩可自行实现
     * @method ajax
     * @param {Object} options 支持原生的所有ajax参数及回调方法.新增 showMask:false 是否采用默认的全局遮罩,新增showError:true 采用默认的错误提示
     * @return {Object} 返回原生ajax对象,支持promise等方式调用
     */
    //框架使用代理模式,避免用户直接覆盖beforeSend,complete,error
    fish._active=0;//计数器,保证任意多个ajax请求页面上只有一个全局遮罩
    fish.ajax = function(options) {
        options = $.extend({
            showMask:false,//是否采用默认的全局遮罩
            showError:true,//是否采用默认的错误提示
            type: "post",
            dataType:"json"
        },options);

        var oldBeforeSend = options.beforeSend;
        options.beforeSend = function(xhr, status) {
            var context = options.context || this;
            if(oldBeforeSend && oldBeforeSend.apply(context, [xhr, status]) === false) return false;
            if(options.showMask===true && fish._active++ === 0){
                $.blockUI && $.blockUI();
            }
        };
        var oldComplete = options.complete;
        options.complete = function(xhr, status) {
            var context = options.context || this;
            oldComplete && oldComplete.apply(context, [xhr, status]);
            if(options.showMask===true && (--fish._active === 0)){
                $.unblockUI && $.unblockUI();
            }
        };

        var oldError = options.error;
        options.error = function(xhr) {
            var context = options.context || this;
            oldError && oldError.apply(context, [xhr]);
            if(options.showError!==true) return ;
            var tip = "";
            if (xhr.responseText == null || xhr.responseText == "") {
                tip = "XHR Error, readystate=" + xhr.readyState + ", status=" + xhr.status;
            } else {
                var txt = xhr.responseText;
                if ((txt.indexOf("{") == 0) && (txt.lastIndexOf("}") == (txt.length - 1))) {
                    var error = eval("(" + txt + ")");
                    tip = error.code + " : " + error.message;
                }else{
                    tip = txt;
                }
            }
            fish.showError(tip);
        };

        return $.ajax(options);
    }

    /**
     * 提供方法的延迟操作,产生全局遮罩.一般用于初始化页面;初始化方法执行之前加上遮罩,结束之后取消遮罩
     * @method delay(wait)
     * @param  {Function} func 要执行的函数,执行期间会参数全局遮罩
     * @return {Object}    要执行的函数的返回值
     */
    fish.delay = fish.wait = function(func) {
        if(!$.isFunction(func)) return;
        if(fish._active++ === 0){
            $.blockUI && $.blockUI();
        }
        var args = Array.prototype.slice.call(arguments, 1);
        return setTimeout(function() {
            var result = func.apply(null, args);
            if (--fish._active === 0) {
                $.unblockUI && $.unblockUI();
            }
            return result;
        }, 100);
    }


    return fish;
}();

/*!

 handlebars v1.3.0

Copyright (C) 2011 by Yehuda Katz

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

@license
*/
/* exported Handlebars */
var Handlebars = (function() {
// handlebars/safe-string.js
var __module4__ = (function() {
  "use strict";
  var __exports__;
  // Build out our basic SafeString type
  function SafeString(string) {
    this.string = string;
  }

  SafeString.prototype.toString = function() {
    return "" + this.string;
  };

  __exports__ = SafeString;
  return __exports__;
})();

// handlebars/utils.js
var __module3__ = (function(__dependency1__) {
  "use strict";
  var __exports__ = {};
  /*jshint -W004 */
  var SafeString = __dependency1__;

  var escape = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;",
    "'": "&#x27;",
    "`": "&#x60;"
  };

  var badChars = /[&<>"'`]/g;
  var possible = /[&<>"'`]/;

  function escapeChar(chr) {
    return escape[chr] || "&amp;";
  }

  function extend(obj, value) {
    for(var key in value) {
      if(Object.prototype.hasOwnProperty.call(value, key)) {
        obj[key] = value[key];
      }
    }
  }

  __exports__.extend = extend;var toString = Object.prototype.toString;
  __exports__.toString = toString;
  // Sourced from lodash
  // https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
  var isFunction = function(value) {
    return typeof value === 'function';
  };
  // fallback for older versions of Chrome and Safari
  if (isFunction(/x/)) {
    isFunction = function(value) {
      return typeof value === 'function' && toString.call(value) === '[object Function]';
    };
  }
  var isFunction;
  __exports__.isFunction = isFunction;
  var isArray = Array.isArray || function(value) {
    return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
  };
  __exports__.isArray = isArray;

  function escapeExpression(string) {
    // don't escape SafeStrings, since they're already safe
    if (string instanceof SafeString) {
      return string.toString();
    } else if (!string && string !== 0) {
      return "";
    }

    // Force a string conversion as this will be done by the append regardless and
    // the regex test will do this transparently behind the scenes, causing issues if
    // an object's to string has escaped characters in it.
    string = "" + string;

    if(!possible.test(string)) { return string; }
    return string.replace(badChars, escapeChar);
  }

  __exports__.escapeExpression = escapeExpression;function isEmpty(value) {
    if (!value && value !== 0) {
      return true;
    } else if (isArray(value) && value.length === 0) {
      return true;
    } else {
      return false;
    }
  }

  __exports__.isEmpty = isEmpty;
  return __exports__;
})(__module4__);

// handlebars/exception.js
var __module5__ = (function() {
  "use strict";
  var __exports__;

  var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

  function Exception(message, node) {
    var line;
    if (node && node.firstLine) {
      line = node.firstLine;

      message += ' - ' + line + ':' + node.firstColumn;
    }

    var tmp = Error.prototype.constructor.call(this, message);

    // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
    for (var idx = 0; idx < errorProps.length; idx++) {
      this[errorProps[idx]] = tmp[errorProps[idx]];
    }

    if (line) {
      this.lineNumber = line;
      this.column = node.firstColumn;
    }
  }

  Exception.prototype = new Error();

  __exports__ = Exception;
  return __exports__;
})();

// handlebars/base.js
var __module2__ = (function(__dependency1__, __dependency2__) {
  "use strict";
  var __exports__ = {};
  var Utils = __dependency1__;
  var Exception = __dependency2__;

  var VERSION = "1.3.0";
  __exports__.VERSION = VERSION;var COMPILER_REVISION = 4;
  __exports__.COMPILER_REVISION = COMPILER_REVISION;
  var REVISION_CHANGES = {
    1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
    2: '== 1.0.0-rc.3',
    3: '== 1.0.0-rc.4',
    4: '>= 1.0.0'
  };
  __exports__.REVISION_CHANGES = REVISION_CHANGES;
  var isArray = Utils.isArray,
      isFunction = Utils.isFunction,
      toString = Utils.toString,
      objectType = '[object Object]';

  function HandlebarsEnvironment(helpers, partials) {
    this.helpers = helpers || {};
    this.partials = partials || {};

    registerDefaultHelpers(this);
  }

  __exports__.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
    constructor: HandlebarsEnvironment,

    logger: logger,
    log: log,

    registerHelper: function(name, fn, inverse) {
      if (toString.call(name) === objectType) {
        if (inverse || fn) { throw new Exception('Arg not supported with multiple helpers'); }
        Utils.extend(this.helpers, name);
      } else {
        if (inverse) { fn.not = inverse; }
        this.helpers[name] = fn;
      }
    },

    registerPartial: function(name, str) {
      if (toString.call(name) === objectType) {
        Utils.extend(this.partials,  name);
      } else {
        this.partials[name] = str;
      }
    }
  };

  function registerDefaultHelpers(instance) {
    instance.registerHelper('helperMissing', function(arg) {
      if(arguments.length === 2) {
        return undefined;
      } else {
        throw new Exception("Missing helper: '" + arg + "'");
      }
    });

    instance.registerHelper('blockHelperMissing', function(context, options) {
      var inverse = options.inverse || function() {}, fn = options.fn;

      if (isFunction(context)) { context = context.call(this); }

      if(context === true) {
        return fn(this);
      } else if(context === false || context == null) {
        return inverse(this);
      } else if (isArray(context)) {
        if(context.length > 0) {
          return instance.helpers.each(context, options);
        } else {
          return inverse(this);
        }
      } else {
        return fn(context);
      }
    });

    instance.registerHelper('each', function(context, options) {
      var fn = options.fn, inverse = options.inverse;
      var i = 0, ret = "", data;

      if (isFunction(context)) { context = context.call(this); }

      if (options.data) {
        data = createFrame(options.data);
      }

      if(context && typeof context === 'object') {
        if (isArray(context)) {
          for(var j = context.length; i<j; i++) {
            if (data) {
              data.index = i;
              data.first = (i === 0);
              data.last  = (i === (context.length-1));
            }
            ret = ret + fn(context[i], { data: data });
          }
        } else {
          for(var key in context) {
            if(context.hasOwnProperty(key)) {
              if(data) { 
                data.key = key; 
                data.index = i;
                data.first = (i === 0);
              }
              ret = ret + fn(context[key], {data: data});
              i++;
            }
          }
        }
      }

      if(i === 0){
        ret = inverse(this);
      }

      return ret;
    });

    instance.registerHelper('if', function(conditional, options) {
      if (isFunction(conditional)) { conditional = conditional.call(this); }

      // Default behavior is to render the positive path if the value is truthy and not empty.
      // The `includeZero` option may be set to treat the condtional as purely not empty based on the
      // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
      if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
        return options.inverse(this);
      } else {
        return options.fn(this);
      }
    });

    instance.registerHelper('unless', function(conditional, options) {
      return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
    });

    instance.registerHelper('with', function(context, options) {
      if (isFunction(context)) { context = context.call(this); }

      if (!Utils.isEmpty(context)) return options.fn(context);
    });

    instance.registerHelper('log', function(context, options) {
      var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
      instance.log(level, context);
    });
  }

  var logger = {
    methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

    // State enum
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3,
    level: 3,

    // can be overridden in the host environment
    log: function(level, obj) {
      if (logger.level <= level) {
        var method = logger.methodMap[level];
        if (typeof console !== 'undefined' && console[method]) {
          console[method].call(console, obj);
        }
      }
    }
  };
  __exports__.logger = logger;
  function log(level, obj) { logger.log(level, obj); }

  __exports__.log = log;var createFrame = function(object) {
    var obj = {};
    Utils.extend(obj, object);
    return obj;
  };
  __exports__.createFrame = createFrame;
  return __exports__;
})(__module3__, __module5__);

// handlebars/runtime.js
var __module6__ = (function(__dependency1__, __dependency2__, __dependency3__) {
  "use strict";
  var __exports__ = {};
  var Utils = __dependency1__;
  var Exception = __dependency2__;
  var COMPILER_REVISION = __dependency3__.COMPILER_REVISION;
  var REVISION_CHANGES = __dependency3__.REVISION_CHANGES;

  function checkRevision(compilerInfo) {
    var compilerRevision = compilerInfo && compilerInfo[0] || 1,
        currentRevision = COMPILER_REVISION;

    if (compilerRevision !== currentRevision) {
      if (compilerRevision < currentRevision) {
        var runtimeVersions = REVISION_CHANGES[currentRevision],
            compilerVersions = REVISION_CHANGES[compilerRevision];
        throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
              "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
      } else {
        // Use the embedded version info since the runtime doesn't know about this revision yet
        throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
              "Please update your runtime to a newer version ("+compilerInfo[1]+").");
      }
    }
  }

  __exports__.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

  function template(templateSpec, env) {
    if (!env) {
      throw new Exception("No environment passed to template");
    }

    // Note: Using env.VM references rather than local var references throughout this section to allow
    // for external users to override these as psuedo-supported APIs.
    var invokePartialWrapper = function(partial, name, context, helpers, partials, data) {
      var result = env.VM.invokePartial.apply(this, arguments);
      if (result != null) { return result; }

      if (env.compile) {
        var options = { helpers: helpers, partials: partials, data: data };
        partials[name] = env.compile(partial, { data: data !== undefined }, env);
        return partials[name](context, options);
      } else {
        throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
      }
    };

    // Just add water
    var container = {
      escapeExpression: Utils.escapeExpression,
      invokePartial: invokePartialWrapper,
      programs: [],
      program: function(i, fn, data) {
        var programWrapper = this.programs[i];
        if(data) {
          programWrapper = program(i, fn, data);
        } else if (!programWrapper) {
          programWrapper = this.programs[i] = program(i, fn);
        }
        return programWrapper;
      },
      merge: function(param, common) {
        var ret = param || common;

        if (param && common && (param !== common)) {
          ret = {};
          Utils.extend(ret, common);
          Utils.extend(ret, param);
        }
        return ret;
      },
      programWithDepth: env.VM.programWithDepth,
      noop: env.VM.noop,
      compilerInfo: null
    };

    return function(context, options) {
      options = options || {};
      var namespace = options.partial ? options : env,
          helpers,
          partials;

      if (!options.partial) {
        helpers = options.helpers;
        partials = options.partials;
      }
      var result = templateSpec.call(
            container,
            namespace, context,
            helpers,
            partials,
            options.data);

      if (!options.partial) {
        env.VM.checkRevision(container.compilerInfo);
      }

      return result;
    };
  }

  __exports__.template = template;function programWithDepth(i, fn, data /*, $depth */) {
    var args = Array.prototype.slice.call(arguments, 3);

    var prog = function(context, options) {
      options = options || {};

      return fn.apply(this, [context, options.data || data].concat(args));
    };
    prog.program = i;
    prog.depth = args.length;
    return prog;
  }

  __exports__.programWithDepth = programWithDepth;function program(i, fn, data) {
    var prog = function(context, options) {
      options = options || {};

      return fn(context, options.data || data);
    };
    prog.program = i;
    prog.depth = 0;
    return prog;
  }

  __exports__.program = program;function invokePartial(partial, name, context, helpers, partials, data) {
    var options = { partial: true, helpers: helpers, partials: partials, data: data };

    if(partial === undefined) {
      throw new Exception("The partial " + name + " could not be found");
    } else if(partial instanceof Function) {
      return partial(context, options);
    }
  }

  __exports__.invokePartial = invokePartial;function noop() { return ""; }

  __exports__.noop = noop;
  return __exports__;
})(__module3__, __module5__, __module2__);

// handlebars.runtime.js
var __module1__ = (function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__) {
  "use strict";
  var __exports__;
  /*globals Handlebars: true */
  var base = __dependency1__;

  // Each of these augment the Handlebars object. No need to setup here.
  // (This is done to easily share code between commonjs and browse envs)
  var SafeString = __dependency2__;
  var Exception = __dependency3__;
  var Utils = __dependency4__;
  var runtime = __dependency5__;

  // For compatibility and usage outside of module systems, make the Handlebars object a namespace
  var create = function() {
    var hb = new base.HandlebarsEnvironment();

    Utils.extend(hb, base);
    hb.SafeString = SafeString;
    hb.Exception = Exception;
    hb.Utils = Utils;

    hb.VM = runtime;
    hb.template = function(spec) {
      return runtime.template(spec, hb);
    };

    return hb;
  };

  var Handlebars = create();
  Handlebars.create = create;

  __exports__ = Handlebars;
  return __exports__;
})(__module2__, __module4__, __module5__, __module3__, __module6__);

// handlebars/compiler/ast.js
var __module7__ = (function(__dependency1__) {
  "use strict";
  var __exports__;
  var Exception = __dependency1__;

  function LocationInfo(locInfo){
    locInfo = locInfo || {};
    this.firstLine   = locInfo.first_line;
    this.firstColumn = locInfo.first_column;
    this.lastColumn  = locInfo.last_column;
    this.lastLine    = locInfo.last_line;
  }

  var AST = {
    ProgramNode: function(statements, inverseStrip, inverse, locInfo) {
      var inverseLocationInfo, firstInverseNode;
      if (arguments.length === 3) {
        locInfo = inverse;
        inverse = null;
      } else if (arguments.length === 2) {
        locInfo = inverseStrip;
        inverseStrip = null;
      }

      LocationInfo.call(this, locInfo);
      this.type = "program";
      this.statements = statements;
      this.strip = {};

      if(inverse) {
        firstInverseNode = inverse[0];
        if (firstInverseNode) {
          inverseLocationInfo = {
            first_line: firstInverseNode.firstLine,
            last_line: firstInverseNode.lastLine,
            last_column: firstInverseNode.lastColumn,
            first_column: firstInverseNode.firstColumn
          };
          this.inverse = new AST.ProgramNode(inverse, inverseStrip, inverseLocationInfo);
        } else {
          this.inverse = new AST.ProgramNode(inverse, inverseStrip);
        }
        this.strip.right = inverseStrip.left;
      } else if (inverseStrip) {
        this.strip.left = inverseStrip.right;
      }
    },

    MustacheNode: function(rawParams, hash, open, strip, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "mustache";
      this.strip = strip;

      // Open may be a string parsed from the parser or a passed boolean flag
      if (open != null && open.charAt) {
        // Must use charAt to support IE pre-10
        var escapeFlag = open.charAt(3) || open.charAt(2);
        this.escaped = escapeFlag !== '{' && escapeFlag !== '&';
      } else {
        this.escaped = !!open;
      }

      if (rawParams instanceof AST.SexprNode) {
        this.sexpr = rawParams;
      } else {
        // Support old AST API
        this.sexpr = new AST.SexprNode(rawParams, hash);
      }

      this.sexpr.isRoot = true;

      // Support old AST API that stored this info in MustacheNode
      this.id = this.sexpr.id;
      this.params = this.sexpr.params;
      this.hash = this.sexpr.hash;
      this.eligibleHelper = this.sexpr.eligibleHelper;
      this.isHelper = this.sexpr.isHelper;
    },

    SexprNode: function(rawParams, hash, locInfo) {
      LocationInfo.call(this, locInfo);

      this.type = "sexpr";
      this.hash = hash;

      var id = this.id = rawParams[0];
      var params = this.params = rawParams.slice(1);

      // a mustache is an eligible helper if:
      // * its id is simple (a single part, not `this` or `..`)
      var eligibleHelper = this.eligibleHelper = id.isSimple;

      // a mustache is definitely a helper if:
      // * it is an eligible helper, and
      // * it has at least one parameter or hash segment
      this.isHelper = eligibleHelper && (params.length || hash);

      // if a mustache is an eligible helper but not a definite
      // helper, it is ambiguous, and will be resolved in a later
      // pass or at runtime.
    },

    PartialNode: function(partialName, context, strip, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type         = "partial";
      this.partialName  = partialName;
      this.context      = context;
      this.strip = strip;
    },

    BlockNode: function(mustache, program, inverse, close, locInfo) {
      LocationInfo.call(this, locInfo);

      if(mustache.sexpr.id.original !== close.path.original) {
        throw new Exception(mustache.sexpr.id.original + " doesn't match " + close.path.original, this);
      }

      this.type = 'block';
      this.mustache = mustache;
      this.program  = program;
      this.inverse  = inverse;

      this.strip = {
        left: mustache.strip.left,
        right: close.strip.right
      };

      (program || inverse).strip.left = mustache.strip.right;
      (inverse || program).strip.right = close.strip.left;

      if (inverse && !program) {
        this.isInverse = true;
      }
    },

    ContentNode: function(string, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "content";
      this.string = string;
    },

    HashNode: function(pairs, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "hash";
      this.pairs = pairs;
    },

    IdNode: function(parts, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "ID";

      var original = "",
          dig = [],
          depth = 0;

      for(var i=0,l=parts.length; i<l; i++) {
        var part = parts[i].part;
        original += (parts[i].separator || '') + part;

        if (part === ".." || part === "." || part === "this") {
          if (dig.length > 0) {
            throw new Exception("Invalid path: " + original, this);
          } else if (part === "..") {
            depth++;
          } else {
            this.isScoped = true;
          }
        } else {
          dig.push(part);
        }
      }

      this.original = original;
      this.parts    = dig;
      this.string   = dig.join('.');
      this.depth    = depth;

      // an ID is simple if it only has one part, and that part is not
      // `..` or `this`.
      this.isSimple = parts.length === 1 && !this.isScoped && depth === 0;

      this.stringModeValue = this.string;
    },

    PartialNameNode: function(name, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "PARTIAL_NAME";
      this.name = name.original;
    },

    DataNode: function(id, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "DATA";
      this.id = id;
    },

    StringNode: function(string, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "STRING";
      this.original =
        this.string =
        this.stringModeValue = string;
    },

    IntegerNode: function(integer, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "INTEGER";
      this.original =
        this.integer = integer;
      this.stringModeValue = Number(integer);
    },

    BooleanNode: function(bool, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "BOOLEAN";
      this.bool = bool;
      this.stringModeValue = bool === "true";
    },

    CommentNode: function(comment, locInfo) {
      LocationInfo.call(this, locInfo);
      this.type = "comment";
      this.comment = comment;
    }
  };

  // Must be exported as an object rather than the root of the module as the jison lexer
  // most modify the object to operate properly.
  __exports__ = AST;
  return __exports__;
})(__module5__);

// handlebars/compiler/parser.js
var __module9__ = (function() {
  "use strict";
  var __exports__;
  /* jshint ignore:start */
  /* Jison generated parser */
  var handlebars = (function(){
  var parser = {trace: function trace() { },
  yy: {},
  symbols_: {"error":2,"root":3,"statements":4,"EOF":5,"program":6,"simpleInverse":7,"statement":8,"openInverse":9,"closeBlock":10,"openBlock":11,"mustache":12,"partial":13,"CONTENT":14,"COMMENT":15,"OPEN_BLOCK":16,"sexpr":17,"CLOSE":18,"OPEN_INVERSE":19,"OPEN_ENDBLOCK":20,"path":21,"OPEN":22,"OPEN_UNESCAPED":23,"CLOSE_UNESCAPED":24,"OPEN_PARTIAL":25,"partialName":26,"partial_option0":27,"sexpr_repetition0":28,"sexpr_option0":29,"dataName":30,"param":31,"STRING":32,"INTEGER":33,"BOOLEAN":34,"OPEN_SEXPR":35,"CLOSE_SEXPR":36,"hash":37,"hash_repetition_plus0":38,"hashSegment":39,"ID":40,"EQUALS":41,"DATA":42,"pathSegments":43,"SEP":44,"$accept":0,"$end":1},
  terminals_: {2:"error",5:"EOF",14:"CONTENT",15:"COMMENT",16:"OPEN_BLOCK",18:"CLOSE",19:"OPEN_INVERSE",20:"OPEN_ENDBLOCK",22:"OPEN",23:"OPEN_UNESCAPED",24:"CLOSE_UNESCAPED",25:"OPEN_PARTIAL",32:"STRING",33:"INTEGER",34:"BOOLEAN",35:"OPEN_SEXPR",36:"CLOSE_SEXPR",40:"ID",41:"EQUALS",42:"DATA",44:"SEP"},
  productions_: [0,[3,2],[3,1],[6,2],[6,3],[6,2],[6,1],[6,1],[6,0],[4,1],[4,2],[8,3],[8,3],[8,1],[8,1],[8,1],[8,1],[11,3],[9,3],[10,3],[12,3],[12,3],[13,4],[7,2],[17,3],[17,1],[31,1],[31,1],[31,1],[31,1],[31,1],[31,3],[37,1],[39,3],[26,1],[26,1],[26,1],[30,2],[21,1],[43,3],[43,1],[27,0],[27,1],[28,0],[28,2],[29,0],[29,1],[38,1],[38,2]],
  performAction: function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$) {

  var $0 = $$.length - 1;
  switch (yystate) {
  case 1: return new yy.ProgramNode($$[$0-1], this._$); 
  break;
  case 2: return new yy.ProgramNode([], this._$); 
  break;
  case 3:this.$ = new yy.ProgramNode([], $$[$0-1], $$[$0], this._$);
  break;
  case 4:this.$ = new yy.ProgramNode($$[$0-2], $$[$0-1], $$[$0], this._$);
  break;
  case 5:this.$ = new yy.ProgramNode($$[$0-1], $$[$0], [], this._$);
  break;
  case 6:this.$ = new yy.ProgramNode($$[$0], this._$);
  break;
  case 7:this.$ = new yy.ProgramNode([], this._$);
  break;
  case 8:this.$ = new yy.ProgramNode([], this._$);
  break;
  case 9:this.$ = [$$[$0]];
  break;
  case 10: $$[$0-1].push($$[$0]); this.$ = $$[$0-1]; 
  break;
  case 11:this.$ = new yy.BlockNode($$[$0-2], $$[$0-1].inverse, $$[$0-1], $$[$0], this._$);
  break;
  case 12:this.$ = new yy.BlockNode($$[$0-2], $$[$0-1], $$[$0-1].inverse, $$[$0], this._$);
  break;
  case 13:this.$ = $$[$0];
  break;
  case 14:this.$ = $$[$0];
  break;
  case 15:this.$ = new yy.ContentNode($$[$0], this._$);
  break;
  case 16:this.$ = new yy.CommentNode($$[$0], this._$);
  break;
  case 17:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 18:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 19:this.$ = {path: $$[$0-1], strip: stripFlags($$[$0-2], $$[$0])};
  break;
  case 20:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 21:this.$ = new yy.MustacheNode($$[$0-1], null, $$[$0-2], stripFlags($$[$0-2], $$[$0]), this._$);
  break;
  case 22:this.$ = new yy.PartialNode($$[$0-2], $$[$0-1], stripFlags($$[$0-3], $$[$0]), this._$);
  break;
  case 23:this.$ = stripFlags($$[$0-1], $$[$0]);
  break;
  case 24:this.$ = new yy.SexprNode([$$[$0-2]].concat($$[$0-1]), $$[$0], this._$);
  break;
  case 25:this.$ = new yy.SexprNode([$$[$0]], null, this._$);
  break;
  case 26:this.$ = $$[$0];
  break;
  case 27:this.$ = new yy.StringNode($$[$0], this._$);
  break;
  case 28:this.$ = new yy.IntegerNode($$[$0], this._$);
  break;
  case 29:this.$ = new yy.BooleanNode($$[$0], this._$);
  break;
  case 30:this.$ = $$[$0];
  break;
  case 31:$$[$0-1].isHelper = true; this.$ = $$[$0-1];
  break;
  case 32:this.$ = new yy.HashNode($$[$0], this._$);
  break;
  case 33:this.$ = [$$[$0-2], $$[$0]];
  break;
  case 34:this.$ = new yy.PartialNameNode($$[$0], this._$);
  break;
  case 35:this.$ = new yy.PartialNameNode(new yy.StringNode($$[$0], this._$), this._$);
  break;
  case 36:this.$ = new yy.PartialNameNode(new yy.IntegerNode($$[$0], this._$));
  break;
  case 37:this.$ = new yy.DataNode($$[$0], this._$);
  break;
  case 38:this.$ = new yy.IdNode($$[$0], this._$);
  break;
  case 39: $$[$0-2].push({part: $$[$0], separator: $$[$0-1]}); this.$ = $$[$0-2]; 
  break;
  case 40:this.$ = [{part: $$[$0]}];
  break;
  case 43:this.$ = [];
  break;
  case 44:$$[$0-1].push($$[$0]);
  break;
  case 47:this.$ = [$$[$0]];
  break;
  case 48:$$[$0-1].push($$[$0]);
  break;
  }
  },
  table: [{3:1,4:2,5:[1,3],8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],22:[1,13],23:[1,14],25:[1,15]},{1:[3]},{5:[1,16],8:17,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],22:[1,13],23:[1,14],25:[1,15]},{1:[2,2]},{5:[2,9],14:[2,9],15:[2,9],16:[2,9],19:[2,9],20:[2,9],22:[2,9],23:[2,9],25:[2,9]},{4:20,6:18,7:19,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,21],20:[2,8],22:[1,13],23:[1,14],25:[1,15]},{4:20,6:22,7:19,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,21],20:[2,8],22:[1,13],23:[1,14],25:[1,15]},{5:[2,13],14:[2,13],15:[2,13],16:[2,13],19:[2,13],20:[2,13],22:[2,13],23:[2,13],25:[2,13]},{5:[2,14],14:[2,14],15:[2,14],16:[2,14],19:[2,14],20:[2,14],22:[2,14],23:[2,14],25:[2,14]},{5:[2,15],14:[2,15],15:[2,15],16:[2,15],19:[2,15],20:[2,15],22:[2,15],23:[2,15],25:[2,15]},{5:[2,16],14:[2,16],15:[2,16],16:[2,16],19:[2,16],20:[2,16],22:[2,16],23:[2,16],25:[2,16]},{17:23,21:24,30:25,40:[1,28],42:[1,27],43:26},{17:29,21:24,30:25,40:[1,28],42:[1,27],43:26},{17:30,21:24,30:25,40:[1,28],42:[1,27],43:26},{17:31,21:24,30:25,40:[1,28],42:[1,27],43:26},{21:33,26:32,32:[1,34],33:[1,35],40:[1,28],43:26},{1:[2,1]},{5:[2,10],14:[2,10],15:[2,10],16:[2,10],19:[2,10],20:[2,10],22:[2,10],23:[2,10],25:[2,10]},{10:36,20:[1,37]},{4:38,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],20:[2,7],22:[1,13],23:[1,14],25:[1,15]},{7:39,8:17,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,21],20:[2,6],22:[1,13],23:[1,14],25:[1,15]},{17:23,18:[1,40],21:24,30:25,40:[1,28],42:[1,27],43:26},{10:41,20:[1,37]},{18:[1,42]},{18:[2,43],24:[2,43],28:43,32:[2,43],33:[2,43],34:[2,43],35:[2,43],36:[2,43],40:[2,43],42:[2,43]},{18:[2,25],24:[2,25],36:[2,25]},{18:[2,38],24:[2,38],32:[2,38],33:[2,38],34:[2,38],35:[2,38],36:[2,38],40:[2,38],42:[2,38],44:[1,44]},{21:45,40:[1,28],43:26},{18:[2,40],24:[2,40],32:[2,40],33:[2,40],34:[2,40],35:[2,40],36:[2,40],40:[2,40],42:[2,40],44:[2,40]},{18:[1,46]},{18:[1,47]},{24:[1,48]},{18:[2,41],21:50,27:49,40:[1,28],43:26},{18:[2,34],40:[2,34]},{18:[2,35],40:[2,35]},{18:[2,36],40:[2,36]},{5:[2,11],14:[2,11],15:[2,11],16:[2,11],19:[2,11],20:[2,11],22:[2,11],23:[2,11],25:[2,11]},{21:51,40:[1,28],43:26},{8:17,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],20:[2,3],22:[1,13],23:[1,14],25:[1,15]},{4:52,8:4,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],20:[2,5],22:[1,13],23:[1,14],25:[1,15]},{14:[2,23],15:[2,23],16:[2,23],19:[2,23],20:[2,23],22:[2,23],23:[2,23],25:[2,23]},{5:[2,12],14:[2,12],15:[2,12],16:[2,12],19:[2,12],20:[2,12],22:[2,12],23:[2,12],25:[2,12]},{14:[2,18],15:[2,18],16:[2,18],19:[2,18],20:[2,18],22:[2,18],23:[2,18],25:[2,18]},{18:[2,45],21:56,24:[2,45],29:53,30:60,31:54,32:[1,57],33:[1,58],34:[1,59],35:[1,61],36:[2,45],37:55,38:62,39:63,40:[1,64],42:[1,27],43:26},{40:[1,65]},{18:[2,37],24:[2,37],32:[2,37],33:[2,37],34:[2,37],35:[2,37],36:[2,37],40:[2,37],42:[2,37]},{14:[2,17],15:[2,17],16:[2,17],19:[2,17],20:[2,17],22:[2,17],23:[2,17],25:[2,17]},{5:[2,20],14:[2,20],15:[2,20],16:[2,20],19:[2,20],20:[2,20],22:[2,20],23:[2,20],25:[2,20]},{5:[2,21],14:[2,21],15:[2,21],16:[2,21],19:[2,21],20:[2,21],22:[2,21],23:[2,21],25:[2,21]},{18:[1,66]},{18:[2,42]},{18:[1,67]},{8:17,9:5,11:6,12:7,13:8,14:[1,9],15:[1,10],16:[1,12],19:[1,11],20:[2,4],22:[1,13],23:[1,14],25:[1,15]},{18:[2,24],24:[2,24],36:[2,24]},{18:[2,44],24:[2,44],32:[2,44],33:[2,44],34:[2,44],35:[2,44],36:[2,44],40:[2,44],42:[2,44]},{18:[2,46],24:[2,46],36:[2,46]},{18:[2,26],24:[2,26],32:[2,26],33:[2,26],34:[2,26],35:[2,26],36:[2,26],40:[2,26],42:[2,26]},{18:[2,27],24:[2,27],32:[2,27],33:[2,27],34:[2,27],35:[2,27],36:[2,27],40:[2,27],42:[2,27]},{18:[2,28],24:[2,28],32:[2,28],33:[2,28],34:[2,28],35:[2,28],36:[2,28],40:[2,28],42:[2,28]},{18:[2,29],24:[2,29],32:[2,29],33:[2,29],34:[2,29],35:[2,29],36:[2,29],40:[2,29],42:[2,29]},{18:[2,30],24:[2,30],32:[2,30],33:[2,30],34:[2,30],35:[2,30],36:[2,30],40:[2,30],42:[2,30]},{17:68,21:24,30:25,40:[1,28],42:[1,27],43:26},{18:[2,32],24:[2,32],36:[2,32],39:69,40:[1,70]},{18:[2,47],24:[2,47],36:[2,47],40:[2,47]},{18:[2,40],24:[2,40],32:[2,40],33:[2,40],34:[2,40],35:[2,40],36:[2,40],40:[2,40],41:[1,71],42:[2,40],44:[2,40]},{18:[2,39],24:[2,39],32:[2,39],33:[2,39],34:[2,39],35:[2,39],36:[2,39],40:[2,39],42:[2,39],44:[2,39]},{5:[2,22],14:[2,22],15:[2,22],16:[2,22],19:[2,22],20:[2,22],22:[2,22],23:[2,22],25:[2,22]},{5:[2,19],14:[2,19],15:[2,19],16:[2,19],19:[2,19],20:[2,19],22:[2,19],23:[2,19],25:[2,19]},{36:[1,72]},{18:[2,48],24:[2,48],36:[2,48],40:[2,48]},{41:[1,71]},{21:56,30:60,31:73,32:[1,57],33:[1,58],34:[1,59],35:[1,61],40:[1,28],42:[1,27],43:26},{18:[2,31],24:[2,31],32:[2,31],33:[2,31],34:[2,31],35:[2,31],36:[2,31],40:[2,31],42:[2,31]},{18:[2,33],24:[2,33],36:[2,33],40:[2,33]}],
  defaultActions: {3:[2,2],16:[2,1],50:[2,42]},
  parseError: function parseError(str, hash) {
      throw new Error(str);
  },
  parse: function parse(input) {
      var self = this, stack = [0], vstack = [null], lstack = [], table = this.table, yytext = "", yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
      this.lexer.setInput(input);
      this.lexer.yy = this.yy;
      this.yy.lexer = this.lexer;
      this.yy.parser = this;
      if (typeof this.lexer.yylloc == "undefined")
          this.lexer.yylloc = {};
      var yyloc = this.lexer.yylloc;
      lstack.push(yyloc);
      var ranges = this.lexer.options && this.lexer.options.ranges;
      if (typeof this.yy.parseError === "function")
          this.parseError = this.yy.parseError;
      function popStack(n) {
          stack.length = stack.length - 2 * n;
          vstack.length = vstack.length - n;
          lstack.length = lstack.length - n;
      }
      function lex() {
          var token;
          token = self.lexer.lex() || 1;
          if (typeof token !== "number") {
              token = self.symbols_[token] || token;
          }
          return token;
      }
      var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
      while (true) {
          state = stack[stack.length - 1];
          if (this.defaultActions[state]) {
              action = this.defaultActions[state];
          } else {
              if (symbol === null || typeof symbol == "undefined") {
                  symbol = lex();
              }
              action = table[state] && table[state][symbol];
          }
          if (typeof action === "undefined" || !action.length || !action[0]) {
              var errStr = "";
              if (!recovering) {
                  expected = [];
                  for (p in table[state])
                      if (this.terminals_[p] && p > 2) {
                          expected.push("'" + this.terminals_[p] + "'");
                      }
                  if (this.lexer.showPosition) {
                      errStr = "Parse error on line " + (yylineno + 1) + ":\n" + this.lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'";
                  } else {
                      errStr = "Parse error on line " + (yylineno + 1) + ": Unexpected " + (symbol == 1?"end of input":"'" + (this.terminals_[symbol] || symbol) + "'");
                  }
                  this.parseError(errStr, {text: this.lexer.match, token: this.terminals_[symbol] || symbol, line: this.lexer.yylineno, loc: yyloc, expected: expected});
              }
          }
          if (action[0] instanceof Array && action.length > 1) {
              throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);
          }
          switch (action[0]) {
          case 1:
              stack.push(symbol);
              vstack.push(this.lexer.yytext);
              lstack.push(this.lexer.yylloc);
              stack.push(action[1]);
              symbol = null;
              if (!preErrorSymbol) {
                  yyleng = this.lexer.yyleng;
                  yytext = this.lexer.yytext;
                  yylineno = this.lexer.yylineno;
                  yyloc = this.lexer.yylloc;
                  if (recovering > 0)
                      recovering--;
              } else {
                  symbol = preErrorSymbol;
                  preErrorSymbol = null;
              }
              break;
          case 2:
              len = this.productions_[action[1]][1];
              yyval.$ = vstack[vstack.length - len];
              yyval._$ = {first_line: lstack[lstack.length - (len || 1)].first_line, last_line: lstack[lstack.length - 1].last_line, first_column: lstack[lstack.length - (len || 1)].first_column, last_column: lstack[lstack.length - 1].last_column};
              if (ranges) {
                  yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]];
              }
              r = this.performAction.call(yyval, yytext, yyleng, yylineno, this.yy, action[1], vstack, lstack);
              if (typeof r !== "undefined") {
                  return r;
              }
              if (len) {
                  stack = stack.slice(0, -1 * len * 2);
                  vstack = vstack.slice(0, -1 * len);
                  lstack = lstack.slice(0, -1 * len);
              }
              stack.push(this.productions_[action[1]][0]);
              vstack.push(yyval.$);
              lstack.push(yyval._$);
              newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
              stack.push(newState);
              break;
          case 3:
              return true;
          }
      }
      return true;
  }
  };


  function stripFlags(open, close) {
    return {
      left: open.charAt(2) === '~',
      right: close.charAt(0) === '~' || close.charAt(1) === '~'
    };
  }

  /* Jison generated lexer */
  var lexer = (function(){
  var lexer = ({EOF:1,
  parseError:function parseError(str, hash) {
          if (this.yy.parser) {
              this.yy.parser.parseError(str, hash);
          } else {
              throw new Error(str);
          }
      },
  setInput:function (input) {
          this._input = input;
          this._more = this._less = this.done = false;
          this.yylineno = this.yyleng = 0;
          this.yytext = this.matched = this.match = '';
          this.conditionStack = ['INITIAL'];
          this.yylloc = {first_line:1,first_column:0,last_line:1,last_column:0};
          if (this.options.ranges) this.yylloc.range = [0,0];
          this.offset = 0;
          return this;
      },
  input:function () {
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var lines = ch.match(/(?:\r\n?|\n).*/g);
          if (lines) {
              this.yylineno++;
              this.yylloc.last_line++;
          } else {
              this.yylloc.last_column++;
          }
          if (this.options.ranges) this.yylloc.range[1]++;

          this._input = this._input.slice(1);
          return ch;
      },
  unput:function (ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);

          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length-len-1);
          //this.yyleng -= len;
          this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length-1);
          this.matched = this.matched.substr(0, this.matched.length-1);

          if (lines.length-1) this.yylineno -= lines.length-1;
          var r = this.yylloc.range;

          this.yylloc = {first_line: this.yylloc.first_line,
            last_line: this.yylineno+1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length:
                this.yylloc.first_column - len
            };

          if (this.options.ranges) {
              this.yylloc.range = [r[0], r[0] + this.yyleng - len];
          }
          return this;
      },
  more:function () {
          this._more = true;
          return this;
      },
  less:function (n) {
          this.unput(this.match.slice(n));
      },
  pastInput:function () {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
      },
  upcomingInput:function () {
          var next = this.match;
          if (next.length < 20) {
              next += this._input.substr(0, 20-next.length);
          }
          return (next.substr(0,20)+(next.length > 20 ? '...':'')).replace(/\n/g, "");
      },
  showPosition:function () {
          var pre = this.pastInput();
          var c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c+"^";
      },
  next:function () {
          if (this.done) {
              return this.EOF;
          }
          if (!this._input) this.done = true;

          var token,
              match,
              tempMatch,
              index,
              col,
              lines;
          if (!this._more) {
              this.yytext = '';
              this.match = '';
          }
          var rules = this._currentRules();
          for (var i=0;i < rules.length; i++) {
              tempMatch = this._input.match(this.rules[rules[i]]);
              if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                  match = tempMatch;
                  index = i;
                  if (!this.options.flex) break;
              }
          }
          if (match) {
              lines = match[0].match(/(?:\r\n?|\n).*/g);
              if (lines) this.yylineno += lines.length;
              this.yylloc = {first_line: this.yylloc.last_line,
                             last_line: this.yylineno+1,
                             first_column: this.yylloc.last_column,
                             last_column: lines ? lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length};
              this.yytext += match[0];
              this.match += match[0];
              this.matches = match;
              this.yyleng = this.yytext.length;
              if (this.options.ranges) {
                  this.yylloc.range = [this.offset, this.offset += this.yyleng];
              }
              this._more = false;
              this._input = this._input.slice(match[0].length);
              this.matched += match[0];
              token = this.performAction.call(this, this.yy, this, rules[index],this.conditionStack[this.conditionStack.length-1]);
              if (this.done && this._input) this.done = false;
              if (token) return token;
              else return;
          }
          if (this._input === "") {
              return this.EOF;
          } else {
              return this.parseError('Lexical error on line '+(this.yylineno+1)+'. Unrecognized text.\n'+this.showPosition(),
                      {text: "", token: null, line: this.yylineno});
          }
      },
  lex:function lex() {
          var r = this.next();
          if (typeof r !== 'undefined') {
              return r;
          } else {
              return this.lex();
          }
      },
  begin:function begin(condition) {
          this.conditionStack.push(condition);
      },
  popState:function popState() {
          return this.conditionStack.pop();
      },
  _currentRules:function _currentRules() {
          return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules;
      },
  topState:function () {
          return this.conditionStack[this.conditionStack.length-2];
      },
  pushState:function begin(condition) {
          this.begin(condition);
      }});
  lexer.options = {};
  lexer.performAction = function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {


  function strip(start, end) {
    return yy_.yytext = yy_.yytext.substr(start, yy_.yyleng-end);
  }


  var YYSTATE=YY_START
  switch($avoiding_name_collisions) {
  case 0:
                                     if(yy_.yytext.slice(-2) === "\\\\") {
                                       strip(0,1);
                                       this.begin("mu");
                                     } else if(yy_.yytext.slice(-1) === "\\") {
                                       strip(0,1);
                                       this.begin("emu");
                                     } else {
                                       this.begin("mu");
                                     }
                                     if(yy_.yytext) return 14;
                                   
  break;
  case 1:return 14;
  break;
  case 2:
                                     this.popState();
                                     return 14;
                                   
  break;
  case 3:strip(0,4); this.popState(); return 15;
  break;
  case 4:return 35;
  break;
  case 5:return 36;
  break;
  case 6:return 25;
  break;
  case 7:return 16;
  break;
  case 8:return 20;
  break;
  case 9:return 19;
  break;
  case 10:return 19;
  break;
  case 11:return 23;
  break;
  case 12:return 22;
  break;
  case 13:this.popState(); this.begin('com');
  break;
  case 14:strip(3,5); this.popState(); return 15;
  break;
  case 15:return 22;
  break;
  case 16:return 41;
  break;
  case 17:return 40;
  break;
  case 18:return 40;
  break;
  case 19:return 44;
  break;
  case 20:// ignore whitespace
  break;
  case 21:this.popState(); return 24;
  break;
  case 22:this.popState(); return 18;
  break;
  case 23:yy_.yytext = strip(1,2).replace(/\\"/g,'"'); return 32;
  break;
  case 24:yy_.yytext = strip(1,2).replace(/\\'/g,"'"); return 32;
  break;
  case 25:return 42;
  break;
  case 26:return 34;
  break;
  case 27:return 34;
  break;
  case 28:return 33;
  break;
  case 29:return 40;
  break;
  case 30:yy_.yytext = strip(1,2); return 40;
  break;
  case 31:return 'INVALID';
  break;
  case 32:return 5;
  break;
  }
  };
  lexer.rules = [/^(?:[^\x00]*?(?=(\{\{)))/,/^(?:[^\x00]+)/,/^(?:[^\x00]{2,}?(?=(\{\{|\\\{\{|\\\\\{\{|$)))/,/^(?:[\s\S]*?--\}\})/,/^(?:\()/,/^(?:\))/,/^(?:\{\{(~)?>)/,/^(?:\{\{(~)?#)/,/^(?:\{\{(~)?\/)/,/^(?:\{\{(~)?\^)/,/^(?:\{\{(~)?\s*else\b)/,/^(?:\{\{(~)?\{)/,/^(?:\{\{(~)?&)/,/^(?:\{\{!--)/,/^(?:\{\{![\s\S]*?\}\})/,/^(?:\{\{(~)?)/,/^(?:=)/,/^(?:\.\.)/,/^(?:\.(?=([=~}\s\/.)])))/,/^(?:[\/.])/,/^(?:\s+)/,/^(?:\}(~)?\}\})/,/^(?:(~)?\}\})/,/^(?:"(\\["]|[^"])*")/,/^(?:'(\\[']|[^'])*')/,/^(?:@)/,/^(?:true(?=([~}\s)])))/,/^(?:false(?=([~}\s)])))/,/^(?:-?[0-9]+(?=([~}\s)])))/,/^(?:([^\s!"#%-,\.\/;->@\[-\^`\{-~]+(?=([=~}\s\/.)]))))/,/^(?:\[[^\]]*\])/,/^(?:.)/,/^(?:$)/];
  lexer.conditions = {"mu":{"rules":[4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32],"inclusive":false},"emu":{"rules":[2],"inclusive":false},"com":{"rules":[3],"inclusive":false},"INITIAL":{"rules":[0,1,32],"inclusive":true}};
  return lexer;})()
  parser.lexer = lexer;
  function Parser () { this.yy = {}; }Parser.prototype = parser;parser.Parser = Parser;
  return new Parser;
  })();__exports__ = handlebars;
  /* jshint ignore:end */
  return __exports__;
})();

// handlebars/compiler/base.js
var __module8__ = (function(__dependency1__, __dependency2__) {
  "use strict";
  var __exports__ = {};
  var parser = __dependency1__;
  var AST = __dependency2__;

  __exports__.parser = parser;

  function parse(input) {
    // Just return if an already-compile AST was passed in.
    if(input.constructor === AST.ProgramNode) { return input; }

    parser.yy = AST;
    return parser.parse(input);
  }

  __exports__.parse = parse;
  return __exports__;
})(__module9__, __module7__);

// handlebars/compiler/compiler.js
var __module10__ = (function(__dependency1__) {
  "use strict";
  var __exports__ = {};
  var Exception = __dependency1__;

  function Compiler() {}

  __exports__.Compiler = Compiler;// the foundHelper register will disambiguate helper lookup from finding a
  // function in a context. This is necessary for mustache compatibility, which
  // requires that context functions in blocks are evaluated by blockHelperMissing,
  // and then proceed as if the resulting value was provided to blockHelperMissing.

  Compiler.prototype = {
    compiler: Compiler,

    disassemble: function() {
      var opcodes = this.opcodes, opcode, out = [], params, param;

      for (var i=0, l=opcodes.length; i<l; i++) {
        opcode = opcodes[i];

        if (opcode.opcode === 'DECLARE') {
          out.push("DECLARE " + opcode.name + "=" + opcode.value);
        } else {
          params = [];
          for (var j=0; j<opcode.args.length; j++) {
            param = opcode.args[j];
            if (typeof param === "string") {
              param = "\"" + param.replace("\n", "\\n") + "\"";
            }
            params.push(param);
          }
          out.push(opcode.opcode + " " + params.join(" "));
        }
      }

      return out.join("\n");
    },

    equals: function(other) {
      var len = this.opcodes.length;
      if (other.opcodes.length !== len) {
        return false;
      }

      for (var i = 0; i < len; i++) {
        var opcode = this.opcodes[i],
            otherOpcode = other.opcodes[i];
        if (opcode.opcode !== otherOpcode.opcode || opcode.args.length !== otherOpcode.args.length) {
          return false;
        }
        for (var j = 0; j < opcode.args.length; j++) {
          if (opcode.args[j] !== otherOpcode.args[j]) {
            return false;
          }
        }
      }

      len = this.children.length;
      if (other.children.length !== len) {
        return false;
      }
      for (i = 0; i < len; i++) {
        if (!this.children[i].equals(other.children[i])) {
          return false;
        }
      }

      return true;
    },

    guid: 0,

    compile: function(program, options) {
      this.opcodes = [];
      this.children = [];
      this.depths = {list: []};
      this.options = options;

      // These changes will propagate to the other compiler components
      var knownHelpers = this.options.knownHelpers;
      this.options.knownHelpers = {
        'helperMissing': true,
        'blockHelperMissing': true,
        'each': true,
        'if': true,
        'unless': true,
        'with': true,
        'log': true
      };
      if (knownHelpers) {
        for (var name in knownHelpers) {
          this.options.knownHelpers[name] = knownHelpers[name];
        }
      }

      return this.accept(program);
    },

    accept: function(node) {
      var strip = node.strip || {},
          ret;
      if (strip.left) {
        this.opcode('strip');
      }

      ret = this[node.type](node);

      if (strip.right) {
        this.opcode('strip');
      }

      return ret;
    },

    program: function(program) {
      var statements = program.statements;

      for(var i=0, l=statements.length; i<l; i++) {
        this.accept(statements[i]);
      }
      this.isSimple = l === 1;

      this.depths.list = this.depths.list.sort(function(a, b) {
        return a - b;
      });

      return this;
    },

    compileProgram: function(program) {
      var result = new this.compiler().compile(program, this.options);
      var guid = this.guid++, depth;

      this.usePartial = this.usePartial || result.usePartial;

      this.children[guid] = result;

      for(var i=0, l=result.depths.list.length; i<l; i++) {
        depth = result.depths.list[i];

        if(depth < 2) { continue; }
        else { this.addDepth(depth - 1); }
      }

      return guid;
    },

    block: function(block) {
      var mustache = block.mustache,
          program = block.program,
          inverse = block.inverse;

      if (program) {
        program = this.compileProgram(program);
      }

      if (inverse) {
        inverse = this.compileProgram(inverse);
      }

      var sexpr = mustache.sexpr;
      var type = this.classifySexpr(sexpr);

      if (type === "helper") {
        this.helperSexpr(sexpr, program, inverse);
      } else if (type === "simple") {
        this.simpleSexpr(sexpr);

        // now that the simple mustache is resolved, we need to
        // evaluate it by executing `blockHelperMissing`
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
        this.opcode('emptyHash');
        this.opcode('blockValue');
      } else {
        this.ambiguousSexpr(sexpr, program, inverse);

        // now that the simple mustache is resolved, we need to
        // evaluate it by executing `blockHelperMissing`
        this.opcode('pushProgram', program);
        this.opcode('pushProgram', inverse);
        this.opcode('emptyHash');
        this.opcode('ambiguousBlockValue');
      }

      this.opcode('append');
    },

    hash: function(hash) {
      var pairs = hash.pairs, pair, val;

      this.opcode('pushHash');

      for(var i=0, l=pairs.length; i<l; i++) {
        pair = pairs[i];
        val  = pair[1];

        if (this.options.stringParams) {
          if(val.depth) {
            this.addDepth(val.depth);
          }
          this.opcode('getContext', val.depth || 0);
          this.opcode('pushStringParam', val.stringModeValue, val.type);

          if (val.type === 'sexpr') {
            // Subexpressions get evaluated and passed in
            // in string params mode.
            this.sexpr(val);
          }
        } else {
          this.accept(val);
        }

        this.opcode('assignToHash', pair[0]);
      }
      this.opcode('popHash');
    },

    partial: function(partial) {
      var partialName = partial.partialName;
      this.usePartial = true;

      if(partial.context) {
        this.ID(partial.context);
      } else {
        this.opcode('push', 'depth0');
      }

      this.opcode('invokePartial', partialName.name);
      this.opcode('append');
    },

    content: function(content) {
      this.opcode('appendContent', content.string);
    },

    mustache: function(mustache) {
      this.sexpr(mustache.sexpr);

      if(mustache.escaped && !this.options.noEscape) {
        this.opcode('appendEscaped');
      } else {
        this.opcode('append');
      }
    },

    ambiguousSexpr: function(sexpr, program, inverse) {
      var id = sexpr.id,
          name = id.parts[0],
          isBlock = program != null || inverse != null;

      this.opcode('getContext', id.depth);

      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);

      this.opcode('invokeAmbiguous', name, isBlock);
    },

    simpleSexpr: function(sexpr) {
      var id = sexpr.id;

      if (id.type === 'DATA') {
        this.DATA(id);
      } else if (id.parts.length) {
        this.ID(id);
      } else {
        // Simplified ID for `this`
        this.addDepth(id.depth);
        this.opcode('getContext', id.depth);
        this.opcode('pushContext');
      }

      this.opcode('resolvePossibleLambda');
    },

    helperSexpr: function(sexpr, program, inverse) {
      var params = this.setupFullMustacheParams(sexpr, program, inverse),
          name = sexpr.id.parts[0];

      if (this.options.knownHelpers[name]) {
        this.opcode('invokeKnownHelper', params.length, name);
      } else if (this.options.knownHelpersOnly) {
        throw new Exception("You specified knownHelpersOnly, but used the unknown helper " + name, sexpr);
      } else {
        this.opcode('invokeHelper', params.length, name, sexpr.isRoot);
      }
    },

    sexpr: function(sexpr) {
      var type = this.classifySexpr(sexpr);

      if (type === "simple") {
        this.simpleSexpr(sexpr);
      } else if (type === "helper") {
        this.helperSexpr(sexpr);
      } else {
        this.ambiguousSexpr(sexpr);
      }
    },

    ID: function(id) {
      this.addDepth(id.depth);
      this.opcode('getContext', id.depth);

      var name = id.parts[0];
      if (!name) {
        this.opcode('pushContext');
      } else {
        this.opcode('lookupOnContext', id.parts[0]);
      }

      for(var i=1, l=id.parts.length; i<l; i++) {
        this.opcode('lookup', id.parts[i]);
      }
    },

    DATA: function(data) {
      this.options.data = true;
      if (data.id.isScoped || data.id.depth) {
        throw new Exception('Scoped data references are not supported: ' + data.original, data);
      }

      this.opcode('lookupData');
      var parts = data.id.parts;
      for(var i=0, l=parts.length; i<l; i++) {
        this.opcode('lookup', parts[i]);
      }
    },

    STRING: function(string) {
      this.opcode('pushString', string.string);
    },

    INTEGER: function(integer) {
      this.opcode('pushLiteral', integer.integer);
    },

    BOOLEAN: function(bool) {
      this.opcode('pushLiteral', bool.bool);
    },

    comment: function() {},

    // HELPERS
    opcode: function(name) {
      this.opcodes.push({ opcode: name, args: [].slice.call(arguments, 1) });
    },

    declare: function(name, value) {
      this.opcodes.push({ opcode: 'DECLARE', name: name, value: value });
    },

    addDepth: function(depth) {
      if(depth === 0) { return; }

      if(!this.depths[depth]) {
        this.depths[depth] = true;
        this.depths.list.push(depth);
      }
    },

    classifySexpr: function(sexpr) {
      var isHelper   = sexpr.isHelper;
      var isEligible = sexpr.eligibleHelper;
      var options    = this.options;

      // if ambiguous, we can possibly resolve the ambiguity now
      if (isEligible && !isHelper) {
        var name = sexpr.id.parts[0];

        if (options.knownHelpers[name]) {
          isHelper = true;
        } else if (options.knownHelpersOnly) {
          isEligible = false;
        }
      }

      if (isHelper) { return "helper"; }
      else if (isEligible) { return "ambiguous"; }
      else { return "simple"; }
    },

    pushParams: function(params) {
      var i = params.length, param;

      while(i--) {
        param = params[i];

        if(this.options.stringParams) {
          if(param.depth) {
            this.addDepth(param.depth);
          }

          this.opcode('getContext', param.depth || 0);
          this.opcode('pushStringParam', param.stringModeValue, param.type);

          if (param.type === 'sexpr') {
            // Subexpressions get evaluated and passed in
            // in string params mode.
            this.sexpr(param);
          }
        } else {
          this[param.type](param);
        }
      }
    },

    setupFullMustacheParams: function(sexpr, program, inverse) {
      var params = sexpr.params;
      this.pushParams(params);

      this.opcode('pushProgram', program);
      this.opcode('pushProgram', inverse);

      if (sexpr.hash) {
        this.hash(sexpr.hash);
      } else {
        this.opcode('emptyHash');
      }

      return params;
    }
  };

  function precompile(input, options, env) {
    if (input == null || (typeof input !== 'string' && input.constructor !== env.AST.ProgramNode)) {
      throw new Exception("You must pass a string or Handlebars AST to Handlebars.precompile. You passed " + input);
    }

    options = options || {};
    if (!('data' in options)) {
      options.data = true;
    }

    var ast = env.parse(input);
    var environment = new env.Compiler().compile(ast, options);
    return new env.JavaScriptCompiler().compile(environment, options);
  }

  __exports__.precompile = precompile;function compile(input, options, env) {
    if (input == null || (typeof input !== 'string' && input.constructor !== env.AST.ProgramNode)) {
      throw new Exception("You must pass a string or Handlebars AST to Handlebars.compile. You passed " + input);
    }

    options = options || {};

    if (!('data' in options)) {
      options.data = true;
    }

    var compiled;

    function compileInput() {
      var ast = env.parse(input);
      var environment = new env.Compiler().compile(ast, options);
      var templateSpec = new env.JavaScriptCompiler().compile(environment, options, undefined, true);
      return env.template(templateSpec);
    }

    // Template is only compiled on first use and cached after that point.
    return function(context, options) {
      if (!compiled) {
        compiled = compileInput();
      }
      return compiled.call(this, context, options);
    };
  }

  __exports__.compile = compile;
  return __exports__;
})(__module5__);

// handlebars/compiler/javascript-compiler.js
var __module11__ = (function(__dependency1__, __dependency2__) {
  "use strict";
  var __exports__;
  var COMPILER_REVISION = __dependency1__.COMPILER_REVISION;
  var REVISION_CHANGES = __dependency1__.REVISION_CHANGES;
  var log = __dependency1__.log;
  var Exception = __dependency2__;

  function Literal(value) {
    this.value = value;
  }

  function JavaScriptCompiler() {}

  JavaScriptCompiler.prototype = {
    // PUBLIC API: You can override these methods in a subclass to provide
    // alternative compiled forms for name lookup and buffering semantics
    nameLookup: function(parent, name /* , type*/) {
      var wrap,
          ret;
      if (parent.indexOf('depth') === 0) {
        wrap = true;
      }

      if (/^[0-9]+$/.test(name)) {
        ret = parent + "[" + name + "]";
      } else if (JavaScriptCompiler.isValidJavaScriptVariableName(name)) {
        ret = parent + "." + name;
      }
      else {
        ret = parent + "['" + name + "']";
      }

      if (wrap) {
        return '(' + parent + ' && ' + ret + ')';
      } else {
        return ret;
      }
    },

    compilerInfo: function() {
      var revision = COMPILER_REVISION,
          versions = REVISION_CHANGES[revision];
      return "this.compilerInfo = ["+revision+",'"+versions+"'];\n";
    },

    appendToBuffer: function(string) {
      if (this.environment.isSimple) {
        return "return " + string + ";";
      } else {
        return {
          appendToBuffer: true,
          content: string,
          toString: function() { return "buffer += " + string + ";"; }
        };
      }
    },

    initializeBuffer: function() {
      return this.quotedString("");
    },

    namespace: "Handlebars",
    // END PUBLIC API

    compile: function(environment, options, context, asObject) {
      this.environment = environment;
      this.options = options || {};

      log('debug', this.environment.disassemble() + "\n\n");

      this.name = this.environment.name;
      this.isChild = !!context;
      this.context = context || {
        programs: [],
        environments: [],
        aliases: { }
      };

      this.preamble();

      this.stackSlot = 0;
      this.stackVars = [];
      this.registers = { list: [] };
      this.hashes = [];
      this.compileStack = [];
      this.inlineStack = [];

      this.compileChildren(environment, options);

      var opcodes = environment.opcodes, opcode;

      this.i = 0;

      for(var l=opcodes.length; this.i<l; this.i++) {
        opcode = opcodes[this.i];

        if(opcode.opcode === 'DECLARE') {
          this[opcode.name] = opcode.value;
        } else {
          this[opcode.opcode].apply(this, opcode.args);
        }

        // Reset the stripNext flag if it was not set by this operation.
        if (opcode.opcode !== this.stripNext) {
          this.stripNext = false;
        }
      }

      // Flush any trailing content that might be pending.
      this.pushSource('');

      if (this.stackSlot || this.inlineStack.length || this.compileStack.length) {
        throw new Exception('Compile completed with content left on stack');
      }

      return this.createFunctionContext(asObject);
    },

    preamble: function() {
      var out = [];

      if (!this.isChild) {
        var namespace = this.namespace;

        var copies = "helpers = this.merge(helpers, " + namespace + ".helpers);";
        if (this.environment.usePartial) { copies = copies + " partials = this.merge(partials, " + namespace + ".partials);"; }
        if (this.options.data) { copies = copies + " data = data || {};"; }
        out.push(copies);
      } else {
        out.push('');
      }

      if (!this.environment.isSimple) {
        out.push(", buffer = " + this.initializeBuffer());
      } else {
        out.push("");
      }

      // track the last context pushed into place to allow skipping the
      // getContext opcode when it would be a noop
      this.lastContext = 0;
      this.source = out;
    },

    createFunctionContext: function(asObject) {
      var locals = this.stackVars.concat(this.registers.list);

      if(locals.length > 0) {
        this.source[1] = this.source[1] + ", " + locals.join(", ");
      }

      // Generate minimizer alias mappings
      if (!this.isChild) {
        for (var alias in this.context.aliases) {
          if (this.context.aliases.hasOwnProperty(alias)) {
            this.source[1] = this.source[1] + ', ' + alias + '=' + this.context.aliases[alias];
          }
        }
      }

      if (this.source[1]) {
        this.source[1] = "var " + this.source[1].substring(2) + ";";
      }

      // Merge children
      if (!this.isChild) {
        this.source[1] += '\n' + this.context.programs.join('\n') + '\n';
      }

      if (!this.environment.isSimple) {
        this.pushSource("return buffer;");
      }

      var params = this.isChild ? ["depth0", "data"] : ["Handlebars", "depth0", "helpers", "partials", "data"];

      for(var i=0, l=this.environment.depths.list.length; i<l; i++) {
        params.push("depth" + this.environment.depths.list[i]);
      }

      // Perform a second pass over the output to merge content when possible
      var source = this.mergeSource();

      if (!this.isChild) {
        source = this.compilerInfo()+source;
      }

      if (asObject) {
        params.push(source);

        return Function.apply(this, params);
      } else {
        var functionSource = 'function ' + (this.name || '') + '(' + params.join(',') + ') {\n  ' + source + '}';
        log('debug', functionSource + "\n\n");
        return functionSource;
      }
    },
    mergeSource: function() {
      // WARN: We are not handling the case where buffer is still populated as the source should
      // not have buffer append operations as their final action.
      var source = '',
          buffer;
      for (var i = 0, len = this.source.length; i < len; i++) {
        var line = this.source[i];
        if (line.appendToBuffer) {
          if (buffer) {
            buffer = buffer + '\n    + ' + line.content;
          } else {
            buffer = line.content;
          }
        } else {
          if (buffer) {
            source += 'buffer += ' + buffer + ';\n  ';
            buffer = undefined;
          }
          source += line + '\n  ';
        }
      }
      return source;
    },

    // [blockValue]
    //
    // On stack, before: hash, inverse, program, value
    // On stack, after: return value of blockHelperMissing
    //
    // The purpose of this opcode is to take a block of the form
    // `{{#foo}}...{{/foo}}`, resolve the value of `foo`, and
    // replace it on the stack with the result of properly
    // invoking blockHelperMissing.
    blockValue: function() {
      this.context.aliases.blockHelperMissing = 'helpers.blockHelperMissing';

      var params = ["depth0"];
      this.setupParams(0, params);

      this.replaceStack(function(current) {
        params.splice(1, 0, current);
        return "blockHelperMissing.call(" + params.join(", ") + ")";
      });
    },

    // [ambiguousBlockValue]
    //
    // On stack, before: hash, inverse, program, value
    // Compiler value, before: lastHelper=value of last found helper, if any
    // On stack, after, if no lastHelper: same as [blockValue]
    // On stack, after, if lastHelper: value
    ambiguousBlockValue: function() {
      this.context.aliases.blockHelperMissing = 'helpers.blockHelperMissing';

      var params = ["depth0"];
      this.setupParams(0, params);

      var current = this.topStack();
      params.splice(1, 0, current);

      this.pushSource("if (!" + this.lastHelper + ") { " + current + " = blockHelperMissing.call(" + params.join(", ") + "); }");
    },

    // [appendContent]
    //
    // On stack, before: ...
    // On stack, after: ...
    //
    // Appends the string value of `content` to the current buffer
    appendContent: function(content) {
      if (this.pendingContent) {
        content = this.pendingContent + content;
      }
      if (this.stripNext) {
        content = content.replace(/^\s+/, '');
      }

      this.pendingContent = content;
    },

    // [strip]
    //
    // On stack, before: ...
    // On stack, after: ...
    //
    // Removes any trailing whitespace from the prior content node and flags
    // the next operation for stripping if it is a content node.
    strip: function() {
      if (this.pendingContent) {
        this.pendingContent = this.pendingContent.replace(/\s+$/, '');
      }
      this.stripNext = 'strip';
    },

    // [append]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Coerces `value` to a String and appends it to the current buffer.
    //
    // If `value` is truthy, or 0, it is coerced into a string and appended
    // Otherwise, the empty string is appended
    append: function() {
      // Force anything that is inlined onto the stack so we don't have duplication
      // when we examine local
      this.flushInline();
      var local = this.popStack();
      this.pushSource("if(" + local + " || " + local + " === 0) { " + this.appendToBuffer(local) + " }");
      if (this.environment.isSimple) {
        this.pushSource("else { " + this.appendToBuffer("''") + " }");
      }
    },

    // [appendEscaped]
    //
    // On stack, before: value, ...
    // On stack, after: ...
    //
    // Escape `value` and append it to the buffer
    appendEscaped: function() {
      this.context.aliases.escapeExpression = 'this.escapeExpression';

      this.pushSource(this.appendToBuffer("escapeExpression(" + this.popStack() + ")"));
    },

    // [getContext]
    //
    // On stack, before: ...
    // On stack, after: ...
    // Compiler value, after: lastContext=depth
    //
    // Set the value of the `lastContext` compiler value to the depth
    getContext: function(depth) {
      if(this.lastContext !== depth) {
        this.lastContext = depth;
      }
    },

    // [lookupOnContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext[name], ...
    //
    // Looks up the value of `name` on the current context and pushes
    // it onto the stack.
    lookupOnContext: function(name) {
      this.push(this.nameLookup('depth' + this.lastContext, name, 'context'));
    },

    // [pushContext]
    //
    // On stack, before: ...
    // On stack, after: currentContext, ...
    //
    // Pushes the value of the current context onto the stack.
    pushContext: function() {
      this.pushStackLiteral('depth' + this.lastContext);
    },

    // [resolvePossibleLambda]
    //
    // On stack, before: value, ...
    // On stack, after: resolved value, ...
    //
    // If the `value` is a lambda, replace it on the stack by
    // the return value of the lambda
    resolvePossibleLambda: function() {
      this.context.aliases.functionType = '"function"';

      this.replaceStack(function(current) {
        return "typeof " + current + " === functionType ? " + current + ".apply(depth0) : " + current;
      });
    },

    // [lookup]
    //
    // On stack, before: value, ...
    // On stack, after: value[name], ...
    //
    // Replace the value on the stack with the result of looking
    // up `name` on `value`
    lookup: function(name) {
      this.replaceStack(function(current) {
        return current + " == null || " + current + " === false ? " + current + " : " + this.nameLookup(current, name, 'context');
      });
    },

    // [lookupData]
    //
    // On stack, before: ...
    // On stack, after: data, ...
    //
    // Push the data lookup operator
    lookupData: function() {
      this.pushStackLiteral('data');
    },

    // [pushStringParam]
    //
    // On stack, before: ...
    // On stack, after: string, currentContext, ...
    //
    // This opcode is designed for use in string mode, which
    // provides the string value of a parameter along with its
    // depth rather than resolving it immediately.
    pushStringParam: function(string, type) {
      this.pushStackLiteral('depth' + this.lastContext);

      this.pushString(type);

      // If it's a subexpression, the string result
      // will be pushed after this opcode.
      if (type !== 'sexpr') {
        if (typeof string === 'string') {
          this.pushString(string);
        } else {
          this.pushStackLiteral(string);
        }
      }
    },

    emptyHash: function() {
      this.pushStackLiteral('{}');

      if (this.options.stringParams) {
        this.push('{}'); // hashContexts
        this.push('{}'); // hashTypes
      }
    },
    pushHash: function() {
      if (this.hash) {
        this.hashes.push(this.hash);
      }
      this.hash = {values: [], types: [], contexts: []};
    },
    popHash: function() {
      var hash = this.hash;
      this.hash = this.hashes.pop();

      if (this.options.stringParams) {
        this.push('{' + hash.contexts.join(',') + '}');
        this.push('{' + hash.types.join(',') + '}');
      }

      this.push('{\n    ' + hash.values.join(',\n    ') + '\n  }');
    },

    // [pushString]
    //
    // On stack, before: ...
    // On stack, after: quotedString(string), ...
    //
    // Push a quoted version of `string` onto the stack
    pushString: function(string) {
      this.pushStackLiteral(this.quotedString(string));
    },

    // [push]
    //
    // On stack, before: ...
    // On stack, after: expr, ...
    //
    // Push an expression onto the stack
    push: function(expr) {
      this.inlineStack.push(expr);
      return expr;
    },

    // [pushLiteral]
    //
    // On stack, before: ...
    // On stack, after: value, ...
    //
    // Pushes a value onto the stack. This operation prevents
    // the compiler from creating a temporary variable to hold
    // it.
    pushLiteral: function(value) {
      this.pushStackLiteral(value);
    },

    // [pushProgram]
    //
    // On stack, before: ...
    // On stack, after: program(guid), ...
    //
    // Push a program expression onto the stack. This takes
    // a compile-time guid and converts it into a runtime-accessible
    // expression.
    pushProgram: function(guid) {
      if (guid != null) {
        this.pushStackLiteral(this.programExpression(guid));
      } else {
        this.pushStackLiteral(null);
      }
    },

    // [invokeHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // Pops off the helper's parameters, invokes the helper,
    // and pushes the helper's return value onto the stack.
    //
    // If the helper is not found, `helperMissing` is called.
    invokeHelper: function(paramSize, name, isRoot) {
      this.context.aliases.helperMissing = 'helpers.helperMissing';
      this.useRegister('helper');

      var helper = this.lastHelper = this.setupHelper(paramSize, name, true);
      var nonHelper = this.nameLookup('depth' + this.lastContext, name, 'context');

      var lookup = 'helper = ' + helper.name + ' || ' + nonHelper;
      if (helper.paramsInit) {
        lookup += ',' + helper.paramsInit;
      }

      this.push(
        '('
          + lookup
          + ',helper '
            + '? helper.call(' + helper.callParams + ') '
            + ': helperMissing.call(' + helper.helperMissingParams + '))');

      // Always flush subexpressions. This is both to prevent the compounding size issue that
      // occurs when the code has to be duplicated for inlining and also to prevent errors
      // due to the incorrect options object being passed due to the shared register.
      if (!isRoot) {
        this.flushInline();
      }
    },

    // [invokeKnownHelper]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of helper invocation
    //
    // This operation is used when the helper is known to exist,
    // so a `helperMissing` fallback is not required.
    invokeKnownHelper: function(paramSize, name) {
      var helper = this.setupHelper(paramSize, name);
      this.push(helper.name + ".call(" + helper.callParams + ")");
    },

    // [invokeAmbiguous]
    //
    // On stack, before: hash, inverse, program, params..., ...
    // On stack, after: result of disambiguation
    //
    // This operation is used when an expression like `{{foo}}`
    // is provided, but we don't know at compile-time whether it
    // is a helper or a path.
    //
    // This operation emits more code than the other options,
    // and can be avoided by passing the `knownHelpers` and
    // `knownHelpersOnly` flags at compile-time.
    invokeAmbiguous: function(name, helperCall) {
      this.context.aliases.functionType = '"function"';
      this.useRegister('helper');

      this.emptyHash();
      var helper = this.setupHelper(0, name, helperCall);

      var helperName = this.lastHelper = this.nameLookup('helpers', name, 'helper');

      var nonHelper = this.nameLookup('depth' + this.lastContext, name, 'context');
      var nextStack = this.nextStack();

      if (helper.paramsInit) {
        this.pushSource(helper.paramsInit);
      }
      this.pushSource('if (helper = ' + helperName + ') { ' + nextStack + ' = helper.call(' + helper.callParams + '); }');
      this.pushSource('else { helper = ' + nonHelper + '; ' + nextStack + ' = typeof helper === functionType ? helper.call(' + helper.callParams + ') : helper; }');
    },

    // [invokePartial]
    //
    // On stack, before: context, ...
    // On stack after: result of partial invocation
    //
    // This operation pops off a context, invokes a partial with that context,
    // and pushes the result of the invocation back.
    invokePartial: function(name) {
      var params = [this.nameLookup('partials', name, 'partial'), "'" + name + "'", this.popStack(), "helpers", "partials"];

      if (this.options.data) {
        params.push("data");
      }

      this.context.aliases.self = "this";
      this.push("self.invokePartial(" + params.join(", ") + ")");
    },

    // [assignToHash]
    //
    // On stack, before: value, hash, ...
    // On stack, after: hash, ...
    //
    // Pops a value and hash off the stack, assigns `hash[key] = value`
    // and pushes the hash back onto the stack.
    assignToHash: function(key) {
      var value = this.popStack(),
          context,
          type;

      if (this.options.stringParams) {
        type = this.popStack();
        context = this.popStack();
      }

      var hash = this.hash;
      if (context) {
        hash.contexts.push("'" + key + "': " + context);
      }
      if (type) {
        hash.types.push("'" + key + "': " + type);
      }
      hash.values.push("'" + key + "': (" + value + ")");
    },

    // HELPERS

    compiler: JavaScriptCompiler,

    compileChildren: function(environment, options) {
      var children = environment.children, child, compiler;

      for(var i=0, l=children.length; i<l; i++) {
        child = children[i];
        compiler = new this.compiler();

        var index = this.matchExistingProgram(child);

        if (index == null) {
          this.context.programs.push('');     // Placeholder to prevent name conflicts for nested children
          index = this.context.programs.length;
          child.index = index;
          child.name = 'program' + index;
          this.context.programs[index] = compiler.compile(child, options, this.context);
          this.context.environments[index] = child;
        } else {
          child.index = index;
          child.name = 'program' + index;
        }
      }
    },
    matchExistingProgram: function(child) {
      for (var i = 0, len = this.context.environments.length; i < len; i++) {
        var environment = this.context.environments[i];
        if (environment && environment.equals(child)) {
          return i;
        }
      }
    },

    programExpression: function(guid) {
      this.context.aliases.self = "this";

      if(guid == null) {
        return "self.noop";
      }

      var child = this.environment.children[guid],
          depths = child.depths.list, depth;

      var programParams = [child.index, child.name, "data"];

      for(var i=0, l = depths.length; i<l; i++) {
        depth = depths[i];

        if(depth === 1) { programParams.push("depth0"); }
        else { programParams.push("depth" + (depth - 1)); }
      }

      return (depths.length === 0 ? "self.program(" : "self.programWithDepth(") + programParams.join(", ") + ")";
    },

    register: function(name, val) {
      this.useRegister(name);
      this.pushSource(name + " = " + val + ";");
    },

    useRegister: function(name) {
      if(!this.registers[name]) {
        this.registers[name] = true;
        this.registers.list.push(name);
      }
    },

    pushStackLiteral: function(item) {
      return this.push(new Literal(item));
    },

    pushSource: function(source) {
      if (this.pendingContent) {
        this.source.push(this.appendToBuffer(this.quotedString(this.pendingContent)));
        this.pendingContent = undefined;
      }

      if (source) {
        this.source.push(source);
      }
    },

    pushStack: function(item) {
      this.flushInline();

      var stack = this.incrStack();
      if (item) {
        this.pushSource(stack + " = " + item + ";");
      }
      this.compileStack.push(stack);
      return stack;
    },

    replaceStack: function(callback) {
      var prefix = '',
          inline = this.isInline(),
          stack,
          createdStack,
          usedLiteral;

      // If we are currently inline then we want to merge the inline statement into the
      // replacement statement via ','
      if (inline) {
        var top = this.popStack(true);

        if (top instanceof Literal) {
          // Literals do not need to be inlined
          stack = top.value;
          usedLiteral = true;
        } else {
          // Get or create the current stack name for use by the inline
          createdStack = !this.stackSlot;
          var name = !createdStack ? this.topStackName() : this.incrStack();

          prefix = '(' + this.push(name) + ' = ' + top + '),';
          stack = this.topStack();
        }
      } else {
        stack = this.topStack();
      }

      var item = callback.call(this, stack);

      if (inline) {
        if (!usedLiteral) {
          this.popStack();
        }
        if (createdStack) {
          this.stackSlot--;
        }
        this.push('(' + prefix + item + ')');
      } else {
        // Prevent modification of the context depth variable. Through replaceStack
        if (!/^stack/.test(stack)) {
          stack = this.nextStack();
        }

        this.pushSource(stack + " = (" + prefix + item + ");");
      }
      return stack;
    },

    nextStack: function() {
      return this.pushStack();
    },

    incrStack: function() {
      this.stackSlot++;
      if(this.stackSlot > this.stackVars.length) { this.stackVars.push("stack" + this.stackSlot); }
      return this.topStackName();
    },
    topStackName: function() {
      return "stack" + this.stackSlot;
    },
    flushInline: function() {
      var inlineStack = this.inlineStack;
      if (inlineStack.length) {
        this.inlineStack = [];
        for (var i = 0, len = inlineStack.length; i < len; i++) {
          var entry = inlineStack[i];
          if (entry instanceof Literal) {
            this.compileStack.push(entry);
          } else {
            this.pushStack(entry);
          }
        }
      }
    },
    isInline: function() {
      return this.inlineStack.length;
    },

    popStack: function(wrapped) {
      var inline = this.isInline(),
          item = (inline ? this.inlineStack : this.compileStack).pop();

      if (!wrapped && (item instanceof Literal)) {
        return item.value;
      } else {
        if (!inline) {
          if (!this.stackSlot) {
            throw new Exception('Invalid stack pop');
          }
          this.stackSlot--;
        }
        return item;
      }
    },

    topStack: function(wrapped) {
      var stack = (this.isInline() ? this.inlineStack : this.compileStack),
          item = stack[stack.length - 1];

      if (!wrapped && (item instanceof Literal)) {
        return item.value;
      } else {
        return item;
      }
    },

    quotedString: function(str) {
      return '"' + str
        .replace(/\\/g, '\\\\')
        .replace(/"/g, '\\"')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/\u2028/g, '\\u2028')   // Per Ecma-262 7.3 + 7.8.4
        .replace(/\u2029/g, '\\u2029') + '"';
    },

    setupHelper: function(paramSize, name, missingParams) {
      var params = [],
          paramsInit = this.setupParams(paramSize, params, missingParams);
      var foundHelper = this.nameLookup('helpers', name, 'helper');

      return {
        params: params,
        paramsInit: paramsInit,
        name: foundHelper,
        callParams: ["depth0"].concat(params).join(", "),
        helperMissingParams: missingParams && ["depth0", this.quotedString(name)].concat(params).join(", ")
      };
    },

    setupOptions: function(paramSize, params) {
      var options = [], contexts = [], types = [], param, inverse, program;

      options.push("hash:" + this.popStack());

      if (this.options.stringParams) {
        options.push("hashTypes:" + this.popStack());
        options.push("hashContexts:" + this.popStack());
      }

      inverse = this.popStack();
      program = this.popStack();

      // Avoid setting fn and inverse if neither are set. This allows
      // helpers to do a check for `if (options.fn)`
      if (program || inverse) {
        if (!program) {
          this.context.aliases.self = "this";
          program = "self.noop";
        }

        if (!inverse) {
          this.context.aliases.self = "this";
          inverse = "self.noop";
        }

        options.push("inverse:" + inverse);
        options.push("fn:" + program);
      }

      for(var i=0; i<paramSize; i++) {
        param = this.popStack();
        params.push(param);

        if(this.options.stringParams) {
          types.push(this.popStack());
          contexts.push(this.popStack());
        }
      }

      if (this.options.stringParams) {
        options.push("contexts:[" + contexts.join(",") + "]");
        options.push("types:[" + types.join(",") + "]");
      }

      if(this.options.data) {
        options.push("data:data");
      }

      return options;
    },

    // the params and contexts arguments are passed in arrays
    // to fill in
    setupParams: function(paramSize, params, useRegister) {
      var options = '{' + this.setupOptions(paramSize, params).join(',') + '}';

      if (useRegister) {
        this.useRegister('options');
        params.push('options');
        return 'options=' + options;
      } else {
        params.push(options);
        return '';
      }
    }
  };

  var reservedWords = (
    "break else new var" +
    " case finally return void" +
    " catch for switch while" +
    " continue function this with" +
    " default if throw" +
    " delete in try" +
    " do instanceof typeof" +
    " abstract enum int short" +
    " boolean export interface static" +
    " byte extends long super" +
    " char final native synchronized" +
    " class float package throws" +
    " const goto private transient" +
    " debugger implements protected volatile" +
    " double import public let yield"
  ).split(" ");

  var compilerWords = JavaScriptCompiler.RESERVED_WORDS = {};

  for(var i=0, l=reservedWords.length; i<l; i++) {
    compilerWords[reservedWords[i]] = true;
  }

  JavaScriptCompiler.isValidJavaScriptVariableName = function(name) {
    if(!JavaScriptCompiler.RESERVED_WORDS[name] && /^[a-zA-Z_$][0-9a-zA-Z_$]*$/.test(name)) {
      return true;
    }
    return false;
  };

  __exports__ = JavaScriptCompiler;
  return __exports__;
})(__module2__, __module5__);

// handlebars.js
var __module0__ = (function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__) {
  "use strict";
  var __exports__;
  /*globals Handlebars: true */
  var Handlebars = __dependency1__;

  // Compiler imports
  var AST = __dependency2__;
  var Parser = __dependency3__.parser;
  var parse = __dependency3__.parse;
  var Compiler = __dependency4__.Compiler;
  var compile = __dependency4__.compile;
  var precompile = __dependency4__.precompile;
  var JavaScriptCompiler = __dependency5__;

  var _create = Handlebars.create;
  var create = function() {
    var hb = _create();

    hb.compile = function(input, options) {
      return compile(input, options, hb);
    };
    hb.precompile = function (input, options) {
      return precompile(input, options, hb);
    };

    hb.AST = AST;
    hb.Compiler = Compiler;
    hb.JavaScriptCompiler = JavaScriptCompiler;
    hb.Parser = Parser;
    hb.parse = parse;

    return hb;
  };

  Handlebars = create();
  Handlebars.create = create;

  __exports__ = Handlebars;
  return __exports__;
})(__module1__, __module7__, __module8__, __module10__, __module11__);

  return __module0__;
})();

/*!
 * jQuery JavaScript Library v1.8.3
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: Tue Nov 13 2012 08:20:33 GMT-0500 (Eastern Standard Time)
 */
(function( window, undefined ) {
var
	// A central reference to the root jQuery(document)
	rootjQuery,

	// The deferred used on DOM ready
	readyList,

	// Use the correct document accordingly with window argument (sandbox)
	document = window.document,
	location = window.location,
	navigator = window.navigator,

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// Save a reference to some core methods
	core_push = Array.prototype.push,
	core_slice = Array.prototype.slice,
	core_indexOf = Array.prototype.indexOf,
	core_toString = Object.prototype.toString,
	core_hasOwn = Object.prototype.hasOwnProperty,
	core_trim = String.prototype.trim,

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Used for matching numbers
	core_pnum = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,

	// Used for detecting and trimming whitespace
	core_rnotwhite = /\S/,
	core_rspace = /\s+/,

	// Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	rquickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// The ready event handler and self cleanup method
	DOMContentLoaded = function() {
		if ( document.addEventListener ) {
			document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
			jQuery.ready();
		} else if ( document.readyState === "complete" ) {
			// we're here because readyState === "complete" in oldIE
			// which is good enough for us to call the dom ready!
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	},

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context && context.nodeType ? context.ownerDocument || context : document );

					// scripts is true for back-compat
					selector = jQuery.parseHTML( match[1], doc, true );
					if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {
						this.attr.call( selector, context, true );
					}

					return jQuery.merge( this, selector );

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.8.3",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return core_slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Add the callback
		jQuery.ready.promise().done( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( core_slice.apply( this, arguments ),
			"slice", core_slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: core_push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( !document.body ) {
			return setTimeout( jQuery.ready, 1 );
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.trigger ) {
			jQuery( document ).trigger("ready").off("ready");
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	isWindow: function( obj ) {
		return obj != null && obj == obj.window;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ core_toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!core_hasOwn.call(obj, "constructor") &&
				!core_hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || core_hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	// data: string of html
	// context (optional): If specified, the fragment will be created in this context, defaults to document
	// scripts (optional): If true, will include scripts passed in the html string
	parseHTML: function( data, context, scripts ) {
		var parsed;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		if ( typeof context === "boolean" ) {
			scripts = context;
			context = 0;
		}
		context = context || document;

		// Single tag
		if ( (parsed = rsingleTag.exec( data )) ) {
			return [ context.createElement( parsed[1] ) ];
		}

		parsed = jQuery.buildFragment( [ data ], context, scripts ? null : [] );
		return jQuery.merge( [],
			(parsed.cacheable ? jQuery.clone( parsed.fragment ) : parsed.fragment).childNodes );
	},

	parseJSON: function( data ) {
		if ( !data || typeof data !== "string") {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		if ( !data || typeof data !== "string" ) {
			return null;
		}
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && core_rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	// args is for internal usage only
	each: function( obj, callback, args ) {
		var name,
			i = 0,
			length = obj.length,
			isObj = length === undefined || jQuery.isFunction( obj );

		if ( args ) {
			if ( isObj ) {
				for ( name in obj ) {
					if ( callback.apply( obj[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( obj[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in obj ) {
					if ( callback.call( obj[ name ], name, obj[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( obj[ i ], i, obj[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return obj;
	},

	// Use native String.trim function wherever possible
	trim: core_trim && !core_trim.call("\uFEFF\xA0") ?
		function( text ) {
			return text == null ?
				"" :
				core_trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				( text + "" ).replace( rtrim, "" );
		},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var type,
			ret = results || [];

		if ( arr != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			type = jQuery.type( arr );

			if ( arr.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( arr ) ) {
				core_push.call( ret, arr );
			} else {
				jQuery.merge( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		var len;

		if ( arr ) {
			if ( core_indexOf ) {
				return core_indexOf.call( arr, elem, i );
			}

			len = arr.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in arr && arr[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var l = second.length,
			i = first.length,
			j = 0;

		if ( typeof l === "number" ) {
			for ( ; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var retVal,
			ret = [],
			i = 0,
			length = elems.length;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key,
			ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = core_slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context, args.concat( core_slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	// Multifunctional method to get and set values of a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, fn, key, value, chainable, emptyGet, pass ) {
		var exec,
			bulk = key == null,
			i = 0,
			length = elems.length;

		// Sets many values
		if ( key && typeof key === "object" ) {
			for ( i in key ) {
				jQuery.access( elems, fn, i, key[i], 1, emptyGet, value );
			}
			chainable = 1;

		// Sets one value
		} else if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = pass === undefined && jQuery.isFunction( value );

			if ( bulk ) {
				// Bulk operations only iterate when executing function values
				if ( exec ) {
					exec = fn;
					fn = function( elem, key, value ) {
						return exec.call( jQuery( elem ), value );
					};

				// Otherwise they run against the entire set
				} else {
					fn.call( elems, value );
					fn = null;
				}
			}

			if ( fn ) {
				for (; i < length; i++ ) {
					fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
				}
			}

			chainable = 1;
		}

		return chainable ?
			elems :

			// Gets
			bulk ?
				fn.call( elems ) :
				length ? fn( elems[0], key ) : emptyGet;
	},

	now: function() {
		return ( new Date() ).getTime();
	}
});

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called after the browser event has already occurred.
		// we once tried to use readyState "interactive" here, but it caused issues like the one
		// discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			setTimeout( jQuery.ready, 1 );

		// Standards-based browsers support DOMContentLoaded
		} else if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else {
			// Ensure firing before onload, maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var top = false;

			try {
				top = window.frameElement == null && document.documentElement;
			} catch(e) {}

			if ( top && top.doScroll ) {
				(function doScrollCheck() {
					if ( !jQuery.isReady ) {

						try {
							// Use the trick by Diego Perini
							// http://javascript.nwbox.com/IEContentLoaded/
							top.doScroll("left");
						} catch(e) {
							return setTimeout( doScrollCheck, 50 );
						}

						// and execute any waiting functions
						jQuery.ready();
					}
				})();
			}
		}
	}
	return readyList.promise( obj );
};

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

// All jQuery objects should point back to these
rootjQuery = jQuery(document);
// String to Object options format cache
var optionsCache = {};

// Convert String-formatted options into Object-formatted ones and store in cache
function createOptions( options ) {
	var object = optionsCache[ options ] = {};
	jQuery.each( options.split( core_rspace ), function( _, flag ) {
		object[ flag ] = true;
	});
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		( optionsCache[ options ] || createOptions( options ) ) :
		jQuery.extend( {}, options );

	var // Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list was already fired
		fired,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = !options.once && [],
		// Fire callbacks
		fire = function( data ) {
			memory = options.memory && data;
			fired = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			firing = true;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {
					memory = false; // To prevent further calls using add
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( stack ) {
					if ( stack.length ) {
						fire( stack.shift() );
					}
				} else if ( memory ) {
					list = [];
				} else {
					self.disable();
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					// First, we save the current length
					var start = list.length;
					(function add( args ) {
						jQuery.each( args, function( _, arg ) {
							var type = jQuery.type( arg );
							if ( type === "function" ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && type !== "string" ) {
								// Inspect recursively
								add( arg );
							}
						});
					})( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away
					} else if ( memory ) {
						firingStart = start;
						fire( memory );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					jQuery.each( arguments, function( _, arg ) {
						var index;
						while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
							list.splice( index, 1 );
							// Handle firing indexes
							if ( firing ) {
								if ( index <= firingLength ) {
									firingLength--;
								}
								if ( index <= firingIndex ) {
									firingIndex--;
								}
							}
						}
					});
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				return jQuery.inArray( fn, list ) > -1;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				args = args || [];
				args = [ context, args.slice ? args.slice() : args ];
				if ( list && ( !fired || stack ) ) {
					if ( firing ) {
						stack.push( args );
					} else {
						fire( args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};
jQuery.extend({

	Deferred: function( func ) {
		var tuples = [
				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks("once memory"), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks("once memory"), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks("memory") ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var action = tuple[ 0 ],
								fn = fns[ i ];
							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[1] ]( jQuery.isFunction( fn ) ?
								function() {
									var returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise()
											.done( newDefer.resolve )
											.fail( newDefer.reject )
											.progress( newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								} :
								newDefer[ action ]
							);
						});
						fns = null;
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[1] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(function() {
					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ] = list.fire
			deferred[ tuple[0] ] = list.fire;
			deferred[ tuple[0] + "With" ] = list.fireWith;
		});

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = core_slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred. If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;
					if( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject )
						.progress( updateFunc( i, progressContexts, progressValues ) );
				} else {
					--remaining;
				}
			}
		}

		// if we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
});
jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		fragment,
		eventName,
		i,
		isSupported,
		clickFn,
		div = document.createElement("div");

	// Setup
	div.setAttribute( "className", "t" );
	div.innerHTML = "  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";

	// Support tests won't run in some limited or non-browser environments
	all = div.getElementsByTagName("*");
	a = div.getElementsByTagName("a")[ 0 ];
	if ( !all || !a || !all.length ) {
		return {};
	}

	// First batch of tests
	select = document.createElement("select");
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName("input")[ 0 ];

	a.style.cssText = "top:1px;float:left;opacity:.5";
	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.5/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form (#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// jQuery.support.boxModel DEPRECATED in 1.8 since we don't support Quirks Mode
		boxModel: ( document.compatMode === "CSS1Compat" ),

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true,
		boxSizingReliable: true,
		pixelPosition: false
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", clickFn = function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent("onclick");
		div.detachEvent( "onclick", clickFn );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute( "type", "radio" );
	support.radioValue = input.value === "t";

	input.setAttribute( "checked", "checked" );

	// #11217 - WebKit loses check when the name is after the checked attribute
	input.setAttribute( "name", "t" );

	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for ( i in {
			submit: true,
			change: true,
			focusin: true
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, div, tds, marginDiv,
			divReset = "padding:0;margin:0;border:0;display:block;overflow:hidden;",
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		container = document.createElement("div");
		container.style.cssText = "visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName("td");
		tds[ 0 ].style.cssText = "padding:0;margin:0;border:0;display:none";
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Check box-sizing and margin behavior
		div.innerHTML = "";
		div.style.cssText = "box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";
		support.boxSizing = ( div.offsetWidth === 4 );
		support.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== 1 );

		// NOTE: To any future maintainer, we've window.getComputedStyle
		// because jsdom on node.js will break without it.
		if ( window.getComputedStyle ) {
			support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== "1%";
			support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: "4px" } ).width === "4px";

			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. For more
			// info see bug #3333
			// Fails in WebKit before Feb 2011 nightlies
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			marginDiv = document.createElement("div");
			marginDiv.style.cssText = div.style.cssText = divReset;
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";
			div.appendChild( marginDiv );
			support.reliableMarginRight =
				!parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );
		}

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.innerHTML = "";
			div.style.cssText = divReset + "width:1px;padding:1px;display:inline;zoom:1";
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "block";
			div.style.overflow = "visible";
			div.innerHTML = "<div></div>";
			div.firstChild.style.width = "5px";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );

			container.style.zoom = 1;
		}

		// Null elements to avoid leaks in IE
		body.removeChild( container );
		container = div = tds = marginDiv = null;
	});

	// Null elements to avoid leaks in IE
	fragment.removeChild( div );
	all = a = select = opt = input = fragment = div = null;

	return support;
})();
var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	deletedIds: [],

	// Remove at next major release (1.9/2.0)
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = jQuery.deletedIds.pop() || jQuery.guid++;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,
			id = isNode ? elem[ jQuery.expando ] : jQuery.expando;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split(" ");
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject( cache[ id ] ) ) {
				return;
			}
		}

		// Destroy the cache
		if ( isNode ) {
			jQuery.cleanData( [ elem ], true );

		// Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
		} else if ( jQuery.support.deleteExpando || cache != cache.window ) {
			delete cache[ id ];

		// When all else fails, null
		} else {
			cache[ id ] = null;
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];

		// nodes accept data unless otherwise specified; rejection can be conditional
		return !noData || noData !== true && elem.getAttribute("classid") === noData;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, part, attr, name, l,
			elem = this[0],
			i = 0,
			data = null;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = jQuery.data( elem );

				if ( elem.nodeType === 1 && !jQuery._data( elem, "parsedAttrs" ) ) {
					attr = elem.attributes;
					for ( l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( !name.indexOf( "data-" ) ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( elem, name, data[ name ] );
						}
					}
					jQuery._data( elem, "parsedAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split( ".", 2 );
		parts[1] = parts[1] ? "." + parts[1] : "";
		part = parts[1] + "!";

		return jQuery.access( this, function( value ) {

			if ( value === undefined ) {
				data = this.triggerHandler( "getData" + part, [ parts[0] ] );

				// Try to fetch any internally stored data first
				if ( data === undefined && elem ) {
					data = jQuery.data( elem, key );
					data = dataAttr( elem, key, data );
				}

				return data === undefined && parts[1] ?
					this.data( parts[0] ) :
					data;
			}

			parts[1] = value;
			this.each(function() {
				var self = jQuery( this );

				self.triggerHandler( "setData" + part, parts );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + part, parts );
			});
		}, null, value, arguments.length > 1, null, false );
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				// Only convert to a number if it doesn't change the string
				+data + "" === data ? +data :
				rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	var name;
	for ( name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}
jQuery.extend({
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray(data) ) {
					queue = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// not intended for public consumption - generates a queueHooks object, or returns the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return jQuery._data( elem, key ) || jQuery._data( elem, key, {
			empty: jQuery.Callbacks("once memory").add(function() {
				jQuery.removeData( elem, type + "queue", true );
				jQuery.removeData( elem, key, true );
			})
		});
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[0], type );
		}

		return data === undefined ?
			this :
			this.each(function() {
				var queue = jQuery.queue( this, type, data );

				// ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[0] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while( i-- ) {
			tmp = jQuery._data( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
});
var nodeHook, boolHook, fixSpecified,
	rclass = /[\t\r\n]/g,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea|)$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( core_rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( setClass.indexOf( " " + classNames[ c ] + " " ) < 0 ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var removes, className, elem, c, cl, i, l;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}
		if ( (value && typeof value === "string") || value === undefined ) {
			removes = ( value || "" ).split( core_rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];
				if ( elem.nodeType === 1 && elem.className ) {

					className = (" " + elem.className + " ").replace( rclass, " " );

					// loop over each item in the removal list
					for ( c = 0, cl = removes.length; c < cl; c++ ) {
						// Remove until there is nothing to remove,
						while ( className.indexOf(" " + removes[ c ] + " ") >= 0 ) {
							className = className.replace( " " + removes[ c ] + " " , " " );
						}
					}
					elem.className = value ? jQuery.trim( className ) : "";
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( core_rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space separated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) >= 0 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var val,
				self = jQuery(this);

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// oldIE doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&
							// Don't return options that are disabled or in a disabled optgroup
							( jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null ) &&
							( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( (option.selected = jQuery.inArray( option.value, values ) >= 0) ) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	// Unused in 1.8, left in so attrFn-stabbers won't die; remove in 1.9
	attrFn: {},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && jQuery.isFunction( jQuery.fn[ name ] ) ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, value + "" );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, isBool,
			i = 0;

		if ( value && elem.nodeType === 1 ) {

			attrNames = value.split( core_rspace );

			for ( ; i < attrNames.length; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;
					isBool = rboolean.test( name );

					// See #9699 for explanation of this approach (setting first, then removal)
					// Do not do this for boolean attributes (see #10870)
					if ( !isBool ) {
						jQuery.attr( elem, name, "" );
					}
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( isBool && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
// if ( !getSetAttribute ) {

// 	fixSpecified = {
// 		name: true,
// 		id: true,
// 		coords: true
// 	};

// 	// Use this for any attribute in IE6/7
// 	// This fixes almost every IE6/7 issue
// 	nodeHook = jQuery.valHooks.button = {
// 		get: function( elem, name ) {
// 			var ret;
// 			ret = elem.getAttributeNode( name );
// 			return ret && ( fixSpecified[ name ] ? ret.value !== "" : ret.specified ) ?
// 				ret.value :
// 				undefined;
// 		},
// 		set: function( elem, value, name ) {
// 			// Set the existing or create a new attribute node
// 			var ret = elem.getAttributeNode( name );
// 			if ( !ret ) {
// 				ret = document.createAttribute( name );
// 				elem.setAttributeNode( ret );
// 			}
// 			return ( ret.value = value + "" );
// 		}
// 	};

// 	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
// 	// This is for removals
// 	jQuery.each([ "width", "height" ], function( i, name ) {
// 		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
// 			set: function( elem, value ) {
// 				if ( value === "" ) {
// 					elem.setAttribute( name, "auto" );
// 					return value;
// 				}
// 			}
// 		});
// 	});

// 	// Set contenteditable to false on removals(#10429)
// 	// Setting to empty string throws an error as an invalid value
// 	jQuery.attrHooks.contenteditable = {
// 		get: nodeHook.get,
// 		set: function( elem, value, name ) {
// 			if ( value === "" ) {
// 				value = "false";
// 			}
// 			nodeHook.set( elem, value, name );
// 		}
// 	};
// }


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = value + "" );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});
var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*|)(?:\.(.+)|)$/,
	rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var t, tns, type, origType, namespaces, origCount,
			j, events, special, eventType, handleObj,
			elemData = jQuery.hasData( elem ) && jQuery._data( elem );

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			delete elemData.handle;

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, "events", true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType,
			type = event.type || event,
			namespaces = [];

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			for ( old = elem; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old === (elem.ownerDocument || document) ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var i, j, cur, ret, selMatch, matched, matches, handleObj, sel, related,
			handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = core_slice.call( arguments ),
			run_all = !event.exclusive && !event.namespace,
			special = jQuery.event.special[ event.type ] || {},
			handlerQueue = [];

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers that should run if there are delegated events
		// Avoid non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !(event.button && event.type === "click") ) {

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {

				// Don't process clicks (ONLY) on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.disabled !== true || event.type !== "click" ) {
					selMatch = {};
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];
						sel = handleObj.selector;

						if ( selMatch[ sel ] === undefined ) {
							selMatch[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) >= 0 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( selMatch[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push({ elem: cur, matches: matches });
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events, metaKey==false if it's undefined (#3368, #11328; IE6/7/8)
		event.metaKey = !!event.metaKey;

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		var name = "on" + type;

		if ( elem.detachEvent ) {

			// #8545, #7054, preventing memory leaks for custom events in IE6-8
			// detachEvent needed property on element, by name of that event, to properly expose it to GC
			if ( typeof elem[ name ] === "undefined" ) {
				elem[ name ] = null;
			}

			elem.detachEvent( name, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !jQuery._data( form, "_submit_attached" ) ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						event._submit_bubble = true;
					});
					jQuery._data( form, "_submit_attached", true );
				}
			});
			// return undefined since we don't need an event listener
		},

		postDispatch: function( event ) {
			// If form was submitted by the user, bubble the event up the tree
			if ( event._submit_bubble ) {
				delete event._submit_bubble;
				if ( this.parentNode && !event.isTrigger ) {
					jQuery.event.simulate( "submit", this.parentNode, event, true );
				}
			}
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
						}
						// Allow triggered, simulated change events (#11500)
						jQuery.event.simulate( "change", this, event, true );
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, "_change_attached" ) ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					jQuery._data( elem, "_change_attached", true );
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return !rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) { // && selector != null
				// ( types-Object, data )
				data = data || selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on( types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ? this.off( selector, "**" ) : this.off( types, selector || "**", fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});
/*!
 * Sizzle CSS Selector Engine
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license
 * http://sizzlejs.com/
 */
(function( window, undefined ) {

var cachedruns,
	assertGetIdNotName,
	Expr,
	getText,
	isXML,
	contains,
	compile,
	sortOrder,
	hasDuplicate,
	outermostContext,

	baseHasDuplicate = true,
	strundefined = "undefined",

	expando = ( "sizcache" + Math.random() ).replace( ".", "" ),

	Token = String,
	document = window.document,
	docElem = document.documentElement,
	dirruns = 0,
	done = 0,
	pop = [].pop,
	push = [].push,
	slice = [].slice,
	// Use a stripped-down indexOf if a native one is unavailable
	indexOf = [].indexOf || function( elem ) {
		var i = 0,
			len = this.length;
		for ( ; i < len; i++ ) {
			if ( this[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	// Augment a function for special use by Sizzle
	markFunction = function( fn, value ) {
		fn[ expando ] = value == null || value;
		return fn;
	},

	createCache = function() {
		var cache = {},
			keys = [];

		return markFunction(function( key, value ) {
			// Only keep the most recent entries
			if ( keys.push( key ) > Expr.cacheLength ) {
				delete cache[ keys.shift() ];
			}

			// Retrieve with (key + " ") to avoid collision with native Object.prototype properties (see Issue #157)
			return (cache[ key + " " ] = value);
		}, cache );
	},

	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),

	// Regex

	// Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",
	// http://www.w3.org/TR/css3-syntax/#characters
	characterEncoding = "(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",

	// Loosely modeled on CSS identifier characters
	// An unquoted value should be a CSS identifier (http://www.w3.org/TR/css3-selectors/#attribute-selectors)
	// Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = characterEncoding.replace( "w", "w#" ),

	// Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
	operators = "([*^$|!~]?=)",
	attributes = "\\[" + whitespace + "*(" + characterEncoding + ")" + whitespace +
		"*(?:" + operators + whitespace + "*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|(" + identifier + ")|)|)" + whitespace + "*\\]",

	// Prefer arguments not in parens/brackets,
	//   then attribute selectors and non-pseudos (denoted by :),
	//   then anything else
	// These preferences are here to reduce the number of selectors
	//   needing tokenize in the PSEUDO preFilter
	pseudos = ":(" + characterEncoding + ")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:" + attributes + ")|[^:]|\\\\.)*|.*))\\)|)",

	// For matchExpr.POS and matchExpr.needsContext
	pos = ":(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
		"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([\\x20\\t\\r\\n\\f>+~])" + whitespace + "*" ),
	rpseudo = new RegExp( pseudos ),

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,

	rnot = /^:not/,
	rsibling = /[\x20\t\r\n\f]*[+~]/,
	rendsWithNot = /:not\($/,

	rheader = /h\d/i,
	rinputs = /input|select|textarea|button/i,

	rbackslash = /\\(?!\\)/g,

	matchExpr = {
		"ID": new RegExp( "^#(" + characterEncoding + ")" ),
		"CLASS": new RegExp( "^\\.(" + characterEncoding + ")" ),
		"NAME": new RegExp( "^\\[name=['\"]?(" + characterEncoding + ")['\"]?\\]" ),
		"TAG": new RegExp( "^(" + characterEncoding.replace( "w", "w*" ) + ")" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"POS": new RegExp( pos, "i" ),
		"CHILD": new RegExp( "^:(only|nth|first|last)-child(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		// For use in libraries implementing .is()
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|" + pos, "i" )
	},

	// Support

	// Used for testing something on an element
	assert = function( fn ) {
		var div = document.createElement("div");

		try {
			return fn( div );
		} catch (e) {
			return false;
		} finally {
			// release memory in IE
			div = null;
		}
	},

	// Check if getElementsByTagName("*") returns only elements
	assertTagNameNoComments = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
	}),

	// Check if getAttribute returns normalized href attributes
	assertHrefNotNormalized = assert(function( div ) {
		div.innerHTML = "<a href='#'></a>";
		return div.firstChild && typeof div.firstChild.getAttribute !== strundefined &&
			div.firstChild.getAttribute("href") === "#";
	}),

	// Check if attributes should be retrieved by attribute nodes
	assertAttributes = assert(function( div ) {
		div.innerHTML = "<select></select>";
		var type = typeof div.lastChild.getAttribute("multiple");
		// IE8 returns a string for some attributes even when not present
		return type !== "boolean" && type !== "string";
	}),

	// Check if getElementsByClassName can be trusted
	assertUsableClassName = assert(function( div ) {
		// Opera can't find a second classname (in 9.6)
		div.innerHTML = "<div class='hidden e'></div><div class='hidden'></div>";
		if ( !div.getElementsByClassName || !div.getElementsByClassName("e").length ) {
			return false;
		}

		// Safari 3.2 caches class attributes and doesn't catch changes
		div.lastChild.className = "e";
		return div.getElementsByClassName("e").length === 2;
	}),

	// Check if getElementById returns elements by name
	// Check if getElementsByName privileges form controls or returns elements by ID
	assertUsableName = assert(function( div ) {
		// Inject content
		div.id = expando + 0;
		div.innerHTML = "<a name='" + expando + "'></a><div name='" + expando + "'></div>";
		docElem.insertBefore( div, docElem.firstChild );

		// Test
		var pass = document.getElementsByName &&
			// buggy browsers will return fewer than the correct 2
			document.getElementsByName( expando ).length === 2 +
			// buggy browsers will return more than the correct 0
			document.getElementsByName( expando + 0 ).length;
		assertGetIdNotName = !document.getElementById( expando );

		// Cleanup
		docElem.removeChild( div );

		return pass;
	});

// If slice is not available, provide a backup
try {
	slice.call( docElem.childNodes, 0 )[0].nodeType;
} catch ( e ) {
	slice = function( i ) {
		var elem,
			results = [];
		for ( ; (elem = this[i]); i++ ) {
			results.push( elem );
		}
		return results;
	};
}

function Sizzle( selector, context, results, seed ) {
	results = results || [];
	context = context || document;
	var match, elem, xml, m,
		nodeType = context.nodeType;

	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	if ( nodeType !== 1 && nodeType !== 9 ) {
		return [];
	}

	xml = isXML( context );

	if ( !xml && !seed ) {
		if ( (match = rquickExpr.exec( selector )) ) {
			// Speed-up: Sizzle("#ID")
			if ( (m = match[1]) ) {
				if ( nodeType === 9 ) {
					elem = context.getElementById( m );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE, Opera, and Webkit return items
						// by name instead of ID
						if ( elem.id === m ) {
							results.push( elem );
							return results;
						}
					} else {
						return results;
					}
				} else {
					// Context is not a document
					if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&
						contains( context, elem ) && elem.id === m ) {
						results.push( elem );
						return results;
					}
				}

			// Speed-up: Sizzle("TAG")
			} else if ( match[2] ) {
				push.apply( results, slice.call(context.getElementsByTagName( selector ), 0) );
				return results;

			// Speed-up: Sizzle(".CLASS")
			} else if ( (m = match[3]) && assertUsableClassName && context.getElementsByClassName ) {
				push.apply( results, slice.call(context.getElementsByClassName( m ), 0) );
				return results;
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed, xml );
}

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	return Sizzle( expr, null, null, [ elem ] ).length > 0;
};

// Returns a function to use in pseudos for input types
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

// Returns a function to use in pseudos for buttons
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

// Returns a function to use in pseudos for positionals
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
			// Use textContent for elements
			// innerText usage removed for consistency of new lines (see #11153)
			if ( typeof elem.textContent === "string" ) {
				return elem.textContent;
			} else {
				// Traverse its children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
		// Do not include comment or processing instruction nodes
	} else {

		// If no nodeType, this is expected to be an array
		for ( ; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	}
	return ret;
};

isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

// Element contains another
contains = Sizzle.contains = docElem.contains ?
	function( a, b ) {
		var adown = a.nodeType === 9 ? a.documentElement : a,
			bup = b && b.parentNode;
		return a === bup || !!( bup && bup.nodeType === 1 && adown.contains && adown.contains(bup) );
	} :
	docElem.compareDocumentPosition ?
	function( a, b ) {
		return b && !!( a.compareDocumentPosition( b ) & 16 );
	} :
	function( a, b ) {
		while ( (b = b.parentNode) ) {
			if ( b === a ) {
				return true;
			}
		}
		return false;
	};

Sizzle.attr = function( elem, name ) {
	var val,
		xml = isXML( elem );

	if ( !xml ) {
		name = name.toLowerCase();
	}
	if ( (val = Expr.attrHandle[ name ]) ) {
		return val( elem );
	}
	if ( xml || assertAttributes ) {
		return elem.getAttribute( name );
	}
	val = elem.getAttributeNode( name );
	return val ?
		typeof elem[ name ] === "boolean" ?
			elem[ name ] ? name : null :
			val.specified ? val.value : null :
		null;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	// IE6/7 return a modified href
	attrHandle: assertHrefNotNormalized ?
		{} :
		{
			"href": function( elem ) {
				return elem.getAttribute( "href", 2 );
			},
			"type": function( elem ) {
				return elem.getAttribute("type");
			}
		},

	find: {
		"ID": assertGetIdNotName ?
			function( id, context, xml ) {
				if ( typeof context.getElementById !== strundefined && !xml ) {
					var m = context.getElementById( id );
					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					return m && m.parentNode ? [m] : [];
				}
			} :
			function( id, context, xml ) {
				if ( typeof context.getElementById !== strundefined && !xml ) {
					var m = context.getElementById( id );

					return m ?
						m.id === id || typeof m.getAttributeNode !== strundefined && m.getAttributeNode("id").value === id ?
							[m] :
							undefined :
						[];
				}
			},

		"TAG": assertTagNameNoComments ?
			function( tag, context ) {
				if ( typeof context.getElementsByTagName !== strundefined ) {
					return context.getElementsByTagName( tag );
				}
			} :
			function( tag, context ) {
				var results = context.getElementsByTagName( tag );

				// Filter out possible comments
				if ( tag === "*" ) {
					var elem,
						tmp = [],
						i = 0;

					for ( ; (elem = results[i]); i++ ) {
						if ( elem.nodeType === 1 ) {
							tmp.push( elem );
						}
					}

					return tmp;
				}
				return results;
			},

		"NAME": assertUsableName && function( tag, context ) {
			if ( typeof context.getElementsByName !== strundefined ) {
				return context.getElementsByName( name );
			}
		},

		"CLASS": assertUsableClassName && function( className, context, xml ) {
			if ( typeof context.getElementsByClassName !== strundefined && !xml ) {
				return context.getElementsByClassName( className );
			}
		}
	},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( rbackslash, "" );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[4] || match[5] || "" ).replace( rbackslash, "" );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				3 xn-component of xn+y argument ([+-]?\d*n|)
				4 sign of xn-component
				5 x of xn-component
				6 sign of y-component
				7 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1] === "nth" ) {
				// nth-child requires argument
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[3] = +( match[3] ? match[4] + (match[5] || 1) : 2 * ( match[2] === "even" || match[2] === "odd" ) );
				match[4] = +( ( match[6] + match[7] ) || match[2] === "odd" );

			// other types prohibit arguments
			} else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var unquoted, excess;
			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			if ( match[3] ) {
				match[2] = match[3];
			} else if ( (unquoted = match[4]) ) {
				// Only check arguments that contain a pseudo
				if ( rpseudo.test(unquoted) &&
					// Get excess from tokenize (recursively)
					(excess = tokenize( unquoted, true )) &&
					// advance to the next closing parenthesis
					(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

					// excess is a negative index
					unquoted = unquoted.slice( 0, excess );
					match[0] = match[0].slice( 0, excess );
				}
				match[2] = unquoted;
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {
		"ID": assertGetIdNotName ?
			function( id ) {
				id = id.replace( rbackslash, "" );
				return function( elem ) {
					return elem.getAttribute("id") === id;
				};
			} :
			function( id ) {
				id = id.replace( rbackslash, "" );
				return function( elem ) {
					var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode("id");
					return node && node.value === id;
				};
			},

		"TAG": function( nodeName ) {
			if ( nodeName === "*" ) {
				return function() { return true; };
			}
			nodeName = nodeName.replace( rbackslash, "" ).toLowerCase();

			return function( elem ) {
				return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
			};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ expando ][ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( elem.className || (typeof elem.getAttribute !== strundefined && elem.getAttribute("class")) || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem, context ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.substr( result.length - check.length ) === check :
					operator === "~=" ? ( " " + result + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.substr( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, argument, first, last ) {

			if ( type === "nth" ) {
				return function( elem ) {
					var node, diff,
						parent = elem.parentNode;

					if ( first === 1 && last === 0 ) {
						return true;
					}

					if ( parent ) {
						diff = 0;
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								diff++;
								if ( elem === node ) {
									break;
								}
							}
						}
					}

					// Incorporate the offset (or cast to NaN), then check against cycle size
					diff -= last;
					return diff === first || ( diff % first === 0 && diff / first >= 0 );
				};
			}

			return function( elem ) {
				var node = elem;

				switch ( type ) {
					case "only":
					case "first":
						while ( (node = node.previousSibling) ) {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						if ( type === "first" ) {
							return true;
						}

						node = elem;

						/* falls through */
					case "last":
						while ( (node = node.nextSibling) ) {
							if ( node.nodeType === 1 ) {
								return false;
							}
						}

						return true;
				}
			};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf.call( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
			//   not comment, processing instructions, or others
			// Thanks to Diego Perini for the nodeName shortcut
			//   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
			var nodeType;
			elem = elem.firstChild;
			while ( elem ) {
				if ( elem.nodeName > "@" || (nodeType = elem.nodeType) === 3 || nodeType === 4 ) {
					return false;
				}
				elem = elem.nextSibling;
			}
			return true;
		},

		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"text": function( elem ) {
			var type, attr;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" &&
				(type = elem.type) === "text" &&
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === type );
		},

		// Input types
		"radio": createInputPseudo("radio"),
		"checkbox": createInputPseudo("checkbox"),
		"file": createInputPseudo("file"),
		"password": createInputPseudo("password"),
		"image": createInputPseudo("image"),

		"submit": createButtonPseudo("submit"),
		"reset": createButtonPseudo("reset"),

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"focus": function( elem ) {
			var doc = elem.ownerDocument;
			return elem === doc.activeElement && (!doc.hasFocus || doc.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		"active": function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		},

		// Positional types
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			for ( var i = 0; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			for ( var i = 1; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			for ( var i = argument < 0 ? argument + length : argument; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			for ( var i = argument < 0 ? argument + length : argument; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

function siblingCheck( a, b, ret ) {
	if ( a === b ) {
		return ret;
	}

	var cur = a.nextSibling;

	while ( cur ) {
		if ( cur === b ) {
			return -1;
		}

		cur = cur.nextSibling;
	}

	return 1;
}

sortOrder = docElem.compareDocumentPosition ?
	function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		return ( !a.compareDocumentPosition || !b.compareDocumentPosition ?
			a.compareDocumentPosition :
			a.compareDocumentPosition(b) & 4
		) ? -1 : 1;
	} :
	function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

// Always assume the presence of duplicates if sort doesn't
// pass them to our comparison function (as in Google Chrome).
[0, 0].sort( sortOrder );
baseHasDuplicate = !hasDuplicate;

// Document sorting and removing duplicates
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		i = 1,
		j = 0;

	hasDuplicate = baseHasDuplicate;
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		for ( ; (elem = results[i]); i++ ) {
			if ( elem === results[ i - 1 ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	return results;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

function tokenize( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ expando ][ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( tokens = [] );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			tokens.push( matched = new Token( match.shift() ) );
			soFar = soFar.slice( matched.length );

			// Cast descendant combinators to space
			matched.type = match[0].replace( rtrim, " " );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {

				tokens.push( matched = new Token( match.shift() ) );
				soFar = soFar.slice( matched.length );
				matched.type = type;
				matched.matches = match;
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && combinator.dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( checkNonElements || elem.nodeType === 1  ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			// We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
			if ( !xml ) {
				var cache,
					dirkey = dirruns + " " + doneName + " ",
					cachedkey = dirkey + cachedruns;
				while ( (elem = elem[ dir ]) ) {
					if ( checkNonElements || elem.nodeType === 1 ) {
						if ( (cache = elem[ expando ]) === cachedkey ) {
							return elem.sizset;
						} else if ( typeof cache === "string" && cache.indexOf(dirkey) === 0 ) {
							if ( elem.sizset ) {
								return elem;
							}
						} else {
							elem[ expando ] = cachedkey;
							if ( matcher( elem, context, xml ) ) {
								elem.sizset = true;
								return elem;
							}
							elem.sizset = false;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( checkNonElements || elem.nodeType === 1 ) {
						if ( matcher( elem, context, xml ) ) {
							return elem;
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf.call( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && tokens.slice( 0, i - 1 ).join("").replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && tokens.join("")
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, expandContext ) {
			var elem, j, matcher,
				setMatched = [],
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				outermost = expandContext != null,
				contextBackup = outermostContext,
				// We must always have either seed elements or context
				elems = seed || byElement && Expr.find["TAG"]( "*", expandContext && context.parentNode || context ),
				// Nested matchers should use non-integer dirruns
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.E);

			if ( outermost ) {
				outermostContext = context !== document && context;
				cachedruns = superMatcher.el;
			}

			// Add elements passing elementMatchers directly to results
			for ( ; (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					for ( j = 0; (matcher = elementMatchers[j]); j++ ) {
						if ( matcher( elem, context, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
						cachedruns = ++superMatcher.el;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// Apply set filters to unmatched elements
			matchedCount += i;
			if ( bySet && i !== matchedCount ) {
				for ( j = 0; (matcher = setMatchers[j]); j++ ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	superMatcher.el = 0;
	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ expando ][ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !group ) {
			group = tokenize( selector );
		}
		i = group.length;
		while ( i-- ) {
			cached = matcherFromTokens( group[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );
	}
	return cached;
};

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function select( selector, context, results, seed, xml ) {
	var i, tokens, token, type, find,
		match = tokenize( selector ),
		j = match.length;

	if ( !seed ) {
		// Try to minimize operations if there is only one group
		if ( match.length === 1 ) {

			// Take a shortcut and set the context if the root selector is an ID
			tokens = match[0] = match[0].slice( 0 );
			if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
					context.nodeType === 9 && !xml &&
					Expr.relative[ tokens[1].type ] ) {

				context = Expr.find["ID"]( token.matches[0].replace( rbackslash, "" ), context, xml )[0];
				if ( !context ) {
					return results;
				}

				selector = selector.slice( tokens.shift().length );
			}

			// Fetch a seed set for right-to-left matching
			for ( i = matchExpr["POS"].test( selector ) ? -1 : tokens.length - 1; i >= 0; i-- ) {
				token = tokens[i];

				// Abort if we hit a combinator
				if ( Expr.relative[ (type = token.type) ] ) {
					break;
				}
				if ( (find = Expr.find[ type ]) ) {
					// Search, expanding context for leading sibling combinators
					if ( (seed = find(
						token.matches[0].replace( rbackslash, "" ),
						rsibling.test( tokens[0].type ) && context.parentNode || context,
						xml
					)) ) {

						// If seed is empty or no tokens remain, we can return early
						tokens.splice( i, 1 );
						selector = seed.length && tokens.join("");
						if ( !selector ) {
							push.apply( results, slice.call( seed, 0 ) );
							return results;
						}

						break;
					}
				}
			}
		}
	}

	// Compile and execute a filtering function
	// Provide `match` to avoid retokenization if we modified the selector above
	compile( selector, match )(
		seed,
		context,
		xml,
		results,
		rsibling.test( selector )
	);
	return results;
}

if ( document.querySelectorAll ) {
	(function() {
		var disconnectedMatch,
			oldSelect = select,
			rescape = /'|\\/g,
			rattributeQuotes = /\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,

			// qSa(:focus) reports false when true (Chrome 21), no need to also add to buggyMatches since matches checks buggyQSA
			// A support test would require too much code (would include document ready)
			rbuggyQSA = [ ":focus" ],

			// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
			// A support test would require too much code (would include document ready)
			// just skip matchesSelector for :active
			rbuggyMatches = [ ":active" ],
			matches = docElem.matchesSelector ||
				docElem.mozMatchesSelector ||
				docElem.webkitMatchesSelector ||
				docElem.oMatchesSelector ||
				docElem.msMatchesSelector;

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explictly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			div.innerHTML = "<select><option selected=''></option></select>";

			// IE8 - Some boolean attributes are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:checked|disabled|ismap|multiple|readonly|selected|value)" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here (do not put tests after this one)
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}
		});

		assert(function( div ) {

			// Opera 10-12/IE9 - ^= $= *= and empty values
			// Should not select anything
			div.innerHTML = "<p test=''></p>";
			if ( div.querySelectorAll("[test^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:\"\"|'')" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here (do not put tests after this one)
			div.innerHTML = "<input type='hidden'/>";
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push(":enabled", ":disabled");
			}
		});

		// rbuggyQSA always contains :focus, so no need for a length check
		rbuggyQSA = /* rbuggyQSA.length && */ new RegExp( rbuggyQSA.join("|") );

		select = function( selector, context, results, seed, xml ) {
			// Only use querySelectorAll when not filtering,
			// when this is not xml,
			// and when no QSA bugs apply
			if ( !seed && !xml && !rbuggyQSA.test( selector ) ) {
				var groups, i,
					old = true,
					nid = expando,
					newContext = context,
					newSelector = context.nodeType === 9 && selector;

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					groups = tokenize( selector );

					if ( (old = context.getAttribute("id")) ) {
						nid = old.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", nid );
					}
					nid = "[id='" + nid + "'] ";

					i = groups.length;
					while ( i-- ) {
						groups[i] = nid + groups[i].join("");
					}
					newContext = rsibling.test( selector ) && context.parentNode || context;
					newSelector = groups.join(",");
				}

				if ( newSelector ) {
					try {
						push.apply( results, slice.call( newContext.querySelectorAll(
							newSelector
						), 0 ) );
						return results;
					} catch(qsaError) {
					} finally {
						if ( !old ) {
							context.removeAttribute("id");
						}
					}
				}
			}

			return oldSelect( selector, context, results, seed, xml );
		};

		if ( matches ) {
			assert(function( div ) {
				// Check to see if it's possible to do matchesSelector
				// on a disconnected node (IE 9)
				disconnectedMatch = matches.call( div, "div" );

				// This should fail with an exception
				// Gecko does not error, returns false instead
				try {
					matches.call( div, "[test!='']:sizzle" );
					rbuggyMatches.push( "!=", pseudos );
				} catch ( e ) {}
			});

			// rbuggyMatches always contains :active and :focus, so no need for a length check
			rbuggyMatches = /* rbuggyMatches.length && */ new RegExp( rbuggyMatches.join("|") );

			Sizzle.matchesSelector = function( elem, expr ) {
				// Make sure that attribute selectors are quoted
				expr = expr.replace( rattributeQuotes, "='$1']" );

				// rbuggyMatches always contains :active, so no need for an existence check
				if ( !isXML( elem ) && !rbuggyMatches.test( expr ) && !rbuggyQSA.test( expr ) ) {
					try {
						var ret = matches.call( elem, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9
								elem.document && elem.document.nodeType !== 11 ) {
							return ret;
						}
					} catch(e) {}
				}

				return Sizzle( expr, null, null, [ elem ] ).length > 0;
			};
		}
	})();
}

// Deprecated
Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Back-compat
function setFilters() {}
Expr.filters = setFilters.prototype = Expr.pseudos;
Expr.setFilters = new setFilters();

// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.pseudos;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})( window );
var runtil = /Until$/,
	rparentsprev = /^(?:parents|prev(?:Until|All))/,
	isSimple = /^.[^:#\[\.,]*$/,
	rneedsContext = jQuery.expr.match.needsContext,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var i, l, length, n, r, ret,
			self = this;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		ret = this.pushStack( "", "find", selector );

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var i,
			targets = jQuery( target, this ),
			len = targets.length;

		return this.filter(function() {
			for ( i = 0; i < len; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && (
			typeof selector === "string" ?
				// If this is a positional/relative selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				rneedsContext.test( selector ) ?
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			ret = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			cur = this[i];

			while ( cur && cur.ownerDocument && cur !== context && cur.nodeType !== 11 ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;
				}
				cur = cur.parentNode;
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter(selector)
		);
	}
});

jQuery.fn.andSelf = jQuery.fn.addBack;

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

function sibling( cur, dir ) {
	do {
		cur = cur[ dir ];
	} while ( cur && cur.nodeType !== 1 );

	return cur;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( this.length > 1 && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, core_slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}
function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style|link)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")[\\s/>]", "i"),
	rcheckableType = /^(?:checkbox|radio)$/,
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document ),
	fragmentDiv = safeFragment.appendChild( document.createElement("div") );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,
// unless wrapped in a div with non-breaking characters in front of it.
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "X<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( value ) {
		return jQuery.access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );
		}, null, value, arguments.length );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( !isDisconnected( this[0] ) ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		}

		if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			return this.pushStack( jQuery.merge( set, this ), "before", this.selector );
		}
	},

	after: function() {
		if ( !isDisconnected( this[0] ) ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		}

		if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			return this.pushStack( jQuery.merge( this, set ), "after", this.selector );
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		return jQuery.access( this, function( value ) {
			var elem = this[0] || {},
				i = 0,
				l = this.length;

			if ( value === undefined ) {
				return elem.nodeType === 1 ?
					elem.innerHTML.replace( rinlinejQuery, "" ) :
					undefined;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&
				( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&
				!wrapMap[ ( rtagName.exec( value ) || ["", ""] )[1].toLowerCase() ] ) {

				value = value.replace( rxhtmlTag, "<$1></$2>" );

				try {
					for (; i < l; i++ ) {
						// Remove element nodes and prevent memory leaks
						elem = this[i] || {};
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( elem.getElementsByTagName( "*" ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch(e) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function( value ) {
		if ( !isDisconnected( this[0] ) ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		}

		return this.length ?
			this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
			this;
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {

		// Flatten any nested arrays
		args = [].concat.apply( [], args );

		var results, first, fragment, iNoClone,
			i = 0,
			value = args[0],
			scripts = [],
			l = this.length;

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && l > 1 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call( this, i, table ? self.html() : undefined );
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			results = jQuery.buildFragment( args, this, scripts );
			fragment = results.fragment;
			first = fragment.firstChild;

			if ( fragment.childNodes.length === 1 ) {
				fragment = first;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				// Use the original fragment for the last item instead of the first because it can end up
				// being emptied incorrectly in certain situations (#8070).
				// Fragments from the fragment cache must always be cloned and never used in place.
				for ( iNoClone = results.cacheable || l - 1; i < l; i++ ) {
					callback.call(
						table && jQuery.nodeName( this[i], "table" ) ?
							findOrAppend( this[i], "tbody" ) :
							this[i],
						i === iNoClone ?
							fragment :
							jQuery.clone( fragment, true, true )
					);
				}
			}

			// Fix #11809: Avoid leaking memory
			fragment = first = null;

			if ( scripts.length ) {
				jQuery.each( scripts, function( i, elem ) {
					if ( elem.src ) {
						if ( jQuery.ajax ) {
							jQuery.ajax({
								url: elem.src,
								type: "GET",
								dataType: "script",
								async: false,
								global: false,
								"throws": true
							});
						} else {
							jQuery.error("no ajax");
						}
					} else {
						jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "" ) );
					}

					if ( elem.parentNode ) {
						elem.parentNode.removeChild( elem );
					}
				});
			}
		}

		return this;
	}
});

function findOrAppend( elem, tag ) {
	return elem.getElementsByTagName( tag )[0] || elem.appendChild( elem.ownerDocument.createElement( tag ) );
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type, events[ type ][ i ] );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	if ( nodeName === "object" ) {
		// IE6-10 improperly clones children of object elements using classid.
		// IE10 throws NoModificationAllowedError if parent is null, #12132.
		if ( dest.parentNode ) {
			dest.outerHTML = src.outerHTML;
		}

		// This path appears unavoidable for IE9. When cloning an object
		// element in IE9, the outerHTML strategy above is not sufficient.
		// If the src has innerHTML and the destination does not,
		// copy the src.innerHTML into the dest.innerHTML. #10324
		if ( jQuery.support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML)) ) {
			dest.innerHTML = src.innerHTML;
		}

	} else if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set

		dest.defaultChecked = dest.checked = src.checked;

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;

	// IE blanks contents when cloning scripts
	} else if ( nodeName === "script" && dest.text !== src.text ) {
		dest.text = src.text;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, context, scripts ) {
	var fragment, cacheable, cachehit,
		first = args[ 0 ];

	// Set context from what may come in as undefined or a jQuery collection or a node
	// Updated to fix #12266 where accessing context[0] could throw an exception in IE9/10 &
	// also doubles as fix for #8950 where plain objects caused createDocumentFragment exception
	context = context || document;
	context = !context.nodeType && context[0] || context;
	context = context.ownerDocument || context;

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && context === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		// Mark cacheable and look for a hit
		cacheable = true;
		fragment = jQuery.fragments[ first ];
		cachehit = fragment !== undefined;
	}

	if ( !fragment ) {
		fragment = context.createDocumentFragment();
		jQuery.clean( args, context, fragment, scripts );

		// Update the cache, but only store false
		// unless this is a second parsing of the same content
		if ( cacheable ) {
			jQuery.fragments[ first ] = cachehit && fragment;
		}
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			i = 0,
			ret = [],
			insert = jQuery( selector ),
			l = insert.length,
			parent = this.length === 1 && this[0].parentNode;

		if ( (parent == null || parent && parent.nodeType === 11 && parent.childNodes.length === 1) && l === 1 ) {
			insert[ original ]( this[0] );
			return this;
		} else {
			for ( ; i < l; i++ ) {
				elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( rcheckableType.test( elem.type ) ) {
		elem.defaultChecked = elem.checked;
	}
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			clone;

		if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( "<" + elem.nodeName + ">" ) ) {
			clone = elem.cloneNode( true );

		// IE<=8 does not properly clone detached, unknown element nodes
		} else {
			fragmentDiv.innerHTML = elem.outerHTML;
			fragmentDiv.removeChild( clone = fragmentDiv.firstChild );
		}

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var i, j, elem, tag, wrap, depth, div, hasBody, tbody, len, handleScript, jsTags,
			safe = context === document && safeFragment,
			ret = [];

		// Ensure that context is a document
		if ( !context || typeof context.createDocumentFragment === "undefined" ) {
			context = document;
		}

		// Use the already-created safe fragment if context permits
		for ( i = 0; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Ensure a safe container in which to render the html
					safe = safe || createSafeFragment( context );
					div = context.createElement("div");
					safe.appendChild( div );

					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Go to html and back, then peel off extra wrappers
					tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase();
					wrap = wrapMap[ tag ] || wrapMap._default;
					depth = wrap[0];
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						hasBody = rtbody.test(elem);
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;

					// Take out of fragment container (we need a fresh div each time)
					div.parentNode.removeChild( div );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				jQuery.merge( ret, elem );
			}
		}

		// Fix #11356: Clear elements from safeFragment
		if ( div ) {
			elem = div = safe = null;
		}

		// Reset defaultChecked for any radios and checkboxes
		// about to be appended to the DOM in IE 6/7 (#8060)
		if ( !jQuery.support.appendChecked ) {
			for ( i = 0; (elem = ret[i]) != null; i++ ) {
				if ( jQuery.nodeName( elem, "input" ) ) {
					fixDefaultChecked( elem );
				} else if ( typeof elem.getElementsByTagName !== "undefined" ) {
					jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
				}
			}
		}

		// Append elements to a provided document fragment
		if ( fragment ) {
			// Special handling of each script element
			handleScript = function( elem ) {
				// Check if we consider it executable
				if ( !elem.type || rscriptType.test( elem.type ) ) {
					// Detach the script and store it in the scripts array (if provided) or the fragment
					// Return truthy to indicate that it has been handled
					return scripts ?
						scripts.push( elem.parentNode ? elem.parentNode.removeChild( elem ) : elem ) :
						fragment.appendChild( elem );
				}
			};

			for ( i = 0; (elem = ret[i]) != null; i++ ) {
				// Check if we're done after handling an executable script
				if ( !( jQuery.nodeName( elem, "script" ) && handleScript( elem ) ) ) {
					// Append to fragment and handle embedded scripts
					fragment.appendChild( elem );
					if ( typeof elem.getElementsByTagName !== "undefined" ) {
						// handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration
						jsTags = jQuery.grep( jQuery.merge( [], elem.getElementsByTagName("script") ), handleScript );

						// Splice the scripts into ret after their former ancestor and advance our index beyond them
						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
						i += jsTags.length;
					}
				}
			}
		}

		return ret;
	},

	cleanData: function( elems, /* internal */ acceptData ) {
		var data, id, elem, type,
			i = 0,
			internalKey = jQuery.expando,
			cache = jQuery.cache,
			deleteExpando = jQuery.support.deleteExpando,
			special = jQuery.event.special;

		for ( ; (elem = elems[i]) != null; i++ ) {

			if ( acceptData || jQuery.acceptData( elem ) ) {

				id = elem[ internalKey ];
				data = id && cache[ id ];

				if ( data ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Remove cache only if it was not already removed by jQuery.event.remove
					if ( cache[ id ] ) {

						delete cache[ id ];

						// IE does not allow us to delete expando properties from nodes,
						// nor does it have a removeAttribute function on Document nodes;
						// we must handle all of these cases
						if ( deleteExpando ) {
							delete elem[ internalKey ];

						} else if ( elem.removeAttribute ) {
							elem.removeAttribute( internalKey );

						} else {
							elem[ internalKey ] = null;
						}

						jQuery.deletedIds.push( id );
					}
				}
			}
		}
	}
});
// Limit scope pollution from any deprecated API
(function() {

var matched, browser;

// Use of jQuery.browser is frowned upon.
// More details: http://api.jquery.com/jQuery.browser
// jQuery.uaMatch maintained for back-compat
jQuery.uaMatch = function( ua ) {
	ua = ua.toLowerCase();

	var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
		/(webkit)[ \/]([\w.]+)/.exec( ua ) ||
		/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
		/(msie) ([\w.]+)/.exec( ua ) ||
		ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
		[];

	return {
		browser: match[ 1 ] || "",
		version: match[ 2 ] || "0"
	};
};

matched = jQuery.uaMatch( navigator.userAgent );
browser = {};

if ( matched.browser ) {
	browser[ matched.browser ] = true;
	browser.version = matched.version;
}

// Chrome is Webkit, but Webkit is also Safari.
if ( browser.chrome ) {
	browser.webkit = true;
} else if ( browser.webkit ) {
	browser.safari = true;
}

jQuery.browser = browser;

jQuery.sub = function() {
	function jQuerySub( selector, context ) {
		return new jQuerySub.fn.init( selector, context );
	}
	jQuery.extend( true, jQuerySub, this );
	jQuerySub.superclass = this;
	jQuerySub.fn = jQuerySub.prototype = this();
	jQuerySub.fn.constructor = jQuerySub;
	jQuerySub.sub = this.sub;
	jQuerySub.fn.init = function init( selector, context ) {
		if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
			context = jQuerySub( context );
		}

		return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
	};
	jQuerySub.fn.init.prototype = jQuerySub.fn;
	var rootjQuerySub = jQuerySub(document);
	return jQuerySub;
};

})();
var curCSS, iframe, iframeDoc,
	ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	rposition = /^(top|right|bottom|left)$/,
	// swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
	// see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rmargin = /^margin/,
	rnumsplit = new RegExp( "^(" + core_pnum + ")(.*)$", "i" ),
	rnumnonpx = new RegExp( "^(" + core_pnum + ")(?!px)[a-z%]+$", "i" ),
	rrelNum = new RegExp( "^([-+])=(" + core_pnum + ")", "i" ),
	elemdisplay = { BODY: "block" },

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: 0,
		fontWeight: 400
	},

	cssExpand = [ "Top", "Right", "Bottom", "Left" ],
	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],

	eventsToggle = jQuery.fn.toggle;

// return a css property mapped to a potentially vendor prefixed property
function vendorPropName( style, name ) {

	// shortcut for names that are not vendor prefixed
	if ( name in style ) {
		return name;
	}

	// check for vendor prefixed names
	var capName = name.charAt(0).toUpperCase() + name.slice(1),
		origName = name,
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in style ) {
			return name;
		}
	}

	return origName;
}

function isHidden( elem, el ) {
	elem = el || elem;
	return jQuery.css( elem, "display" ) === "none" || !jQuery.contains( elem.ownerDocument, elem );
}

function showHide( elements, show ) {
	var elem, display,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		values[ index ] = jQuery._data( elem, "olddisplay" );
		if ( show ) {
			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && elem.style.display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = jQuery._data( elem, "olddisplay", css_defaultDisplay(elem.nodeName) );
			}
		} else {
			display = curCSS( elem, "display" );

			if ( !values[ index ] && display !== "none" ) {
				jQuery._data( elem, "olddisplay", display );
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.fn.extend({
	css: function( name, value ) {
		return jQuery.access( this, function( elem, name, value ) {
			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state, fn2 ) {
		var bool = typeof state === "boolean";

		if ( jQuery.isFunction( state ) && jQuery.isFunction( fn2 ) ) {
			return eventsToggle.apply( this, arguments );
		}

		return this.each(function() {
			if ( bool ? state : isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		});
	}
});

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;

				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, numeric, extra ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );

		// gets hook for the prefixed version
		// followed by the unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name );
		}

		//convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Return, converting to number if forced or a qualifier was provided and val looks numeric
		if ( numeric || extra !== undefined ) {
			num = parseFloat( val );
			return numeric || jQuery.isNumeric( num ) ? num || 0 : val;
		}
		return val;
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var ret, name,
			old = {};

		// Remember the old values, and insert the new ones
		for ( name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		ret = callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}

		return ret;
	}
});

// NOTE: To any future maintainer, we've window.getComputedStyle
// because jsdom on node.js will break without it.
if ( window.getComputedStyle ) {
	curCSS = function( elem, name ) {
		var ret, width, minWidth, maxWidth,
			computed = window.getComputedStyle( elem, null ),
			style = elem.style;

		if ( computed ) {

			// getPropertyValue is only needed for .css('filter') in IE9, see #12537
			ret = computed.getPropertyValue( name ) || computed[ name ];

			if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
				ret = jQuery.style( elem, name );
			}

			// A tribute to the "awesome hack by Dean Edwards"
			// Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
			// Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
			// this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
			if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {
				width = style.width;
				minWidth = style.minWidth;
				maxWidth = style.maxWidth;

				style.minWidth = style.maxWidth = style.width = ret;
				ret = computed.width;

				style.width = width;
				style.minWidth = minWidth;
				style.maxWidth = maxWidth;
			}
		}

		return ret;
	};
} else if ( document.documentElement.currentStyle ) {
	curCSS = function( elem, name ) {
		var left, rsLeft,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret == null && style && style[ name ] ) {
			ret = style[ name ];
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		// but not position css attributes, as those are proportional to the parent element instead
		// and we can't measure the parent instead because it might trigger a "stacking dolls" problem
		if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ret;
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

function setPositiveNumber( elem, value, subtract ) {
	var matches = rnumsplit.exec( value );
	return matches ?
			Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || "px" ) :
			value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?
		// If we already have the right measurement, avoid augmentation
		4 :
		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {
		// both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			// we use jQuery.css instead of curCSS here
			// because of the reliableMarginRight CSS hook!
			val += jQuery.css( elem, extra + cssExpand[ i ], true );
		}

		// From this point on we use curCSS for maximum performance (relevant in animations)
		if ( isBorderBox ) {
			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;
			}

			// at this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
		} else {
			// at this point, extra isn't content, so add padding
			val += parseFloat( curCSS( elem, "padding" + cssExpand[ i ] ) ) || 0;

			// at this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += parseFloat( curCSS( elem, "border" + cssExpand[ i ] + "Width" ) ) || 0;
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		valueIsBorderBox = true,
		isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box";

	// some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {
		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test(val) ) {
			return val;
		}

		// we need the check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox
		)
	) + "px";
}


// Try to determine the default display value of an element
function css_defaultDisplay( nodeName ) {
	if ( elemdisplay[ nodeName ] ) {
		return elemdisplay[ nodeName ];
	}

	var elem = jQuery( "<" + nodeName + ">" ).appendTo( document.body ),
		display = elem.css("display");
	elem.remove();

	// If the simple way fails,
	// get element's real default display by attaching it to a temp iframe
	if ( display === "none" || display === "" ) {
		// Use the already-created iframe if possible
		iframe = document.body.appendChild(
			iframe || jQuery.extend( document.createElement("iframe"), {
				frameBorder: 0,
				width: 0,
				height: 0
			})
		);

		// Create a cacheable copy of the iframe document on first call.
		// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
		// document to it; WebKit & Firefox won't allow reusing the iframe document.
		if ( !iframeDoc || !iframe.createElement ) {
			iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
			iframeDoc.write("<!doctype html><html><body>");
			iframeDoc.close();
		}

		elem = iframeDoc.body.appendChild( iframeDoc.createElement(nodeName) );

		display = curCSS( elem, "display" );
		document.body.removeChild( iframe );
	}

	// Store the correct default display
	elemdisplay[ nodeName ] = display;

	return display;
}

jQuery.each([ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {
				// certain elements can have dimension info if we invisibly show them
				// however, it must have a current display style that would benefit from this
				if ( elem.offsetWidth === 0 && rdisplayswap.test( curCSS( elem, "display" ) ) ) {
					return jQuery.swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, name, extra );
					});
				} else {
					return getWidthOrHeight( elem, name, extra );
				}
			}
		},

		set: function( elem, value, extra ) {
			return setPositiveNumber( elem, value, extra ?
				augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.support.boxSizing && jQuery.css( elem, "boxSizing" ) === "border-box"
				) : 0
			);
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( 0.01 * parseFloat( RegExp.$1 ) ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" &&
				style.removeAttribute ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

// These hooks cannot be added until DOM ready because the support test
// for it is not run until after DOM ready
jQuery(function() {
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				return jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						return curCSS( elem, "marginRight" );
					}
				});
			}
		};
	}

	// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
	// getComputedStyle returns percent when specified for top/left/bottom/right
	// rather than make the css module depend on the offset module, we just check for it here
	if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {
		jQuery.each( [ "top", "left" ], function( i, prop ) {
			jQuery.cssHooks[ prop ] = {
				get: function( elem, computed ) {
					if ( computed ) {
						var ret = curCSS( elem, prop );
						// if curCSS returns percentage, fallback to offset
						return rnumnonpx.test( ret ) ? jQuery( elem ).position()[ prop ] + "px" : ret;
					}
				}
			};
		});
	}

});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		return ( elem.offsetWidth === 0 && elem.offsetHeight === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || curCSS( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}

// These hooks are used by animate to expand properties
jQuery.each({
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i,

				// assumes a single number if not a string
				parts = typeof value === "string" ? value.split(" ") : [ value ],
				expanded = {};

			for ( i = 0; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
});
var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	rselectTextarea = /^(?:select|textarea)/i;

jQuery.fn.extend({
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

//Serialize an array of form elements or a set of
//key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {
			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		});

	} else {
		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {
		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}
var
	// Document location
	ajaxLocParts,
	ajaxLocation,

	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType, list, placeBefore,
			dataTypes = dataTypeExpression.toLowerCase().split( core_rspace ),
			i = 0,
			length = dataTypes.length;

		if ( jQuery.isFunction( func ) ) {
			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var selection,
		list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters );

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	// Don't do a request if no elements are being requested
	if ( !this.length ) {
		return this;
	}

	var selector, type, response,
		self = this,
		off = url.indexOf(" ");

	if ( off >= 0 ) {
		selector = url.slice( off, url.length );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// Request the remote document
	jQuery.ajax({
		url: url,

		// if "type" variable is undefined, then "GET" method will be used
		type: type,
		dataType: "html",
		data: params,
		complete: function( jqXHR, status ) {
			if ( callback ) {
				self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );
			}
		}
	}).done(function( responseText ) {

		// Save response for use in complete callback
		response = arguments;

		// See if a selector was specified
		self.html( selector ?

			// Create a dummy div to hold the results
			jQuery("<div>")

				// inject the contents of the document in, removing the scripts
				// to avoid any 'Permission Denied' errors in IE
				.append( responseText.replace( rscript, "" ) )

				// Locate the specified elements
				.find( selector ) :

			// If not, just inject the full result
			responseText );

	});

	return this;
};

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // ifModified key
			ifModifiedKey,
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// The jqXHR state
			state = 0,
			// Default abort message
			strAbort = "canceled",
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || strAbort;
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					modified = jqXHR.getResponseHeader("Last-Modified");
					if ( modified ) {
						jQuery.lastModified[ ifModifiedKey ] = modified;
					}
					modified = jqXHR.getResponseHeader("Etag");
					if ( modified ) {
						jQuery.etag[ ifModifiedKey ] = modified;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					isSuccess = ajaxConvert( s, response );
					statusText = isSuccess.state;
					success = isSuccess.data;
					error = isSuccess.error;
					isSuccess = !error;
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.always( tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( core_rspace );

		// A cross-domain request is in order when we have a protocol:host:port mismatch
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already and return
				return jqXHR.abort();

		}

		// aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	var conv, conv2, current, tmp,
		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice(),
		prev = dataTypes[ 0 ],
		converters = {},
		i = 0;

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	// Convert to each sequential dataType, tolerating list modification
	for ( ; (current = dataTypes[++i]); ) {

		// There's only work to do if current dataType is non-auto
		if ( current !== "*" ) {

			// Convert response if prev dataType is non-auto and differs from current
			if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split(" ");
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {
								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.splice( i--, 0, current );
								}

								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s["throws"] ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return { state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current };
						}
					}
				}
			}

			// Update prev for next iteration
			prev = current;
		}
	}

	return { state: "success", data: response };
}
var oldCallbacks = [],
	rquestion = /\?/,
	rjsonp = /(=)\?(?=&|$)|\?\?/,
	nonce = jQuery.now();

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		data = s.data,
		url = s.url,
		hasCallback = s.jsonp !== false,
		replaceInUrl = hasCallback && rjsonp.test( url ),
		replaceInData = hasCallback && !replaceInUrl && typeof data === "string" &&
			!( s.contentType || "" ).indexOf("application/x-www-form-urlencoded") &&
			rjsonp.test( data );

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( s.dataTypes[ 0 ] === "jsonp" || replaceInUrl || replaceInData ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;
		overwritten = window[ callbackName ];

		// Insert callback into url or form data
		if ( replaceInUrl ) {
			s.url = url.replace( rjsonp, "$1" + callbackName );
		} else if ( replaceInData ) {
			s.data = data.replace( rjsonp, "$1" + callbackName );
		} else if ( hasCallback ) {
			s.url += ( rquestion.test( url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always(function() {
			// Restore preexisting value
			window[ callbackName ] = overwritten;

			// Save back as free
			if ( s[ callbackName ] ) {
				// make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		});

		// Delegate to script
		return "script";
	}
});
// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});
var xhrCallbacks,
	// #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var handle, i,
						xhr = s.xhr();

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occurred
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}

									// When requesting binary data, IE6-9 will throw an exception
									// on any attempt to access responseText (#11426)
									try {
										responses.text = xhr.responseText;
									} catch( e ) {
									}

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					if ( !s.async ) {
						// if we're in sync mode we fire the callback
						callback();
					} else if ( xhr.readyState === 4 ) {
						// (IE6 & IE7) if it's in cache and has been
						// retrieved directly we need to fire the callback
						setTimeout( callback, 0 );
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}
var fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = new RegExp( "^(?:([-+])=|)(" + core_pnum + ")([a-z%]*)$", "i" ),
	rrun = /queueHooks$/,
	animationPrefilters = [ defaultPrefilter ],
	tweeners = {
		"*": [function( prop, value ) {
			var end, unit,
				tween = this.createTween( prop, value ),
				parts = rfxnum.exec( value ),
				target = tween.cur(),
				start = +target || 0,
				scale = 1,
				maxIterations = 20;

			if ( parts ) {
				end = +parts[2];
				unit = parts[3] || ( jQuery.cssNumber[ prop ] ? "" : "px" );

				// We need to compute starting value
				if ( unit !== "px" && start ) {
					// Iteratively approximate from a nonzero starting point
					// Prefer the current property, because this process will be trivial if it uses the same units
					// Fallback to end or a simple constant
					start = jQuery.css( tween.elem, prop, true ) || end || 1;

					do {
						// If previous iteration zeroed out, double until we get *something*
						// Use a string for doubling factor so we don't accidentally see scale as unchanged below
						scale = scale || ".5";

						// Adjust and apply
						start = start / scale;
						jQuery.style( tween.elem, prop, start + unit );

					// Update scale, tolerating zero or NaN from tween.cur()
					// And breaking the loop if scale is unchanged or perfect, or if we've just had enough
					} while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );
				}

				tween.unit = unit;
				tween.start = start;
				// If a +=/-= token was provided, we're doing a relative animation
				tween.end = parts[1] ? start + ( parts[1] + 1 ) * end : end;
			}
			return tween;
		}]
	};

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout(function() {
		fxNow = undefined;
	}, 0 );
	return ( fxNow = jQuery.now() );
}

function createTweens( animation, props ) {
	jQuery.each( props, function( prop, value ) {
		var collection = ( tweeners[ prop ] || [] ).concat( tweeners[ "*" ] ),
			index = 0,
			length = collection.length;
		for ( ; index < length; index++ ) {
			if ( collection[ index ].call( animation, prop, value ) ) {

				// we're done with this property
				return;
			}
		}
	});
}

function Animation( elem, properties, options ) {
	var result,
		index = 0,
		tweenerIndex = 0,
		length = animationPrefilters.length,
		deferred = jQuery.Deferred().always( function() {
			// don't match elem in the :animated selector
			delete tick.elem;
		}),
		tick = function() {
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),
				// archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ]);

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise({
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, { specialEasing: {} }, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end, easing ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,
					// if we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;

				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// resolve when we played the last frame
				// otherwise, reject
				if ( gotoEnd ) {
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		}),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			return result;
		}
	}

	createTweens( animation, props );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			anim: animation,
			queue: animation.opts.queue,
			elem: elem
		})
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// not quite $.extend, this wont overwrite keys already present.
			// also - reusing 'index' from above because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

jQuery.Animation = jQuery.extend( Animation, {

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.split(" ");
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			tweeners[ prop ] = tweeners[ prop ] || [];
			tweeners[ prop ].unshift( callback );
		}
	},

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			animationPrefilters.unshift( callback );
		} else {
			animationPrefilters.push( callback );
		}
	}
});

function defaultPrefilter( elem, props, opts ) {
	var index, prop, value, length, dataShow, toggle, tween, hooks, oldfire,
		anim = this,
		style = elem.style,
		orig = {},
		handled = [],
		hidden = elem.nodeType && isHidden( elem );

	// handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always(function() {
			// doing this makes sure that the complete handler will be called
			// before this completes
			anim.always(function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			});
		});
	}

	// height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {
		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE does not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		if ( jQuery.css( elem, "display" ) === "inline" &&
				jQuery.css( elem, "float" ) === "none" ) {

			// inline-level elements accept inline-block;
			// block-level elements need to be inline with layout
			if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === "inline" ) {
				style.display = "inline-block";

			} else {
				style.zoom = 1;
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		if ( !jQuery.support.shrinkWrapBlocks ) {
			anim.done(function() {
				style.overflow = opts.overflow[ 0 ];
				style.overflowX = opts.overflow[ 1 ];
				style.overflowY = opts.overflow[ 2 ];
			});
		}
	}


	// show/hide pass
	for ( index in props ) {
		value = props[ index ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ index ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {
				continue;
			}
			handled.push( index );
		}
	}

	length = handled.length;
	if ( length ) {
		dataShow = jQuery._data( elem, "fxshow" ) || jQuery._data( elem, "fxshow", {} );
		if ( "hidden" in dataShow ) {
			hidden = dataShow.hidden;
		}

		// store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done(function() {
				jQuery( elem ).hide();
			});
		}
		anim.done(function() {
			var prop;
			jQuery.removeData( elem, "fxshow", true );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		});
		for ( index = 0 ; index < length ; index++ ) {
			prop = handled[ index ];
			tween = anim.createTween( prop, hidden ? dataShow[ prop ] : 0 );
			orig[ prop ] = dataShow[ prop ] || jQuery.style( elem, prop );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}
	}
}

function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || "swing";
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			if ( tween.elem[ tween.prop ] != null &&
				(!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {
				return tween.elem[ tween.prop ];
			}

			// passing any value as a 4th parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails
			// so, simple values such as "10px" are parsed to Float.
			// complex values such as "rotate(1rad)" are returned as is.
			result = jQuery.css( tween.elem, tween.prop, false, "" );
			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {
			// use step hook for back compat - use cssHook if its there - use .style if its
			// available and use plain properties where available
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Remove in 2.0 - this supports IE8's panic based approach
// to setting things on disconnected nodes

Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.each([ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ||
			// special check for .toggle( handler, handler, ... )
			( !i && jQuery.isFunction( speed ) && jQuery.isFunction( easing ) ) ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
});

jQuery.fn.extend({
	fadeTo: function( speed, to, easing, callback ) {

		// show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// animate to the value specified
			.end().animate({ opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {
				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations resolve immediately
				if ( empty ) {
					anim.stop( true );
				}
			};

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = jQuery._data( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		});
	}
});

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		attrs = { height: type },
		i = 0;

	// if we include width, step value is 1 to do all cssExpand values,
	// if we don't include width, step value is 2 to skip over Left and Right
	includeWidth = includeWidth? 1 : 0;
	for( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx("show"),
	slideUp: genFx("hide"),
	slideToggle: genFx("toggle"),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
		opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p*Math.PI ) / 2;
	}
};

jQuery.timers = [];
jQuery.fx = Tween.prototype.init;
jQuery.fx.tick = function() {
	var timer,
		timers = jQuery.timers,
		i = 0;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];
		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	if ( timer() && jQuery.timers.push( timer ) && !timerId ) {
		timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.interval = 13;

jQuery.fx.stop = function() {
	clearInterval( timerId );
	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,
	// Default speed
	_default: 400
};

// Back Compat <1.8 extension point
jQuery.fx.step = {};

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}
var rroot = /^(?:body|html)$/i;

jQuery.fn.offset = function( options ) {
	if ( arguments.length ) {
		return options === undefined ?
			this :
			this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
	}

	var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
		box = { top: 0, left: 0 },
		elem = this[ 0 ],
		doc = elem && elem.ownerDocument;

	if ( !doc ) {
		return;
	}

	if ( (body = doc.body) === elem ) {
		return jQuery.offset.bodyOffset( elem );
	}

	docElem = doc.documentElement;

	// Make sure it's not a disconnected DOM node
	if ( !jQuery.contains( docElem, elem ) ) {
		return box;
	}

	// If we don't have gBCR, just use 0,0 rather than error
	// BlackBerry 5, iOS 3 (original iPhone)
	if ( typeof elem.getBoundingClientRect !== "undefined" ) {
		box = elem.getBoundingClientRect();
	}
	win = getWindow( doc );
	clientTop  = docElem.clientTop  || body.clientTop  || 0;
	clientLeft = docElem.clientLeft || body.clientLeft || 0;
	scrollTop  = win.pageYOffset || docElem.scrollTop;
	scrollLeft = win.pageXOffset || docElem.scrollLeft;
	return {
		top: box.top  + scrollTop  - clientTop,
		left: box.left + scrollLeft - clientLeft
	};
};

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent || document.body;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( {scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function( method, prop ) {
	var top = /Y/.test( prop );

	jQuery.fn[ method ] = function( val ) {
		return jQuery.access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? (prop in win) ? win[ prop ] :
					win.document.documentElement[ method ] :
					elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : jQuery( win ).scrollLeft(),
					 top ? val : jQuery( win ).scrollTop()
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length, null );
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}
// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name }, function( defaultExtra, funcName ) {
		// margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return jQuery.access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {
					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
					// unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?
					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, value, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	});
});
// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}

})( window );

/**
 *@class fish.desktop.util.Util
 *工具类,拥有underscore-1.1.6的所有方法和自定义方法
 *@singleton
 */
//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
(function() {

    // Baseline setup
    // --------------
    // Establish the root object, `window` in the browser, or `exports` on the server.
    var root = this;

    // Save the previous value of the `_` variable.
    var previousUnderscore = root._;

    // Establish the object that gets returned to break out of a loop iteration.
    var breaker = {};

    // Save bytes in the minified (but not gzipped) version:
    var ArrayProto = Array.prototype,
        ObjProto = Object.prototype,
        FuncProto = Function.prototype;

    // Create quick reference variables for speed access to core prototypes.
    var
    push = ArrayProto.push,
        slice = ArrayProto.slice,
        concat = ArrayProto.concat,
        toString = ObjProto.toString,
        hasOwnProperty = ObjProto.hasOwnProperty;

    // All **ECMAScript 5** native function implementations that we hope to use
    // are declared here.
    var
    nativeForEach = ArrayProto.forEach,
        nativeMap = ArrayProto.map,
        nativeReduce = ArrayProto.reduce,
        nativeReduceRight = ArrayProto.reduceRight,
        nativeFilter = ArrayProto.filter,
        nativeEvery = ArrayProto.every,
        nativeSome = ArrayProto.some,
        nativeIndexOf = ArrayProto.indexOf,
        nativeLastIndexOf = ArrayProto.lastIndexOf,
        nativeIsArray = Array.isArray,
        nativeKeys = Object.keys,
        nativeBind = FuncProto.bind;

    // Create a safe reference to the Underscore object for use below.
    var _ = function(obj) {
        if (obj instanceof _) return obj;
        if (!(this instanceof _)) return new _(obj);
        this._wrapped = obj;
    };

    // Export the Underscore object for **Node.js**, with
    // backwards-compatibility for the old `require()` API. If we're in
    // the browser, add `_` as a global object via a string identifier,
    // for Closure Compiler "advanced" mode.
    if (typeof exports !== 'undefined') {
        if (typeof module !== 'undefined' && module.exports) {
            exports = module.exports = _;
        }
        exports._ = _;
    } else {
        root._ = _;
    }

    // Current version.
    _.VERSION = '1.6.0';

    // Collection Functions
    // --------------------
    /**
     * 遍历obj，按顺序遍历输出每个值。Aliased as `forEach`。如果存在原生的forEach方法，Underscore就使用它代替。  
     * The cornerstone, an `each` implementation, aka `forEach`.  
     * Handles objects with the built-in `forEach`, arrays, and raw objects.  
     * Delegates to **ECMAScript 5**'s native `forEach` if available.
     * @method each
     * <pre>
        _.each([1, 2, 3], alert);
        => alerts each number in turn...
        _.each({one: 1, two: 2, three: 3}, alert);
        => alerts each number value in turn...
     * </pre>
     * @param obj 可以是数组也可以是对象
     * @param {Function} iterator 用来处理每个元素.如果obj是数组,参数为(element, index, obj);如果obj是个对象,iterator的参数是 (value, key, obj)
     * @param context (optional) 如果传递了context参数,则把iterator绑定到context对象上
     */

    var each = _.each = _.forEach = function(obj, iterator, context) {
        if (obj == null) return obj;
        if (nativeForEach && obj.forEach === nativeForEach) {
            obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
            for (var i = 0, length = obj.length; i < length; i++) {
                if (iterator.call(context, obj[i], i, obj) === breaker) return;
            }
        } else {
            var keys = _.keys(obj);
            for (var i = 0, length = keys.length; i < length; i++) {
                if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
            }
        }
        return obj;
    };


    /**
     * 遍历obj，按顺序映射每个值到一个新的数组中。Aliased as `collect`.如果存在原生的map方法，就用原生map方法来代替。  
     * Return the results of applying the iterator to each element.  
     * Delegates to **ECMAScript 5**'s native `map` if available.
     * @method map
     * <pre>
        _.map([1, 2, 3], function(num){ return num * 3; });
        => [3, 6, 9]
        _.map({one: 1, two: 2, three: 3}, function(num, key){ return num * 3; });
        => [3, 6, 9]
     * </pre>
     * @param obj 可以是数组也可以是对象
     * @param {Function} iterator 用来处理每个元素并返回。如果obj是数组，参数为(element, index, obj);如果obj是个对象，iterator的参数是 (value, key, obj)
     * @param context (optional)  如果传递了context参数，则把iterator绑定到context对象上
     * @return {Array} 返回一个新的数组
     */

    _.map = _.collect = function(obj, iterator, context) {
        var results = [];
        if (obj == null) return results;
        if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
        each(obj, function(value, index, list) {
            results.push(iterator.call(context, value, index, list));
        });
        return results;
    };

    var reduceError = 'Reduce of empty array with no initial value';

    /**
     * 遍历obj，按顺序将每个值归结为一个单独的值。Aliased as `foldl/inject`。  
     * **Reduce** builds up a single result from a list of values, aka `inject`,
     * or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.  
     * @method reduce
     * <pre>
        var sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num; }, 0);
        => 6
     * </pre>
     * @param obj 可以是数组也可以是对象
     * @param {Function} iterator 用来处理每个元素并返回。如果obj是数组，参数为(memo, element, index, obj);如果obj是个对象，iterator的参数是 (memo, value, key, obj)
     * @param memo 函数的初始值，后续每一步值都需要由iterator返回
     * @param context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return 返回一个新的值
     */
    _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null) obj = [];
        if (nativeReduce && obj.reduce === nativeReduce) {
            if (context) iterator = _.bind(iterator, context);
            return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
        }
        each(obj, function(value, index, list) {
            if (!initial) {
                memo = value;
                initial = true;
            } else {
                memo = iterator.call(context, memo, value, index, list);
            }
        });
        if (!initial) throw new TypeError(reduceError);
        return memo;
    };

    /**
     * 遍历obj，按倒顺将每个值归结为一个单独的值。Aliased as `foldr`。  
     * The right-associative version of reduce, also known as `foldr`.  
     * Delegates to **ECMAScript 5**'s native `reduceRight` if available.
     * @method reduceRight
     * <pre>
        var list = [[0, 1], [2, 3], [4, 5]];
        var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
        => [4, 5, 2, 3, 0, 1]
     * </pre>
     * @param  {Object} obj 可以是数组也可以是对象
     * @param  {Function} iterator 用来处理每个元素并返回。如果obj是数组，参数为(memo, element, index, obj);如果obj是个对象，iterator的参数是 (memo, value, key, obj)
     * @param  {Object} memo 函数的初始值，后续每一步值都需要由iterator返回
     * @param  {Object} context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return {Object} 返回一个新的值
     */
    _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
        var initial = arguments.length > 2;
        if (obj == null) obj = [];
        if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
            if (context) iterator = _.bind(iterator, context);
            return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
        }
        var length = obj.length;
        if (length !== +length) {
            var keys = _.keys(obj);
            length = keys.length;
        }
        each(obj, function(value, index, list) {
            index = keys ? keys[--length] : --length;
            if (!initial) {
                memo = obj[index];
                initial = true;
            } else {
                memo = iterator.call(context, memo, obj[index], index, list);
            }
        });
        if (!initial) throw new TypeError(reduceError);
        return memo;
    };


    /**
     * 遍历obj，返回第一个通过predicate迭代器真值检测的元素值。Aliased as `detect`。如果找到匹配的元素，函数将立即返回，不会遍历整个obj。  
     * Return the first value which passes a truth test. Aliased as `detect`.
     * @method find
     * <pre>
        var even = _.find([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
        => 2
     * </pre>
     * @param  {Object} obj 一般为数组
     * @param  {Function} predicate 参数为(memo, element, index, obj)，用来匹配符合条件的值
     * @param  {Object} context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return {Object} 返回第一个匹配的值
     */
    _.find = _.detect = function(obj, predicate, context) {
        var result;
        any(obj, function(value, index, list) {
            if (predicate.call(context, value, index, list)) {
                result = value;
                return true;
            }
        });
        return result;
    };

    /**
     * 遍历list中的每个值，返回包含所有通过iterator真值检测的元素值。Aliased as `select`。如果存在原生filter方法，则用原生的filter方法。  
     * Return all the elements that pass a truth test.  
     * Delegates to **ECMAScript 5**'s native `filter` if available.  
     * Aliased as `select`.
     * <pre>
        var evens = _.filter([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
        => [2, 4, 6]
     * </pre>
     * @param  {Object} obj 一般为数组
     * @param  {Function} predicate 参数为(memo, element, index, obj)，用来匹配符合条件的值
     * @param  {Object} context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return {Array} 返回符合条件的数据集合
     */
    _.filter = _.select = function(obj, predicate, context) {
        var results = [];
        if (obj == null) return results;
        if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);
        each(obj, function(value, index, list) {
            if (predicate.call(context, value, index, list)) results.push(value);
        });
        return results;
    };

    /**
     * 返回list中没有通过iterator真值检测的元素集合，与filter相反。  
     * Return all the elements for which a truth test fails.
     * <pre>
        var odds = _.reject([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
        => [1, 3, 5]
     * </pre>
     * @param  {Object} obj 一般为数组
     * @param  {Function} predicate 参数为(memo, element, index, obj)，用来过滤掉符合条件的值
     * @param  {Object} context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return {Array} 返回不符合条件的数据集合
     */
    _.reject = function(obj, predicate, context) {
        return _.filter(obj, function(value, index, list) {
            return !predicate.call(context, value, index, list);
        }, context);
    };

    /**
     * 如果list中的所有元素都通过iterator的真值检测就返回true。Aliased as `all`。如果存在原生的every方法，就使用原生的every。  
     * Determine whether all of the elements match a truth test.  
     * Delegates to **ECMAScript 5**'s native `every` if available.  
     * Aliased as `all`.
     * <pre>
        _.every([true, 1, null, 'yes']);
        => false
     * </pre>
     * @param  {Object} obj 一般为数组
     * @param  {Function} predicate (optional)  可为空，参数为(memo, element, index, obj)，用来匹配符合条件的值,为空的话就默认为**{@link fish.desktop.util.Util#identity identity}**方法
     * @param  {Object} context (optional)  如果传递了context参数，则把iterator绑定到context对象上
     * @return {Boolean} 如果数据都匹配返回true，否则返回fasle
     */
    _.every = _.all = function(obj, predicate, context) {
        predicate || (predicate = _.identity);
        var result = true;
        if (obj == null) return result;
        if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);
        each(obj, function(value, index, list) {
            if (!(result = result && predicate.call(context, value, index, list))) return breaker;
        });
        return !!result;
    };


    /**
     * 如果list中有任何一个元素通过 iterator 的真值检测就返回true。Aliased as `some`。一旦找到了符合条件的元素, 就直接中断对list的遍历. 如果存在原生的some方法，就使用原生的some。  
     * Determine if at least one element in the object matches a truth test.  
     * Delegates to **ECMAScript 5**'s native `some` if available.  
     * Aliased as `any`.
     * <pre>
        _.some([null, 0, 'yes', false]);
        => true
     * </pre>
     * @param  {Object} obj 一般为数组
     * @param  {Function} predicate (optional) 可为空，参数为(memo, element, index, obj)，用来匹配符合条件的值,为空的话就默认为**{@link fish.desktop.util.Util#identity identity}**方法
     * @param  {Object} context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return {Boolean} 如果有任一数据匹配返回true，否则返回fasle
     */
    var any = _.some = _.any = function(obj, predicate, context) {
        predicate || (predicate = _.identity);
        var result = false;
        if (obj == null) return result;
        if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);
        each(obj, function(value, index, list) {
            if (result || (result = predicate.call(context, value, index, list))) return breaker;
        });
        return !!result;
    };

    /**
     * 如果obj包含指定的value则返回true。Aliased as `include`。如果list 是数组，内部使用indexOf判断  
     * Determine if the array or object contains a given value (using `===`).  
     * Aliased as `include`.
     * <pre>
        _.contains([1, 2, 3], 3);
        => true
     * </pre>
     * @param  {Object} obj 一般为数组
     * @param  {Object} target 需要判断的指定值
     * @return {Boolean} 如果对象内包含指定值返回true，否则返回fasle
     */
    _.contains = _.include = function(obj, target) {
        if (obj == null) return false;
        if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
        return any(obj, function(value) {
            return value === target;
        });
    };

    /**
     * 在list的每个元素上执行methodName方法。任何传递给invoke的额外参数，invoke都会在调用methodName方法的时候传递给它。  
     * Invoke a method (with arguments) on every item in a collection.
     * <pre>
        _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
        => [[1, 5, 7], [1, 2, 3]]
     * </pre>
     * @param  {Object} obj 一般为数组
     * @param  {Function} method 每一个元素要执行的方法,也可以是方法名称
     * @return {Array} 返回一个新的数组
     */
    _.invoke = function(obj, method) {
        var args = slice.call(arguments, 2);
        var isFunc = _.isFunction(method);
        return _.map(obj, function(value) {
            return (isFunc ? method : value[method]).apply(value, args);
        });
    };

    /**
     * map最常使用的用例模型的版本，即萃取对象数组中某属性值，返回一个数组。  
     * Convenience version of a common use case of `map`: fetching a property.
     * <pre>
        var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
        _.pluck(stooges, 'name');
        => ["moe", "larry", "curly"]
     * </pre>
     * @param  {Object} obj 一般为对象数组
     * @param  {Object} key 要萃取的对象的属性名称
     * @return {Array} 返回一个新的数组
     */
    _.pluck = function(obj, key) {
        return _.map(obj, _.property(key));
    };

    /**
     * 遍历list中的每一个值，返回一个数组，这个数组包含包含properties所列出的属性的所有的键 - 值对。  
     * Convenience version of a common use case of `filter`: selecting only objects  
     * containing specific `key:value` pairs.
     * <pre>
    _.where(listOfPlays, {author: "Shakespeare", year: 1611});
    => [{title: "Cymbeline", author: "Shakespeare", year: 1611},
        {title: "The Tempest", author: "Shakespeare", year: 1611}]
     * </pre>
     * @param obj 一般为对象数组
     * @param attrs 需要过滤的属性集合
     * @return {Array} 返回一个新的数组
     */
    _.where = function(obj, attrs) {
        return _.filter(obj, _.matches(attrs));
    };

    /**
     * 遍历list中的每一个值，返回匹配properties所列出的属性的所有的键 - 值对的第一个值。  
     * Convenience version of a common use case of `find`: getting the first object  
     * containing specific `key:value` pairs.
     * <pre>
    _.findWhere(publicServicePulitzers, {newsroom: "The New York Times"});
    => {year: 1918, newsroom: "The New York Times",
      reason: "For its public service in publishing in full so many official reports,
      documents and speeches by European statesmen relating to the progress and
      conduct of the war."}
     * </pre>
     * @param obj 一般为对象数组
     * @param attrs 需要过滤的属性集合
     * @return {Array} 返回第一个符合条件的对象
     */
    _.findWhere = function(obj, attrs) {
        return _.find(obj, _.matches(attrs));
    };


    /**
     * 返回list中的最大值。如果传递iterator参数，iterator将作为list排序的依据。如果是数字数组(不超过65535个)，直接调用Math.max方法。  
     * Return the maximum element or (element-based computation).  
     * Can't optimize arrays of integers longer than 65,535 elements.
     * See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
     * <pre>
        var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
        _.max(stooges, function(stooge){ return stooge.age; });
        => {name: 'curly', age: 60};
    * </pre>
     * @param  obj 一般为数组
     * @param  {Function} iterator (optional) 返回每一个数据中用来比较的值，如果未定义，默认为其本身。
     * @param  {Object} context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return {Object} 返回经比较后最大的数据
     */
    _.max = function(obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
            return Math.max.apply(Math, obj);
        }
        var result = -Infinity,
            lastComputed = -Infinity;
        each(obj, function(value, index, list) {
            var computed = iterator ? iterator.call(context, value, index, list) : value;
            if (computed > lastComputed) {
                result = value;
                lastComputed = computed;
            }
        });
        return result;
    };

    /**
     * 返回list中的最小值。如果传递iterator参数，iterator将作为list排序的依据。  
     * Return the minimum element (or element-based computation).
     * <pre>
        var numbers = [10, 5, 100, 2, 1000];
        _.min(numbers);
        => 2
    * </pre>
     * @param  obj 一般为数组
     * @param  {Function} iterator (optional) 返回每一个数据中用来比较的值，如果未定义，默认为其本身。
     * @param  {Object} context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return {Object} 返回经比较后最小的数据
     */
    _.min = function(obj, iterator, context) {
        if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
            return Math.min.apply(Math, obj);
        }
        var result = Infinity,
            lastComputed = Infinity;
        each(obj, function(value, index, list) {
            var computed = iterator ? iterator.call(context, value, index, list) : value;
            if (computed < lastComputed) {
                result = value;
                lastComputed = computed;
            }
        });
        return result;
    };

    /**
     * 返回一个随机乱序的 obj 副本, 使用[Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle)来进行随机乱序.  
     * Shuffle an array, using the modern version of the
     * [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
     * <pre>
        _.shuffle([1, 2, 3, 4, 5, 6]);
        => [4, 1, 6, 3, 5, 2]
     * </pre>
     * @param  {Array} obj 一般为数组
     * @return {Array} 返回乱序的数组
     */
    _.shuffle = function(obj) {
        var rand;
        var index = 0;
        var shuffled = [];
        each(obj, function(value) {
            rand = _.random(index++);
            shuffled[index - 1] = shuffled[rand];
            shuffled[rand] = value;
        });
        return shuffled;
    };

    /**
     * 从 obj中产生一个随机样本。传递一个数字表示从obj中返回n个随机元素。否则将返回一个单一的随机项。  
     * Sample **n** random values from a collection.  
     * If **n** is not specified, returns a single random element.  
     * The internal `guard` argument allows it to work with `map`.
     * <pre>
        _.sample([1, 2, 3, 4, 5, 6]);
        => 4
        _.sample([1, 2, 3, 4, 5, 6], 3);
        => [1, 6, 2]
     * </pre>
     * @param  {Array} obj 一般为数组
     * @param  {Number} n (optional) 随机返回的元素个数
     * @param  {Object} guard (optional) 设置为true会返回单一的随机项
     * @return {Object} 如果第二参数未定义或者定义了第三个参数，则返回随机一项，其他适合则返回n个随机元素的集合
     */
    _.sample = function(obj, n, guard) {
        if (n == null || guard) {
            if (obj.length !== +obj.length) obj = _.values(obj);
            return obj[_.random(obj.length - 1)];
        }
        return _.shuffle(obj).slice(0, Math.max(0, n));
    };

    // An internal function to generate lookup iterators.
    var lookupIterator = function(value) {
        if (value == null) return _.identity;
        if (_.isFunction(value)) return value;
        return _.property(value);
    };

    /**
     * 返回一个排序后的obj拷贝副本。  
     * Sort the object's values by a criterion produced by an iterator.
     * <pre>
        _.sortBy([1, 2, 3, 4, 5, 6], function(num){ return Math.sin(num); });
        => [5, 4, 6, 3, 1, 2]
     * </pre>
     * @param  {Array} obj 一般为数组
     * @param  {Function} iterator (optional) 如果有iterator参数，iterator将作为obj排序的依据。迭代器也可以是字符串的属性的名称进行排序的
     * @param  {Object} context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return {Array} 返回乱序的数组
     */
    _.sortBy = function(obj, iterator, context) {
        iterator = lookupIterator(iterator);
        return _.pluck(_.map(obj, function(value, index, list) {
            return {
                value: value,
                index: index,
                criteria: iterator.call(context, value, index, list)
            };
        }).sort(function(left, right) {
            var a = left.criteria;
            var b = right.criteria;
            if (a !== b) {
                if (a > b || a === void 0) return 1;
                if (a < b || b === void 0) return -1;
            }
            return left.index - right.index;
        }), 'value');
    };

    // An internal function used for aggregate "group by" operations.
    var group = function(behavior) {
        return function(obj, iterator, context) {
            var result = {};
            iterator = lookupIterator(iterator);
            each(obj, function(value, index) {
                var key = iterator.call(context, value, index, obj);
                behavior(result, key, value);
            });
            return result;
        };
    };

    /**
     * 把一个集合分组为多个集合，通过 iterator 返回的结果进行分组.  
     * Groups the object's values by a criterion. Pass either a string attribute to group by, or a function that returns the criterion.
     * <pre>
        _.groupBy([1.3, 2.1, 2.4], function(num){ return Math.floor(num); });
        => {1: [1.3], 2: [2.1, 2.4]}
        _.groupBy(['one', 'two', 'three'], 'length');
        => {3: ["one", "two"], 5: ["three"]}
     * </pre>
     * @param  {Array} obj 一般为数组
     * @param  {Function} iterator (optional) 用来返回一个在列表中的每个元素键的函数或属性名，返回的值作为key。
     * @param  {Object} context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return {Object} 返回分组的对象
     */
    _.groupBy = group(function(result, key, value) {
        _.has(result, key) ? result[key].push(value) : result[key] = [value];
    });

    /**
     * 给定一个集合，和一个， 返回一个每一项索引的对象。  
     * Indexes the object's values by a criterion, similar to `groupBy`, but for when you know that your index values will be unique.
     * <pre>
        var stooges = [{name: 'moe', age: 40}, {name: 'larry', age: 50}, {name: 'curly', age: 60}];
        _.indexBy(stooges, 'age');
        => {
          "40": {name: 'moe', age: 40},
          "50": {name: 'larry', age: 50},
          "60": {name: 'curly', age: 60}
        }
     * </pre>
     * @param  {Array} obj 一般为数组
     * @param  {Function} iterator (optional) 用来返回一个在列表中的每个元素键的函数或属性名，返回的值作为key，key值要求唯一。
     * @param  {Object} context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return {Object} 返回一个指定了key的map
     */
    _.indexBy = group(function(result, key, value) {
        result[key] = value;
    });

    /**
     * 排序一个列表组成一个组，并且返回各组中的对象的数量的计数。  
     * Counts instances of an object that group by a certain criterion. Pass either a string attribute to count by, or a function that returns the criterion.
     * <pre>
        _.countBy([1, 2, 3, 4, 5], function(num) {
          return num % 2 == 0 ? 'even': 'odd';
        });
        => {odd: 3, even: 2}
     * </pre>
     * @param  {Array} obj 一般为数组
     * @param  {Function} iterator (optional) 用来返回一个在列表中的每个元素键的函数或属性名，返回的值作为key。
     * @param  {Object} context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return {Object} 返回只有key值和对应key的数据总数的分组对象
     */
    _.countBy = group(function(result, key) {
        _.has(result, key) ? result[key]++ : result[key] = 1;
    });

    /**
     * 使用二分查找确定value在list中的位置序号。  
     * Use a comparator function to figure out the smallest index at which an object should be inserted so as to maintain order. Uses binary search.
     * <pre>
        _.sortedIndex([10, 20, 30, 40, 50], 35);
        => 3
        var stooges = [{name: 'moe', age: 40}, {name: 'curly', age: 60}];
        _.sortedIndex(stooges, {name: 'larry', age: 50}, 'age');
        => 1
     * </pre>
     * @param  {Array} array 一般为数组
     * @param  {Object} obj  array排序后，定位obj插入的位置,使之能保持list原有的排序
     * @param  {Function} iterator (optional) 作为list排序的依据，也可以是字符串的属性名用来排序(比如length)
     * @param  {Object} context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return {Number} 返回obj所在的最终排序位置的下标。
     */
    _.sortedIndex = function(array, obj, iterator, context) {
        iterator = lookupIterator(iterator);
        var value = iterator.call(context, obj);
        var low = 0,
            high = array.length;
        while (low < high) {
            var mid = (low + high) >>> 1;
            iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
        }
        return low;
    };

    /**
     * 把obj(任何可以迭代的对象)转换成一个数组，在转换 arguments 对象时非常有用。  
     * Safely create a real, live array from anything iterable.
     * <pre>
        (function(){ return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
        => [2, 3, 4]
     * </pre>
     * @param  obj 可以迭代的对象
     * @return {Array} 返回数组
     */
    _.toArray = function(obj) {
        if (!obj) return [];
        if (_.isArray(obj)) return slice.call(obj);
        if (obj.length === +obj.length) {
            return _.map(obj, _.identity);
        }
        return _.values(obj);
    };

    /**
     * 返回对象的长度。如果对象没有length属性，返回属性的数量  
     * Return the number of elements in an object.
     * <pre>
        _.size({one: 1, two: 2, three: 3});
        => 3
     * </pre>
     * @param  obj 可以迭代的对象
     * @return {Number} 返回对象的长度
     */
    _.size = function(obj) {
        if (obj == null) return 0;
        return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
    };

    // Array Functions
    // ---------------
    /**
     * 返回数组的前n个元素。Aliased as `head` or `take`。  
     * Get the first element of an array. Passing **n** will return the first N values in the array. Aliased as `head` and `take`. The **guard** check allows it to work with `_.map`.
     * <pre>
        _.first([5, 4, 3, 2, 1]);
        => 5
     * </pre>
     * @param  {Array} array 对象数组
     * @param  {Number} n (optional) 返回的前几个元素数量，为空默认为1.
     * @param  {Object} guard (optional) 设置为true会返回第一个元素
     * @return {Array} 如果第二参数未定义或者定义了第三个参数，则返回第一个元素，其他情况则返回n个随机元素的集合
     */
    _.first = _.head = _.take = function(array, n, guard) {
        if (array == null) return void 0;
        if ((n == null) || guard) return array[0];
        if (n < 0) return [];
        return slice.call(array, 0, n);
    };

    /**
     * 排除数组的后n个元素。  
     * Returns everything but the last entry of the array. Especially useful on the arguments object. Passing **n** will return all the values in the array, excluding the last N. The **guard** check allows it to work with `_.map`.
     * <pre>
        _.initial([5, 4, 3, 2, 1]);
        => [5, 4, 3, 2]
     * </pre>
     * @param  {Array} array 对象数组
     * @param  {Number} n (optional) 排除的后几个元素数量，为空默认为1.
     * @param  {Object} guard (optional) 设置为true会返回第一个元素
     * @return {Array} 返回排除过的数据集合
     */
    _.initial = function(array, n, guard) {
        return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
    };

    /**
     * 返回数组里的后面的n个元素。  
     * Get the last element of an array. Passing **n** will return the last N values in the array. The **guard** check allows it to work with `_.map`.
     * <pre>
        _.last([5, 4, 3, 2, 1]);
        => 1
     * </pre>
     * @param  {Array} array 对象数组
     * @param  {Number} n (optional) 返回的后几个元素数量，为空默认为1.
     * @param  {Object} guard (optional) 设置为true会返回最后一个元素
     * @return {Array} 如果第二参数未定义或者定义了第三个参数，则返回最后一个元素，其他情况则返回n个随机元素的集合
     */
    _.last = function(array, n, guard) {
        if (array == null) return void 0;
        if ((n == null) || guard) return array[array.length - 1];
        return slice.call(array, Math.max(array.length - n, 0));
    };

    /**
     * 返回数组中除了第n个元素外的其他全部元素。Aliased as `tail` or `drop`。  
     * Returns everything but the first entry of the array. Aliased as `tail` and `drop`.  
     * Especially useful on the arguments object. Passing an **n** will return the rest N values in the array. The **guard** check allows it to work with `_.map`.
     * <pre>
        _.rest([5, 4, 3, 2, 1]);
        => [4, 3, 2, 1]
     * </pre>
     * @param  {Array} array 对象数组
     * @param  {Number} n (optional) 从第几个元素后开始返回，为空默认为1.
     * @param  {Object} guard (optional) 设置为true会排除第一个元素
     * @return {Array} 返回排除了前几个元素的数据集合
     */
    _.rest = _.tail = _.drop = function(array, n, guard) {
        return slice.call(array, (n == null) || guard ? 1 : n);
    };

    /**
     * 返回一个除去所有false值的 array副本。在javascript中, false, null, 0, "", undefined 和 NaN 都是false值.  
     * Trim out all falsy values from an array.
     * <pre>
        _.compact([0, 1, false, 2, '', 3]);
        => [1, 2, 3]
     * </pre>
     * @param  {Array} array 对象数组
     * @return {Array} 返回排除了值为false的数据集合
     */
    _.compact = function(array) {
        return _.filter(array, _.identity);
    };

    // Internal implementation of a recursive `flatten` function.
    var flatten = function(input, shallow, output) {
        if (shallow && _.every(input, _.isArray)) {
            return concat.apply(output, input);
        }
        each(input, function(value) {
            if (_.isArray(value) || _.isArguments(value)) {
                shallow ? push.apply(output, value) : flatten(value, shallow, output);
            } else {
                output.push(value);
            }
        });
        return output;
    };

    /**
     * 将一个嵌套多层的数组array(嵌套可以是任何层数)转换为只有一层的数组。  
     * Flatten out an array, either recursively (by default), or just one level.
     * <pre>
        _.flatten([1, [2], [3, [[4]]]]);
        => [1, 2, 3, 4];
        _.flatten([1, [2], [3, [[4]]]], true);
        => [1, 2, 3, [[4]]];
     * </pre>
     * @param  {Array} array 对象数组
     * @param  {Object} shallow (optional) 如果传递shallow参数，数组将只减少一维的嵌套。
     * @return {Array} 返回嵌套只有一层的对象，或者减少一维嵌套。
     */
    _.flatten = function(array, shallow) {
        return flatten(array, shallow, []);
    };

    /**
     * 返回一个删除了指定数据的array副本。剔除的数据为目标数组后面的参数，全等条件。  
     * Return a version of the array that does not contain the specified value(s).
     * <pre>
        _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
        => [2, 3, 4]
     * </pre>
     * @param  {Array} array 目标数组
     * @return {Array} 返回剔除掉指定数据的数组
     */
    _.without = function(array) {
        return _.difference(array, slice.call(arguments, 1));
    };

    /**
     * 将一个数组按照一定的条件拆分成两个。  
     * Split an array into two arrays: one whose elements all satisfy the given predicate, and one whose elements all do not satisfy the predicate.
     * <pre>
        _.partition([1,2,3,4,5],function(item){return item >3 ;});
        => [[4,5],[1,2,3]]
     * </pre>
     * @param  {Array} array
     * @param  {Function} predicate 判断每一个元素，返回true还是false，根据返回值会将元素分到不同的数组里面
     * @param  {Object} context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return {Array} 返回一个长度为2的二维数组，一个数组内符合条件的数据，一个数组内为不符合条件的数据。
     */
    _.partition = function(array, predicate, context) {
        predicate = lookupIterator(predicate);
        var pass = [],
            fail = [];
        each(array, function(elem) {
            (predicate.call(context, elem) ? pass : fail).push(elem);
        });
        return [pass, fail];
    };

    /**
     * 返回array去重后的副本, 使用全等条件.Aliased as `unique`。  
     * Produce a duplicate-free version of the array. If the array has already been sorted, you have the option of using a faster algorithm.  
     * Aliased as `unique`.
     * <pre>
        _.uniq([1, 2, 1, 3, 1, 4]);
        => [1, 2, 3, 4]
     * </pre>
     * @param  {Array} array 对象数组
     * @param  {Boolean} isSorted (optional) 如果确定array已经排序, 那么给isSorted参数传递 true值, 此函数将运行的更快的算法。
     * @param  {Function} iterator (optional) 如果要处理对象元素, 传参iterator来获取要对比的属性.
     * @param  {Object} context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return {Array} 返回排过重的数组
     */
    _.uniq = _.unique = function(array, isSorted, iterator, context) {
        if (_.isFunction(isSorted)) {
            context = iterator;
            iterator = isSorted;
            isSorted = false;
        }
        var initial = iterator ? _.map(array, iterator, context) : array;
        var results = [];
        var seen = [];
        each(initial, function(value, index) {
            if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
                seen.push(value);
                results.push(array[index]);
            }
        });
        return results;
    };

    /**
     * 返回传入的arrays（数组）并集：按顺序返回，数组的元素是唯一的，可以传入一个或多个 arrays（数组）  
     * Produce an array that contains the union: each distinct element from all of the passed-in arrays.
     * <pre>
        _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
        => [1, 2, 3, 101, 10]
     * </pre>
     * @return {Array} 合并了所有参数值的数组
     */
    _.union = function() {
        return _.uniq(_.flatten(arguments, true));
    };


    /**
     * 返回传入arrays（数组）交集。结果中的每个值是存在于传入的每个arrays（数组）里。  
     * Produce an array that contains every item shared between all the passed-in arrays.
     * <pre>
        _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);
        => [1, 2]
     * </pre>
     * @param  {Array} array 目标数组
     * @return {Array} 返回所有参数数组里面都包含的数值的集合
     */
    _.intersection = function(array) {
        var rest = slice.call(arguments, 1);
        return _.filter(_.uniq(array), function(item) {
            return _.every(rest, function(other) {
                return _.contains(other, item);
            });
        });
    };

    /**
     * 返回一个删除了指定数据的array副本。剔除的数据为参数数组中任一数组里面出现的元素。  
     * Take the difference between one array and a number of other arrays.  
     * Only the elements present in just the first array will remain.
     * <pre>
        _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
        => [1, 3, 4]
     * </pre>
     * @param  {Array} array 目标数组
     * @return {Array} 返回剔除掉指定数据的数组
     */
    _.difference = function(array) {
        var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
        return _.filter(array, function(value) {
            return !_.contains(rest, value);
        });
    };

    /**
     * 将每个相应位置的arrays的值合并在一起。  
     * Zip together multiple lists into a single array -- elements that share an index go together.
     * <pre>
        _.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]);
        => [["moe", 30, true], ["larry", 40, false], ["curly", 50, false]]
        _.zip.apply(_, arrayOfRowsOfData);
        => arrayOfColumnsOfData
     * </pre>
     * @return {Array} 行转列之后的数组
     */
    _.zip = function() {
        var length = _.max(_.pluck(arguments, 'length').concat(0));
        var results = new Array(length);
        for (var i = 0; i < length; i++) {
            results[i] = _.pluck(arguments, '' + i);
        }
        return results;
    };


    /**
     * 将数组转换为对象。  
     * Converts lists into objects. Pass either a single array of `[key, value]` pairs, or two parallel arrays of the same length -- one of keys, and one of the corresponding values.
     * <pre>
        _.object(['moe', 'larry', 'curly'], [30, 40, 50]);
        => {moe: 30, larry: 40, curly: 50}
        _.object([['moe', 30], ['larry', 40], ['curly', 50]]);
        => {moe: 30, larry: 40, curly: 50}
     * </pre>
     * @param  {Array} list 目标数组，可以是每一个元素为[key, value]格式的
     * @param  {Array} values (optional) 如果list参数是key的列表，此参数则为值的列表，长度和list一样
     * @return {Object}        返回一个对象
     */
    _.object = function(list, values) {
        if (list == null) return {};
        var result = {};
        for (var i = 0, length = list.length; i < length; i++) {
            if (values) {
                result[list[i]] = values[i];
            } else {
                result[list[i][0]] = list[i][1];
            }
        }
        return result;
    };


    /**
     * 返回item在该 array 中的索引值，如果item不存在 array中就返回-1。使用原生的indexOf 函数，除非它失效。  
     * If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),we need this function. Return the position of the first occurrence of an item in an array, or -1 if the item is not included in the array.  
     * Delegates to **ECMAScript 5**'s native `indexOf` if available.  
     * If the array is large and already in sort order, pass `true` for **isSorted** to use binary search.
     * <pre>
        _.indexOf([1, 2, 3], 2);
        => 1
     * </pre>
     * @param  {Array}  array     目标数组
     * @param  {Object}  item     数组内要寻找的目标元素
     * @param  {Boolean} isSorted (optional) 知道数组已经排序，传递true给isSorted将更快的用二进制搜索；也可以传入数字，表示将从你给定的索性值开始搜索。
     * @return {Number}           返回目标元素在数组中的索引值
     */
    _.indexOf = function(array, item, isSorted) {
        if (array == null) return -1;
        var i = 0,
            length = array.length;
        if (isSorted) {
            if (typeof isSorted == 'number') {
                i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
            } else {
                i = _.sortedIndex(array, item);
                return array[i] === item ? i : -1;
            }
        }
        if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
        for (; i < length; i++)
            if (array[i] === item) return i;
        return -1;
    };

    /**
     * 返回item在该 array 中的从最后开始的索引值，如果item不存在 array中就返回-1。如果支持原生的lastIndexOf，将使用原生的lastIndexOf函数。  
     * Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
     * <pre>
        _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
        => 4
     * </pre>
     * @param  {Array}  array     目标数组
     * @param  {Object}  item     数组内要寻找的目标元素
     * @param  {Number} from (optional) 将从你给定的索性值开始搜索。
     * @return {Number}           返回目标元素在数组中的索引值
     */
    _.lastIndexOf = function(array, item, from) {
        if (array == null) return -1;
        var hasIndex = from != null;
        if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
            return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
        }
        var i = (hasIndex ? from : array.length);
        while (i--)
            if (array[i] === item) return i;
        return -1;
    };

    /**
     * 一个用来创建整数灵活编号的列表的函数，便于each 和 map循环。  
     * Generate an integer Array containing an arithmetic progression. A port of the native Python `range()` function. See [the Python documentation](http://docs.python.org/library/functions.html#range).
     * <pre>
        _.range(10);
        => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
        _.range(1, 11);
        => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
        _.range(0, 30, 5);
        => [0, 5, 10, 15, 20, 25]
        _.range(0, -10, -1);
        => [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
        _.range(0);
        => []
     * </pre>
     * @param  {Number} start (optional) 默认为 0
     * @param  {Number} stop (optional)  决定返回的数据数量
     * @param  {Number} step (optional) 默认为 1,可设置为负数表示负增长
     * @return {Array}       返回一个从start 到stop的整数的列表
     */
    _.range = function(start, stop, step) {
        if (arguments.length <= 1) {
            stop = start || 0;
            start = 0;
        }
        step = arguments[2] || 1;

        var length = Math.max(Math.ceil((stop - start) / step), 0);
        var idx = 0;
        var range = new Array(length);

        while (idx < length) {
            range[idx++] = start;
            start += step;
        }

        return range;
    };

    // Function (ahem) Functions
    // ------------------
    // Reusable constructor function for prototype setting.
    var ctor = function() {};

    /**
     * 绑定函数 function 到对象 object 上  
     * Create a function bound to a given object (assigning `this`, and arguments, optionally).   
     * Delegates to **ECMAScript 5**'s native `Function.bind` if available.
     * <pre>
        var func = function(greeting){ return greeting + ': ' + this.name };
        func = _.bind(func, {name: 'moe'}, 'hi');
        func();
        => 'hi: moe'
     * </pre>
     * @param  {Function} func  要执行的方法
     * @param  {Object} context 方法的执行者，对应func函数内的this
     * @param {Object} arguments (optional) 任意可选参数arguments 可以绑定到函数 function , 可以填充函数所需要的参数
     * @return {Object}         func执行的返回值
     */
    _.bind = function(func, context) {
        var args, bound;
        if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
        if (!_.isFunction(func)) throw new TypeError;
        args = slice.call(arguments, 2);
        return bound = function() {
            if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
            ctor.prototype = func.prototype;
            var self = new ctor;
            ctor.prototype = null;
            var result = func.apply(self, args.concat(slice.call(arguments)));
            if (Object(result) === result) return result;
            return self;
        };
    };

    /**
     * 局部应用一个函数填充在任意数值的参数， 不改变其动态this值  
     * Partially apply a function by creating a version that has had some of its arguments pre-filled, without changing its dynamic `this` context. _ acts as a placeholder, allowing any combination of arguments to be pre-filled.
     * <pre>
        var add = function(a, b) { return a + b; };
        add5 = _.partial(add, 5);
        add5(10);
        => 15
     * </pre>
     * @param  {Function} func  要执行的方法
     * @param {Object} arguments (optional) 任意可选参数arguments可以绑定到函数function,可以填充函数所需要的参数
     * @return {Object}         func执行的返回值
     */
    _.partial = function(func) {
        var boundArgs = slice.call(arguments, 1);
        return function() {
            var position = 0;
            var args = boundArgs.slice();
            for (var i = 0, length = args.length; i < length; i++) {
                if (args[i] === _) args[i] = arguments[position++];
            }
            while (position < arguments.length) args.push(arguments[position++]);
            return func.apply(this, args);
        };
    };

    /**
     * 把methodNames参数指定的方法绑定到object上，这些方法就会在对象的上下文环境中执行。绑定函数用作事件处理函数时非常便利，否则函数被调用时this一点用也没有。  
     * Bind a number of an object's methods to that object. Remaining arguments are the method names to be bound. Useful for ensuring that all callbacks defined on an object belong to it.
     * <pre>
        var buttonView = {
          label  : 'underscore',
          onClick: function(){ alert('clicked: ' + this.label); },
          onHover: function(){ console.log('hovering: ' + this.label); }
        };
        _.bindAll(buttonView, 'onClick', 'onHover');
        // When the button is clicked, this.label will have the correct value.
        jQuery('#underscore_button').bind('click', buttonView.onClick);
     * </pre>
     * @param  {Object} obj 目标对象
     * @param  {String} methodNames (optional) 如果不设置methodNames参数，对象上的所有方法都会被绑定。
     * @return {Object}     绑定后的目标对象
     */
    _.bindAll = function(obj) {
        var funcs = slice.call(arguments, 1);
        if (funcs.length === 0) throw new Error('bindAll must be passed function names');
        each(funcs, function(f) {
            obj[f] = _.bind(obj[f], obj);
        });
        return obj;
    };

    /**
     * Memoizes方法可以缓存某函数的计算结果。对于耗时较长的计算是很有帮助的。默认使用function的第一个参数作为key  
     * Memoize an expensive function by storing its results.
     * <pre>
        var fibonacci = _.memoize(function(n) {
          return n < 2 ? n: fibonacci(n - 1) + fibonacci(n - 2);
        });
     * </pre>
     * @param  {Function} func  要执行的方法
     * @param  {Function} hasher (optional) 的返回值作为key存储函数的计算结果。
     * @return {Object}        返回缓存的结果
     */
    _.memoize = function(func, hasher) {
        var memo = {};
        hasher || (hasher = _.identity);
        return function() {
            var key = hasher.apply(this, arguments);
            return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
        };
    };

    /**
     * 类似setTimeout，等待wait毫秒后调用function。  
     * Delays a function for the given number of milliseconds, and then calls it with the arguments supplied.
     * <pre>
        var log = _.bind(console.log, console);
        _.delay(log, 1000, 'logged later');
        => 'logged later' // Appears after one second.
     * </pre>
     * @param  {Function} func  要执行的方法
     * @param  {Number} wait 延迟执行的时间
     * @param  {Object} arguments (optional) 如果传递可选的参数arguments，当函数func执行时， arguments 会作为参数传入。
     * @return {Object}      返回执行的结果
     */
    _.delay = function(func, wait) {
        var args = slice.call(arguments, 2);
        return setTimeout(function() {
            return func.apply(null, args);
        }, wait);
    };

    /**
     * 延迟调用function直到当前调用栈清空为止，类似使用延时为1的setTimeout方法。对于执行开销大的计算和无阻塞UI线程的HTML渲染时候非常有用。  
     * Defers a function, scheduling it to run after the current call stack has cleared.
     * <pre>
        _.defer(function(){ alert('deferred'); });
        // Returns from the function before the alert runs.
     * </pre>
     * @param  {Function} func  要执行的方法
     * @param  {Object} arguments (optional) 如果传递可选的参数arguments，当函数func执行时，arguments 会作为参数传入。
     * @return {Object}      返回执行的结果
     */
    _.defer = function(func) {
        return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
    };

    /**
     * 创建并返回一个像节流阀一样的函数，当重复调用函数的时候，最多每隔 wait毫秒调用一次该函数。 对于想控制一些触发频率较高的事件有帮助。  
     * Returns a function, that, when invoked, will only be triggered at most once during a given window of time. Normally, the throttled function will run as much as it can, without ever going more than once per `wait` duration;  
     * but if you'd like to disable the execution on the leading edge, pass `{leading: false}`. To disable execution on the trailing edge, ditto.
     * <pre>
        var throttled = _.throttle(updatePosition, 100);
        $(window).scroll(throttled);
     * </pre>
     * @param  {Function} func  要执行的方法
     * @param  {Number} wait    函数调用的间隔时间
     * @param  {Object} options (optional) 禁用第一次首先执行的话，传递{leading: false}，禁用最后一次执行的话，传递{trailing: false}。
     * @return {Object}      返回执行的结果
     */
    _.throttle = function(func, wait, options) {
        var context, args, result;
        var timeout = null;
        var previous = 0;
        options || (options = {});
        var later = function() {
            previous = options.leading === false ? 0 : _.now();
            timeout = null;
            result = func.apply(context, args);
            context = args = null;
        };
        return function() {
            var now = _.now();
            if (!previous && options.leading === false) previous = now;
            var remaining = wait - (now - previous);
            context = this;
            args = arguments;
            if (remaining <= 0) {
                clearTimeout(timeout);
                timeout = null;
                previous = now;
                result = func.apply(context, args);
                context = args = null;
            } else if (!timeout && options.trailing !== false) {
                timeout = setTimeout(later, remaining);
            }
            return result;
        };
    };

    /**
     * 返回 function 函数的防反跳版本, 将延迟函数的执行(真正的执行)在函数最后一次调用时刻的 wait 毫秒之后. 对于必须在一些输入（多是一些用户操作）停止到达之后执行的行为有帮助。  
     * Returns a function, that, as long as it continues to be invoked, will not be triggered. The function will be called after it stops being called for N milliseconds. If `immediate` is passed, trigger the function on the leading edge, instead of the trailing.
     * <pre>
        var lazyLayout = _.debounce(calculateLayout, 300);
        $(window).resize(lazyLayout);
     * </pre>
     * @param  {Function} func  要执行的方法
     * @param  {Number} wait    函数调用的延时时间
     * @param  {Boolean} immediate (optional) 传参 immediate 为 true 会让 debounce 在 wait 间隔之后 触发最后的函数调用而不是最先的函数调用. 在类似不小心点了提交按钮两下而提交了两次的情况下很有用.
     * @return {Object}      返回执行的结果
     */
    _.debounce = function(func, wait, immediate) {
        var timeout, args, context, timestamp, result;

        var later = function() {
            var last = _.now() - timestamp;
            if (last < wait) {
                timeout = setTimeout(later, wait - last);
            } else {
                timeout = null;
                if (!immediate) {
                    result = func.apply(context, args);
                    context = args = null;
                }
            }
        };

        return function() {
            context = this;
            args = arguments;
            timestamp = _.now();
            var callNow = immediate && !timeout;
            if (!timeout) {
                timeout = setTimeout(later, wait);
            }
            if (callNow) {
                result = func.apply(context, args);
                context = args = null;
            }

            return result;
        };
    };

    /**
     * 创建一个只能调用一次的函数。重复调用改进的方法也没有效果，只会返回第一次执行时的结果。 作为初始化函数使用时非常有用, 不用再设一个boolean值来检查是否已经初始化完成.  
     * Returns a function that will be executed at most one time, no matter how often you call it. Useful for lazy initialization.
     * <pre>
        var initialize = _.once(createApplication);
        initialize();
        initialize();
        // Application is only created once.
     * </pre>
     * @param  {Function} func  要执行的方法
     * @return {Object}      返回执行的结果
     */
    _.once = function(func) {
        var ran = false,
            memo;
        return function() {
            if (ran) return memo;
            ran = true;
            memo = func.apply(this, arguments);
            func = null;
            return memo;
        };
    };

    /**
     * 将第一个函数 function 封装到函数 wrapper 里面, 并把函数 function 作为第一个参数传给 wrapper. 这样可以让 wrapper 在 function 运行之前和之后 执行代码, 调整参数然后附有条件地执行.  
     * Returns the first function passed as an argument to the second,allowing you to adjust arguments, run code before and after, and conditionally execute the original function.
     * <pre>
        var hello = function(name) { return "hello: " + name; };
        hello = _.wrap(hello, function(func) {
          return "before, " + func("moe") + ", after";
        });
        hello();
        => 'before, hello: moe, after'
     * </pre>
     * @param  {Function} func  要执行的方法
     * @param  {Function} wrapper 外围方法，func将会作为此方法的第一个参数，可以在这个方法里面有条件的调用func
     * @return {Object}      返回执行的结果
     */
    _.wrap = function(func, wrapper) {
        return _.partial(wrapper, func);
    };

    /**
     * 返回函数集 functions 组合后的复合函数, 也就是一个函数执行完之后把返回的结果再作为参数赋给下一个函数来执行. 以此类推. 在数学里, 把函数 f(), g(), 和 h() 组合起来可以得到复合函数 f(g(h())).  
     * Returns a function that is the composition of a list of functions, each consuming the return value of the function that follows.
     * <pre>
        var greet    = function(name){ return "hi: " + name; };
        var exclaim  = function(statement){ return statement.toUpperCase() + "!"; };
        var welcome = _.compose(greet, exclaim);
        welcome('moe');
        => 'hi: MOE!
     * </pre>
     * @param  {Function} func (optional) 任何个参数func将会被嵌套进来执行，后一个func的返回值作为前一个func的参数
     * @return {Object}      返回执行的结果
     */
    _.compose = function() {
        var funcs = arguments;
        return function() {
            var args = arguments;
            for (var i = funcs.length - 1; i >= 0; i--) {
                args = [funcs[i].apply(this, args)];
            }
            return args[0];
        };
    };

    /**
     * 创建一个函数, 只有在运行了times次之后才有效果. 在处理同组异步请求返回结果时, 如果你要确保同组里所有异步请求完成之后才 执行这个函数, 这将非常有用.  
     * Returns a function that will only be executed after being called N times.
     * <pre>
        var renderNotes = _.after(notes.length, render);
        _.each(notes, function(note) {
          note.asyncSave({success: renderNotes});
        });
        // renderNotes is run once, after all notes have saved.
     * </pre>
     * @param  {Number} times 函数执行的次数
     * @param  {Function} func  函数执行次数到达之后真正触发的事件
     * @return {Object}      返回执行的结果
     */
    _.after = function(times, func) {
        return function() {
            if (--times < 1) {
                return func.apply(this, arguments);
            }
        };
    };

    // Object Functions
    // ----------------
    /**
     * 获取object对象所有的属性名称。  
     * Retrieve the names of an object's properties.  
     * Delegates to **ECMAScript 5**'s native `Object.keys`
     * <pre>
        _.keys({one: 1, two: 2, three: 3});
        => ["one", "two", "three"]
     * </pre>
     * @param  {Object} obj 目标对象
     * @return {Array}     目标对象的属性名称
     */
    _.keys = function(obj) {
        if (!_.isObject(obj)) return [];
        if (nativeKeys) return nativeKeys(obj);
        var keys = [];
        for (var key in obj)
            if (_.has(obj, key)) keys.push(key);
        return keys;
    };

    /**
     * 返回object对象所有的属性值。  
     * Retrieve the values of an object's properties.
     * <pre>
        _.values({one: 1, two: 2, three: 3});
        => [1, 2, 3]
     * </pre>
     * @param  {Object} obj 目标对象
     * @return {Array}     目标对象的属性值
     */
    _.values = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var values = new Array(length);
        for (var i = 0; i < length; i++) {
            values[i] = obj[keys[i]];
        }
        return values;
    };

    /**
     * 把一个对象转变为一个[key, value]形式的数组。  
     * Convert an object into a list of `[key, value]` pairs.
     * <pre>
        _.pairs({one: 1, two: 2, three: 3});
        => [["one", 1], ["two", 2], ["three", 3]]
     * </pre>
     * @param  {Object} obj 目标对象
     * @return {Array}      返回数组，每个元素都是属性名和属性值组成。
     */
    _.pairs = function(obj) {
        var keys = _.keys(obj);
        var length = keys.length;
        var pairs = new Array(length);
        for (var i = 0; i < length; i++) {
            pairs[i] = [keys[i], obj[keys[i]]];
        }
        return pairs;
    };

    /**
     * 返回一个object副本，使其键（keys）和值（values）对换。对于这个操作，必须确保object里所有的值都是唯一的且可以序列号成字符串.  
     * Invert the keys and values of an object. The values must be serializable.
     * <pre>
        _.invert({Moe: "Moses", Larry: "Louis", Curly: "Jerome"});
        => {Moses: "Moe", Louis: "Larry", Jerome: "Curly"};
     * </pre>
     * @param  {Object} obj 目标对象
     * @return {Object}      转换过属性名和属性值的对象。
     */
    _.invert = function(obj) {
        var result = {};
        var keys = _.keys(obj);
        for (var i = 0, length = keys.length; i < length; i++) {
            result[obj[keys[i]]] = keys[i];
        }
        return result;
    };

    /**
     * 返回一个对象里所有的方法名, 而且是已经排序的 。Aliased as `methods`。  
     * Return a sorted list of the function names available on the object.  
     * Aliased as `methods`
     * <pre>
        _.functions(_);
        => ["all", "any", "bind", "bindAll", "clone", "compact", "compose" ...
     * </pre>
     * @param  {Object} obj 目标对象
     * @return {Array}      返回数组，每个元素是属性值为函数的属性名称。
     */
    _.functions = _.methods = function(obj) {
        var names = [];
        for (var key in obj) {
            if (_.isFunction(obj[key])) names.push(key);
        }
        return names.sort();
    };

    /**
     * 复制source对象中的所有属性覆盖到destination对象上，并且返回 destination 对象. 复制是按顺序的, 所以后面的对象属性会把前面的对象属性覆盖掉(如果有重复).  
     * Extend a given object with all the properties in passed-in object(s).
     * <pre>
        _.extend({name: 'moe'}, {age: 50});
        => {name: 'moe', age: 50}
     * </pre>
     * @param  {Object} obj 目标参数
     * @param  {Object} objs (optional) 一些列的复制对象，最终这些对象的属性都附加到第一个对象上
     * @return {Object}     返回第一个对象(目标对象)
     */
    _.extend = function(obj) {
        each(slice.call(arguments, 1), function(source) {
            if (source) {
                for (var prop in source) {
                    obj[prop] = source[prop];
                }
            }
        });
        return obj;
    };

    /**
     * 返回一个object副本，只过滤出keys(有效的键组成的数组)参数指定的属性值。  
     * Return a copy of the object only containing the whitelisted properties.
     * <pre>
        _.pick({name: 'moe', age: 50, userid: 'moe1'}, 'name', 'age');
        => {name: 'moe', age: 50}
     * </pre>
     * @param  {Object} obj 目标对象
     * @param  {Object} keys (optional) 一些列的属性key，最终obj对象的这些属性都会被提炼到返回副本里面
     * @return {Object}     从目标对象中返回指定keys的副本对象
     */
    _.pick = function(obj) {
        var copy = {};
        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
        each(keys, function(key) {
            if (key in obj) copy[key] = obj[key];
        });
        return copy;
    };

    /**
     * 返回一个object副本，只过滤出除去keys(有效的键组成的数组)参数指定的属性值。  
     * Return a copy of the object without the blacklisted properties.
     * <pre>
        _.omit({name: 'moe', age: 50, userid: 'moe1'}, 'userid');
        => {name: 'moe', age: 50}
     * </pre>
     * @param  {Object} obj 目标对象
     * @param  {Object} keys (optional) 一些列的属性key，最终obj对象的这些属性都会在返回的副本对象里面剔除
     * @return {Object}     从目标对象中返回不含指定keys的副本对象
     */
    _.omit = function(obj) {
        var copy = {};
        var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
        for (var key in obj) {
            if (!_.contains(keys, key)) copy[key] = obj[key];
        }
        return copy;
    };

    /**
     * 用defaults对象填充object中undefined属性。并且返回这个object。一旦这个属性被填充，再使用defaults方法将不会有任何效果。  
     * Fill in a given object with default properties.
     * <pre>
        var iceCream = {flavor: "chocolate"};
        _.defaults(iceCream, {flavor: "vanilla", sprinkles: "lots"});
        => {flavor: "chocolate", sprinkles: "lots"}
     * </pre>
     * @param  {Object} obj 目标对象
     * @param  {Object} defaults (optional) 一些列的复制对象，会按顺序将obj中没有的属性加上
     * @return {Object}     返回一个被填充后的对象
     */
    _.defaults = function(obj) {
        each(slice.call(arguments, 1), function(source) {
            if (source) {
                for (var prop in source) {
                    if (obj[prop] === void 0) obj[prop] = source[prop];
                }
            }
        });
        return obj;
    };

    /**
     * 创建 一个浅复制（浅拷贝）的克隆object。任何嵌套的对象或数组都通过引用拷贝，不会复制。  
     * Create a (shallow-cloned) duplicate of an object.
     * <pre>
        _.clone({name: 'moe'});
        => {name: 'moe'};
     * </pre>
     * @param  {Object} obj 目标对象
     * @return {Object}     目标对象的副本
     */
    _.clone = function(obj) {
        if (!_.isObject(obj)) return obj;
        return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };

    /**
     * 用 object作为参数来调用函数interceptor，然后返回object。这种方法的主要意图是作为函数链式调用 的一环, 为了对此对象执行操作并返回对象本身。  
     * Invokes interceptor with the obj, and then returns obj.  
     * The primary purpose of this method is to "tap into" a method chain, in order to perform operations on intermediate results within the chain.
     * <pre>
        _.chain([1,2,3,200])
          .filter(function(num) { return num % 2 == 0; })
          .tap(alert)
          .map(function(num) { return num * num })
          .value();
        => // [2, 200] (alerted)
        => [4, 40000]
     * </pre>
     * @param  {Object} obj
     * @param  {Function} interceptor
     * @return {Object}  obj
     */
    _.tap = function(obj, interceptor) {
        interceptor(obj);
        return obj;
    };

    // Internal recursive comparison function for `isEqual`.
    var eq = function(a, b, aStack, bStack) {
        // Identical objects are equal. `0 === -0`, but they aren't identical.
        // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
        if (a === b) return a !== 0 || 1 / a == 1 / b;
        // A strict comparison is necessary because `null == undefined`.
        if (a == null || b == null) return a === b;
        // Unwrap any wrapped objects.
        if (a instanceof _) a = a._wrapped;
        if (b instanceof _) b = b._wrapped;
        // Compare `[[Class]]` names.
        var className = toString.call(a);
        if (className != toString.call(b)) return false;
        switch (className) {
            // Strings, numbers, dates, and booleans are compared by value.
            case '[object String]':
                // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
                // equivalent to `new String("5")`.
                return a == String(b);
            case '[object Number]':
                // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
                // other numeric values.
                return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
            case '[object Date]':
            case '[object Boolean]':
                // Coerce dates and booleans to numeric primitive values. Dates are compared by their
                // millisecond representations. Note that invalid dates with millisecond representations
                // of `NaN` are not equivalent.
                return +a == +b;
                // RegExps are compared by their source patterns and flags.
            case '[object RegExp]':
                return a.source == b.source && a.global == b.global && a.multiline == b.multiline && a.ignoreCase == b.ignoreCase;
        }
        if (typeof a != 'object' || typeof b != 'object') return false;
        // Assume equality for cyclic structures. The algorithm for detecting cyclic
        // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
        var length = aStack.length;
        while (length--) {
            // Linear search. Performance is inversely proportional to the number of
            // unique nested structures.
            if (aStack[length] == a) return bStack[length] == b;
        }
        // Objects with different constructors are not equivalent, but `Object`s
        // from different frames are.
        var aCtor = a.constructor,
            bCtor = b.constructor;
        if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) && _.isFunction(bCtor) && (bCtor instanceof bCtor)) && ('constructor' in a && 'constructor' in b)) {
            return false;
        }
        // Add the first object to the stack of traversed objects.
        aStack.push(a);
        bStack.push(b);
        var size = 0,
            result = true;
        // Recursively compare objects and arrays.
        if (className == '[object Array]') {
            // Compare array lengths to determine if a deep comparison is necessary.
            size = a.length;
            result = size == b.length;
            if (result) {
                // Deep compare the contents, ignoring non-numeric properties.
                while (size--) {
                    if (!(result = eq(a[size], b[size], aStack, bStack))) break;
                }
            }
        } else {
            // Deep compare objects.
            for (var key in a) {
                if (_.has(a, key)) {
                    // Count the expected number of properties.
                    size++;
                    // Deep compare each member.
                    if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
                }
            }
            // Ensure that both objects contain the same number of properties.
            if (result) {
                for (key in b) {
                    if (_.has(b, key) && !(size--)) break;
                }
                result = !size;
            }
        }
        // Remove the first object from the stack of traversed objects.
        aStack.pop();
        bStack.pop();
        return result;
    };

    /**
     * 执行两个对象之间的优化深度比较，确定他们是否应被视为相等。  
     * Perform a deep comparison to check if two objects are equal.
     * <pre>
        var moe   = {name: 'moe', luckyNumbers: [13, 27, 34]};
        var clone = {name: 'moe', luckyNumbers: [13, 27, 34]};
        moe == clone;
        => false
        _.isEqual(moe, clone);
        => true
     * </pre>
     * @param  {Object}  a 源对象
     * @param  {Object}  b 目标对象
     * @return {Boolean}   两对象值是否相等
     */
    _.isEqual = function(a, b) {
        return eq(a, b, [], []);
    };

    /**
     * 如果object 不包含任何值(没有可枚举的属性)，返回true。也可以判断字符串或者数组的长度为0  
     * Is a given array, string, or object empty?  
     * An "empty" object has no enumerable own-properties.
     * <pre>
        _.isEmpty([1, 2, 3]);
        => false
        _.isEmpty({});
        => true
     * </pre>
     * @param  {Object}  obj 目标对象
     * @return {Boolean}    目标对象是否为空值
     */
    _.isEmpty = function(obj) {
        if (obj == null) return true;
        if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
        for (var key in obj)
            if (_.has(obj, key)) return false;
        return true;
    };

    /**
     * 如果object是一个DOM元素，返回true。属性nodeType为1表示为element对象  
     * Is a given value a DOM element?
     * <pre>
        _.isElement(jQuery('body')[0]);
        => true
     * </pre>
     * @param  {Object}  obj 目标对象
     * @return {Boolean} 是否为dom对象
     */
    _.isElement = function(obj) {
        return !!(obj && obj.nodeType === 1);
    };

    /**
     * 如果object是一个数组，返回true。如果存在原生的Array.isArray方法，就用原生方法来代替。  
     * Is a given value an array?  
     * Delegates to ECMA5's native Array.isArray
     * <pre>
        (function(){ return _.isArray(arguments); })();
        => false
        _.isArray([1,2,3]);
        => true
     * </pre>
     * @param  {Object}  obj 目标对象
     * @return {Boolean} 目标对象是否为数组
     */
    _.isArray = nativeIsArray ||
        function(obj) {
            return toString.call(obj) == '[object Array]';
    };

    /**
     * 如果object是一个对象，返回true。需要注意的是JavaScript数组和函数是对象，字符串和数字不是。  
     * Is a given variable an object?
     * <pre>
        _.isObject({});
        => true
        _.isObject(1);
        => false
     * </pre>
     * @param  {Object}  obj 目标对象
     * @return {Boolean}     true or false
     */
    _.isObject = function(obj) {
        return obj === Object(obj);
    };

    /**
     * 如果object是一个参数对象，返回true  
     * Is a given variable an arguments?
     * @method isArguments
     * <pre>
        (function(){ return _.isArguments(arguments); })(1, 2, 3);
        => true
        _.isArguments([1,2,3]);
        => false
     * </pre>
     * @param {Object}  obj 目标对象
     * @return {Boolean}    true or false
     */

    /**
     * 如果object是一个函数对象，返回true  
     * Is a given variable a function?
     * @method isFunction
     * <pre>
        _.isFunction(alert);
        => true
     * </pre>
     * @param {Object}  obj 目标对象
     * @return {Boolean}    true or false
     */

    /**
     * 如果object是一个字符串，返回true  
     * Is a given variable a String?
     * @method isString
     * <pre>
        _.isString("moe");
        => true
     * </pre>
     * @param {Object}  obj 目标对象
     * @return {Boolean}    true or false
     */

    /**
     * 如果object是一个数值，返回true, 包括 NaN  
     * Is a given variable a number?
     * @method isNumber
     * <pre>
        _.isNumber(8.4 * 5);
        => true
     * </pre>
     * @param {Object}  obj 目标对象
     * @return {Boolean}    true or false
     */

    /**
     * 如果object是一个日期时间，返回true  
     * Is a given variable a date?
     * @method isDate
     * <pre>
        _.isDate(new Date());
        => true
     * </pre>
     * @param {Object}  obj 目标对象
     * @return {Boolean}    true or false
     */

    /**
     * 如果object是一个正则表达式，返回true  
     * Is a given variable a regExp?
     * @method isRegExp
     * <pre>
        _.isRegExp(/moe/);
        => true
     * </pre>
     * @param {Object}  obj 目标对象
     * @return {Boolean}    true or false
     */

    // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
    each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
        _['is' + name] = function(obj) {
            return toString.call(obj) == '[object ' + name + ']';
        };
    });

    // Define a fallback version of the method in browsers (ahem, IE), where
    // there isn't any inspectable "Arguments" type.
    if (!_.isArguments(arguments)) {
        _.isArguments = function(obj) {
            return !!(obj && _.has(obj, 'callee'));
        };
    }

    // Optimize `isFunction` if appropriate.
    if (typeof(/./) !== 'function') {
        _.isFunction = function(obj) {
            return typeof obj === 'function';
        };
    }

    /**
     * 如果object是一个有限的数字，返回true。  
     * Is a given object a finite number?
     * <pre>
        _.isFinite(-101);
        => true
        _.isFinite(-Infinity);
        => false
     * </pre>
     * @param  {Object}  obj 目标对象
     * @return {Boolean}     true or false
     */
    _.isFinite = function(obj) {
        return isFinite(obj) && !isNaN(parseFloat(obj));
    };

    /**
     * 如果object是数组或者NaN，返回true。和原生的isNaN 函数不一样，如果变量是undefined，原生的isNaN 函数也会返回 true  
     * Is the given value `NaN`? (NaN is the only number which does not equal itself).
     * <pre>
        _.isNaN(NaN);
        => true
        isNaN(undefined);
        => true
        _.isNaN(undefined);
        => false
     * </pre>
     * @param  {Object}  obj 目标对象
     * @return {Boolean}     true or false
     */
    _.isNaN = function(obj) {
        return _.isNumber(obj) && obj != +obj;
    };

    /**
     * 如果object是一个布尔值，返回true。  
     * Is a given value a boolean?
     * <pre>
        _.isBoolean(null);
        => false
     * </pre>
     * @param  {Object}  obj 目标对象
     * @return {Boolean}     true or false
     */
    _.isBoolean = function(obj) {
        return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
    };

    /**
     * 如果object的值是 null，返回true。  
     * Is a given value equal to null?
     * <pre>
        _.isNull(null);
        => true
        _.isNull(undefined);
        => false
     * </pre>
     * @param  {Object}  obj 目标对象
     * @return {Boolean}     true or false
     */
    _.isNull = function(obj) {
        return obj === null;
    };

    /**
     * 如果value是undefined，返回true。  
     * Is a given variable undefined?
     * <pre>
        _.isUndefined(window.missingVariable);
        => true
     * </pre>
     * @param  {Object}  obj 目标对象
     * @return {Boolean}     true or false
     */
    _.isUndefined = function(obj) {
        return obj === void 0;
    };

    /**
     * 对象是否包含给定的键吗？等同于object.hasOwnProperty(key)，但是使用hasOwnProperty 函数的一个安全引用，以防意外覆盖。  
     * Shortcut function for checking if an object has a given property directly on itself (in other words, not on a prototype).
     * <pre>
        _.has({a: 1, b: 2, c: 3}, "b");
        => true
     * </pre>
     * @param  {Object} obj 目标对象
     * @param  {String}  key 目标的属性名称
     * @return {Boolean}     对象是否拥有属性true or false
     */
    _.has = function(obj, key) {
        return hasOwnProperty.call(obj, key);
    };

    // Utility Functions
    // -----------------
    /**
     * 放弃Underscore 的控制变量"_"。返回Underscore 对象的引用。  
     * Run Underscore.js in *noConflict* mode, returning the `_` variable to its previous owner. Returns a reference to the Underscore object.
     * <pre>
        var underscore = _.noConflict();
     * </pre>
     * @return {Object} 返回underscore对象
     */
    _.noConflict = function() {
        root._ = previousUnderscore;
        return this;
    };

    /**
     * 返回与传入参数相等的值. 相当于数学里的: f(x) = x, 在Underscore里被用作默认的迭代器iterator.  
     * Keep the identity function around for default iterators.
     * <pre>
        var moe = {name: 'moe'};
        moe === _.identity(moe);
        => true
     * </pre>
     * @param  {Object} value 传入的值
     * @return {Object} 返回传入的值
     */
    _.identity = function(value) {
        return value;
    };
    /**
     * 返回一个函数，函数的返回值就是传入的参数。 相当于x=f(x)();
    * <pre>
        var obj={a:11};
        var func=_.constant(a);
        func().a
        => 11
     * </pre>
     * @param  {Object} value 传入的值
     * @return {Function}     返回无参函数，函数返回值为传入的值。
     */
    _.constant = function(value) {
        return function() {
            return value;
        };
    };
    /**
     * 返回一个函数，在函数的参数对象里面取key对应的值  
     * Returns a function that will itself return the key property of any passed-in object.
     * <pre>
        var moe = {name: 'moe'};
        'moe' === _.property('name')(moe);
        => true
     * </pre>
     * @param  {String} key 属性名称
     * @return {Function}   返回函数，函数内会取参数对象的属性名用来返回属性值
     */
    _.property = function(key) {
        return function(obj) {
            return obj[key];
        };
    };

    // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
    /**
     * 返回一个函数，若函数的参数如果都具有attr中一样的属性，则返回true。
     * Returns a predicate function that will tell you if a passed in object contains all of the key/value properties present in attrs.
     * <pre>
        var ready = _.matches({selected: true, visible: true});
        var readyToGoList = _.filter(list, ready);
     * </pre>
     * @param  {Object} attrs 需要判断的属性对象
     * @return {Function}      返回函数，函数内会判断参数对象是否都包含attr的属性值，返回true or false
     */
    _.matches = function(attrs) {
        return function(obj) {
            if (obj === attrs) return true; //avoid comparing an object to itself.
            for (var key in attrs) {
                if (attrs[key] !== obj[key]) return false;
            }
            return true;
        }
    };

    /**
     * 调用给定的迭代函数n次,每一次传递index参数，调用迭代函数。 注意: 本例使用 链式语法。  
     * Run a function **n** times.
     * <pre>
        _(3).times(function(n){ genie.grantWishNumber(n); });
        => alert(n) 分别打印出为0,1,2
     * </pre>
     * @param  {Number} n        函数调用的次数，每调用一次，index加1，index从0开始
     * @param  {Function} iterator 执行函数
     * @param  {Object} context (optional) 如果传递了context参数，则把iterator绑定到context对象上
     * @return {Array}          返回一个长度为n的数组，每个值为每次调用函数的返回值
     */
    _.times = function(n, iterator, context) {
        var accum = Array(Math.max(0, n));
        for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
        return accum;
    };

    /**
     * 返回一个min 和 max之间的随机整数。  
     * Return a random integer between min and max (inclusive).
     * <pre>
        _.random(0, 100);
        => 42
     * </pre>
     * @param  {Number} min (optional) 返回的随机整数的最小范围，此参数不传，默认为0，
     * @param  {Number} max (optional) 返回的随机整数的最大范围
     * @return {Number}     返回一个范围内的整数
     */
    _.random = function(min, max) {
        if (max == null) {
            max = min;
            min = 0;
        }
        return min + Math.floor(Math.random() * (max - min + 1));
    };

    /**
     * 返回当前时间的时间戳  
     * A (possibly faster) way to get the current timestamp as an integer.
     * <pre>
         _.now();
         => 1393573920327
     * </pre>
     * @return {Number}     返回时间戳
     */
    _.now = Date.now ||
        function() {
            return new Date().getTime();
    };

    /**
     * 转义HTML字符串，替换&, <, >, ", ', and /字符。  
     * Functions for escaping strings from HTML interpolation.
     * @method escape
     * <pre>
        _.escape('Curly, Larry & Moe');
        => "Curly, Larry &amp; Moe"
     * </pre>
     * @param {String}  string 目标字符串
     * @return {String}        转义后的字符串
     */

    /**
     * 和**{@link fish.desktop.util.Util#escape escape}**相反。转义HTML字符串，替换&, &lt;, &gt;, &quot;, &#x27;, and &#x2F;字符。  
     * Functions for unescaping strings to HTML interpolation.
     * @method unescape
     * <pre>
        _.unescape('Curly, Larry &amp; Moe');
        => "Curly, Larry & Moe"
     * </pre>
     * @param {String}  string 目标字符串
     * @return {String}        还原转义后的字符串，
     */


    // List of HTML entities for escaping.
    var entityMap = {
        escape: {
            '&': '&amp;',
            '<': '&lt;',
            '>': '&gt;',
            '"': '&quot;',
            "'": '&#x27;'
        }
    };
    entityMap.unescape = _.invert(entityMap.escape);

    // Regexes containing the keys and values listed immediately above.
    var entityRegexes = {
        escape: new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
        unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
    };

    // Functions for escaping and unescaping strings to/from HTML interpolation.
    _.each(['escape', 'unescape'], function(method) {
        _[method] = function(string) {
            if (string == null) return '';
            return ('' + string).replace(entityRegexes[method], function(match) {
                return entityMap[method][match];
            });
        };
    });

    /**
     * 如果对象 object 中的属性 property 是函数, 则调用它, 否则, 返回它。  
     * If the value of the named `property` is a function then invoke it with the `object` as context; otherwise, return it.
     * <pre>
        var object = {cheese: 'crumpets', stuff: function(){ return 'nonsense'; }};
        _.result(object, 'cheese');
        => "crumpets"
        _.result(object, 'stuff');
        => "nonsense"
     * </pre>
     * @param  {Object} object   目标对象
     * @param  {String} property 属性名
     * @return {Object}          返回属性对应的值，或者属性对应的方法执行的返回值
     */
    _.result = function(object, property) {
        if (object == null) return void 0;
        var value = object[property];
        return _.isFunction(value) ? value.call(object) : value;
    };

    /**
     * 您可以用您自己的实用程序函数扩展Underscore。传递一个 {name: function}定义的哈希添加到Underscore对象，以及面向对象封装。  
     * Add your own custom functions to the Underscore object.
     * <pre>
        _.mixin({
          capitalize: function(string) {
            return string.charAt(0).toUpperCase() + string.substring(1).toLowerCase();
          }
        });
        _("fabio").capitalize();
        => "Fabio"
     * </pre>
     * @param  {Object} obj 定义为{name: function}的对象附加到Underscore原型链上，支持Underscore对象之间调用name()方法来执行function
     * @return {Object}     将方法定义到Underscore原型链上
     */
    _.mixin = function(obj) {
        each(_.functions(obj), function(name) {
            var func = _[name] = obj[name];
            _.prototype[name] = function() {
                var args = [this._wrapped];
                push.apply(args, arguments);
                return result.call(this, func.apply(_, args));
            };
        });
    };

    var idCounter = 0;
    /**
     * 为需要的客户端模型或DOM元素生成一个全局唯一的id。  
     * Generate a unique integer id (unique within the entire client session).  
     * Useful for temporary DOM ids.
     * <pre>
        _.uniqueId('contact_');
        => 'contact_104'
     * </pre>
     * @param  {String} prefix (optional) 如果prefix参数存在， id 将附加给它。
     * @return {String}        生成全局唯一的字符串
     */
    _.uniqueId = function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
    };

    // By default, Underscore uses ERB-style template delimiters, change the
    // following template settings to use alternative delimiters.
    _.templateSettings = {
        evaluate: /<%([\s\S]+?)%>/g,
        interpolate: /<%=([\s\S]+?)%>/g,
        escape: /<%-([\s\S]+?)%>/g
    };

    // When customizing `templateSettings`, if you don't want to define an
    // interpolation, evaluation or escaping regex, we need one that is
    // guaranteed not to match.
    var noMatch = /(.)^/;

    // Certain characters need to be escaped so that they can be put into a
    // string literal.
    var escapes = {
        "'": "'",
        '\\': '\\',
        '\r': 'r',
        '\n': 'n',
        '\t': 't',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
    };

    var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

    /**
     * 将 JavaScript 模板编译为可以用于页面呈现的函数, 对于通过JSON数据源生成复杂的HTML并呈现出来的操作非常有用。 模板函数可以使用 <%= … %>插入变量, 也可以用<% … %>执行任意的 JavaScript 代码。 如果您希望插入一个值, 并让其进行HTML转义,请使用<%- … %>。 当你要给模板函数赋值的时候，可以传递一个含有与模板对应属性的data对象 。 如果您要写一个一次性的, 您可以传对象 data 作为第二个参数给模板 template 来直接呈现, 这样页面会立即呈现而不是返回一个模板函数. 参数 settings 是一个哈希表包含任何可以覆盖的设置templateSettings.  
     * JavaScript micro-templating, similar to John Resig's implementation.  
     * Underscore templating handles arbitrary delimiters, preserves whitespace,and correctly escapes quotes within interpolated code.
     * @param  {String} text     模板文件
     * @param  {Object} data (optional) 模板中用到的数据
     * @param  {Object} settings (optional) 模板的默认设置，可覆盖
     * @return {String}          返回编译后的模板文件
     */
    _.template = function(text, data, settings) {
        var render;
        settings = _.defaults({}, settings, _.templateSettings);

        // Combine delimiters into one regular expression via alternation.
        var matcher = new RegExp([
            (settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source
        ].join('|') + '|$', 'g');

        // Compile the template source, escaping string literals appropriately.
        var index = 0;
        var source = "__p+='";
        text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
            source += text.slice(index, offset).replace(escaper, function(match) {
                return '\\' + escapes[match];
            });

            if (escape) {
                source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
            }
            if (interpolate) {
                source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
            }
            if (evaluate) {
                source += "';\n" + evaluate + "\n__p+='";
            }
            index = offset + match.length;
            return match;
        });
        source += "';\n";

        // If a variable is not specified, place data values in local scope.
        if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

        source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";

        try {
            render = new Function(settings.variable || 'obj', '_', source);
        } catch (e) {
            e.source = source;
            throw e;
        }

        if (data) return render(data, _);
        var template = function(data) {
            return render.call(this, data, _);
        };

        // Provide the compiled function source as a convenience for precompilation.
        template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

        return template;
    };

    /**
     * 对一个对象使用 chain 方法, 会把这个对象封装并 让以后每次方法的调用结束后都返回这个封装的对象.支持链式语法  
     * Add a "chain" function, which will delegate to the wrapper.
     * <pre>
        var stooges = [{name: 'curly', age: 25}, {name: 'moe', age: 21}, {name: 'larry', age: 23}];
        var youngest = _.chain(stooges)
          .sortBy(function(stooge){ return stooge.age; })
          .map(function(stooge){ return stooge.name + ' is ' + stooge.age; })
          .first()
          .value();
        => "moe is 21"
     * </pre>
     * @param  {Object} obj 目标对象
     * @return {Object}     返回链式对象
     */
    _.chain = function(obj) {
        return _(obj).chain();
    };

    // OOP
    // ---------------
    /**
     * 如果对应已经支持链式则返回自身，否则进行链式封装  
     * If Underscore is called as a function, it returns a wrapped object that can be used OO-style. This wrapper holds altered versions of all the underscore functions. Wrapped objects may be chained.  
     * Helper function to continue chaining intermediate results.
     * @param  {Object} obj 目标对象
     * @return {Object}     返回链式对象
     * @ignore
     */
    var result = function(obj) {
        return this._chain ? _(obj).chain() : obj;
    };

    // Add all of the Underscore functions to the wrapper object.
    _.mixin(_);

    // Add all mutator Array functions to the wrapper.
    each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            var obj = this._wrapped;
            method.apply(obj, arguments);
            if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
            return result.call(this, obj);
        };
    });

    // Add all accessor Array functions to the wrapper.
    each(['concat', 'join', 'slice'], function(name) {
        var method = ArrayProto[name];
        _.prototype[name] = function() {
            return result.call(this, method.apply(this._wrapped, arguments));
        };
    });

    _.extend(_.prototype, {

        // Start chaining a wrapped Underscore object.
        chain: function() {
            this._chain = true;
            return this;
        },

        /**
         * 获取封装对象的最终值.  
         * Extracts the result from a wrapped and chained object.
         * <pre>
            _([1, 2, 3]).value();
            => [1, 2, 3]
         * </pre>
         * @return {Object} 返回封装对象的原始值
         */
        value: function() {
            return this._wrapped;
        }

    });

    // AMD registration happens at the end for compatibility with AMD loaders
    // that may not enforce next-turn semantics on modules. Even though general
    // practice for AMD registration is to be anonymous, underscore registers
    // as a named module because, like jQuery, it is a base library that is
    // popular enough to be bundled in a third party lib, but not be part of
    // an AMD load request. Those cases could generate an error when an
    // anonymous define() is called outside of a loader request.
    if (typeof define === 'function' && define.amd) {
        define('underscore', [], function() {
            return _;
        });
    }
}).call(this);
/**
 * 本地存储，localStorage适配层
 * @class fish.desktop.util.Store
 */
fish.store = {
    /**
     * 获取本地存储容量数量
     * @method length
     * @return {Number} 返回本地存储容量数量
     */
    length: function() {
        return localStorage.length;
    },
    /**
     * 存储
     * @method set
     * @param {*} key 键名
     * @param {*} value 存储内容
     */
    set: function(key, value) {
        localStorage.setItem(key, value);
    },
    /**
     * 获取对应key内容
     * @method get
     * @param {*} key 键名
     * @return {*}
     */
    get: function(key) {
        return localStorage.getItem(key);
    },
    /**
     * 删除对应key
     * @method remove
     * @param {*} key 键名
     */
    remove: function(key) {
        localStorage.removeItem(key);
    },
    /**
     * 清空所有项
     * @method clear
     */
    clear: function() {
        localStorage.clear();
    },
    /**
     * 遍历
     * @method each
     * @param {Function} fn 回调函数
     * @param {*} fn.key 键
     * @param {*} fn.value 值
     */
    each: function(fn) {
        var n = localStorage.length,
            i = 0,
            fn = fn || function() {};
        for (; i < n; i++) {
            var key = localStorage.key(i);
            if (fn.call(this, key, this.get(key)) === false)
                break;
            //如果内容被删除，则总长度和索引都同步减少
            if (localStorage.length < n) {
                n--;
                i--;
            }
        }
    }
};
/**
 *@class fish.desktop.util.Util
 *工具类,拥有underscore-1.1.6的所有方法和自定义方法
 *@singleton
 */
! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.util', ["underscore", "handlebars"], factory);
    } else {
        factory(_, Handlebars);
    }
}(function(_, handlebars) {

    "use strict";

    var util = {
        version: "1.0.0"
    };
    /**
     * @method load
     * 加载需编译的模板,可能存在I18n的参数,需要requirejs
     * @param {Object} options{template ,i18n ,baseUrl,data}
     * @param callBack(context,i18n) 回调函数中参数为目标文本和目标国际化对象
     */
    util.load = function(options, callBack) {
        var toLoad = [];
        var buildMap = {};
        // deal baseUrl
        options.baseUrl = options.baseUrl ? options.baseUrl : "";
        toLoad.push("text!" + options.baseUrl + options.template);
        options.i18n ? toLoad.push("i18n!" + options.baseUrl + options.i18n) : "";
        // options.css ? toLoad.push("css!" + options.baseUrl + options.css) : "";
        require(toLoad, function(tpl, i18n) {
            // 1) get i18n resource 2) extend to data 3) compile template 4) load data
            if (i18n === undefined) {
                var html = handlebars.compile(tpl)(options); //handlebars.compile(tpl)(options);
                callBack(html); //return context
            } else {
                var data = $.extend(options, i18n);
                var html = handlebars.compile(tpl)(data);
                callBack(html, i18n); //return context and i18n object
            }
        });
    };
    /**
     * @method loadDirect
     * 加载纯粹的HTML,需要requirejs
     * @param {Object} options{template ,baseUrl}
     * @param callBack(context) 回调函数中参数为目标文本
     */
    util.loadDirect = function(options, callBack) {
        var toLoad = [];
        var buildMap = {};
        // deal baseUrl
        options.baseUrl = options.baseUrl ? options.baseUrl : "";
        toLoad.push("text!" + options.baseUrl + options.template);
        // options.css ? toLoad.push("css!" + options.baseUrl + options.css) : "";
        require(toLoad, function(html) {
            callBack(html); //return context
        });
    };
    /**
     * @method loadI18n
     * 加载纯粹的i18n对象,需要requirejs
     * @param {Object} options{i18n}
     * @param callBack(context) 回调函数中参数为目标国际化对象
     */
    util.loadI18n = function(options, callBack) {
        var toLoad = [];
        options.baseUrl = options.baseUrl ? options.baseUrl : "";
        toLoad.push("i18n!" + options.baseUrl + options.i18n);
        require(toLoad, function(i18n) {
            callBack(i18n); //return i18n object
        });
    };

    /**
     * 加载JS脚本，带有排除重复加载的功能。
     * @param  {String} src JS脚本路径
     */
    util.loadScript = function(src) {
        var id = src.substring(0, src.length - 3) + "-js";
        id = String(id).replace(/[!"#$%&'()*+,.\/:; <=>?@\[\\\]\^`{|}~]/g, "\\$&");
        if ($("#" + id)[0]) { //如果存在
            $("#" + id).remove();
        }
        var head = document.getElementsByTagName('head')[0];
        var node = document.createElement('script');
        node.type = 'text/javascript';
        node.charset = 'utf-8';
        node.async = true;
        node.src = src;
        node.id = id;
        head.appendChild(node);
    }

    /**
     * 获取input textarea中光标的位置
     * @method getCursorPosition
     * @param {Element} el 元素(input, textarea)
     * @return {Object} {text: "", start: 0, end: 0 }
     */
    util.getCursorPosition = function(el) {
        var rangeData = {
            text: "",
            start: 0,
            end: 0
        };
        el.focus();
        if (el.setSelectionRange) { // W3C
            rangeData.start = el.selectionStart;
            rangeData.end = el.selectionEnd;
            rangeData.text = (rangeData.start != rangeData.end) ? el.value.substring(rangeData.start, rangeData.end) : "";
            return rangeData;
        }
        if (document.selection) { // IE8 below
            var i,
                oS = document.selection.createRange(),
                // Don't: oR = el.createTextRange()
                oR = document.body.createTextRange();
            oR.moveToElementText(el);

            rangeData.text = oS.text;
            rangeData.bookmark = oS.getBookmark();

            // object.moveStart(sUnit [, iCount])
            // Return Value: Integer that returns the number of units moved.
            for (i = 0; oR.compareEndPoints('StartToStart', oS) < 0 && oS.moveStart("character", -1) !== 0; i++) {
                // Why? You can alert(el.value.length)
                if (el.value.charAt(i) == '\n') {
                    i++;
                }
            }
            rangeData.start = i;
            rangeData.end = rangeData.text.length + rangeData.start;
            return rangeData;
        }

        return null;
    };

    /**
     * 设置元素的光标 setCursorPosition
     * @method
     * @param {Element} el input,textarea
     * @param {Object} rangeData
     */
    util.setCursorPosition = function(el, rangeData) {
        if (!rangeData) {
            throw Error("You must get cursor position first.");
            return;
        }
        if (el.setSelectionRange) { // W3C
            //      el.focus();
            el.setSelectionRange(rangeData.start, rangeData.end);
            return;
        }
        if (el.createTextRange) { // IE8 below
            var oR = el.createTextRange();
            // Fixbug :
            // In IE, if cursor position at the end of el, the setCursorPosition function don't work
            if (el.value.length === rangeData.start) {
                oR.collapse(false);
                oR.select();
            } else {
                oR.moveToBookmark(rangeData.bookmark);
                oR.select();
            }
        }
    };
    
    //将util、Underscore的方法挂载到fish对象上
    if (window.fish) {
        window.fish.util ? "" : window.fish.util = {};
        _.extend(window.fish.util, util);
        _.extend(window.fish.util, _);
    }
});

/**
 * Created by huangxinghui on 2014/11/25.
 */
(function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.dateutil', factory);
    } else {
        factory();
    }
})(function() {
    var MILLIS_PER_SECOND = 1000,
        MILLIS_PER_MINUTE = 60 * MILLIS_PER_SECOND,
        MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE,
        MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR,
        NON_PUNCTUATION_EXPRESSION = /[^ -\/:-@\[-`{-~\t\n\rTZ]+/g;

    function getStartOfDay(date){
        return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 0, 0, 0, 0);
    }

    function getEndOfDay(date) {
        return new Date(date.getFullYear(), date.getMonth(), date.getDate(), 23, 59, 59, 999);
    }

    function addYears(date, years) {
        var result = new Date(date.getTime());
        result.setYear(date.getFullYear() + years);
        return result;
    }

    function addMonths(date, months) {
        var result = new Date(date.getTime());
        result.setMonth(date.getMonth() + months);
        result = handleShorterMonth(date, result);
        return result;
    }

    function addDays(date, days) {
        return add(date, MILLIS_PER_DAY, days);
    }

    function addHours(date, hours) {
        return add(date, MILLIS_PER_HOUR, hours);
    }

    function addMinutes(date, minutes) {
        return add(date, MILLIS_PER_MINUTE, minutes);
    }

    function add(date, multiplier, num) {
        var resultTime = date.getTime() + multiplier * num;
        return new Date(resultTime);
    }

    function handleShorterMonth(originalDate, newDate) {
        var result = newDate;
        var originalDayOfMonth = originalDate.getDate();
        if (originalDayOfMonth > result.getDate()) {
            result = addDays(newDate, -(newDate.getDate()));
        }
        return result;
    }

    function formatDate(date, format) {
        if (date == null) {
            return '';
        }
        var meridian = fish.getResource('datetimepicker.meridiem'),
            monthsShort = fish.getResource('datetimepicker.monthsShort'),
            months = fish.getResource('datetimepicker.months'),
            daysShort = fish.getResource('datetimepicker.daysShort'),
            days = fish.getResource('datetimepicker.days'),
            val = {
                // year
                yy: date.getFullYear().toString().substring(2),
                yyyy: date.getFullYear(),
                // month
                m: date.getMonth() + 1,
                M: monthsShort[date.getMonth()],
                MM: months[date.getMonth()],
                // day
                d: date.getDate(),
                D: daysShort[date.getDay()],
                DD: days[date.getDay()],
                p: (meridian.length == 2 ? meridian[date.getHours() < 12 ? 0 : 1] : ''),
                // hour
                h: date.getHours(),
                // minute
                i: date.getMinutes(),
                // second
                s: date.getSeconds()
            };

        format = parseFormat(format);

        if (meridian.length == 2) {
            val.H = (val.h % 12 == 0 ? 12 : val.h % 12);
        } else {
            val.H = val.h;
        }
        val.HH = (val.H < 10 ? '0' : '') + val.H;
        val.P = val.p.toUpperCase();
        val.hh = (val.h < 10 ? '0' : '') + val.h;
        val.ii = (val.i < 10 ? '0' : '') + val.i;
        val.ss = (val.s < 10 ? '0' : '') + val.s;
        val.dd = (val.d < 10 ? '0' : '') + val.d;
        val.mm = (val.m < 10 ? '0' : '') + val.m;
        var date = [],
            seps = $.extend([], format.separators);
        for (var i = 0, cnt = format.parts.length; i < cnt; i++) {
            if (seps.length) {
                date.push(seps.shift());
            }
            date.push(val[format.parts[i]]);
        }
        if (seps.length) {
            date.push(seps.shift());
        }
        return date.join('');
    }

    function parseFormat(format) {
        var pattern = /hh?|HH?|p|P|ii?|ss?|dd?|DD?|mm?|MM?|yy(?:yy)?/g,
            separators = format.replace(pattern, '\0').split('\0'),
            parts = format.match(pattern);
        if (!separators || !separators.length || !parts || parts.length == 0) {
            throw new Error("Invalid date format.");
        }
        return {
            separators: separators,
            parts: parts
        };
    }

    function parseDate(date, format) {
        if (date instanceof Date) {
            return date;
        }

        if (date == null || date.length != format.length)
            return null;

        if (/^[-+]\d+[dmwy]([\s,]+[-+]\d+[dmwy])*$/.test(date)) {
            var part_re = /([-+]\d+)([dmwy])/,
                parts = date.match(/([-+]\d+)([dmwy])/g),
                part, dir;
            date = new Date();
            for (var i = 0; i < parts.length; i++) {
                part = part_re.exec(parts[i]);
                dir = parseInt(part[1]);
                switch (part[2]) {
                    case 'd':
                        date.setDate(date.getDate() + dir);
                        break;
                    case 'm':
                        date = addMonths(date, dir);
                        break;
                    case 'w':
                        date.setDate(date.getDate() + dir * 7);
                        break;
                    case 'y':
                        date = addYears(date, dir);
                        break;
                }
            }
            return new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), 0);
        }

        format = parseFormat(format);

        var parts = date && date.match(NON_PUNCTUATION_EXPRESSION) || [],
            date = new Date(0, 0, 0, 0, 0, 0, 0),
            months = fish.getResource('datetimepicker.months'),
            monthsShort = fish.getResource('datetimepicker.monthsShort'),
            meridian = fish.getResource('datetimepicker.meridian'),
            parsed = {},
            setters_order = ['hh', 'h', 'ii', 'i', 'ss', 's', 'yyyy', 'yy', 'M', 'MM', 'm', 'mm', 'D', 'DD', 'd', 'dd', 'H', 'HH', 'p', 'P'],
            setters_map = {
                hh: function(d, v) {
                    return d.setHours(v);
                },
                h: function(d, v) {
                    return d.setHours(v);
                },
                HH: function(d, v) {
                    return d.setHours(v == 12 ? 0 : v);
                },
                H: function(d, v) {
                    return d.setHours(v == 12 ? 0 : v);
                },
                ii: function(d, v) {
                    return d.setMinutes(v);
                },
                i: function(d, v) {
                    return d.setMinutes(v);
                },
                ss: function(d, v) {
                    return d.setSeconds(v);
                },
                s: function(d, v) {
                    return d.setSeconds(v);
                },
                yyyy: function(d, v) {
                    return d.setFullYear(v);
                },
                yy: function(d, v) {
                    return d.setFullYear(2000 + v);
                },
                m: function(d, v) {
                    v -= 1;
                    while (v < 0) v += 12;
                    v %= 12;
                    d.setMonth(v);
                    while (d.getMonth() != v)
                        d.setDate(d.getDate() - 1);
                    return d;
                },
                d: function(d, v) {
                    return d.setDate(v);
                },
                p: function(d, v) {
                    return d.setHours(v == 1 ? d.getHours() + 12 : d.getHours());
                }
            },
            val, filtered, part;
        setters_map['M'] = setters_map['MM'] = setters_map['mm'] = setters_map['m'];
        setters_map['dd'] = setters_map['d'];
        setters_map['P'] = setters_map['p'];
        date = new Date(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds());
        if (parts.length == format.parts.length) {
            for (var i = 0, cnt = format.parts.length; i < cnt; i++) {
                val = parseInt(parts[i], 10);
                part = format.parts[i];
                if (isNaN(val)) {
                    switch (part) {
                        case 'MM':
                            filtered = $(months).filter(function() {
                                var m = this.slice(0, parts[i].length),
                                    p = parts[i].slice(0, m.length);
                                return m == p;
                            });
                            val = $.inArray(filtered[0], months) + 1;
                            break;
                        case 'M':
                            filtered = $(monthsShort).filter(function() {
                                var m = this.slice(0, parts[i].length),
                                    p = parts[i].slice(0, m.length);
                                return m == p;
                            });
                            val = $.inArray(filtered[0], monthsShort) + 1;
                            break;
                        case 'p':
                        case 'P':
                            val = $.inArray(parts[i].toLowerCase(), meridian);
                            break;
                    }
                }
                parsed[part] = val;
            }
            for (var i = 0, s; i < setters_order.length; i++) {
                s = setters_order[i];
                if (s in parsed && !isNaN(parsed[s]))
                    setters_map[s](date, parsed[s])
            }
        }
        return date;
    }

    function isLeapYear(year) {
        return (((year % 4 === 0) && (year % 100 !== 0)) || (year % 400 === 0));
    }

    function getDaysInMonth(year, month) {
        return [31, (isLeapYear(year) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    }

    return fish.dateutil = {
        addYears: addYears,
        addMonths: addMonths,
        addDays: addDays,
        addHours: addHours,
        addMinutes: addMinutes,
        format: formatDate,
        parse: parseDate,
        getDaysInMonth: getDaysInMonth,
        getStartOfDay: getStartOfDay,
        getEndOfDay: getEndOfDay
    }
});
// If you load jQuery, then set jQuery.uiBackCompat = false, then load jQuery UI, none of the 1.8 API will be loaded. 
// jQuery.uiBackCompat = false;

/*!
 * jQuery UI Core 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */
(function($, undefined) {

    var uuid = 0,
        idPrefix = "ui-id-",
        runiqueId = /^ui-id-\d+$/;

    // prevent duplicate loading
    // this is only a problem because we proxy existing functions
    // and we don't want to double proxy them
    $.ui = $.ui || {};
    if ($.ui.version) {
        return;
    }

    /**
     * jqueryui Core
     * @class fish.desktop.uicore.Core
     * 在jquery的基础上封装了部分方法
     */
    $.extend($.ui, {
        version: "1.9.2",

        /**
         * @static {Object} keyCode 公共键码表
         * <pre>
         *   $.ui.keyCode.ENTER //13
         * </pre>
         */
        keyCode: {
            BACKSPACE: 8,
            TAB: 9,

            DELETE: 46,
            ENTER: 13,
            ESCAPE: 27,

            NUMPAD_MULTIPLY: 106, //*
            NUMPAD_ADD: 107, //+
            NUMPAD_ENTER: 108, //Enter
            NUMPAD_SUBTRACT: 109, //-
            NUMPAD_DECIMAL: 110, //.
            NUMPAD_DIVIDE: 111, ///
            COMMA: 188, //,<
            PERIOD: 190, //.>

            SPACE: 32,
            PAGE_UP: 33,
            PAGE_DOWN: 34,
            END: 35,
            HOME: 36,
            LEFT: 37,
            UP: 38,
            RIGHT: 39,
            DOWN: 40
        }
    });

    // plugins
    $.fn.extend({
        _focus: $.fn.focus,
        /**
         * @method focus 重载$.fn.focus方法
         * @param  {number} delay
         * @param  {Function} callback
         */
        focus: function(delay, fn) {
            return typeof delay === "number" ?
                this.each(function() {
                    var elem = this;
                    setTimeout(function() {
                        $(elem).focus();
                        if (fn) {
                            fn.call(elem);
                        }
                    }, delay);
                }) :
                this._focus.apply(this, arguments);
        },
        /**
         * @method scrollParent
         * Get the closest ancestor element that is scrollable.
         */
        scrollParent: function() {
            var scrollParent;
            if (($.ui.ie && (/(static|relative)/).test(this.css('position'))) || (/absolute/).test(this.css('position'))) {
                scrollParent = this.parents().filter(function() {
                    return (/(relative|absolute|fixed)/).test($.css(this, 'position')) && (/(auto|scroll)/).test($.css(this, 'overflow') + $.css(this, 'overflow-y') + $.css(this, 'overflow-x'));
                }).eq(0);
            } else {
                scrollParent = this.parents().filter(function() {
                    return (/(auto|scroll)/).test($.css(this, 'overflow') + $.css(this, 'overflow-y') + $.css(this, 'overflow-x'));
                }).eq(0);
            }

            return (/fixed/).test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;
        },
        /**
         * @method zIndex
         * @param  {number} [zIndex]
         * Get/Set the z-index for an element.
         */
        zIndex: function(zIndex) {
            if (zIndex !== undefined) {
                return this.css("zIndex", zIndex);
            }

            if (this.length) {
                var elem = $(this[0]),
                    position, value;
                while (elem.length && elem[0] !== document) {
                    // Ignore z-index if position is set to a value where z-index is ignored by the browser
                    // This makes behavior of this function consistent across browsers
                    // WebKit always returns auto if the element is positioned
                    position = elem.css("position");
                    if (position === "absolute" || position === "relative" || position === "fixed") {
                        // IE returns 0 when zIndex is not specified
                        // other browsers return a string
                        // we ignore the case of nested elements with an explicit value of 0
                        // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
                        value = parseInt(elem.css("zIndex"), 10);
                        if (!isNaN(value) && value !== 0) {
                            return value;
                        }
                    }
                    elem = elem.parent();
                }
            }

            return 0;
        },
        /**
         * Generate and apply a unique id for the set of matched elements. Start with 'ui-id-'.
         * @method uniqueId
         */
        uniqueId: function() {
            return this.each(function() {
                if (!this.id) {
                    this.id = idPrefix + (++uuid);
                }
            });
        },
        /**
         * Remove ids that were set by .uniqueId() for the set of matched elements.
         * @method removeUniqueId
         */
        removeUniqueId: function() {
            return this.each(function() {
                if (runiqueId.test(this.id)) {
                    $(this).removeAttr("id");
                }
            });
        }
    });

    // selectors
    function focusable(element, isTabIndexNotNaN) {
        var map, mapName, img,
            nodeName = element.nodeName.toLowerCase();
        if ("area" === nodeName) {
            map = element.parentNode;
            mapName = map.name;
            if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
                return false;
            }
            img = $("img[usemap=#" + mapName + "]")[0];
            return !!img && visible(img);
        }
        return (/input|select|textarea|button|object/.test(nodeName) ?
                !element.disabled :
                "a" === nodeName ?
                element.href || isTabIndexNotNaN :
                isTabIndexNotNaN) &&
            // the element and all of its ancestors must be visible
            visible(element);
    }

    function visible(element) {
        return $.expr.filters.visible(element) &&
            !$(element).parents().andSelf().filter(function() {
                return $.css(this, "visibility") === "hidden";
            }).length;
    }

    $.extend($.expr[":"], {
        /**
         * Selects elements which have data stored under the specified key.
         * The expression $( "div:data(foo)") matches a div if it has data stored via .data( "foo", value ).
         * @cfg {selector} data
         * <pre>
         * $(":data(color)").each(function() {
         *	 var element = $( this);
         * 	 element.css("backgroundColor", element.data("color"));
         * });
         * </pre>
         */
        data: $.expr.createPseudo ?
            $.expr.createPseudo(function(dataName) {
                return function(elem) {
                    return !!$.data(elem, dataName);
                };
            }) :
            // support: jQuery <1.8
            function(elem, i, match) {
                return !!$.data(elem, match[3]);
            },
        /**
         * Selects elements which can be focused.
         * Some elements are natively focusable, while others require explictly setting a tab index. In all cases, the element must be visible in order to be focusable.
         * Elements of the following type are focusable if they are not disabled: input, select, textarea, button, and object. Anchors are focusable if they have an href or tabindex attribute. area elements are focusable if they are inside a named map, have an href attribute, and there is a visible image using the map. All other elements are focusable based solely on their tabindex attribute and visibility.
         * Note: Elements with a negative tab index are :focusable, but not :tabbable.
         * @cfg {selector} focusable
         * <pre>
         * 	$(":focusable").css( "border-color", "red" );
         * </pre>
         */
        focusable: function(element) {
            return focusable(element, !isNaN($.attr(element, "tabindex")));
        },
        /**
         * Selects elements which the user can focus via tabbing.
         * Some elements are natively tabbable, while others require explictly setting a positive tab index. In all cases, the element must be visible in order to be tabbable.
         * Elements of the following type are tabbale if they do not have a negative tab index and are not disabled: input, select, textarea, button, and object. Anchors are focusable if they have an href or positive tabindex attribute. area elements are focusable if they are inside a named map, have an href attribute, and there is a visible image using the map. All other elements are tabbable based solely on their tabindex attribute and visibility.
         * Note: Elements with a negative tab index are :focusable, but not :tabbable.
         * @cfg {selector} tabbable
         * <pre>
         * 	$(":tabbable").css( "border-color", "red" );
         * </pre>
         */
        tabbable: function(element) {
            var tabIndex = $.attr(element, "tabindex"),
                isTabIndexNaN = isNaN(tabIndex);
            return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
        }
    });

    // support
    $(function() {
        var body = document.body,
            div = body.appendChild(div = document.createElement("div"));

        // access offsetHeight before setting the style to prevent a layout bug
        // in IE 9 which causes the element to continue to take up space even
        // after it is removed from the DOM (#8026)
        div.offsetHeight;

        $.extend(div.style, {
            minHeight: "100px",
            height: "auto",
            padding: 0,
            borderWidth: 0
        });

        $.support.minHeight = div.offsetHeight === 100;
        $.support.selectstart = "onselectstart" in div;

        // set display to none to avoid a layout bug in IE
        // http://dev.jquery.com/ticket/4014
        body.removeChild(div).style.display = "none";
    });

    /*// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) { 
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}

*/



    // deprecated

    (function() {
        var uaMatch = /msie ([\w.]+)/.exec(navigator.userAgent.toLowerCase()) || [];
        $.ui.ie = uaMatch.length ? true : false;
        $.ui.ie6 = parseFloat(uaMatch[1], 10) === 6;
    })();

    $.fn.extend({
        /**
         * Disable selection of text content within the set of matched elements.
         * @method
         * @returns {jQuery}
         */
        disableSelection: function() {
            return this.bind(($.support.selectstart ? "selectstart" : "mousedown") +
                ".ui-disableSelection",
                function(event) {
                    event.preventDefault();
                });
        },

        /**
         * Enable selection of text content within the set of matched elements.
         * @method
         * @returns {jQuery}
         */
        enableSelection: function() {
            return this.unbind(".ui-disableSelection");
        }
    });

    $.extend($.ui, {
        // $.ui.plugin is deprecated.  Use the proxy pattern instead.
        plugin: {
            add: function(module, option, set) {
                var i,
                    proto = $.ui[module].prototype;
                for (i in set) {
                    proto.plugins[i] = proto.plugins[i] || [];
                    proto.plugins[i].push([option, set[i]]);
                }
            },
            call: function(instance, name, args) {
                var i,
                    set = instance.plugins[name];
                if (!set || !instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11) {
                    return;
                }

                for (i = 0; i < set.length; i++) {
                    if (instance.options[set[i][0]]) {
                        set[i][1].apply(instance.element, args);
                    }
                }
            }
        },

        contains: $.contains,

        // only used by resizable
        hasScroll: function(el, a) {

            //If overflow is hidden, the element might have extra content, but the user wants to hide it
            if ($(el).css("overflow") === "hidden") {
                return false;
            }

            var scroll = (a && a === "left") ? "scrollLeft" : "scrollTop",
                has = false;

            if (el[scroll] > 0) {
                return true;
            }

            // TODO: determine which cases actually cause this to happen
            // if the element doesn't have the scroll set, see if it's possible to
            // set the scroll
            el[scroll] = 1;
            has = (el[scroll] > 0);
            el[scroll] = 0;
            return has;
        },

        // these are odd functions, fix the API or move into individual plugins
        isOverAxis: function(x, reference, size) {
            //Determines when x coordinate is over "b" element axis
            return (x > reference) && (x < (reference + size));
        },
        isOver: function(y, x, top, left, height, width) {
            //Determines when x, y coordinates is over "b" element
            return $.ui.isOverAxis(y, top, height) && $.ui.isOverAxis(x, left, width);
        }
    });

    //2014/9/4 fix position bug in firefox
    $.support.offsetFractions = true;

})(jQuery);

//jQuery UI Widget 1.9.2
/**
 * Widget基类<br>
 * 控件可以继承此基类，以获得公共方法、属性等行为<br>
 * @class fish.desktop.widget.Widget
 * @alternateClassName fish.desktop.widget
 *
 *##Initialization
 *   <pre>
 *     $( "#elem" ).progressbar();
 *   </pre>
 *
 *##Methods
 *   <pre>
 *     $( "#elem" ).progressbar( "value" );
 *   </pre>
 *   注：带下划线'_method'的方法,是私有方法，只能在控件内部使用
 *
 *##Events
 *控件中的事件都可以通过以下两种方式调用
 *  <pre>
 *   $( "#elem" ).bind( "progressbarchange", function() {
 *     alert( "The value has changed!" );
 *  });
 *
 *  //or
 *
 *  $( "#elem" ).progressbar({
 *   change: function() {
 *     alert( "The value has changed!" );
 *    }
 *   });
 *  </pre>
 *
 * 最简单的控件模板
 * <pre>
 * jQuery.widget( name [, base ], prototype )
 *
 * $.widget( "namespace.widgetname", {
 *   options:{},
 *   _create:function(){
 *    ...
 *   },
 *
 *   _method:function(){  //private method
 *      ...
 *   },
 *
 *   methodA:function(){ //public method
 *      ....
 *   },
 *
 *   destory:function(){ // destory method
 *      ...
 *   }
 *
 * });
 *
 * </pre>
 *
 */
(function ($, undefined) {

  var uuid = 0,
      slice = Array.prototype.slice,
      _cleanData = $.cleanData;
// 重写cleanData方法，调用后触发每个元素的remove事件  
  $.cleanData = function (elems) {
    for (var i = 0, elem; (elem = elems[i]) != null; i++) {
      try {
        $(elem).triggerHandler("remove");
        // http://bugs.jquery.com/ticket/8235
      } catch (e) {
      }
    }
    _cleanData(elems);
  };

  $.widget = function (name, base, prototype) {
    var fullName, existingConstructor, constructor, basePrototype,
        namespace = name.split(".")[ 0 ];
    // 比如ui.tabs,上面的name='tabs';fullName='ui-tabs';
    name = name.split(".")[ 1 ];
    fullName = namespace + "-" + name;
    // 如果没有prototype,那么prototype就是第二个参数,这里会把参数补齐,base默认为$.Widget
    // 如果有这第3个参数,表示继承base对象,有base插件提供的基础功能,jQuery.widget( "ui.draggable", $.ui.mouse, {...} )
    if (!prototype) {
      prototype = base;
      base = $.Widget;
    }

    // create selector for plugin
    // 创建一个自定义的伪类选择器,如 $(':ui-tabs') 则表示选择定义了ui-tabs插件的元素
    $.expr[ ":" ][ fullName.toLowerCase() ] = function (elem) {
      return !!$.data(elem, fullName);
    };

    $[ namespace ] = $[ namespace ] || {};//是否有命名空间
    // 这里存一份旧版的插件，如果这个插件已经被使用或者定义了//jquerui1.9支持重定义插件
    existingConstructor = $[ namespace ][ name ];
    constructor = $[ namespace ][ name ] = function (options, element) {
      // 初始化了$.ui.tabs=func
      // allow instantiation without "new" keyword
      // 允许直接调用命名空间上的方法来创建组件
      // 比如：$.ui.tabs({},'#id') 这种方式创建的话，默认没有new 实例化。因为_createWidget是prototype上的方法，需要new关键字来实例化
      // 通过 调用 $.ui.menu 来实例化插件
      if (!this._createWidget) {
        return new constructor(options, element);
      }

      // allow instantiation without initializing for simple inheritance
      // must use "new" keyword (the code above always passes args)
      // 如果存在参数，则说明是正常调用插件
      // _createWidget是创建插件的核心方法
      if (arguments.length) {
        this._createWidget(options, element);
      }
    };
    // extend with the existing constructor to carry over any static properties
    // 合并对象，将旧插件实例，及版本号、prototype合并到constructor
    $.extend(constructor, existingConstructor, {
      version: prototype.version,
      // copy the object used to create the prototype in case we need to
      // redefine the widget later
      // 创建一个新的插件对象,将插件实例暴露给外部，可用户修改及覆盖
      _proto: $.extend({}, prototype),
      // track widgets that inherit from this widget in case this widget is
      // redefined after a widget inherits from it
      _childConstructors: []
    });
    // 实例化父类获取父类的prototype
    basePrototype = new base();//初始化,调用new $.Widget()//继承对象
    // we need to make the options hash a property directly on the new instance
    // otherwise we'll modify the options hash on the prototype that we're
    // inheriting from
    // 初始化options值，深度拷贝
    basePrototype.options = $.widget.extend({}, basePrototype.options);
    //在传入的ui原型中有方法调用this._super 和this.__superApply会调用到base上（最基类上）的方法
    $.each(prototype, function (prop, value) {
      //如果val不是function 则直接给对象赋值字符串??? TODO
      if ($.isFunction(value)) { //对应定义的每一个子属性，如果是方法的话，保留原父方法
        prototype[ prop ] = (function () {
          //两种调用父类函数的方法
          var _super = function () {
                return base.prototype[ prop ].apply(this, arguments);
              },
              _superApply = function (args) {
                return base.prototype[ prop ].apply(this, args);
              };
          return function () {
            var __super = this._super,
                __superApply = this._superApply,
                returnValue;

            this._super = _super;
            this._superApply = _superApply;

            returnValue = value.apply(this, arguments);//防止覆盖父类函数嘛??? TODO 

            this._super = __super;
            this._superApply = __superApply;

            return returnValue;
          };
        })();
      }
    });
    // 给ui.tabs继承父类的所有原型方法和参数
    // 为新的ui模块创建原型，使用深度拷贝，在basePrototype上扩展一些模块基本信息
    constructor.prototype = $.widget.extend(basePrototype, {
      // TODO: remove support for widgetEventPrefix
      // always use the name + a colon as the prefix, e.g., draggable:start
      // don't prefix for widgets that aren't DOM-based
      widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name//事件前缀
      // 组件的事件名前缀，调用_trigger的时候会默认给trigger的事件加上前缀
      // 例如_trigger('create')实际会触发'tabscreate'事件
    }, prototype, {
      constructor: constructor,
      namespace: namespace,
      widgetName: name,
      // TODO remove widgetBaseClass, see #8155
      widgetBaseClass: fullName,
      widgetFullName: fullName
    });

    // If this widget is being redefined then we need to find all widgets that
    // are inheriting from it and redefine all of them so that they inherit from
    // the new version of this widget. We're essentially trying to replace one
    // level in the prototype chain.
    if (existingConstructor) {
      $.each(existingConstructor._childConstructors, function (i, child) {
        var childPrototype = child.prototype;

        // redefine the child widget using the same prototype that was
        // originally used, but inherit from the new version of the base
        $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
      });
      // remove the list of existing child constructors from the old constructor
      // so the old child constructors can be garbage collected
      delete existingConstructor._childConstructors;
    } else {
      base._childConstructors.push(constructor);
    }
    $.widget.bridge(name, constructor);//将此方法挂在jQuery对象上,也就是$('#tab1').tabs();
  };

  $.widget.extend = function (target) {
    var input = slice.call(arguments, 1),
        inputIndex = 0,
        inputLength = input.length,
        key,
        value;
    for (; inputIndex < inputLength; inputIndex++) {
      for (key in input[ inputIndex ]) {
        value = input[ inputIndex ][ key ];
        if (input[ inputIndex ].hasOwnProperty(key) && value !== undefined) {
          // Clone objects
          if ($.isPlainObject(value)) {
            target[ key ] = $.isPlainObject(target[ key ]) ?
              $.widget.extend({}, target[ key ], value) :
              // Don't extend strings, arrays, etc. with objects
              $.widget.extend({}, value);
            // Copy everything else by reference
          } else {
            target[ key ] = value;
          }
        }
      }
    }
    return target;
  };

  $.widget.bridge = function (name, object) {//这里的object就是constructor
    var fullName = object.prototype.widgetFullName || name;
    // 所有初始化方法的入口
    $.fn[ name ] = function (options) {
      var isMethodCall = typeof options === "string",
          args = slice.call(arguments, 1), //第一个参数是callee
          returnValue = this;
      //如果第一个参数是string类型，就认为是调用模块方法
      //剩下的参数作为方法的参数，后面会用到
      // allow multiple hashes to be passed on init
      options = !isMethodCall && args.length ?
        $.widget.extend.apply(null, [ options ].concat(args)) :
        options;
      //可以简单认为是$.extend(true,options,args[0],...),args可以是一个参数或是数组
      if (isMethodCall) { //如果是调用函数
        this.each(function () {
          var methodValue,
              instance = $.data(this, fullName);//得到实例，实例作为一个数据和元素关联上
          if (!instance) {
            return $.error("cannot call methods on " + name + " prior to initialization; " +
              "attempted to call method '" + options + "'");
          }
          //开头带下划线的方法都是私有方法，不让调用
          if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
            return $.error("no such method '" + options + "' for " + name + " widget instance");
          }
          //如果实例和方法均存在，调用方法，把args作为参数传进去instance;//否则返回undefined
          methodValue = instance[ options ].apply(instance, args);
          if (methodValue !== instance && methodValue !== undefined) {
            //如果methodValue不是jquery对象也不是undefined
            returnValue = methodValue && methodValue.jquery ?
              returnValue.pushStack(methodValue.get()) :
              methodValue;
            return false;
          }
        });
      } else { //如果不是函数
        this.each(function () {
          var instance = $.data(this, fullName); //得到实例,实例作为一个数据和元素关联上
          if (instance) { //实例存在
            instance.option(options || {})._init();//调用option函数,一般是设置状态之类的操作;再次调用_init函数，根据options调整
          } else {
            $.data(this, fullName, new object(options, this));
            //没有实例的话，给元素绑定一个实例。注意这里的this是dom，object是模块类
          }
        });
      }

      return returnValue;
    };
  };
//所有模块的基类
  $.Widget = function (/* options, element */) {
  };
  $.Widget._childConstructors = [];

  $.Widget.prototype = {
    widgetName: "widget",
    widgetEventPrefix: "",
    defaultElement: "<div>",
    options: {
      /**
       * @cfg {Boolean} disabled=false Disables the widget if set to true.
       */
      disabled: false,
      /**
       * @cfg {*} hide=null type:Boolean,Number,String,Object
       *      If and how to animate the hiding of the element.<br>
       *      <b>Multiple types supported:</b><br>
       *      <b>Boolean</b>: When set to false, no animation will be used and the element will be hidden immediately. When set to true, the element will fade out with the default duration and the default easing.<br>
       *      <b>Number</b>: The element will fade out with the specified duration and the default easing.<br>
       *      <b>String</b>: The element will be hidden using the specified effect. The value can either be the name of a built-in jQuery animateion method, such as "slideUp", or the name of a jQuery UI effect, such as "fold". In either case the effect will be used with the default duration and the default easing.<br>
       *      <b>Object</b>: If the value is an object, then effect, duration, and easing properties may be provided. If the effect property contains the name of a jQuery method, then that method will be used; otherwise it is assumed to be the name of a jQuery UI effect. When using a jQuery UI effect that supports additional settings, you may include those settings in the object and they will be passed to the effect. If duration or easing is omitted, then the default values will be used. If effect is omitted, then "fadeOut" will be used.<br>
       *
       *
       *   <pre>
       *   $( ".selector" ).widget({ hide: { effect: "explode", duration: 1000 } });
       *
       *   // getter
       *   var hide = $( ".selector" ).widget( "option", "hide" );
       *   // setter
       *   $( ".selector" ).widget( "option", "hide", { effect: "explode", duration: 1000 } );
       *  </pre>
       */
      //hide
      /**
       * @cfg {*} show=null type:Boolean,Number,String,Object
       * If and how to animate the showing of the element.<br/>
       * <b>Multiple types supported:</b><br/>
       * <b>Boolean</b>: When set to false, no animation will be used and the element will be shown immediately. When set to true, the element will fade in with the default duration and the default easing.<br/>
       * <b>Number</b>: The element will fade in with the specified duration and the default easing.<br/>
       * <b>String</b>: The element will be shown using the specified effect. The value can either be the name of a built-in jQuery animateion method, such as "slideDown", or the name of a jQuery UI effect, such as "fold". In either case the effect will be used with the default duration and the default easing.<br/>
       * <b>Object</b>: If the value is an object, then effect, duration, and easing properties may be provided. If the effect property contains the name of a jQuery method, then that method will be used; otherwise it is assumed to be the name of a jQuery UI effect. When using a jQuery UI effect that supports additional settings, you may include those settings in the object and they will be passed to the effect. If duration or easing is omitted, then the default values will be used. If effect is omitted, then "fadeIn" will be used.<br/>
       *
       * <pre>
       *   $( ".selector" ).widget({ show: { effect: "blind", duration: 800 } });
       *   //or
       *
       *  // getter
       *  var show = $( ".selector" ).widget( "option", "show" );
       *   // setter
       *  $( ".selector" ).widget( "option", "show", { effect: "blind", duration: 800 } );
       * </pre>
       */
      //show


      // callbacks
      /**
       * Triggered when the widget is created.
       * @event create
       * @param {Event} event event
       * @param {Object} ui The ui object is empty but included for consistency with other events.
       */
      create: null
    },//上面的属性会在创建模块时被覆盖;不能重写
    _createWidget: function (options, element) {
      element = $(element || this.defaultElement || this)[ 0 ];
      this.element = $(element);
      this.uuid = uuid++;
      this.eventNamespace = "." + this.widgetName + this.uuid;
      this.options = $.widget.extend({}, //参数处理
        this.options,
        this._getCreateOptions(),
        options);

      this.bindings = $();
      this.hoverable = $();
      this.focusable = $();

      if (element !== this) {
        // 1.9 BC for #7810
        // TODO remove dual storage
        $.data(element, this.widgetName, this); //缓存实例，保存jquery对象
        $.data(element, this.widgetFullName, this);
        this._on(true, this.element, {
          remove: function (event) {
            if (event.target === element) {
              this.destroy();
            }
          }
        });
        this.document = $(element.style ?
          // element within the document
          element.ownerDocument :
          // element is window or document
          element.document || element);
        this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
      }
            this._create(); //创建
      // 如果绑定了初始化的回调函数，会在这里触发。注意绑定的事件名是需要加上前缀的，如$('#tab1').bind('tabscreate',function(){});
      this._trigger("create", null, this._getCreateEventData());
      //2014/9/30 init UI的样式控制
      $(element).removeClass('init');
      //
      this._init();//初始化
      this._formSupport();//增加对form的支持
      this._validateHandler();//增加对校验控件的支持
    },

    _getCreateOptions: $.noop,
    _getCreateEventData: $.noop,
    _create: $.noop,
    _init: $.noop,
    _formHandler:$.noop,
    _validateHandler:$.noop,
    _formSupport : function(){
      var that = this, $element = this.element , $form;
      if($element.is("form")) return ;
      $form = $element.closest('form');
      if(!$form[0]) return ;
      $.data(this.element[0], "uuid", this);
      //保存实例对象到element元素上,在form插件中使用到,便于form获取到element后能取到实例对象进行控件操作
      $form.on('reset.form', function(e) {
          setTimeout(function() { //先执行form默认的reset行为
              that._update && that._update();
          }, 0)
      }).on('clear.form', function(e) {
          that._update && that._update(null);
      }).on('setvalue' + this.uuid+'.form', function(e, value) {
          that._update && that._update(value);
      }).on('disable.form', function(e) {
          that.disable();
      }).on('enable.form', function(e) {
          that.enable();
      });
      this._formHandler($form);
    },
    _getValidFlag:function(){
        var el = this.element[0],
          wrap = el.form || $(el).closest('.ui-validator');
        return $(wrap).attr('novalidate')==='novalidate';
    },
    /**
     * Removes the widget functionality completely. This will return the element back to its pre-init state.
     * @method
     * @return jQuery(Plugin Only)
     */
    destroy: function () { //销毁模块：去除绑定事件、去除数据、去除样式、属性
      this._destroy();
      // we can probably remove the unbind calls in 2.0
      // all event bindings should go through this._on()
      this.element
        .unbind(this.eventNamespace)
        // 1.9 BC for #7810
        // TODO remove dual storage
        .removeData(this.widgetName)//删除在create时保存的数据,下次就会重新实例化了
        .removeData(this.widgetFullName);
        // support: jquery <1.6.3
        // http://bugs.jquery.com/ticket/9413
        // .removeData($.camelCase(this.widgetFullName));
      this.widget()
        .unbind(this.eventNamespace)
        .removeAttr("aria-disabled")
        .removeClass(
          this.widgetFullName + "-disabled " +
          "ui-state-disabled");

      // clean up events and states
      this.bindings.unbind(this.eventNamespace);
      this.hoverable.removeClass("ui-state-hover");
      this.focusable.removeClass("ui-state-focus");
    },

    /*需要注意的是，destroy方法在jquery.ui.widget.js中是有默认实现的，而_create和_init没有实现。因此如果用自己的方法覆盖destroy，不要忘记调用默认的：

     destory: function () {
     console.log('destory');
     // call the original destroy method since we overwrote it
     $.Widget.prototype.destroy.call(this);
     }*/
// 重写_setOption函数，也要加上$.Widget.prototype._setOption.apply(this, arguments);
    /*_create: 生成HTML，事件绑定。

     _init: 执行默认的初始化动作，例如把页面变成初始状态。

     destory: 调用$.Widget.prototype.destroy.call(this)，删除HTML*/

    _destroy: $.noop,

    /**
     * Returns a jQuery object containing the original element or other relevant generated element.
     * @method
     * @returns {jQuery}
     */
    widget: function () { //返回jquery对象
      return this.element;
    },

    /**
     * Sets the value of the widget option associated with the specified optionName.<br>
     * <b>no arguments</b>: Gets an object containing key/value pairs representing the current options hash.<br>
     * <b>one string arguments</b>: Gets the value currently associated with the specified optionName.<br>
     * <b>two string arguments</b>: Sets the value of the option associated with the specified optionName.<br>
     * <b>one object arguments</b>: Sets one or more options.<br>

     * @method option
     * @param {String} [key] The name of the option to set.
     * @param {Object} [value] A value to set for the option.
     * @return {jQuery}
     */
    option: function (key, value) { //设置选项函数
      var options = key,
          parts,
          curOption,
          i;

      if (arguments.length === 0) { //返回一个新的对象，不是内部数据的引用
        // don't return a reference to the internal hash
        return $.widget.extend({}, this.options);
      }

      if (typeof key === "string") {
        // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
        options = {};
        parts = key.split(".");
        key = parts.shift();
        if (parts.length) {
          curOption = options[ key ] = $.widget.extend({}, this.options[ key ]);
          for (i = 0; i < parts.length - 1; i++) {
            curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
            curOption = curOption[ parts[ i ] ];
          }
          key = parts.pop();
          if (value === undefined) { //取值
            return curOption[ key ] === undefined ? null : curOption[ key ];
          }
          curOption[ key ] = value; //设置值
        } else {
          if (value === undefined) {//取值
            return this.options[ key ] === undefined ? null : this.options[ key ];
          }
          options[ key ] = value;//设置值
        }
      }
      //调用内部的_setOption
      this._setOptions(options);

      return this;
    },
    _setOptions: function (options) {
      var key;

      for (key in options) {
        this._setOption(key, options[ key ]);
      }

      return this;
    },
    _setOption: function (key, value) {
      this.options[ key ] = value;

      if (key === "disabled") { //增加或是去除className
        this.widget()
          .toggleClass(this.widgetFullName + "-disabled ui-state-disabled", !!value)
          .attr("aria-disabled", value);
        this.hoverable.removeClass("ui-state-hover");
        this.focusable.removeClass("ui-state-focus");
      }

      return this;
    },

    /**
     * Enables the widget.
     * @method
     * @returns {jQuery}
     */
    enable: function () {
      return this._setOption("disabled", false);
    },

    /**
     * Disables the widget.
     * @method
     * @returns {jQuery}
     */
    disable: function () {
      return this._setOption("disabled", true);
    },

    _on: function (suppressDisabledCheck, element, handlers) {
      var delegateElement,
          instance = this;

      // no suppressDisabledCheck flag, shuffle arguments
      if (typeof suppressDisabledCheck !== "boolean") {
        handlers = element;
        element = suppressDisabledCheck;
        suppressDisabledCheck = false;
      }

      // no element argument, shuffle and use this.element
      if (!handlers) {//就只有一个handlers,也就是说element就是handlers了
        handlers = element;
        element = this.element;
        delegateElement = this.widget();
      } else {
        // accept selectors, DOM elements
        element = delegateElement = $(element);
        this.bindings = this.bindings.add(element);
      }

      $.each(handlers, function (event, handler) {
        function handlerProxy() {
          // allow widgets to customize the disabled handling
          // - disabled as an array instead of boolean
          // - disabled class as method for disabling individual parts
          if (!suppressDisabledCheck &&
            ( instance.options.disabled === true ||
              $(this).hasClass("ui-state-disabled") )) {
            return;
          }
          return ( typeof handler === "string" ? instance[ handler ] : handler )
            .apply(instance, arguments);
        }

        // copy the guid so direct unbinding works
        if (typeof handler !== "string") {
          handlerProxy.guid = handler.guid =
            handler.guid || handlerProxy.guid || $.guid++;
        }

        var match = event.match(/^(\w+)\s*(.*)$/),
            eventName = match[1] + instance.eventNamespace,
            selector = match[2];
        if (selector) {
          delegateElement.delegate(selector, eventName, handlerProxy);
        } else {
          element.bind(eventName, handlerProxy);
        }
      });
    },

    _off: function (element, eventName) {
      eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
      element.unbind(eventName).undelegate(eventName);
    },

    _delay: function (handler, delay) {
      function handlerProxy() {
        return ( typeof handler === "string" ? instance[ handler ] : handler )
          .apply(instance, arguments);
      }

      var instance = this;
      return setTimeout(handlerProxy, delay || 0);
    },

    _hoverable: function (element) {
      this.hoverable = this.hoverable.add(element);
      this._on(element, {
        mouseenter: function (event) {
          $(event.currentTarget).addClass("ui-state-hover");
        },
        mouseleave: function (event) {
          $(event.currentTarget).removeClass("ui-state-hover");
        }
      });
    },

    _focusable: function (element) {
      this.focusable = this.focusable.add(element);
      this._on(element, {
        focusin: function (event) {
          $(event.currentTarget).addClass("ui-state-focus");
        },
        focusout: function (event) {
          $(event.currentTarget).removeClass("ui-state-focus");
        }
      });
    },
    // $.widget中优化过的trigger方法。可以同时调用config中的方法和bind的方法。
    // 即可以用两个方式去给组件绑定事件。如$("tabs").tabs({"change":function(){//handler}});或者$("tabs").bind("tabschange",function(){//handler});  
    _trigger: function (type, event, data) {
      // 调用初始化配置config中的回调方法
      var prop, orig,
          callback = this.options[ type ];

      data = data || {};
      // 封装js标准event对象为jquery的Event对象
      event = $.Event(event);
      // 给事件名称加上前缀，前缀默认是组件的名字。如_trigger("change")实际会触发"tabschange"事件
      event.type = ( type === this.widgetEventPrefix ?
        type :
        this.widgetEventPrefix + type ).toLowerCase();
      // the original event may come from any element
      // so we need to reset the target on the new event
      event.target = this.element[ 0 ];

      // copy original event properties over to the new event
      orig = event.originalEvent;
      if (orig) {//把原始的event属性重新赋到event变量上
        for (prop in orig) {
          if (!( prop in event )) {
            event[ prop ] = orig[ prop ];
          }
        }
      }
      // 触发element中绑定的事件
      this.element.trigger(event, data);
      return !( $.isFunction(callback) &&
        callback.apply(this.element[0], [ event ].concat(data)) === false ||
        event.isDefaultPrevented() );
    }
  };

  $.each({ show: "fadeIn", hide: "fadeOut" }, function (method, defaultEffect) {
    $.Widget.prototype[ "_" + method ] = function (element, options, callback) {
      if (typeof options === "string") {
        options = { effect: options };
      }
      var hasOptions,
          effectName = !options ?
            method :
              options === true || typeof options === "number" ?
            defaultEffect :
            options.effect || defaultEffect;
      options = options || {};
      if (typeof options === "number") {
        options = { duration: options };
      }
      hasOptions = !$.isEmptyObject(options);
      options.complete = callback;
      if (options.delay) {
        element.delay(options.delay);
      }
      if (hasOptions && $.effects && ( $.effects.effect[ effectName ] || $.uiBackCompat !== false && $.effects[ effectName ] )) {
        element[ method ](options);
      } else if (effectName !== method && element[ effectName ]) {
        element[ effectName ](options.duration, options.easing, callback);
      } else {
        element.queue(function (next) {
          $(this)[ method ]();
          if (callback) {
            callback.call(element[ 0 ]);
          }
          next();
        });
      }
    };
  });

// DEPRECATED
  if ($.uiBackCompat !== false) {
    $.Widget.prototype._getCreateOptions = function () {
      return $.metadata && $.metadata.get(this.element[0])[ this.widgetName ];
    };
  }

})(jQuery);

/*!
 * jQuery UI Mouse 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 *
 * Depends:
 *	jquery.ui.widget.js
 */


/**
 * Similar to jQuery.Widget, the mouse interaction is not intended to be used directly. <br>
 * It is purely a base layer for other widgets to inherit from. <br>
 * This page only documents what is added to jQuery.Widget, but it does include internal methods that are not intended to be overwritten.<br>
 * The intended public API is _mouseStart(), _mouseDrag(), _mouseStop(), and _mouseCapture().<br>
 *
 * @class fish.desktop.widget.Mouse
 * @alternateClassName desktop.widget.Mouse
 * @extends fish.desktop.widget
 */
(function ($, undefined) {

  var mouseHandled = false;
  $(document).mouseup(function (e) {
    mouseHandled = false;
  });

  $.widget("ui.mouse", {
    version: "1.9.2",
    options: {
      /**
       * @cfg {Selector} cancel='input,textarea,button,select,option' Prevents interactions from starting on specified elements.
       */
      cancel: 'input,textarea,button,select,option',
      /**
       * @cfg {Number} distance=1
       * Distance in pixels after mousedown the mouse must move before the interaction should start.<br/>
       * This option can be used to prevent unwanted interactions when clicking on an element.
       */
      distance: 1,
      /**
       * @cfg {Number} delay=0
       * Time in milliseconds after mousedown until the interaction should start.<br/>
       * This option can be used to prevent unwanted interactions when clicking on an element.
       */
      delay: 0
    },
    _mouseInit: function () {
      var that = this;

      this.element
        .bind('mousedown.' + this.widgetName, function (event) {
          return that._mouseDown(event);
        })
        .bind('click.' + this.widgetName, function (event) {
          if (true === $.data(event.target, that.widgetName + '.preventClickEvent')) {
            $.removeData(event.target, that.widgetName + '.preventClickEvent');
            event.stopImmediatePropagation();
            return false;
          }
        });

      this.started = false;
    },

    // TODO: make sure destroying one instance of mouse doesn't mess with
    // other instances of mouse
    _mouseDestroy: function () {
      this.element.unbind('.' + this.widgetName);
      if (this._mouseMoveDelegate) {
        $(document)
          .unbind('mousemove.' + this.widgetName, this._mouseMoveDelegate)
          .unbind('mouseup.' + this.widgetName, this._mouseUpDelegate);
      }
    },

    _mouseDown: function (event) {
      // don't let more than one widget handle mouseStart
      if (mouseHandled) {
        return;
      }

      // we may have missed mouseup (out of window)
      (this._mouseStarted && this._mouseUp(event));

      this._mouseDownEvent = event;

      var that = this,
          btnIsLeft = (event.which === 1),
          // event.target.nodeName works around a bug in IE 8 with
          // disabled inputs (#7620)
          elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
      if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
        return true;
      }

      this.mouseDelayMet = !this.options.delay;
      if (!this.mouseDelayMet) {
        this._mouseDelayTimer = setTimeout(function () {
          that.mouseDelayMet = true;
        }, this.options.delay);
      }

      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted = (this._mouseStart(event) !== false);
        if (!this._mouseStarted) {
          event.preventDefault();
          return true;
        }
      }

      // Click event may never have fired (Gecko & Opera)
      if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
        $.removeData(event.target, this.widgetName + '.preventClickEvent');
      }

      // these delegates are required to keep context
      this._mouseMoveDelegate = function (event) {
        return that._mouseMove(event);
      };
      this._mouseUpDelegate = function (event) {
        return that._mouseUp(event);
      };
      $(document)
        .bind('mousemove.' + this.widgetName, this._mouseMoveDelegate)
        .bind('mouseup.' + this.widgetName, this._mouseUpDelegate);

      event.preventDefault();

      mouseHandled = true;
      return true;
    },

    _mouseMove: function (event) {
      // IE mouseup check - mouseup happened when mouse was out of window
      if ($.ui.ie && !(document.documentMode >= 9) && !event.button) {
        return this._mouseUp(event);
      }

      if (this._mouseStarted) {
        this._mouseDrag(event);
        return event.preventDefault();
      }

      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted =
          (this._mouseStart(this._mouseDownEvent, event) !== false);
        (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
      }

      return !this._mouseStarted;
    },

    _mouseUp: function (event) {
      $(document)
        .unbind('mousemove.' + this.widgetName, this._mouseMoveDelegate)
        .unbind('mouseup.' + this.widgetName, this._mouseUpDelegate);

      if (this._mouseStarted) {
        this._mouseStarted = false;

        if (event.target === this._mouseDownEvent.target) {
          $.data(event.target, this.widgetName + '.preventClickEvent', true);
        }

        this._mouseStop(event);
      }

      return false;
    },

    _mouseDistanceMet: function (event) {
      return (Math.max(
        Math.abs(this._mouseDownEvent.pageX - event.pageX),
        Math.abs(this._mouseDownEvent.pageY - event.pageY)
      ) >= this.options.distance
        );
    },

    _mouseDelayMet: function (event) {
      return this.mouseDelayMet;
    },

    // These are placeholder methods, to be overriden by extending plugin
    /**
     * The extending widget should implement a _mouseStart() method to handle the beginning of an interaction.<br>
     * This method will receive the mouse event associated with the start of the interaction.
     * @param {Event} event event
     * @return {jQuery}
     */
    _mouseStart: function (event) {
    },
    /**
     * The extending widget should implement a _mouseDrag() method to handle each movement of an interaction.<br>
     * This method will receive the mouse event associated with the movement.
     * @param {Event} event event
     * @return {jQuery}
     */
    _mouseDrag: function (event) {
    },
    /**
     * The extending widget should implement a _mouseStop() method to handle the end of an interaction.<br>
     * This method will receive the mouse event associated with the end of the interaction.
     * @param {Event} event event
     * @return {jQuery}
     */
    _mouseStop: function (event) {
    },
    /**
     * Determines whether an interaction should start based on event target of the interaction.<br>
     * The default implementation always returns true.
     * @param {Event} event event
     * @return {Boolean}
     */
    _mouseCapture: function (event) {
      return true;
    }
  });

})(jQuery);

// jQuery UI Position 1.9.2

/**
 * The jQuery UI .position() method allows you to position an element relative to the window, document, another element, or the cursor/mouse, without worrying about offset parents.<br/>
 *
 * <pre>
 *   $('selector').position({
 *      my: "center top",
 *      at: "center bottom",
 *      collision: "flipfit flip"
 *   });
 *</pre>
 * <a href="http://jqueryui.com/position/" title='Live Demo' target='_blank'>Demo</a>
 * @class fish.desktop.uicore.Position
 */
(function ($, undefined) {

  $.ui = $.ui || {};

  var cachedScrollbarWidth,
      max = Math.max,
      abs = Math.abs,
      round = Math.round,
      rhorizontal = /left|center|right/,
      rvertical = /top|center|bottom/,
      roffset = /[\+\-]\d+%?/,
      rposition = /^\w+/,
      rpercent = /%$/,
      _position = $.fn.position;

  function getOffsets(offsets, width, height) {
    return [
        parseInt(offsets[ 0 ], 10) * ( rpercent.test(offsets[ 0 ]) ? width / 100 : 1 ),
        parseInt(offsets[ 1 ], 10) * ( rpercent.test(offsets[ 1 ]) ? height / 100 : 1 )
    ];
  }

  function parseCss(element, property) {
    return parseInt($.css(element, property), 10) || 0;
  }

  $.position = {
    scrollbarWidth: function () {
      if (cachedScrollbarWidth !== undefined) {
        return cachedScrollbarWidth;
      }
      var w1, w2,
          div = $("<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
          innerDiv = div.children()[0];

      $("body").append(div);
      w1 = innerDiv.offsetWidth;
      div.css("overflow", "scroll");

      w2 = innerDiv.offsetWidth;

      if (w1 === w2) {
        w2 = div[0].clientWidth;
      }

      div.remove();

      return (cachedScrollbarWidth = w1 - w2);
    },
    getScrollInfo: function (within) {
      var overflowX = within.isWindow ? "" : within.element.css("overflow-x"),
          overflowY = within.isWindow ? "" : within.element.css("overflow-y"),
          hasOverflowX = overflowX === "scroll" ||
            ( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
          hasOverflowY = overflowY === "scroll" ||
            ( overflowY === "auto" && within.height < within.element[0].scrollHeight );
      return {
        width: hasOverflowX ? $.position.scrollbarWidth() : 0,
        height: hasOverflowY ? $.position.scrollbarWidth() : 0
      };
    },
    getWithinInfo: function (element) {
      var withinElement = $(element || window),
          isWindow = $.isWindow(withinElement[0]);
      return {
        element: withinElement,
        isWindow: isWindow,
        offset: withinElement.offset() || { left: 0, top: 0 },
        scrollLeft: withinElement.scrollLeft(),
        scrollTop: withinElement.scrollTop(),
        width: isWindow ? withinElement.width() : withinElement.outerWidth(),
        height: isWindow ? withinElement.height() : withinElement.outerHeight()
      };
    }
  };

  /**
   *  Position an element relative to another.
   * @method
   * @param {Object} options options
   * @param {String} options.my=center
   *        Defines which position on the element being positioned to align with the target element: "horizontal vertical" alignment.
   *        A single value such as "right" will be normalized to "right center", "top" will be normalized to "center top"
   *        (following CSS convention). Acceptable horizontal values: "left", "center", "right". Acceptable vertical
   *        values: "top", "center", "bottom". Example: "left top" or "center center". Each dimension can also contain offsets,
   *        in pixels or percent, e.g., "right+10 top-25%". Percentage offsets are relative to the element being positioned.
   *
   * @param {String} options.at=center
   *    Defines which position on the target element to align the positioned element against: "horizontal vertical" alignment.
   *    See the my option for full details on possible values. Percentage offsets are relative to the target element.
   *
   * @param {*} options.of=null
   *  Type:Selector, Element, jQuery, Event<br>
   *   Which element to position against. If you provide a selector or jQuery object,
   *   the first matching element will be used. If you provide an event object, the pageX and pageY properties will be used. Example: "#top-menu"
   *
   * @param {String} options.collision='flip'
   *  When the positioned element overflows the window in some direction, move it to an alternative position. Similar to my and at, this accepts a single value or a pair for horizontal/vertical, e.g., "flip", "fit", "fit flip", "fit none".<br>
   *  <b>"flip"</b>: Flips the element to the opposite side of the target and the collision detection is run again to see if it will fit. Whichever side allows more of the element to be visible will be used.<br>
   *  <b>"fit"</b>: Shift the element away from the edge of the window.<br>
   *  <b>"flipfit"</b>: First applies the flip logic, placing the element on whichever side allows more of the element to be visible. Then the fit logic is applied to ensure as much of the element is visible as possible.<br>
   *  <b>"none"</b>: Does not apply any collision detection.<br>
   *
   * @param {Function} options.using=null
   *    When specified, the actual property setting is delegated to this callback. Receives two parameters:<br/>
   *    The first is a hash of top and left values for the position that should be set and can be forwarded to .css() or
   *    .animate().<br/>
   *    The second provides feedback about the position and dimensions of both elements, as well as calculations to
   *    their relative position. Both target and element have these properties: element, left, top, width, height.
   *    In addition, there's horizontal, vertical and important, giving you twelve potential directions like
   *    { horizontal: "center", vertical: "left", important: "horizontal" }.<br/>
   *
   * @param {*} options.within
   * Type:Selector, Element, jQuery<br>
   * Element to position within, affecting collision detection.
   * If you provide a selector or jQuery object, the first matching element will be used.
   *
   */
  $.fn.position = function (options) {
    if (!options || !options.of) {
      return _position.apply(this, arguments);
    }

    // make a copy, we don't want to modify arguments
    options = $.extend({}, options);

    var atOffset, targetWidth, targetHeight, targetOffset, basePosition,
        target = $(options.of),
        within = $.position.getWithinInfo(options.within),
        scrollInfo = $.position.getScrollInfo(within),
        targetElem = target[0],
        collision = ( options.collision || "flip" ).split(" "),
        offsets = {};

    if (targetElem.nodeType === 9) {
      targetWidth = target.width();
      targetHeight = target.height();
      targetOffset = { top: 0, left: 0 };
    } else if ($.isWindow(targetElem)) {
      targetWidth = target.width();
      targetHeight = target.height();
      targetOffset = { top: target.scrollTop(), left: target.scrollLeft() };
    } else if (targetElem.preventDefault) {
      // force left top to allow flipping
      options.at = "left top";
      targetWidth = targetHeight = 0;
      targetOffset = { top: targetElem.pageY, left: targetElem.pageX };
    } else {
      targetWidth = target.outerWidth();
      targetHeight = target.outerHeight();
      targetOffset = target.offset();
    }
    // clone to reuse original targetOffset later
    basePosition = $.extend({}, targetOffset);

    // force my and at to have valid horizontal and vertical positions
    // if a value is missing or invalid, it will be converted to center
    $.each([ "my", "at" ], function () {
      var pos = ( options[ this ] || "" ).split(" "),
          horizontalOffset,
          verticalOffset;

      if (pos.length === 1) {
        pos = rhorizontal.test(pos[ 0 ]) ?
          pos.concat([ "center" ]) :
          rvertical.test(pos[ 0 ]) ?
            [ "center" ].concat(pos) :
            [ "center", "center" ];
      }
      pos[ 0 ] = rhorizontal.test(pos[ 0 ]) ? pos[ 0 ] : "center";
      pos[ 1 ] = rvertical.test(pos[ 1 ]) ? pos[ 1 ] : "center";

      // calculate offsets
      horizontalOffset = roffset.exec(pos[ 0 ]);
      verticalOffset = roffset.exec(pos[ 1 ]);
      offsets[ this ] = [
        horizontalOffset ? horizontalOffset[ 0 ] : 0,
        verticalOffset ? verticalOffset[ 0 ] : 0
      ];

      // reduce to just the positions without the offsets
      options[ this ] = [
        rposition.exec(pos[ 0 ])[ 0 ],
        rposition.exec(pos[ 1 ])[ 0 ]
      ];
    });

    // normalize collision option
    if (collision.length === 1) {
      collision[ 1 ] = collision[ 0 ];
    }

    if (options.at[ 0 ] === "right") {
      basePosition.left += targetWidth;
    } else if (options.at[ 0 ] === "center") {
      basePosition.left += targetWidth / 2;
    }

    if (options.at[ 1 ] === "bottom") {
      basePosition.top += targetHeight;
    } else if (options.at[ 1 ] === "center") {
      basePosition.top += targetHeight / 2;
    }

    atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
    basePosition.left += atOffset[ 0 ];
    basePosition.top += atOffset[ 1 ];

    return this.each(function () {
      var collisionPosition, using,
          elem = $(this),
          elemWidth = elem.outerWidth(),
          elemHeight = elem.outerHeight(),
          marginLeft = parseCss(this, "marginLeft"),
          marginTop = parseCss(this, "marginTop"),
          collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width,
          collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height,
          position = $.extend({}, basePosition),
          myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());

      if (options.my[ 0 ] === "right") {
        position.left -= elemWidth;
      } else if (options.my[ 0 ] === "center") {
        position.left -= elemWidth / 2;
      }

      if (options.my[ 1 ] === "bottom") {
        position.top -= elemHeight;
      } else if (options.my[ 1 ] === "center") {
        position.top -= elemHeight / 2;
      }

      position.left += myOffset[ 0 ];
      position.top += myOffset[ 1 ];

      // if the browser doesn't support fractions, then round for consistent results
      if (!$.support.offsetFractions) {
        position.left = round(position.left);
        position.top = round(position.top);
      }

      collisionPosition = {
        marginLeft: marginLeft,
        marginTop: marginTop
      };

      $.each([ "left", "top" ], function (i, dir) {
        if ($.ui.position[ collision[ i ] ]) {
          $.ui.position[ collision[ i ] ][ dir ](position, {
            targetWidth: targetWidth,
            targetHeight: targetHeight,
            elemWidth: elemWidth,
            elemHeight: elemHeight,
            collisionPosition: collisionPosition,
            collisionWidth: collisionWidth,
            collisionHeight: collisionHeight,
            offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
            my: options.my,
            at: options.at,
            within: within,
            elem: elem
          });
        }
      });

      if ($.fn.bgiframe) {
        elem.bgiframe();
      }

      if (options.using) {
        // adds feedback as second argument to using callback, if present
        using = function (props) {
          var left = targetOffset.left - position.left,
              right = left + targetWidth - elemWidth,
              top = targetOffset.top - position.top,
              bottom = top + targetHeight - elemHeight,
              feedback = {
                target: {
                  element: target,
                  left: targetOffset.left,
                  top: targetOffset.top,
                  width: targetWidth,
                  height: targetHeight
                },
                element: {
                  element: elem,
                  left: position.left,
                  top: position.top,
                  width: elemWidth,
                  height: elemHeight
                },
                horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
              };
          if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
            feedback.horizontal = "center";
          }
          if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
            feedback.vertical = "middle";
          }
          if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
            feedback.important = "horizontal";
          } else {
            feedback.important = "vertical";
          }
          options.using.call(this, props, feedback);
        };
      }

      elem.offset($.extend(position, { using: using }));
    });
  };

  $.ui.position = {
    fit: {
      left: function (position, data) {
        var within = data.within,
            withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
            outerWidth = within.width,
            collisionPosLeft = position.left - data.collisionPosition.marginLeft,
            overLeft = withinOffset - collisionPosLeft,
            overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
            newOverRight;

        // element is wider than within
        if (data.collisionWidth > outerWidth) {
          // element is initially over the left side of within
          if (overLeft > 0 && overRight <= 0) {
            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
            position.left += overLeft - newOverRight;
            // element is initially over right side of within
          } else if (overRight > 0 && overLeft <= 0) {
            position.left = withinOffset;
            // element is initially over both left and right sides of within
          } else {
            if (overLeft > overRight) {
              position.left = withinOffset + outerWidth - data.collisionWidth;
            } else {
              position.left = withinOffset;
            }
          }
          // too far left -> align with left edge
        } else if (overLeft > 0) {
          position.left += overLeft;
          // too far right -> align with right edge
        } else if (overRight > 0) {
          position.left -= overRight;
          // adjust based on position and margin
        } else {
          position.left = max(position.left - collisionPosLeft, position.left);
        }
      },
      top: function (position, data) {
        var within = data.within,
            withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
            outerHeight = data.within.height,
            collisionPosTop = position.top - data.collisionPosition.marginTop,
            overTop = withinOffset - collisionPosTop,
            overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
            newOverBottom;

        // element is taller than within
        if (data.collisionHeight > outerHeight) {
          // element is initially over the top of within
          if (overTop > 0 && overBottom <= 0) {
            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
            position.top += overTop - newOverBottom;
            // element is initially over bottom of within
          } else if (overBottom > 0 && overTop <= 0) {
            position.top = withinOffset;
            // element is initially over both top and bottom of within
          } else {
            if (overTop > overBottom) {
              position.top = withinOffset + outerHeight - data.collisionHeight;
            } else {
              position.top = withinOffset;
            }
          }
          // too far up -> align with top
        } else if (overTop > 0) {
          position.top += overTop;
          // too far down -> align with bottom edge
        } else if (overBottom > 0) {
          position.top -= overBottom;
          // adjust based on position and margin
        } else {
          position.top = max(position.top - collisionPosTop, position.top);
        }
      }
    },
    flip: {
      left: function (position, data) {
        var within = data.within,
            withinOffset = within.offset.left + within.scrollLeft,
            outerWidth = within.width,
            offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
            collisionPosLeft = position.left - data.collisionPosition.marginLeft,
            overLeft = collisionPosLeft - offsetLeft,
            overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
            myOffset = data.my[ 0 ] === "left" ?
              -data.elemWidth :
                data.my[ 0 ] === "right" ?
              data.elemWidth :
              0,
            atOffset = data.at[ 0 ] === "left" ?
              data.targetWidth :
                data.at[ 0 ] === "right" ?
              -data.targetWidth :
              0,
            offset = -2 * data.offset[ 0 ],
            newOverRight,
            newOverLeft;

        if (overLeft < 0) {
          newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
          if (newOverRight < 0 || newOverRight < abs(overLeft)) {
            position.left += myOffset + atOffset + offset;
          }
        }
        else if (overRight > 0) {
          newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
          if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
            position.left += myOffset + atOffset + offset;
          }
        }
      },
      top: function (position, data) {
        var within = data.within,
            withinOffset = within.offset.top + within.scrollTop,
            outerHeight = within.height,
            offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
            collisionPosTop = position.top - data.collisionPosition.marginTop,
            overTop = collisionPosTop - offsetTop,
            overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
            top = data.my[ 1 ] === "top",
            myOffset = top ?
              -data.elemHeight :
                data.my[ 1 ] === "bottom" ?
              data.elemHeight :
              0,
            atOffset = data.at[ 1 ] === "top" ?
              data.targetHeight :
                data.at[ 1 ] === "bottom" ?
              -data.targetHeight :
              0,
            offset = -2 * data.offset[ 1 ],
            newOverTop,
            newOverBottom;
        if (overTop < 0) {
          newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
          if (( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs(overTop) )) {
            position.top += myOffset + atOffset + offset;
          }
        }
        else if (overBottom > 0) {
          newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
          if (( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs(newOverTop) < overBottom )) {
            position.top += myOffset + atOffset + offset;
          }
        }
      }
    },
    flipfit: {
      left: function () {
        $.ui.position.flip.left.apply(this, arguments);
        $.ui.position.fit.left.apply(this, arguments);
      },
      top: function () {
        $.ui.position.flip.top.apply(this, arguments);
        $.ui.position.fit.top.apply(this, arguments);
      }
    }
  };

// fraction support test
  (function () {
    var testElement, testElementParent, testElementStyle, offsetLeft, i,
        body = document.getElementsByTagName("body")[ 0 ],
        div = document.createElement("div");

    //Create a "fake body" for testing based on method used in jQuery.support
    testElement = document.createElement(body ? "div" : "body");
    testElementStyle = {
      visibility: "hidden",
      width: 0,
      height: 0,
      border: 0,
      margin: 0,
      background: "none"
    };
    if (body) {
      $.extend(testElementStyle, {
        position: "absolute",
        left: "-1000px",
        top: "-1000px"
      });
    }
    for (i in testElementStyle) {
      testElement.style[ i ] = testElementStyle[ i ];
    }
    testElement.appendChild(div);
    testElementParent = body || document.documentElement;
    testElementParent.insertBefore(testElement, testElementParent.firstChild);

    div.style.cssText = "position: absolute; left: 10.7432222px;";

    offsetLeft = $(div).offset().left;
    $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

    testElement.innerHTML = "";
    testElementParent.removeChild(testElement);
  })();

// DEPRECATED
  if ($.uiBackCompat !== false) {
    // offset option
    (function ($) {
      var _position = $.fn.position;
      $.fn.position = function (options) {
        if (!options || !options.offset) {
          return _position.call(this, options);
        }
        var offset = options.offset.split(" "),
            at = options.at.split(" ");
        if (offset.length === 1) {
          offset[ 1 ] = offset[ 0 ];
        }
        if (/^\d/.test(offset[ 0 ])) {
          offset[ 0 ] = "+" + offset[ 0 ];
        }
        if (/^\d/.test(offset[ 1 ])) {
          offset[ 1 ] = "+" + offset[ 1 ];
        }
        if (at.length === 1) {
          if (/left|center|right/.test(at[ 0 ])) {
            at[ 1 ] = "center";
          } else {
            at[ 1 ] = at[ 0 ];
            at[ 0 ] = "center";
          }
        }
        return _position.call(this, $.extend(options, {
          at: at[ 0 ] + offset[ 0 ] + " " + at[ 1 ] + offset[ 1 ],
          offset: undefined
        }));
      };
    }(jQuery) );
  }

}(jQuery) );

/*!
 * jQuery UI Draggable 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
/**
 * 用来支持拖动的工具类。
 * @class fish.desktop.uicore.Draggable
 * @alternateClassName desktop.uicore.Draggable
 */
(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	version: "1.9.2",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false
	},
	_create: function() {

		if (this.options.helper == 'original' && !(/^(?:r|a|f)/).test(this.element.css("position")))
			this.element[0].style.position = 'relative';

		(this.options.addClasses && this.element.addClass("ui-draggable"));
		(this.options.disabled && this.element.addClass("ui-draggable-disabled"));

		this._mouseInit();

	},

	_destroy: function() {
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).is('.ui-resizable-handle'))
			return false;

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle)
			return false;

		$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
			$('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>')
			.css({
				width: this.offsetWidth+"px", height: this.offsetHeight+"px",
				position: "absolute", opacity: "0.001", zIndex: 1000
			})
			.css($(this).offset())
			.appendTo("body");
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css("position");
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);


		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) $.ui.ddmanager.dragStart(this, event);

		return true;
	},

	_mouseDrag: function(event, noPropagation) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger('drag', event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			dropped = $.ui.ddmanager.drop(this, event);

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		//if the original element is no longer in the DOM don't bother to continue (see #8269)
		var element = this.element[0], elementInDom = false;
		while ( element && (element = element.parentNode) ) {
			if (element == document ) {
				elementInDom = true;
			}
		}
		if ( !elementInDom && this.options.helper === "original" )
			return false;

		if((this.options.revert == "invalid" && !dropped) || (this.options.revert == "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			var that = this;
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		//Remove frame helpers
		$("div.ui-draggable-iframeFix").each(function() {
			this.parentNode.removeChild(this);
		});

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) $.ui.ddmanager.dragStop(this, event);

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},
	/**
	 * 撤掉拖动，被拖动的元素会回到原来的位置。
	 * @method cancel
	 * @return {Element} jQuery对象
	 */
	cancel: function() {

		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {

		var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
		$(this.options.handle, this.element)
			.find("*")
			.andSelf()
			.each(function() {
				if(this == event.target) handle = true;
			});

		return handle;

	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == 'clone' ? this.element.clone().removeAttr('id') : this.element);

		if(!helper.parents('body').length)
			helper.appendTo((o.appendTo == 'parent' ? this.element[0].parentNode : o.appendTo));

		if(helper[0] != this.element[0] && !(/(fixed|absolute)/).test(helper.css("position")))
			helper.css("position", "absolute");

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.ui.ie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			o.containment == 'document' ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
			o.containment == 'document' ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
			(o.containment == 'document' ? 0 : $(window).scrollLeft()) + $(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			(o.containment == 'document' ? 0 : $(window).scrollTop()) + ($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor != Array) {
			var c = $(o.containment);
			var ce = c[0]; if(!ce) return;
			var co = c.offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				(parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0),
				(parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0),
				(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
				(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom
			];
			this.relative_container = c;

		} else if(o.containment.constructor == Array) {
			this.containment = o.containment;
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options
			var containment;
			if(this.containment) {
			if (this.relative_container){
				var co = this.relative_container.offset();
				containment = [ this.containment[0] + co.left,
					this.containment[1] + co.top,
					this.containment[2] + co.left,
					this.containment[3] + co.top ];
			}
			else {
				containment = this.containment;
			}

				if(event.pageX - this.offset.click.left < containment[0]) pageX = containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < containment[1]) pageY = containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > containment[2]) pageX = containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > containment[3]) pageY = containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				var top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? (!(top - this.offset.click.top < containment[1] || top - this.offset.click.top > containment[3]) ? top : (!(top - this.offset.click.top < containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? (!(left - this.offset.click.left < containment[0] || left - this.offset.click.left > containment[2]) ? left : (!(left - this.offset.click.left < containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] != this.element[0] && !this.cancelHelperRemoval) this.helper.remove();
		//if($.ui.ddmanager) $.ui.ddmanager.current = null;
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		if(type == "drag") this.positionAbs = this._convertPositionTo("absolute"); //The absolute position has to be recalculated after plugins
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function(event) {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add("draggable", "connectToSortable", {
	/**
	 * 开始拖动。
	 * @method start
	 * @param {Event} event 事件
	 * @param {Element} ui 元素
	 */
	start: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, 'sortable');
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	/**
	 * 停止拖动。
	 * @method stop
	 * @param {Event} event 事件
	 * @param {Element} ui 元素
	 */
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: 'valid/invalid'
				if(this.shouldRevert) this.instance.options.revert = true;

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper == 'original')
					this.instance.currentItem.css({ top: 'auto', left: 'auto' });

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	/**
	 * 拖动过程中。
	 * @method drag
	 * @param {Event} event 事件
	 * @param {Element} ui 元素
	 */
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), that = this;

		var checkPos = function(o) {
			var dyClick = this.offset.click.top, dxClick = this.offset.click.left;
			var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left;
			var itemHeight = o.height, itemWidth = o.width;
			var itemTop = o.top, itemLeft = o.left;

			return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth);
		};

		$.each(inst.sortables, function(i) {

			var innermostIntersecting = false;
			var thisSortable = this;
			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if(this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function () {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if  (this != thisSortable
						&& this.instance._intersectsWith(this.instance.containerCache)
						&& $.ui.contains(thisSortable.instance.element[0], this.instance.element[0]))
						innermostIntersecting = false;
						return innermostIntersecting;
				});
			}


			if(innermostIntersecting) {
				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(that).clone().removeAttr('id').appendTo(this.instance.element).data("sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) this.instance._mouseDrag(event);

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger('out', event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) this.instance.placeholder.remove();

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			};

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function(event, ui) {
		var t = $('body'), o = $(this).data('draggable').options;
		if (t.css("cursor")) o._cursor = t.css("cursor");
		t.css("cursor", o.cursor);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if (o._cursor) $('body').css("cursor", o._cursor);
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data('draggable').options;
		if(t.css("opacity")) o._opacity = t.css("opacity");
		t.css('opacity', o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if(o._opacity) $(ui.helper).css('opacity', o._opacity);
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function(event, ui) {
		var i = $(this).data("draggable");
		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') i.overflowOffset = i.scrollParent.offset();
	},
	drag: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') {

			if(!o.axis || o.axis != 'x') {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
			}

			if(!o.axis || o.axis != 'y') {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
			}

		} else {

			if(!o.axis || o.axis != 'x') {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
			}

			if(!o.axis || o.axis != 'y') {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(i, event);

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options;
		i.snapElements = [];

		$(o.snap.constructor != String ? ( o.snap.items || ':data(draggable)' ) : o.snap).each(function() {
			var $t = $(this); var $o = $t.offset();
			if(this != i.element[0]) i.snapElements.push({
				item: this,
				width: $t.outerWidth(), height: $t.outerHeight(),
				top: $o.top, left: $o.left
			});
		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options;
		var d = o.snapTolerance;

		var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (var i = inst.snapElements.length - 1; i >= 0; i--){

			var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width,
				t = inst.snapElements[i].top, b = t + inst.snapElements[i].height;

			//Yes, I know, this is insane ;)
			if(!((l-d < x1 && x1 < r+d && t-d < y1 && y1 < b+d) || (l-d < x1 && x1 < r+d && t-d < y2 && y2 < b+d) || (l-d < x2 && x2 < r+d && t-d < y1 && y1 < b+d) || (l-d < x2 && x2 < r+d && t-d < y2 && y2 < b+d))) {
				if(inst.snapElements[i].snapping) (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode != 'inner') {
				var ts = Math.abs(t - y2) <= d;
				var bs = Math.abs(b - y1) <= d;
				var ls = Math.abs(l - x2) <= d;
				var rs = Math.abs(r - x1) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
			}

			var first = (ts || bs || ls || rs);

			if(o.snapMode != 'outer') {
				var ts = Math.abs(t - y1) <= d;
				var bs = Math.abs(b - y2) <= d;
				var ls = Math.abs(l - x1) <= d;
				var rs = Math.abs(r - x2) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first))
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		};

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function(event, ui) {

		var o = $(this).data("draggable").options;

		var group = $.makeArray($(o.stack)).sort(function(a,b) {
			return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
		});
		if (!group.length) { return; }

		var min = parseInt(group[0].style.zIndex) || 0;
		$(group).each(function(i) {
			this.style.zIndex = min + i;
		});

		this[0].style.zIndex = min + group.length;

	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("draggable").options;
		if(t.css("zIndex")) o._zIndex = t.css("zIndex");
		t.css('zIndex', o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("draggable").options;
		if(o._zIndex) $(ui.helper).css('zIndex', o._zIndex);
	}
});

})(jQuery);

/*!
 * jQuery UI Droppable 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/droppable/
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.mouse.js
 *	jquery.ui.draggable.js
 */
(function( $, undefined ) {

$.widget("ui.droppable", {
	version: "1.9.2",
	widgetEventPrefix: "drop",
	options: {
		accept: '*',
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: 'default',
		tolerance: 'intersect'
	},
	_create: function() {

		var o = this.options, accept = o.accept;
		this.isover = 0; this.isout = 1;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		//Store the droppable's proportions
		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses && this.element.addClass("ui-droppable"));

	},

	_destroy: function() {
		var drop = $.ui.ddmanager.droppables[this.options.scope];
		for ( var i = 0; i < drop.length; i++ )
			if ( drop[i] == this )
				drop.splice(i, 1);

		this.element.removeClass("ui-droppable ui-droppable-disabled");
	},

	_setOption: function(key, value) {

		if(key == 'accept') {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.addClass(this.options.activeClass);
		(draggable && this._trigger('activate', event, this.ui(draggable)));
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
		(draggable && this._trigger('deactivate', event, this.ui(draggable)));
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.addClass(this.options.hoverClass);
			this._trigger('over', event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('out', event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; // Bail if draggable and droppable are same element

		var childrenIntersection = false;
		this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function() {
			var inst = $.data(this, 'droppable');
			if(
				inst.options.greedy
				&& !inst.options.disabled
				&& inst.options.scope == draggable.options.scope
				&& inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element))
				&& $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) return false;

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('drop', event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) return false;

	var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height;
	var l = droppable.offset.left, r = l + droppable.proportions.width,
		t = droppable.offset.top, b = t + droppable.proportions.height;

	switch (toleranceMode) {
		case 'fit':
			return (l <= x1 && x2 <= r
				&& t <= y1 && y2 <= b);
			break;
		case 'intersect':
			return (l < x1 + (draggable.helperProportions.width / 2) // Right Half
				&& x2 - (draggable.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (draggable.helperProportions.height / 2) // Bottom Half
				&& y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
			break;
		case 'pointer':
			var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left),
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top),
				isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);
			return isOver;
			break;
		case 'touch':
			return (
					(y1 >= t && y1 <= b) ||	// Top edge touching
					(y2 >= t && y2 <= b) ||	// Bottom edge touching
					(y1 < t && y2 > b)		// Surrounded vertically
				) && (
					(x1 >= l && x1 <= r) ||	// Left edge touching
					(x2 >= l && x2 <= r) ||	// Right edge touching
					(x1 < l && x2 > r)		// Surrounded horizontally
				);
			break;
		default:
			return false;
			break;
		}

};

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { 'default': [] },
	prepareOffsets: function(t, event) {

		var m = $.ui.ddmanager.droppables[t.options.scope] || [];
		var type = event ? event.type : null; // workaround for #2317
		var list = (t.currentItem || t.element).find(":data(droppable)").andSelf();

		droppablesLoop: for (var i = 0; i < m.length; i++) {

			if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) continue;	//No disabled and non-accepted
			for (var j=0; j < list.length; j++) { if(list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop; } }; //Filter out elements in the current dragged item
			m[i].visible = m[i].element.css("display") != "none"; if(!m[i].visible) continue; 									//If the element is not visible, continue

			if(type == "mousedown") m[i]._activate.call(m[i], event); //Activate the droppable if used directly from draggables

			m[i].offset = m[i].element.offset();
			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(!this.options) return;
			if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance))
				dropped = this._drop.call(this, event) || dropped;

			if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = 1; this.isover = 0;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
			if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
		});
	},
	drag: function(draggable, event) {

		//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);

		//Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) return;
			var intersects = $.ui.intersect(draggable, this, this.options.tolerance);

			var c = !intersects && this.isover == 1 ? 'isout' : (intersects && this.isover == 0 ? 'isover' : null);
			if(!c) return;

			var parentInstance;
			if (this.options.greedy) {
				// find droppable parents with same scope
				var scope = this.options.scope;
				var parent = this.element.parents(':data(droppable)').filter(function () {
					return $.data(this, 'droppable').options.scope === scope;
				});

				if (parent.length) {
					parentInstance = $.data(parent[0], 'droppable');
					parentInstance.greedyChild = (c == 'isover' ? 1 : 0);
				}
			}

			// we just moved into a greedy child
			if (parentInstance && c == 'isover') {
				parentInstance['isover'] = 0;
				parentInstance['isout'] = 1;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = 1; this[c == 'isout' ? 'isover' : 'isout'] = 0;
			this[c == "isover" ? "_over" : "_out"].call(this, event);

			// we just moved out of a greedy child
			if (parentInstance && c == 'isout') {
				parentInstance['isout'] = 0;
				parentInstance['isover'] = 1;
				parentInstance._over.call(parentInstance, event);
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
		//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
	}
};

})(jQuery);

/**
 * Resizable
 * @class  fish.desktop.widget.Resizable
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function($, undefined) {

	$.widget("ui.resizable", $.ui.mouse, {
		version: "1.9.2",
		widgetEventPrefix: "resize",
		/**
		 * @cfg {Element} alsoResize One or more elements to resize synchronously with the resizable element.
		 */
		/**
		 * @cfg {Boolean} animate Animates to the final size after resizing.
		 */
		/**
		 * @cfg {Number/String} animateDuration How long (slow/fast) to animate when using the animate option.
		 */
		/**
		 * @cfg {String} animateEasing Which easing to apply when using the animate option(default:swing).
		 */
		/**
		 * @cfg {Boolean/Number} aspectRatio Whether the element should be constrained to a specific aspect ratio.
		 */
		/**
		 * @cfg {Boolean} autoHide Whether the handles should hide when the user is not hovering over the element.
		 */
		/**
		 * @cfg {Element} containment Constrains resizing to within the bounds of the specified element or region.
		 */
		/**
		 * @cfg {Boolean} ghost If set to true, a semi-transparent helper element is shown for resizing.
		 */
		/**
		 * @cfg {Array} grid Snaps the resizing element to a grid, every x and y pixels. Array values: [ x, y ].
		 */
		/**
		 * @cfg {String/Object} handles Which handles can be used for resizing.
		 */
		/**
		 * @cfg {String} helper A class name that will be added to a proxy element to outline the resize during the drag of the resize handle. Once the resize is complete, the original element is sized.
		 */
		/**
		 * @cfg {Number} maxHeight The maximum height the resizable should be allowed to resize to.
		 */
		/**
		 * @cfg {Number} maxWidth The maximum width the resizable should be allowed to resize to.
		 */
		/**
		 * @cfg {Number} minHeight The minimum height the resizable should be allowed to resize to.
		 */
		/**
		 * @cfg {Number} minWidth The minimum width the resizable should be allowed to resize to.
		 */
		options: {
			alsoResize: false,
			animate: false,
			animateDuration: "slow",
			animateEasing: "swing",
			aspectRatio: false,
			autoHide: false,
			containment: false,
			ghost: false,
			grid: false,
			handles: "e,s,se",
			helper: false,
			maxHeight: null,
			maxWidth: null,
			minHeight: 10,
			minWidth: 10,
			zIndex: 1000
		},
		_create: function() {

			var that = this,
				o = this.options;
			this.element.addClass("ui-resizable");

			$.extend(this, {
				_aspectRatio: !! (o.aspectRatio),
				aspectRatio: o.aspectRatio,
				originalElement: this.element,
				_proportionallyResizeElements: [],
				_helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null
			});

			//Wrap the element if it cannot hold child nodes
			if (this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

				//Create a wrapper element and set the wrapper to the new current internal element
				this.element.wrap(
				$('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({
					position: this.element.css('position'),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css('top'),
					left: this.element.css('left')
				}));

				//Overwrite the original this.element
				this.element = this.element.parent().data(
					"resizable", this.element.data('resizable'));

				this.elementIsWrapper = true;

				//Move margins to the wrapper
				this.element.css({
					marginLeft: this.originalElement.css("marginLeft"),
					marginTop: this.originalElement.css("marginTop"),
					marginRight: this.originalElement.css("marginRight"),
					marginBottom: this.originalElement.css("marginBottom")
				});
				this.originalElement.css({
					marginLeft: 0,
					marginTop: 0,
					marginRight: 0,
					marginBottom: 0
				});

				//Prevent Safari textarea resize
				this.originalResizeStyle = this.originalElement.css('resize');
				this.originalElement.css('resize', 'none');

				//Push the actual element to our proportionallyResize internal array
				this._proportionallyResizeElements.push(this.originalElement.css({
					position: 'static',
					zoom: 1,
					display: 'block'
				}));

				// avoid IE jump (hard set the margin)
				this.originalElement.css({
					margin: this.originalElement.css('margin')
				});

				// fix handlers offset
				this._proportionallyResize();

			}

			this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? "e,s,se" : {
				n: '.ui-resizable-n',
				e: '.ui-resizable-e',
				s: '.ui-resizable-s',
				w: '.ui-resizable-w',
				se: '.ui-resizable-se',
				sw: '.ui-resizable-sw',
				ne: '.ui-resizable-ne',
				nw: '.ui-resizable-nw'
			});
			if (this.handles.constructor == String) {

				if (this.handles == 'all') this.handles = 'n,e,s,w,se,sw,ne,nw';
				var n = this.handles.split(",");
				this.handles = {};

				for (var i = 0; i < n.length; i++) {

					var handle = $.trim(n[i]),
						hname = 'ui-resizable-' + handle;
					var axis = $('<div class="ui-resizable-handle ' + hname + '"></div>');

					// Apply zIndex to all handles - see #7960
					axis.css({
						zIndex: o.zIndex
					});

					//TODO : What's going on here?
					if ('se' == handle) {
						axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');
					};

					//Insert into internal handles object and append to element
					this.handles[handle] = '.ui-resizable-' + handle;
					this.element.append(axis);
				}

			}

			this._renderAxis = function(target) {

				target = target || this.element;

				for (var i in this.handles) {

					if (this.handles[i].constructor == String) this.handles[i] = $(this.handles[i], this.element).show();

					//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
					if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

						var axis = $(this.handles[i], this.element),
							padWrapper = 0;

						//Checking the correct pad and border
						padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

						//The padding type i have to apply...
						var padPos = ['padding',
							/ne|nw|n/.test(i) ? 'Top' :
							/se|sw|s/.test(i) ? 'Bottom' :
							/^e$/.test(i) ? 'Right' : 'Left'].join("");

						target.css(padPos, padWrapper);

						this._proportionallyResize();

					}

					//TODO: What's that good for? There's not anything to be executed left
					if (!$(this.handles[i]).length) continue;

				}
			};

			//TODO: make renderAxis a prototype function
			this._renderAxis(this.element);

			this._handles = $('.ui-resizable-handle', this.element)
				.disableSelection();

			//Matching axis name
			this._handles.mouseover(function() {
				if (!that.resizing) {
					if (this.className) var axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
					//Axis, default = se
					that.axis = axis && axis[1] ? axis[1] : 'se';
				}
			});

			//If we want to auto hide the elements
			if (o.autoHide) {
				this._handles.hide();
				$(this.element)
					.addClass("ui-resizable-autohide")
					.mouseenter(function() {
					if (o.disabled) return;
					$(this).removeClass("ui-resizable-autohide");
					that._handles.show();
				})
					.mouseleave(function() {
					if (o.disabled) return;
					if (!that.resizing) {
						$(this).addClass("ui-resizable-autohide");
						that._handles.hide();
					}
				});
			}

			//Initialize the mouse interaction
			this._mouseInit();

		},

		_destroy: function() {

			this._mouseDestroy();

			var _destroy = function(exp) {
				$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
					.removeData("resizable").removeData("ui-resizable").unbind(".resizable").find('.ui-resizable-handle').remove();
			};

			//TODO: Unwrap at same DOM position
			if (this.elementIsWrapper) {
				_destroy(this.element);
				var wrapper = this.element;
				this.originalElement.css({
					position: wrapper.css('position'),
					width: wrapper.outerWidth(),
					height: wrapper.outerHeight(),
					top: wrapper.css('top'),
					left: wrapper.css('left')
				}).insertAfter(wrapper);
				wrapper.remove();
			}

			this.originalElement.css('resize', this.originalResizeStyle);
			_destroy(this.originalElement);

			return this;
		},

		_mouseCapture: function(event) {
			var handle = false;
			for (var i in this.handles) {
				if ($(this.handles[i])[0] == event.target) {
					handle = true;
				}
			}

			return !this.options.disabled && handle;
		},

		_mouseStart: function(event) {

			var o = this.options,
				iniPos = this.element.position(),
				el = this.element;

			this.resizing = true;
			this.documentScroll = {
				top: $(document).scrollTop(),
				left: $(document).scrollLeft()
			};

			// bugfix for http://dev.jquery.com/ticket/1749
			if (el.is('.ui-draggable') || (/absolute/).test(el.css('position'))) {
				el.css({
					position: 'absolute',
					top: iniPos.top,
					left: iniPos.left
				});
			}

			this._renderProxy();

			var curleft = num(this.helper.css('left')),
				curtop = num(this.helper.css('top'));

			if (o.containment) {
				curleft += $(o.containment).scrollLeft() || 0;
				curtop += $(o.containment).scrollTop() || 0;
			}

			//Store needed variables
			this.offset = this.helper.offset();
			this.position = {
				left: curleft,
				top: curtop
			};
			this.size = this._helper ? {
				width: el.outerWidth(),
				height: el.outerHeight()
			} : {
				width: el.width(),
				height: el.height()
			};
			this.originalSize = this._helper ? {
				width: el.outerWidth(),
				height: el.outerHeight()
			} : {
				width: el.width(),
				height: el.height()
			};
			this.originalPosition = {
				left: curleft,
				top: curtop
			};
			this.sizeDiff = {
				width: el.outerWidth() - el.width(),
				height: el.outerHeight() - el.height()
			};
			this.originalMousePosition = {
				left: event.pageX,
				top: event.pageY
			};

			//Aspect Ratio
			this.aspectRatio = (typeof o.aspectRatio == 'number') ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

			var cursor = $('.ui-resizable-' + this.axis).css('cursor');
			$('body').css('cursor', cursor == 'auto' ? this.axis + '-resize' : cursor);

			el.addClass("ui-resizable-resizing");
			this._propagate("start", event);
			return true;
		},

		_mouseDrag: function(event) {

			//Increase performance, avoid regex
			var el = this.helper,
				o = this.options,
				props = {},
				that = this,
				smp = this.originalMousePosition,
				a = this.axis;

			var dx = (event.pageX - smp.left) || 0,
				dy = (event.pageY - smp.top) || 0;
			var trigger = this._change[a];
			if (!trigger) return false;

			// Calculate the attrs that will be change
			var data = trigger.apply(this, [event, dx, dy]);

			// Put this in the mouseDrag handler since the user can start pressing shift while resizing
			this._updateVirtualBoundaries(event.shiftKey);
			if (this._aspectRatio || event.shiftKey) data = this._updateRatio(data, event);

			data = this._respectSize(data, event);

			// plugins callbacks need to be called first
			this._propagate("resize", event);

			el.css({
				top: this.position.top + "px",
				left: this.position.left + "px",
				width: this.size.width + "px",
				height: this.size.height + "px"
			});

			if (!this._helper && this._proportionallyResizeElements.length) this._proportionallyResize();

			this._updateCache(data);

			// calling the user callback at the end
			this._trigger('resize', event, this.ui());

			return false;
		},

		_mouseStop: function(event) {

			this.resizing = false;
			var o = this.options,
				that = this;

			if (this._helper) {
				var pr = this._proportionallyResizeElements,
					ista = pr.length && (/textarea/i).test(pr[0].nodeName),
					soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */
					? 0 : that.sizeDiff.height,
					soffsetw = ista ? 0 : that.sizeDiff.width;

				var s = {
					width: (that.helper.width() - soffsetw),
					height: (that.helper.height() - soffseth)
				},
				left = (parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left)) || null,
					top = (parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top)) || null;

				if (!o.animate) this.element.css($.extend(s, {
					top: top,
					left: left
				}));

				that.helper.height(that.size.height);
				that.helper.width(that.size.width);

				if (this._helper && !o.animate) this._proportionallyResize();
			}

			$('body').css('cursor', 'auto');

			this.element.removeClass("ui-resizable-resizing");

			this._propagate("stop", event);

			if (this._helper) this.helper.remove();
			return false;

		},

		_updateVirtualBoundaries: function(forceAspectRatio) {
			var o = this.options,
				pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b;

			b = {
				minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
				maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
				minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
				maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
			};

			if (this._aspectRatio || forceAspectRatio) {
				// We want to create an enclosing box whose aspect ration is the requested one
				// First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
				pMinWidth = b.minHeight * this.aspectRatio;
				pMinHeight = b.minWidth / this.aspectRatio;
				pMaxWidth = b.maxHeight * this.aspectRatio;
				pMaxHeight = b.maxWidth / this.aspectRatio;

				if (pMinWidth > b.minWidth) b.minWidth = pMinWidth;
				if (pMinHeight > b.minHeight) b.minHeight = pMinHeight;
				if (pMaxWidth < b.maxWidth) b.maxWidth = pMaxWidth;
				if (pMaxHeight < b.maxHeight) b.maxHeight = pMaxHeight;
			}
			this._vBoundaries = b;
		},

		_updateCache: function(data) {
			var o = this.options;
			this.offset = this.helper.offset();
			if (isNumber(data.left)) this.position.left = data.left;
			if (isNumber(data.top)) this.position.top = data.top;
			if (isNumber(data.height)) this.size.height = data.height;
			if (isNumber(data.width)) this.size.width = data.width;
		},

		_updateRatio: function(data, event) {

			var o = this.options,
				cpos = this.position,
				csize = this.size,
				a = this.axis;

			if (isNumber(data.height)) data.width = (data.height * this.aspectRatio);
			else if (isNumber(data.width)) data.height = (data.width / this.aspectRatio);

			if (a == 'sw') {
				data.left = cpos.left + (csize.width - data.width);
				data.top = null;
			}
			if (a == 'nw') {
				data.top = cpos.top + (csize.height - data.height);
				data.left = cpos.left + (csize.width - data.width);
			}

			return data;
		},

		_respectSize: function(data, event) {

			var el = this.helper,
				o = this._vBoundaries,
				pRatio = this._aspectRatio || event.shiftKey,
				a = this.axis,
				ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),
				ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
				isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width),
				isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height);

			if (isminw) data.width = o.minWidth;
			if (isminh) data.height = o.minHeight;
			if (ismaxw) data.width = o.maxWidth;
			if (ismaxh) data.height = o.maxHeight;

			var dw = this.originalPosition.left + this.originalSize.width,
				dh = this.position.top + this.size.height;
			var cw = /sw|nw|w/.test(a),
				ch = /nw|ne|n/.test(a);

			if (isminw && cw) data.left = dw - o.minWidth;
			if (ismaxw && cw) data.left = dw - o.maxWidth;
			if (isminh && ch) data.top = dh - o.minHeight;
			if (ismaxh && ch) data.top = dh - o.maxHeight;

			// fixing jump error on top/left - bug #2330
			var isNotwh = !data.width && !data.height;
			if (isNotwh && !data.left && data.top) data.top = null;
			else if (isNotwh && !data.top && data.left) data.left = null;

			return data;
		},

		_proportionallyResize: function() {

			var o = this.options;
			if (!this._proportionallyResizeElements.length) return;
			var element = this.helper || this.element;

			for (var i = 0; i < this._proportionallyResizeElements.length; i++) {

				var prel = this._proportionallyResizeElements[i];

				if (!this.borderDif) {
					var b = [prel.css('borderTopWidth'), prel.css('borderRightWidth'), prel.css('borderBottomWidth'), prel.css('borderLeftWidth')],
						p = [prel.css('paddingTop'), prel.css('paddingRight'), prel.css('paddingBottom'), prel.css('paddingLeft')];

					this.borderDif = $.map(b, function(v, i) {
						var border = parseInt(v, 10) || 0,
							padding = parseInt(p[i], 10) || 0;
						return border + padding;
					});
				}

				prel.css({
					height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
					width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
				});

			};

		},

		_renderProxy: function() {

			var el = this.element,
				o = this.options;
			this.elementOffset = el.offset();

			if (this._helper) {

				this.helper = this.helper || $('<div style="overflow:hidden;"></div>');

				// fix ie6 offset TODO: This seems broken
				var ie6offset = ($.ui.ie6 ? 1 : 0),
					pxyoffset = ($.ui.ie6 ? 2 : -1);

				this.helper.addClass(this._helper).css({
					width: this.element.outerWidth() + pxyoffset,
					height: this.element.outerHeight() + pxyoffset,
					position: 'absolute',
					left: this.elementOffset.left - ie6offset + 'px',
					top: this.elementOffset.top - ie6offset + 'px',
					zIndex: ++o.zIndex //TODO: Don't modify option
				});

				this.helper.appendTo("body")
					.disableSelection();

			} else {
				this.helper = this.element;
			}

		},

		_change: {
			e: function(event, dx, dy) {
				return {
					width: this.originalSize.width + dx
				};
			},
			w: function(event, dx, dy) {
				var o = this.options,
					cs = this.originalSize,
					sp = this.originalPosition;
				return {
					left: sp.left + dx,
					width: cs.width - dx
				};
			},
			n: function(event, dx, dy) {
				var o = this.options,
					cs = this.originalSize,
					sp = this.originalPosition;
				return {
					top: sp.top + dy,
					height: cs.height - dy
				};
			},
			s: function(event, dx, dy) {
				return {
					height: this.originalSize.height + dy
				};
			},
			se: function(event, dx, dy) {
				return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
			},
			sw: function(event, dx, dy) {
				return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
			},
			ne: function(event, dx, dy) {
				return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
			},
			nw: function(event, dx, dy) {
				return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
			}
		},

		_propagate: function(n, event) {
			$.ui.plugin.call(this, n, [event, this.ui()]);
			(n != "resize" && this._trigger(n, event, this.ui()));
		},

		plugins: {},

		ui: function() {
			return {
				originalElement: this.originalElement,
				element: this.element,
				helper: this.helper,
				position: this.position,
				size: this.size,
				originalSize: this.originalSize,
				originalPosition: this.originalPosition
			};
		}

	});

	/*
	 * Resizable Extensions
	 */

	$.ui.plugin.add("resizable", "alsoResize", {

		start: function(event, ui) {
			var that = $(this).data("resizable"),
				o = that.options;

			var _store = function(exp) {
				$(exp).each(function() {
					var el = $(this);
					el.data("resizable-alsoresize", {
						width: parseInt(el.outerWidth(), 10),//fix bug ;when el has padding,need use outerwidth
						height: parseInt(el.outerHeight(), 10),
						left: parseInt(el.css('left'), 10),
						top: parseInt(el.css('top'), 10)
					});
				});
			};

			if (typeof(o.alsoResize) == 'object' && !o.alsoResize.parentNode) {
				if (o.alsoResize.length) {
					o.alsoResize = o.alsoResize[0];
					_store(o.alsoResize);
				} else {
					$.each(o.alsoResize, function(exp) {
						_store(exp);
					});
				}
			} else {
				_store(o.alsoResize);
			}
		},

		resize: function(event, ui) {
			var that = $(this).data("resizable"),
				o = that.options,
				os = that.originalSize,
				op = that.originalPosition;

			var delta = {
				height: (that.size.height - os.height) || 0,
				width: (that.size.width - os.width) || 0,
				top: (that.position.top - op.top) || 0,
				left: (that.position.left - op.left) || 0
			},

			_alsoResize = function(exp, c) {
				$(exp).each(function() {
					var el = $(this),
						start = $(this).data("resizable-alsoresize"),
						style = {},
						css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ['width', 'height'] : ['width', 'height', 'top', 'left'];

					$.each(css, function(i, prop) {
						var sum = (start[prop] || 0) + (delta[prop] || 0);
						if (sum && sum >= 0) style[prop] = sum || null;
						//fix bordor width
			            if(prop === 'width')
			                style['outerWidth'] = sum || null;
			            else if(prop === 'height')
			                style['outerHeight'] = sum || null;
			            else
			                style[prop] = sum || null;
					});
					el.css(style);
				});
			};

			if (typeof(o.alsoResize) == 'object' && !o.alsoResize.nodeType) {
				$.each(o.alsoResize, function(exp, c) {
					_alsoResize(exp, c);
				});
			} else {
				_alsoResize(o.alsoResize);
			}
		},

		stop: function(event, ui) {
			$(this).removeData("resizable-alsoresize");
		}
	});

	$.ui.plugin.add("resizable", "animate", {

		stop: function(event, ui) {
			var that = $(this).data("resizable"),
				o = that.options;

			var pr = that._proportionallyResizeElements,
				ista = pr.length && (/textarea/i).test(pr[0].nodeName),
				soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */
				? 0 : that.sizeDiff.height,
				soffsetw = ista ? 0 : that.sizeDiff.width;

			var style = {
				width: (that.size.width - soffsetw),
				height: (that.size.height - soffseth)
			},
			left = (parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left)) || null,
				top = (parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top)) || null;

			that.element.animate(
			$.extend(style, top && left ? {
				top: top,
				left: left
			} : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(that.element.css('width'), 10),
						height: parseInt(that.element.css('height'), 10),
						top: parseInt(that.element.css('top'), 10),
						left: parseInt(that.element.css('left'), 10)
					};

					if (pr && pr.length) $(pr[0]).css({
						width: data.width,
						height: data.height
					});

					// propagating resize, and updating values for each animation step
					that._updateCache(data);
					that._propagate("resize", event);

				}
			});
		}

	});

	$.ui.plugin.add("resizable", "containment", {

		start: function(event, ui) {
			var that = $(this).data("resizable"),
				o = that.options,
				el = that.element;
			var oc = o.containment,
				ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
			if (!ce) return;

			that.containerElement = $(ce);

			if (/document/.test(oc) || oc == document) {
				that.containerOffset = {
					left: 0,
					top: 0
				};
				that.containerPosition = {
					left: 0,
					top: 0
				};

				that.parentData = {
					element: $(document),
					left: 0,
					top: 0,
					width: $(document).width(),
					height: $(document).height() || document.body.parentNode.scrollHeight
				};
			}

			// i'm a node, so compute top, left, right, bottom
			else {
				var element = $(ce),
					p = [];
				$(["Top", "Right", "Left", "Bottom"]).each(function(i, name) {
					p[i] = num(element.css("padding" + name));
				});

				that.containerOffset = element.offset();
				that.containerPosition = element.position();
				that.containerSize = {
					height: (element.innerHeight() - p[3]),
					width: (element.innerWidth() - p[1])
				};

				var co = that.containerOffset,
					ch = that.containerSize.height,
					cw = that.containerSize.width,
					width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw),
					height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

				that.parentData = {
					element: ce,
					left: co.left,
					top: co.top,
					width: width,
					height: height
				};
			}
		},

		resize: function(event, ui) {
			var that = $(this).data("resizable"),
				o = that.options,
				ps = that.containerSize,
				co = that.containerOffset,
				cs = that.size,
				cp = that.position,
				pRatio = that._aspectRatio || event.shiftKey,
				cop = {
					top: 0,
					left: 0
				}, ce = that.containerElement;

			if (ce[0] != document && (/static/).test(ce.css('position'))) cop = co;

			if (cp.left < (that._helper ? co.left : 0)) {
				that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
				if (pRatio) that.size.height = that.size.width / that.aspectRatio;
				that.position.left = o.helper ? co.left : 0;
			}

			if (cp.top < (that._helper ? co.top : 0)) {
				that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
				if (pRatio) that.size.width = that.size.height * that.aspectRatio;
				that.position.top = that._helper ? co.top : 0;
			}

			that.offset.left = that.parentData.left + that.position.left;
			that.offset.top = that.parentData.top + that.position.top;

			var woset = Math.abs((that._helper ? that.offset.left - cop.left : (that.offset.left - cop.left)) + that.sizeDiff.width),
				hoset = Math.abs((that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)) + that.sizeDiff.height);

			var isParent = that.containerElement.get(0) == that.element.parent().get(0),
				isOffsetRelative = /relative|absolute/.test(that.containerElement.css('position'));

			if (isParent && isOffsetRelative) woset -= that.parentData.left;

			if (woset + that.size.width >= that.parentData.width) {
				that.size.width = that.parentData.width - woset;
				if (pRatio) that.size.height = that.size.width / that.aspectRatio;
			}

			if (hoset + that.size.height >= that.parentData.height) {
				that.size.height = that.parentData.height - hoset;
				if (pRatio) that.size.width = that.size.height * that.aspectRatio;
			}
		},

		stop: function(event, ui) {
			var that = $(this).data("resizable"),
				o = that.options,
				cp = that.position,
				co = that.containerOffset,
				cop = that.containerPosition,
				ce = that.containerElement;

			var helper = $(that.helper),
				ho = helper.offset(),
				w = helper.outerWidth() - that.sizeDiff.width,
				h = helper.outerHeight() - that.sizeDiff.height;

			if (that._helper && !o.animate && (/relative/).test(ce.css('position'))) $(this).css({
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			});

			if (that._helper && !o.animate && (/static/).test(ce.css('position'))) $(this).css({
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			});

		}
	});

	$.ui.plugin.add("resizable", "ghost", {

		start: function(event, ui) {

			var that = $(this).data("resizable"),
				o = that.options,
				cs = that.size;

			that.ghost = that.originalElement.clone();
			that.ghost.css({
				opacity: .25,
				display: 'block',
				position: 'relative',
				height: cs.height,
				width: cs.width,
				margin: 0,
				left: 0,
				top: 0
			})
				.addClass('ui-resizable-ghost')
				.addClass(typeof o.ghost == 'string' ? o.ghost : '');

			that.ghost.appendTo(that.helper);

		},

		resize: function(event, ui) {
			var that = $(this).data("resizable"),
				o = that.options;
			if (that.ghost) that.ghost.css({
				position: 'relative',
				height: that.size.height,
				width: that.size.width
			});
		},

		stop: function(event, ui) {
			var that = $(this).data("resizable"),
				o = that.options;
			if (that.ghost && that.helper) that.helper.get(0).removeChild(that.ghost.get(0));
		}

	});

	$.ui.plugin.add("resizable", "grid", {

		resize: function(event, ui) {
			var that = $(this).data("resizable"),
				o = that.options,
				cs = that.size,
				os = that.originalSize,
				op = that.originalPosition,
				a = that.axis,
				ratio = o._aspectRatio || event.shiftKey;
			o.grid = typeof o.grid == "number" ? [o.grid, o.grid] : o.grid;
			var ox = Math.round((cs.width - os.width) / (o.grid[0] || 1)) * (o.grid[0] || 1),
				oy = Math.round((cs.height - os.height) / (o.grid[1] || 1)) * (o.grid[1] || 1);

			if (/^(se|s|e)$/.test(a)) {
				that.size.width = os.width + ox;
				that.size.height = os.height + oy;
			} else if (/^(ne)$/.test(a)) {
				that.size.width = os.width + ox;
				that.size.height = os.height + oy;
				that.position.top = op.top - oy;
			} else if (/^(sw)$/.test(a)) {
				that.size.width = os.width + ox;
				that.size.height = os.height + oy;
				that.position.left = op.left - ox;
			} else {
				that.size.width = os.width + ox;
				that.size.height = os.height + oy;
				that.position.top = op.top - oy;
				that.position.left = op.left - ox;
			}
		}

	});

	var num = function(v) {
		return parseInt(v, 10) || 0;
	};

	var isNumber = function(value) {
		return !isNaN(parseInt(value, 10));
	};

})(jQuery);
/**
 * Selectable
 * @class  fish.desktop.widget.Selectable
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function($, undefined) {

	$.widget("ui.selectable", $.ui.mouse, {
		version: "1.9.2",
		/**
		 * @cfg {Element} appendTo Which element the selection helper (the lasso) should be appended to.
		 */
		/**
		 * @cfg {Boolean} autoRefresh This determines whether to refresh (recalculate) the position and size of each selectee at the beginning of each select operation. If you have many items, you may want to set this to false and call the refresh() method manually.
		 */
		/**
		 * @cfg {Number} distance Tolerance, in pixels, for when selecting should start. If specified, selecting will not start until the mouse has been dragged beyond the specified distance.
		 */
		/**
		 * @cfg {Element} filter The matching child elements will be made selectees (able to be selected).
		 */
		/**
		 * @cfg {String} tolerance Specifies which mode to use for testing whether the lasso should select an item. Possible values:[fit,touch]
		 */
		options: {
			appendTo: 'body',
			autoRefresh: true,
			distance: 0,
			filter: '*',
			tolerance: 'touch'
		},
		_create: function() {
			var that = this;

			this.element.addClass("ui-selectable");

			this.dragged = false;

			// cache selectee children based on filter
			var selectees;
			this.refresh = function() {
				selectees = $(that.options.filter, that.element[0]);
				selectees.addClass("ui-selectee");
				selectees.each(function() {
					var $this = $(this);
					var pos = $this.offset();
					$.data(this, "selectable-item", {
						element: this,
						$element: $this,
						left: pos.left,
						top: pos.top,
						right: pos.left + $this.outerWidth(),
						bottom: pos.top + $this.outerHeight(),
						startselected: false,
						selected: $this.hasClass('ui-selected'),
						selecting: $this.hasClass('ui-selecting'),
						unselecting: $this.hasClass('ui-unselecting')
					});
				});
			};
			this.refresh();

			this.selectees = selectees.addClass("ui-selectee");

			this._mouseInit();

			this.helper = $("<div class='ui-selectable-helper'></div>");
		},

		_destroy: function() {
			this.selectees.removeClass("ui-selectee")
				.removeData("selectable-item");
			this.element.removeClass("ui-selectable ui-selectable-disabled");
			this._mouseDestroy();
		},

		_mouseStart: function(event) {
			var that = this;

			this.opos = [event.pageX, event.pageY];

			if (this.options.disabled) return;

			var options = this.options;

			this.selectees = $(options.filter, this.element[0]);

			this._trigger("start", event);

			$(options.appendTo).append(this.helper);
			// position helper (lasso)
			this.helper.css({
				"left": event.clientX,
				"top": event.clientY,
				"width": 0,
				"height": 0
			});

			if (options.autoRefresh) {
				this.refresh();
			}

			this.selectees.filter('.ui-selected').each(function() {
				var selectee = $.data(this, "selectable-item");
				selectee.startselected = true;
				if (!event.metaKey && !event.ctrlKey) {
					selectee.$element.removeClass('ui-selected');
					selectee.selected = false;
					selectee.$element.addClass('ui-unselecting');
					selectee.unselecting = true;
					// selectable UNSELECTING callback
					that._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
			});

			$(event.target).parents().andSelf().each(function() {
				var selectee = $.data(this, "selectable-item");
				if (selectee) {
					var doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass('ui-selected');
					selectee.$element.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
						.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
					selectee.unselecting = !doSelect;
					selectee.selecting = doSelect;
					selectee.selected = doSelect;
					// selectable (UN)SELECTING callback
					if (doSelect) {
						that._trigger("selecting", event, {
							selecting: selectee.element
						});
					} else {
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
					return false;
				}
			});

		},

		_mouseDrag: function(event) {
			var that = this;
			this.dragged = true;

			if (this.options.disabled) return;

			var options = this.options;

			var x1 = this.opos[0],
				y1 = this.opos[1],
				x2 = event.pageX,
				y2 = event.pageY;
			if (x1 > x2) {
				var tmp = x2;
				x2 = x1;
				x1 = tmp;
			}
			if (y1 > y2) {
				var tmp = y2;
				y2 = y1;
				y1 = tmp;
			}
			this.helper.css({
				left: x1,
				top: y1,
				width: x2 - x1,
				height: y2 - y1
			});

			this.selectees.each(function() {
				var selectee = $.data(this, "selectable-item");
				//prevent helper from being selected if appendTo: selectable
				if (!selectee || selectee.element == that.element[0]) return;
				var hit = false;
				if (options.tolerance == 'touch') {
					hit = (!(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1));
				} else if (options.tolerance == 'fit') {
					hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
				}

				if (hit) {
					// SELECT
					if (selectee.selected) {
						selectee.$element.removeClass('ui-selected');
						selectee.selected = false;
					}
					if (selectee.unselecting) {
						selectee.$element.removeClass('ui-unselecting');
						selectee.unselecting = false;
					}
					if (!selectee.selecting) {
						selectee.$element.addClass('ui-selecting');
						selectee.selecting = true;
						// selectable SELECTING callback
						that._trigger("selecting", event, {
							selecting: selectee.element
						});
					}
				} else {
					// UNSELECT
					if (selectee.selecting) {
						if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
							selectee.$element.removeClass('ui-selecting');
							selectee.selecting = false;
							selectee.$element.addClass('ui-selected');
							selectee.selected = true;
						} else {
							selectee.$element.removeClass('ui-selecting');
							selectee.selecting = false;
							if (selectee.startselected) {
								selectee.$element.addClass('ui-unselecting');
								selectee.unselecting = true;
							}
							// selectable UNSELECTING callback
							that._trigger("unselecting", event, {
								unselecting: selectee.element
							});
						}
					}
					if (selectee.selected) {
						if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
							selectee.$element.removeClass('ui-selected');
							selectee.selected = false;

							selectee.$element.addClass('ui-unselecting');
							selectee.unselecting = true;
							// selectable UNSELECTING callback
							that._trigger("unselecting", event, {
								unselecting: selectee.element
							});
						}
					}
				}
			});

			return false;
		},

		_mouseStop: function(event) {
			var that = this;

			this.dragged = false;

			var options = this.options;

			$('.ui-unselecting', this.element[0]).each(function() {
				var selectee = $.data(this, "selectable-item");
				selectee.$element.removeClass('ui-unselecting');
				selectee.unselecting = false;
				selectee.startselected = false;
				that._trigger("unselected", event, {
					unselected: selectee.element
				});
			});
			$('.ui-selecting', this.element[0]).each(function() {
				var selectee = $.data(this, "selectable-item");
				selectee.$element.removeClass('ui-selecting').addClass('ui-selected');
				selectee.selecting = false;
				selectee.selected = true;
				selectee.startselected = true;
				that._trigger("selected", event, {
					selected: selectee.element
				});
			});
			this._trigger("stop", event);

			this.helper.remove();

			return false;
		}

	});

})(jQuery);
/*!
 * jQuery UI Sortable 1.9.2
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */


/**
 * The Sortable plugin makes selected elements sortable by dragging with the mouse.
 * @class fish.desktop.widget.Sortable
 * @extends desktop.widget.Mouse
 */
(function ($, undefined) {

  $.widget("ui.sortable", $.ui.mouse, {
    version: "1.9.2",
    widgetEventPrefix: "sort",
    ready: false,
    options: {
      /**
       * @cfg {*} appendTo='parent' type:jQuery,Element,Select,String  
       * Defines where the helper that moves with the mouse is being appended to during the drag (for example, to resolve overlap/zIndex issues).<br>
       * <b>Multiple types supported</b>:<br>
       * <b>jQuery</b>: A jQuery object containing the element to append the helper to.<br>
       * <b>Element</b>: The element to append the helper to.<br>
       * <b>Selector</b>: A selector specifying which element to append the helper to.<br>
       * <b>String</b>: The string "parent" will cause the helper to be a sibling of the sortable item.<br>
       */
      appendTo: "parent",
      /**
       * @cfg {String} axis=false If defined, the items can be dragged only horizontally or vertically. Possible values: "x", "y".
       */
      axis: false,
      /**
       * @cfg {Selector} connectWith=false
       * A selector of other sortable elements that the items from this list should be connected to. <br>
       * This is a one-way relationship, if you want the items to be connected in both directions, the connectWith option must be set on both sortable elements.
       */
      connectWith: false,
      /**
       * @cfg {*} containment=false type:Element,Selector,String  
       * Defines a bounding box that the sortable items are contrained to while dragging.<br>

       * Note: The element specified for containment must have a calculated width and height (though it need not be explicit).
       * For example, if you have float: left sortable children and specify containment: "parent" be sure to have float: left on the sortable/parent container as well or it will have height: 0, causing undefined behavior.<br>

       * Multiple types supported:<br>
       * Element: An element to use as the container.<br>
       * Selector: A selector specifying an element to use as the container.<br>
       * String: A string identifying an element to use as the container. Possible values: "parent", "document", "window"<br>
       */
      containment: false,
      /**
       * @cfg {String} cursor='auto'
       * Defines the cursor that is being shown while sorting.
       */
      cursor: 'auto',
      /**
       * @cfg {String} cursorAt=false
       * Moves the sorting element or helper so the cursor always appears to drag from the same position.
       * Coordinates can be given as a hash using a combination of one or two keys: { top, left, right, bottom }.
       */
      cursorAt: false,
      /**
       * @cfg {Boolean} dropOnEmpty=true
       * If false, items from this sortable can't be dropped on an empty connect sortable (see the connectWith option).
       */
      dropOnEmpty: true,
      /**
       * @cfg {Boolean} forcePlaceholderSize=false
       * If true, forces the placeholder to have a size.
       */
      forcePlaceholderSize: false,
      /**
       * @cfg {Boolean} forceHelperSize=false
       * If true, forces the helper to have a size.
       */
      forceHelperSize: false,
      /**
       * @cfg {Array} grid=false
       * Snaps the sorting element or helper to a grid, every x and y pixels. Array values: [ x, y ].
       */
      grid: false,
      /**
       * @cfg {*} handle=false type:Selector,Element  
       * Restricts sort start click to the specified element.
       */
      handle: false,
      /**
       * @cfg {*} helper="original" type:String,Function  
       * Allows for a helper element to be used for dragging display.<br>
       * Multiple types supported:<br>
       * String: If set to "clone", then the element will be cloned and the clone will be dragged.<br>
       * Function: A function that will return a DOMElement to use while dragging. The function receives the event and the element being sorted.<br>
       */
      helper: "original",
      /**
       * @cfg {Selector} items='> *'
       * Specifies which items inside the element should be sortable.
       */
      items: '> *',
      /**
       * @cfg {Number} opacity=false
       * Defines the opacity of the helper while sorting. From 0.01 to 1.
       */
      opacity: false,
      /**
       * @cfg {String} placeholder=false
       * A class name that gets applied to the otherwise white space.
       */
      placeholder: false,
      /**
       * @cfg {*} revert=false type:Boolean,Number  
       * Whether the sortable items should revert to their new positions using a smooth animation.<br/>
       * Multiple types supported:<br/>
       * Boolean: When set to true, the items will animate with the default duration.<br/>
       * Number: The duration for the animation, in milliseconds.<br/>
       */
      revert: false,
      /**
       * @cfg {Boolean} scroll=true
       * If set to true, the page scrolls when coming to an edge.
       */
      scroll: true,
      /**
       * @cfg {Number} scrollSensitivity=20
       * Defines how near the mouse must be to an edge to start scrolling.
       */
      scrollSensitivity: 20,
      /**
       * @cfg {Number} scrollSpeed=20
       * The speed at which the window should scroll once the mouse pointer gets within the scrollSensitivity distance.
       */
      scrollSpeed: 20,
      scope: "default",
      /**
       * @cfg {String} tolerance='intersect'
       * Specifies which mode to use for testing whether the item being moved is hovering over another item. Possible values:<br/>
       * "intersect": The item overlaps the other item by at least 50%.<br/>
       * "pointer": The mouse pointer overlaps the other item.<br/>
       */
      tolerance: "intersect",
      /**
       * @cfg {number} zIndex=1000
       * Z-index for element/helper while being sorted.
       */
      zIndex: 1000

      //callback (event) in the bottom of this file
    },
    _create: function () {

      var o = this.options;
      this.containerCache = {};
      this.element.addClass("ui-sortable");

      //Get the items
      this.refresh();

      //Let's determine if the items are being displayed horizontally
      this.floating = this.items.length ? o.axis === 'x' || (/left|right/).test(this.items[0].item.css('float')) || (/inline|table-cell/).test(this.items[0].item.css('display')) : false;

      //Let's determine the parent's offset
      this.offset = this.element.offset();

      //Initialize mouse events for interaction
      this._mouseInit();

      //We're ready to go
      this.ready = true

    },

    _destroy: function () {
      this.element
        .removeClass("ui-sortable ui-sortable-disabled");
      this._mouseDestroy();

      for (var i = this.items.length - 1; i >= 0; i--)
        this.items[i].item.removeData(this.widgetName + "-item");

      return this;
    },

    _setOption: function (key, value) {
      if (key === "disabled") {
        this.options[ key ] = value;

        this.widget().toggleClass("ui-sortable-disabled", !!value);
      } else {
        // Don't call widget base _setOption for disable as it adds ui-state-disabled class
        $.Widget.prototype._setOption.apply(this, arguments);
      }
    },

    _mouseCapture: function (event, overrideHandle) {
      var that = this;

      if (this.reverting) {
        return false;
      }

      if (this.options.disabled || this.options.type == 'static') return false;

      //We have to refresh the items data once first
      this._refreshItems(event);

      //Find out if the clicked node (or one of its parents) is a actual item in this.items
      var currentItem = null, nodes = $(event.target).parents().each(function () {
        if ($.data(this, that.widgetName + '-item') == that) {
          currentItem = $(this);
          return false;
        }
      });
      if ($.data(event.target, that.widgetName + '-item') == that) currentItem = $(event.target);

      if (!currentItem) return false;
      if (this.options.handle && !overrideHandle) {
        var validHandle = false;

        $(this.options.handle, currentItem).find("*").andSelf().each(function () {
          if (this == event.target) validHandle = true;
        });
        if (!validHandle) return false;
      }

      this.currentItem = currentItem;
      this._removeCurrentsFromItems();
      return true;

    },

    _mouseStart: function (event, overrideHandle, noActivation) {

      var o = this.options;
      this.currentContainer = this;

      //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
      this.refreshPositions();

      //Create and append the visible helper
      this.helper = this._createHelper(event);

      //Cache the helper size
      this._cacheHelperProportions();

      /*
       * - Position generation -
       * This block generates everything position related - it's the core of draggables.
       */

      //Cache the margins of the original element
      this._cacheMargins();

      //Get the next scrolling parent
      this.scrollParent = this.helper.scrollParent();

      //The element's absolute position on the page minus margins
      this.offset = this.currentItem.offset();
      this.offset = {
        top: this.offset.top - this.margins.top,
        left: this.offset.left - this.margins.left
      };

      $.extend(this.offset, {
        click: { //Where the click happened, relative to the element
          left: event.pageX - this.offset.left,
          top: event.pageY - this.offset.top
        },
        parent: this._getParentOffset(),
        relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
      });

      // Only after we got the offset, we can change the helper's position to absolute
      // TODO: Still need to figure out a way to make relative sorting possible
      this.helper.css("position", "absolute");
      this.cssPosition = this.helper.css("position");

      //Generate the original position
      this.originalPosition = this._generatePosition(event);
      this.originalPageX = event.pageX;
      this.originalPageY = event.pageY;

      //Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
      (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

      //Cache the former DOM position
      this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

      //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
      if (this.helper[0] != this.currentItem[0]) {
        this.currentItem.hide();
      }

      //Create the placeholder
      this._createPlaceholder();

      //Set a containment if given in the options
      if (o.containment)
        this._setContainment();

      if (o.cursor) { // cursor option
        if ($('body').css("cursor")) this._storedCursor = $('body').css("cursor");
        $('body').css("cursor", o.cursor);
      }

      if (o.opacity) { // opacity option
        if (this.helper.css("opacity")) this._storedOpacity = this.helper.css("opacity");
        this.helper.css("opacity", o.opacity);
      }

      if (o.zIndex) { // zIndex option
        if (this.helper.css("zIndex")) this._storedZIndex = this.helper.css("zIndex");
        this.helper.css("zIndex", o.zIndex);
      }

      //Prepare scrolling
      if (this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML')
        this.overflowOffset = this.scrollParent.offset();

      //Call callbacks
      this._trigger("start", event, this._uiHash());

      //Recache the helper size
      if (!this._preserveHelperProportions)
        this._cacheHelperProportions();


      //Post 'activate' events to possible containers
      if (!noActivation) {
        for (var i = this.containers.length - 1; i >= 0; i--) {
          this.containers[i]._trigger("activate", event, this._uiHash(this));
        }
      }

      //Prepare possible droppables
      if ($.ui.ddmanager)
        $.ui.ddmanager.current = this;

      if ($.ui.ddmanager && !o.dropBehaviour)
        $.ui.ddmanager.prepareOffsets(this, event);

      this.dragging = true;

      this.helper.addClass("ui-sortable-helper");
      this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
      return true;

    },

    _mouseDrag: function (event) {

      //Compute the helpers position
      this.position = this._generatePosition(event);
      this.positionAbs = this._convertPositionTo("absolute");

      if (!this.lastPositionAbs) {
        this.lastPositionAbs = this.positionAbs;
      }

      //Do scrolling
      if (this.options.scroll) {
        var o = this.options, scrolled = false;
        if (this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML') {

          if ((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
          else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity)
            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;

          if ((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
          else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity)
            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;

        } else {

          if (event.pageY - $(document).scrollTop() < o.scrollSensitivity)
            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
          else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);

          if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
          else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);

        }

        if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
          $.ui.ddmanager.prepareOffsets(this, event);
      }

      //Regenerate the absolute position used for position checks
      this.positionAbs = this._convertPositionTo("absolute");

      //Set the helper position
      if (!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left + 'px';
      if (!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top + 'px';

      //Rearrange
      for (var i = this.items.length - 1; i >= 0; i--) {

        //Cache variables and intersection, continue if no intersection
        var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);
        if (!intersection) continue;

        // Only put the placeholder inside the current Container, skip all
        // items form other containers. This works because when moving
        // an item from one container to another the
        // currentContainer is switched before the placeholder is moved.
        //
        // Without this moving items in "sub-sortables" can cause the placeholder to jitter
        // beetween the outer and inner container.
        if (item.instance !== this.currentContainer) continue;

        if (itemElement != this.currentItem[0] //cannot intersect with itself
          && this.placeholder[intersection == 1 ? "next" : "prev"]()[0] != itemElement //no useless actions that have been done before
          && !$.contains(this.placeholder[0], itemElement) //no action if the item moved is the parent of the item checked
          && (this.options.type == 'semi-dynamic' ? !$.contains(this.element[0], itemElement) : true)
        //&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container
          ) {

          this.direction = intersection == 1 ? "down" : "up";

          if (this.options.tolerance == "pointer" || this._intersectsWithSides(item)) {
            this._rearrange(event, item);
          } else {
            break;
          }

          this._trigger("change", event, this._uiHash());
          break;
        }
      }

      //Post events to containers
      this._contactContainers(event);

      //Interconnect with droppables
      if ($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

      //Call callbacks
      this._trigger('sort', event, this._uiHash());

      this.lastPositionAbs = this.positionAbs;
      return false;

    },

    _mouseStop: function (event, noPropagation) {

      if (!event) return;

      //If we are using droppables, inform the manager about the drop
      if ($.ui.ddmanager && !this.options.dropBehaviour)
        $.ui.ddmanager.drop(this, event);

      if (this.options.revert) {
        var that = this;
        var cur = this.placeholder.offset();

        this.reverting = true;

        $(this.helper).animate({
          left: cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
          top: cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
        }, parseInt(this.options.revert, 10) || 500, function () {
          that._clear(event);
        });
      } else {
        this._clear(event, noPropagation);
      }

      return false;

    },

    /**
     *
     * Cancels a change in the current sortable and reverts it to the state prior to when the current sort was started.
     * Useful in the stop and receive callback functions.
     * @method
     * @return {jQuery}
     */
    cancel: function () {

      if (this.dragging) {

        this._mouseUp({ target: null });

        if (this.options.helper == "original")
          this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
        else
          this.currentItem.show();

        //Post deactivating events to containers
        for (var i = this.containers.length - 1; i >= 0; i--) {
          this.containers[i]._trigger("deactivate", null, this._uiHash(this));
          if (this.containers[i].containerCache.over) {
            this.containers[i]._trigger("out", null, this._uiHash(this));
            this.containers[i].containerCache.over = 0;
          }
        }

      }

      if (this.placeholder) {
        //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
        if (this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
        if (this.options.helper != "original" && this.helper && this.helper[0].parentNode) this.helper.remove();

        $.extend(this, {
          helper: null,
          dragging: false,
          reverting: false,
          _noFinalSort: null
        });

        if (this.domPosition.prev) {
          $(this.domPosition.prev).after(this.currentItem);
        } else {
          $(this.domPosition.parent).prepend(this.currentItem);
        }
      }

      return this;

    },

    /**
     * Serializes the sortable's item ids into a form/ajax submittable string. Calling this method produces a hash that can be appended to any url to easily submit a new item order back to the server.<br/>
     * It works by default by looking at the id of each item in the format "setname_number", and it spits out a hash like "setname[]=number&setname[]=number".
     *
     * Note: If serialize returns an empty string, make sure the id attributes include an underscore. They must be in the form: "set_number" For example, a 3 element list with id attributes "foo_1", "foo_5", "foo_2" will serialize to "foo[]=1&foo[]=5&foo[]=2". You can use an underscore, equal sign or hyphen to separate the set and number. For example "foo=1", "foo-1", and "foo_1" all serialize to "foo[]=1".
     * @method
     * @param {Object} o Options to customize the serialization.
     * @param {String} o.key Replaces part1[] with the specified value.(default: the part of the attribute in front of the separator)
     * @param {String} o.attribute The name of the attribute to use for the values.(default: "id")
     * @param {RegExp} o.expression A regular expression used to split the attribute value into key and value parts. (default: /(.+)[-=_](.+)/)
     * @returns {string}
     */
    serialize: function (o) {

      var items = this._getItemsAsjQuery(o && o.connected);
      var str = [];
      o = o || {};

      $(items).each(function () {
        var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/));
        if (res) str.push((o.key || res[1] + '[]') + '=' + (o.key && o.expression ? res[1] : res[2]));
      });

      if (!str.length && o.key) {
        str.push(o.key + '=');
      }

      return str.join('&');

    },
    /**
     * Serializes the sortable's item id's into an array of string.
     * @method
     * @param {Object} options Options to customize the serialization.
     * @param {String} options.attribute The name of the attribute to use for the values (default: "id")
     *
     * @return {Array}
     */
    toArray: function (o) {

      var items = this._getItemsAsjQuery(o && o.connected);
      var ret = [];
      o = o || {};

      items.each(function () {
        ret.push($(o.item || this).attr(o.attribute || 'id') || '');
      });
      return ret;

    },

    /* Be careful with the following core functions */
    _intersectsWith: function (item) {

      var x1 = this.positionAbs.left,
          x2 = x1 + this.helperProportions.width,
          y1 = this.positionAbs.top,
          y2 = y1 + this.helperProportions.height;

      var l = item.left,
          r = l + item.width,
          t = item.top,
          b = t + item.height;

      var dyClick = this.offset.click.top,
          dxClick = this.offset.click.left;

      var isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;

      if (this.options.tolerance == "pointer"
        || this.options.forcePointerForContainers
        || (this.options.tolerance != "pointer" && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height'])
        ) {
        return isOverElement;
      } else {

        return (l < x1 + (this.helperProportions.width / 2) // Right Half
          && x2 - (this.helperProportions.width / 2) < r // Left Half
          && t < y1 + (this.helperProportions.height / 2) // Bottom Half
          && y2 - (this.helperProportions.height / 2) < b ); // Top Half

      }
    },

    _intersectsWithPointer: function (item) {

      var isOverElementHeight = (this.options.axis === 'x') || $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
          isOverElementWidth = (this.options.axis === 'y') || $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
          isOverElement = isOverElementHeight && isOverElementWidth,
          verticalDirection = this._getDragVerticalDirection(),
          horizontalDirection = this._getDragHorizontalDirection();

      if (!isOverElement)
        return false;

      return this.floating ?
        ( ((horizontalDirection && horizontalDirection == "right") || verticalDirection == "down") ? 2 : 1 )
        : ( verticalDirection && (verticalDirection == "down" ? 2 : 1) );

    },

    _intersectsWithSides: function (item) {

      var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height / 2), item.height),
          isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width / 2), item.width),
          verticalDirection = this._getDragVerticalDirection(),
          horizontalDirection = this._getDragHorizontalDirection();

      if (this.floating && horizontalDirection) {
        return ((horizontalDirection == "right" && isOverRightHalf) || (horizontalDirection == "left" && !isOverRightHalf));
      } else {
        return verticalDirection && ((verticalDirection == "down" && isOverBottomHalf) || (verticalDirection == "up" && !isOverBottomHalf));
      }

    },

    _getDragVerticalDirection: function () {
      var delta = this.positionAbs.top - this.lastPositionAbs.top;
      return delta != 0 && (delta > 0 ? "down" : "up");
    },

    _getDragHorizontalDirection: function () {
      var delta = this.positionAbs.left - this.lastPositionAbs.left;
      return delta != 0 && (delta > 0 ? "right" : "left");
    },

    /**
     * Refresh the sortable items. Triggers the reloading of all sortable items, causing new items to be recognized.
     * @method
     * @param {Event} event event
     * @return {jQuery}
     */
    refresh: function (event) {
      this._refreshItems(event);
      this.refreshPositions();
      return this;
    },

    _connectWith: function () {
      var options = this.options;
      return options.connectWith.constructor == String
        ? [options.connectWith]
        : options.connectWith;
    },

    _getItemsAsjQuery: function (connected) {

      var items = [];
      var queries = [];
      var connectWith = this._connectWith();

      if (connectWith && connected) {
        for (var i = connectWith.length - 1; i >= 0; i--) {
          var cur = $(connectWith[i]);
          for (var j = cur.length - 1; j >= 0; j--) {
            var inst = $.data(cur[j], this.widgetName);
            if (inst && inst != this && !inst.options.disabled) {
              queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), inst]);
            }
          }
          ;
        }
        ;
      }

      queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), this]);

      for (var i = queries.length - 1; i >= 0; i--) {
        queries[i][0].each(function () {
          items.push(this);
        });
      }
      ;

      return $(items);

    },

    _removeCurrentsFromItems: function () {

      var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

      this.items = $.grep(this.items, function (item) {
        for (var j = 0; j < list.length; j++) {
          if (list[j] == item.item[0])
            return false;
        }
        ;
        return true;
      });

    },

    _refreshItems: function (event) {

      this.items = [];
      this.containers = [this];
      var items = this.items;
      var queries = [
        [$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]
      ];
      var connectWith = this._connectWith();

      if (connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
        for (var i = connectWith.length - 1; i >= 0; i--) {
          var cur = $(connectWith[i]);
          for (var j = cur.length - 1; j >= 0; j--) {
            var inst = $.data(cur[j], this.widgetName);
            if (inst && inst != this && !inst.options.disabled) {
              queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
              this.containers.push(inst);
            }
          }
          ;
        }
        ;
      }

      for (var i = queries.length - 1; i >= 0; i--) {
        var targetData = queries[i][1];
        var _queries = queries[i][0];

        for (var j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
          var item = $(_queries[j]);

          item.data(this.widgetName + '-item', targetData); // Data for target checking (mouse manager)

          items.push({
            item: item,
            instance: targetData,
            width: 0, height: 0,
            left: 0, top: 0
          });
        }
        ;
      }
      ;

    },

    /**
     * Refresh the cached positions of the sortable items. Calling this method refreshes the cached item positions of all sortables.
     * @method
     * @return {jQuery}
     */
    refreshPositions: function (fast) {

      //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
      if (this.offsetParent && this.helper) {
        this.offset.parent = this._getParentOffset();
      }

      for (var i = this.items.length - 1; i >= 0; i--) {
        var item = this.items[i];

        //We ignore calculating positions of all connected containers when we're not over them
        if (item.instance != this.currentContainer && this.currentContainer && item.item[0] != this.currentItem[0])
          continue;

        var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

        if (!fast) {
          item.width = t.outerWidth();
          item.height = t.outerHeight();
        }

        var p = t.offset();
        item.left = p.left;
        item.top = p.top;
      }
      ;

      if (this.options.custom && this.options.custom.refreshContainers) {
        this.options.custom.refreshContainers.call(this);
      } else {
        for (var i = this.containers.length - 1; i >= 0; i--) {
          var p = this.containers[i].element.offset();
          this.containers[i].containerCache.left = p.left;
          this.containers[i].containerCache.top = p.top;
          this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
          this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
        }
        ;
      }

      return this;
    },

    _createPlaceholder: function (that) {
      that = that || this;
      var o = that.options;

      if (!o.placeholder || o.placeholder.constructor == String) {
        var className = o.placeholder;
        o.placeholder = {
          element: function () {

            var el = $(document.createElement(that.currentItem[0].nodeName))
              .addClass(className || that.currentItem[0].className + " ui-sortable-placeholder")
              .removeClass("ui-sortable-helper")[0];

            if (!className)
              el.style.visibility = "hidden";

            return el;
          },
          update: function (container, p) {

            // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
            // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
            if (className && !o.forcePlaceholderSize) return;

            //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
            if (!p.height()) {
              p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css('paddingTop') || 0, 10) - parseInt(that.currentItem.css('paddingBottom') || 0, 10));
            }
            ;
            if (!p.width()) {
              p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css('paddingLeft') || 0, 10) - parseInt(that.currentItem.css('paddingRight') || 0, 10));
            }
            ;
          }
        };
      }

      //Create the placeholder
      that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

      //Append it after the actual current item
      that.currentItem.after(that.placeholder);

      //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
      o.placeholder.update(that, that.placeholder);

    },

    _contactContainers: function (event) {

      // get innermost container that intersects with item
      var innermostContainer = null, innermostIndex = null;


      for (var i = this.containers.length - 1; i >= 0; i--) {

        // never consider a container that's located within the item itself
        if ($.contains(this.currentItem[0], this.containers[i].element[0]))
          continue;

        if (this._intersectsWith(this.containers[i].containerCache)) {

          // if we've already found a container and it's more "inner" than this, then continue
          if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0]))
            continue;

          innermostContainer = this.containers[i];
          innermostIndex = i;

        } else {
          // container doesn't intersect. trigger "out" event if necessary
          if (this.containers[i].containerCache.over) {
            this.containers[i]._trigger("out", event, this._uiHash(this));
            this.containers[i].containerCache.over = 0;
          }
        }

      }

      // if no intersecting containers found, return
      if (!innermostContainer) return;

      // move the item into the container if it's not there already
      if (this.containers.length === 1) {
        this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
        this.containers[innermostIndex].containerCache.over = 1;
      } else {

        //When entering a new container, we will find the item with the least distance and append our item near it
        var dist = 10000;
        var itemWithLeastDistance = null;
        var posProperty = this.containers[innermostIndex].floating ? 'left' : 'top';
        var sizeProperty = this.containers[innermostIndex].floating ? 'width' : 'height';
        var base = this.positionAbs[posProperty] + this.offset.click[posProperty];
        for (var j = this.items.length - 1; j >= 0; j--) {
          if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue;
          if (this.items[j].item[0] == this.currentItem[0]) continue;
          var cur = this.items[j].item.offset()[posProperty];
          var nearBottom = false;
          if (Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)) {
            nearBottom = true;
            cur += this.items[j][sizeProperty];
          }

          if (Math.abs(cur - base) < dist) {
            dist = Math.abs(cur - base);
            itemWithLeastDistance = this.items[j];
            this.direction = nearBottom ? "up" : "down";
          }
        }

        if (!itemWithLeastDistance && !this.options.dropOnEmpty) //Check if dropOnEmpty is enabled
          return;

        this.currentContainer = this.containers[innermostIndex];
        itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
        this._trigger("change", event, this._uiHash());
        this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));

        //Update the placeholder
        this.options.placeholder.update(this.currentContainer, this.placeholder);

        this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
        this.containers[innermostIndex].containerCache.over = 1;
      }


    },

    _createHelper: function (event) {

      var o = this.options;
      var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == 'clone' ? this.currentItem.clone() : this.currentItem);

      if (!helper.parents('body').length) //Add the helper to the DOM if that didn't happen already
        $(o.appendTo != 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);

      if (helper[0] == this.currentItem[0])
        this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };

      if (helper[0].style.width == '' || o.forceHelperSize) helper.width(this.currentItem.width());
      if (helper[0].style.height == '' || o.forceHelperSize) helper.height(this.currentItem.height());

      return helper;

    },

    _adjustOffsetFromHelper: function (obj) {
      if (typeof obj == 'string') {
        obj = obj.split(' ');
      }
      if ($.isArray(obj)) {
        obj = {left: +obj[0], top: +obj[1] || 0};
      }
      if ('left' in obj) {
        this.offset.click.left = obj.left + this.margins.left;
      }
      if ('right' in obj) {
        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
      }
      if ('top' in obj) {
        this.offset.click.top = obj.top + this.margins.top;
      }
      if ('bottom' in obj) {
        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
      }
    },

    _getParentOffset: function () {


      //Get the offsetParent and cache its position
      this.offsetParent = this.helper.offsetParent();
      var po = this.offsetParent.offset();

      // This is a special case where we need to modify a offset calculated on start, since the following happened:
      // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
      // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
      //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
      if (this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
        po.left += this.scrollParent.scrollLeft();
        po.top += this.scrollParent.scrollTop();
      }

      if ((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
        || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.ui.ie)) //Ugly IE fix
        po = { top: 0, left: 0 };

      return {
        top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
        left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
      };

    },

    _getRelativeOffset: function () {

      if (this.cssPosition == "relative") {
        var p = this.currentItem.position();
        return {
          top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
          left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
        };
      } else {
        return { top: 0, left: 0 };
      }

    },

    _cacheMargins: function () {
      this.margins = {
        left: (parseInt(this.currentItem.css("marginLeft"), 10) || 0),
        top: (parseInt(this.currentItem.css("marginTop"), 10) || 0)
      };
    },

    _cacheHelperProportions: function () {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight()
      };
    },

    _setContainment: function () {

      var o = this.options;
      if (o.containment == 'parent') o.containment = this.helper[0].parentNode;
      if (o.containment == 'document' || o.containment == 'window') this.containment = [
          0 - this.offset.relative.left - this.offset.parent.left,
          0 - this.offset.relative.top - this.offset.parent.top,
          $(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
          ($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
      ];

      if (!(/^(document|window|parent)$/).test(o.containment)) {
        var ce = $(o.containment)[0];
        var co = $(o.containment).offset();
        var over = ($(ce).css("overflow") != 'hidden');

        this.containment = [
            co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left,
            co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top,
            co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left,
            co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top
        ];
      }

    },

    _convertPositionTo: function (d, pos) {

      if (!pos) pos = this.position;
      var mod = d == "absolute" ? 1 : -1;
      var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

      return {
        top: (
          pos.top																	// The absolute mouse position
          + this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
          + this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
          - ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
          ),
        left: (
          pos.left																// The absolute mouse position
          + this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
          + this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
          - ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
          )
      };

    },

    _generatePosition: function (event) {

      var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

      // This is another very weird special case that only happens for relative elements:
      // 1. If the css position is relative
      // 2. and the scroll parent is the document or similar to the offset parent
      // we have to refresh the relative offset during the scroll so there are no jumps
      if (this.cssPosition == 'relative' && !(this.scrollParent[0] != document && this.scrollParent[0] != this.offsetParent[0])) {
        this.offset.relative = this._getRelativeOffset();
      }

      var pageX = event.pageX;
      var pageY = event.pageY;

      /*
       * - Position constraining -
       * Constrain the position to a mix of grid, containment.
       */

      if (this.originalPosition) { //If we are not dragging yet, we won't check for options

        if (this.containment) {
          if (event.pageX - this.offset.click.left < this.containment[0]) pageX = this.containment[0] + this.offset.click.left;
          if (event.pageY - this.offset.click.top < this.containment[1]) pageY = this.containment[1] + this.offset.click.top;
          if (event.pageX - this.offset.click.left > this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
          if (event.pageY - this.offset.click.top > this.containment[3]) pageY = this.containment[3] + this.offset.click.top;
        }

        if (o.grid) {
          var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
          pageY = this.containment ? (!(top - this.offset.click.top < this.containment[1] || top - this.offset.click.top > this.containment[3]) ? top : (!(top - this.offset.click.top < this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

          var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
          pageX = this.containment ? (!(left - this.offset.click.left < this.containment[0] || left - this.offset.click.left > this.containment[2]) ? left : (!(left - this.offset.click.left < this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
        }

      }

      return {
        top: (
          pageY																// The absolute mouse position
          - this.offset.click.top													// Click offset (relative to the element)
          - this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
          - this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
          + ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
          ),
        left: (
          pageX																// The absolute mouse position
          - this.offset.click.left												// Click offset (relative to the element)
          - this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
          - this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
          + ( ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
          )
      };

    },

    _rearrange: function (event, i, a, hardRefresh) {

      a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == 'down' ? i.item[0] : i.item[0].nextSibling));

      //Various things done here to improve the performance:
      // 1. we create a setTimeout, that calls refreshPositions
      // 2. on the instance, we have a counter variable, that get's higher after every append
      // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
      // 4. this lets only the last addition to the timeout stack through
      this.counter = this.counter ? ++this.counter : 1;
      var counter = this.counter;

      this._delay(function () {
        if (counter == this.counter) this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
      });

    },

    _clear: function (event, noPropagation) {

      this.reverting = false;
      // We delay all events that have to be triggered to after the point where the placeholder has been removed and
      // everything else normalized again
      var delayedTriggers = [];

      // We first have to update the dom position of the actual currentItem
      // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
      if (!this._noFinalSort && this.currentItem.parent().length) this.placeholder.before(this.currentItem);
      this._noFinalSort = null;

      if (this.helper[0] == this.currentItem[0]) {
        for (var i in this._storedCSS) {
          if (this._storedCSS[i] == 'auto' || this._storedCSS[i] == 'static') this._storedCSS[i] = '';
        }
        this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
      } else {
        this.currentItem.show();
      }

      if (this.fromOutside && !noPropagation) delayedTriggers.push(function (event) {
        this._trigger("receive", event, this._uiHash(this.fromOutside));
      });
      if ((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !noPropagation) delayedTriggers.push(function (event) {
        this._trigger("update", event, this._uiHash());
      }); //Trigger update callback if the DOM position has changed

      // Check if the items Container has Changed and trigger appropriate
      // events.
      if (this !== this.currentContainer) {
        if (!noPropagation) {
          delayedTriggers.push(function (event) {
            this._trigger("remove", event, this._uiHash());
          });
          delayedTriggers.push((function (c) {
            return function (event) {
              c._trigger("receive", event, this._uiHash(this));
            };
          }).call(this, this.currentContainer));
          delayedTriggers.push((function (c) {
            return function (event) {
              c._trigger("update", event, this._uiHash(this));
            };
          }).call(this, this.currentContainer));
        }
      }


      //Post events to containers
      for (var i = this.containers.length - 1; i >= 0; i--) {
        if (!noPropagation) delayedTriggers.push((function (c) {
          return function (event) {
            c._trigger("deactivate", event, this._uiHash(this));
          };
        }).call(this, this.containers[i]));
        if (this.containers[i].containerCache.over) {
          delayedTriggers.push((function (c) {
            return function (event) {
              c._trigger("out", event, this._uiHash(this));
            };
          }).call(this, this.containers[i]));
          this.containers[i].containerCache.over = 0;
        }
      }

      //Do what was originally in plugins
      if (this._storedCursor) $('body').css("cursor", this._storedCursor); //Reset cursor
      if (this._storedOpacity) this.helper.css("opacity", this._storedOpacity); //Reset opacity
      if (this._storedZIndex) this.helper.css("zIndex", this._storedZIndex == 'auto' ? '' : this._storedZIndex); //Reset z-index

      this.dragging = false;
      if (this.cancelHelperRemoval) {
        if (!noPropagation) {
          this._trigger("beforeStop", event, this._uiHash());
          for (var i = 0; i < delayedTriggers.length; i++) {
            delayedTriggers[i].call(this, event);
          }
          ; //Trigger all delayed events
          this._trigger("stop", event, this._uiHash());
        }

        this.fromOutside = false;
        return false;
      }

      if (!noPropagation) this._trigger("beforeStop", event, this._uiHash());

      //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
      this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

      if (this.helper[0] != this.currentItem[0]) this.helper.remove();
      this.helper = null;

      if (!noPropagation) {
        for (var i = 0; i < delayedTriggers.length; i++) {
          delayedTriggers[i].call(this, event);
        }
        ; //Trigger all delayed events
        this._trigger("stop", event, this._uiHash());
      }

      this.fromOutside = false;
      return true;

    },

    _trigger: function () {
      if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
        this.cancel();
      }
    },

    _uiHash: function (_inst) {
      var inst = _inst || this;
      return {
        helper: inst.helper,
        placeholder: inst.placeholder || $([]),
        position: inst.position,
        originalPosition: inst.originalPosition,
        offset: inst.positionAbs,
        item: inst.currentItem,
        sender: _inst ? _inst.element : null
      };
    }

  });

})(jQuery);

/**
 * @event activate
 * This event is triggered when using connected lists, every connected list on drag start receives it.
 * @param {Event} event event
 * @param {Object} ui ui Object
 * @param {jQuery} ui.helper The jQuery object representing the helper being sorted
 * @param {jQuery} ui.item The jQuery object representing the current dragged element
 * @param {Object} ui.offset The current absolute position of the helper represented as { top, left }
 * @param {Object} ui.position The current position of the helper represented as { top, left }
 * @param {Object} ui.originalPosition The original position of the element represented as { top, left }
 * @param {jQuery} ui.sender The sortable that the item comes from if moving from one sortable to another
 */

/**
 * @event beforeStop
 * This event is triggered when sorting stops, but when the placeholder/helper is still available.
 * @param {Event} event event
 * @param {Object} ui ui Object
 * @param {jQuery} ui.helper The jQuery object representing the helper being sorted
 * @param {jQuery} ui.item The jQuery object representing the current dragged element
 * @param {Object} ui.offset The current absolute position of the helper represented as { top, left }
 * @param {Object} ui.position The current position of the helper represented as { top, left }
 * @param {Object} ui.originalPosition The original position of the element represented as { top, left }
 * @param {jQuery} ui.sender The sortable that the item comes from if moving from one sortable to another
 */

/**
 * @event change
 * This event is triggered during sorting, but only when the DOM position has changed.
 * @param {Event} event event
 * @param {Object} ui ui Object
 * @param {jQuery} ui.helper The jQuery object representing the helper being sorted
 * @param {jQuery} ui.item The jQuery object representing the current dragged element
 * @param {Object} ui.offset The current absolute position of the helper represented as { top, left }
 * @param {Object} ui.position The current position of the helper represented as { top, left }
 * @param {Object} ui.originalPosition The original position of the element represented as { top, left }
 * @param {jQuery} ui.sender The sortable that the item comes from if moving from one sortable to another
 */

/**
 * @event deactivate
 * This event is triggered when sorting was stopped, is propagated to all possible connected lists.
 * @param {Event} event event
 * @param {Object} ui ui Object
 * @param {jQuery} ui.helper The jQuery object representing the helper being sorted
 * @param {jQuery} ui.item The jQuery object representing the current dragged element
 * @param {Object} ui.offset The current absolute position of the helper represented as { top, left }
 * @param {Object} ui.position The current position of the helper represented as { top, left }
 * @param {Object} ui.originalPosition The original position of the element represented as { top, left }
 * @param {jQuery} ui.sender The sortable that the item comes from if moving from one sortable to another
 */

/**
 * @event out
 * This event is triggered when a sortable item is moved away from a connected list.
 * @param {Event} event event
 * @param {Object} ui ui Object
 * @param {jQuery} ui.helper The jQuery object representing the helper being sorted
 * @param {jQuery} ui.item The jQuery object representing the current dragged element
 * @param {Object} ui.offset The current absolute position of the helper represented as { top, left }
 * @param {Object} ui.position The current position of the helper represented as { top, left }
 * @param {Object} ui.originalPosition The original position of the element represented as { top, left }
 * @param {jQuery} ui.sender The sortable that the item comes from if moving from one sortable to another
 */

/**
 * @event over
 * This event is triggered when a sortable item is moved into a connected list.
 * @param {Event} event event
 * @param {Object} ui ui Object
 * @param {jQuery} ui.helper The jQuery object representing the helper being sorted
 * @param {jQuery} ui.item The jQuery object representing the current dragged element
 * @param {Object} ui.offset The current absolute position of the helper represented as { top, left }
 * @param {Object} ui.position The current position of the helper represented as { top, left }
 * @param {Object} ui.originalPosition The original position of the element represented as { top, left }
 * @param {jQuery} ui.sender The sortable that the item comes from if moving from one sortable to another
 */

/**
 * @event receive
 * This event is triggered when an item from a connected sortable list has been dropped into another list. The latter is the event target.
 * @param {Event} event event
 * @param {Object} ui ui Object
 * @param {jQuery} ui.helper The jQuery object representing the helper being sorted
 * @param {jQuery} ui.item The jQuery object representing the current dragged element
 * @param {Object} ui.offset The current absolute position of the helper represented as { top, left }
 * @param {Object} ui.position The current position of the helper represented as { top, left }
 * @param {Object} ui.originalPosition The original position of the element represented as { top, left }
 * @param {jQuery} ui.sender The sortable that the item comes from if moving from one sortable to another
 */
/**
 * @event remove
 * This event is triggered when a sortable item from the list has been dropped into another. The former is the event target.
 * @param {Event} event event
 * @param {Object} ui ui Object
 * @param {jQuery} ui.helper The jQuery object representing the helper being sorted
 * @param {jQuery} ui.item The jQuery object representing the current dragged element
 * @param {Object} ui.offset The current absolute position of the helper represented as { top, left }
 * @param {Object} ui.position The current position of the helper represented as { top, left }
 * @param {Object} ui.originalPosition The original position of the element represented as { top, left }
 * @param {jQuery} ui.sender The sortable that the item comes from if moving from one sortable to another
 */

/**
 * @event sort This event is triggered during sorting.
 * @param {Event} event event
 * @param {Object} ui ui Object
 * @param {jQuery} ui.helper The jQuery object representing the helper being sorted
 * @param {jQuery} ui.item The jQuery object representing the current dragged element
 * @param {Object} ui.offset The current absolute position of the helper represented as { top, left }
 * @param {Object} ui.position The current position of the helper represented as { top, left }
 * @param {Object} ui.originalPosition The original position of the element represented as { top, left }
 * @param {jQuery} ui.sender The sortable that the item comes from if moving from one sortable to another
 */


/**
 * @event start  This event is triggered when sorting starts.
 * @param {Event} event event
 * @param {Object} ui ui Object
 * @param {jQuery} ui.helper The jQuery object representing the helper being sorted
 * @param {jQuery} ui.item The jQuery object representing the current dragged element
 * @param {Object} ui.offset The current absolute position of the helper represented as { top, left }
 * @param {Object} ui.position The current position of the helper represented as { top, left }
 * @param {Object} ui.originalPosition The original position of the element represented as { top, left }
 * @param {jQuery} ui.sender The sortable that the item comes from if moving from one sortable to another
 */

/**
 * @event stop  This event is triggered when sorting has stopped.
 * @param {Event} event event
 * @param {Object} ui ui Object
 * @param {jQuery} ui.helper The jQuery object representing the helper being sorted
 * @param {jQuery} ui.item The jQuery object representing the current dragged element
 * @param {Object} ui.offset The current absolute position of the helper represented as { top, left }
 * @param {Object} ui.position The current position of the helper represented as { top, left }
 * @param {Object} ui.originalPosition The original position of the element represented as { top, left }
 * @param {jQuery} ui.sender The sortable that the item comes from if moving from one sortable to another
 */

/**
 * @event update  This event is triggered when sorting has stopped.
 * @param {Event} event event
 * @param {Object} ui ui Object
 * @param {jQuery} ui.helper The jQuery object representing the helper being sorted
 * @param {jQuery} ui.item The jQuery object representing the current dragged element
 * @param {Object} ui.offset The current absolute position of the helper represented as { top, left }
 * @param {Object} ui.position The current position of the helper represented as { top, left }
 * @param {Object} ui.originalPosition The original position of the element represented as { top, left }
 * @param {jQuery} ui.sender The sortable that the item comes from if moving from one sortable to another
 */
/*!
 * jQuery UI Effects 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/effects-core/
 */


/**
 * Effect Function
 * @class fish.desktop.uicore.Effect
 * <pre>
 *   $(element).show({effect: "slideDown"});
 *   或者
 *   $(element).effect(effectMethod, options, speed, callback );
 * </pre>
 */


;(jQuery.effects || (function($, undefined) {

var backCompat = $.uiBackCompat !== false,
	// prefix used for storing data on .data()
	dataSpace = "ui-effects-";

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.0.0
 * http://jquery.com/
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Mon Aug 13 13:41:02 2012 -0500
 */
(function( jQuery, undefined ) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor".split(" "),

	// plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	// a set of RE's that can match strings and generate color tuples.
	stringParsers = [{
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		}],

	// jQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// element for support tests
	supportElem = jQuery( "<p>" )[ 0 ],

	// colors = jQuery.Color.names
	colors,

	// local aliases of functions called often
	each = jQuery.each;

// determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = "_" + spaceName;
	space.props.alpha = {
		idx: 3,
		type: "percent",
		def: 1
	};
});

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return (allowEmpty || !prop.def) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {
		// we add mod before modding to make sure that negatives values
		// get converted properly: -10 -> 350
		return (value + type.mod) % type.mod;
	}

	// for now all property types without mod have min and max
	return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match && parser.parse( match ),
			spaceName = parser.space || "rgba";

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// if this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// exit each( stringParsers ) here because we matched
			return false;
		}
	});

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// if this came from a parsed string, force "transparent" when alpha is 0
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
		if ( rgba.join() === "0,0,0,0" ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// more than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = "array";
		}

		if ( type === "string" ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === "array" ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			});
			return this;
		}

		if ( type === "object" ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				});
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// if the cache doesn't exist, and we know how to convert
						if ( !inst[ cache ] && space.to ) {

							// if the value was null, we don't need to copy it
							// if the key was alpha, we don't need to copy it either
							if ( key === "alpha" || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// this is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					});

					// everything defined but alpha?
					if ( inst[ cache ] && $.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
						// use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				});
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if (isCache) {
				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				});
			}
			return same;
		});
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		});
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( "transparent" ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// if null, don't override start value
			if ( endValue === null ) {
				return;
			}
			// if null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue > type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue > type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		});
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {
		// if we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		}));
	},
	toRgbaString: function() {
		var prefix = "rgba(",
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i > 2 ? 1 : 0 ) : v;
			});

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = "rgb(";
		}

		return prefix + rgba.join() + ")";
	},
	toHslaString: function() {
		var prefix = "hsla(",
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i > 2 ? 1 : 0;
				}

				// catch 1 and 2
				if ( i && i < 3 ) {
					v = Math.round( v * 100 ) + "%";
				}
				return v;
			});

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = "hsl(";
		}
		return prefix + hsla.join() + ")";
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return "#" + jQuery.map( rgba, function( v ) {

			// default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? "0" + v : v;
		}).join("");
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
	}
});
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 < 1 ) {
		return p + (q - p) * h * 6;
	}
	if ( h * 2 < 1) {
		return q;
	}
	if ( h * 3 < 2 ) {
		return p + (q - p) * ((2/3) - h) * 6;
	}
	return p;
}

spaces.hsla.to = function ( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	if ( l === 0 || l === 1 ) {
		s = l;
	} else if ( l <= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function ( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};


each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// generate a cache for this space if it doesn't exist
		if ( to && !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === "array" || type === "object" ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === "object" ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		});

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {
		// alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === "undefined" ) {
				return cur;
			}

			if ( vtype === "function" ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null && prop.empty ) {
				return this;
			}
			if ( vtype === "string" ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	});
});

// add .fx.step functions
each( stepHooks, function( i, hook ) {
	jQuery.cssHooks[ hook ] = {
		set: function( elem, value ) {
			var parsed, curElem,
				backgroundColor = "";

			if ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) {
				value = color( parsed || value );
				if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
					curElem = hook === "backgroundColor" ? elem.parentNode : elem;
					while (
						(backgroundColor === "" || backgroundColor === "transparent") &&
						curElem && curElem.style
					) {
						try {
							backgroundColor = jQuery.css( curElem, "backgroundColor" );
							curElem = curElem.parentNode;
						} catch ( e ) {
						}
					}

					value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
						backgroundColor :
						"_default" );
				}

				value = value.toRgbaString();
			}
			try {
				elem.style[ hook ] = value;
			} catch( error ) {
				// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
			}
		}
	};
	jQuery.fx.step[ hook ] = function( fx ) {
		if ( !fx.colorInit ) {
			fx.start = color( fx.elem, hook );
			fx.end = color( fx.end );
			fx.colorInit = true;
		}
		jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
	};
});

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
			expanded[ "border" + part + "Color" ] = value;
		});
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {
	// 4.1. Basic color keywords
	aqua: "#00ffff",
	black: "#000000",
	blue: "#0000ff",
	fuchsia: "#ff00ff",
	gray: "#808080",
	green: "#008000",
	lime: "#00ff00",
	maroon: "#800000",
	navy: "#000080",
	olive: "#808000",
	purple: "#800080",
	red: "#ff0000",
	silver: "#c0c0c0",
	teal: "#008080",
	white: "#ffffff",
	yellow: "#ffff00",

	// 4.2.3. "transparent" color keyword
	transparent: [ null, null, null, 0 ],

	_default: "#ffffff"
};

})( jQuery );



/*CLASS ANIMATIONS*/
(function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
	$.fx.step[ prop ] = function( fx ) {
		if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
			jQuery.style( fx.elem, prop, fx.end );
			fx.setAttr = true;
		}
	};
});

function getElementStyles() {
	var style = this.ownerDocument.defaultView ?
			this.ownerDocument.defaultView.getComputedStyle( this, null ) :
			this.currentStyle,
		newStyle = {},
		key,
		len;

	// webkit enumerates style porperties
	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === "string" ) {
				newStyle[ $.camelCase( key ) ] = style[ key ];
			}
		}
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === "string" ) {
				newStyle[ key ] = style[ key ];
			}
		}
	}

	return newStyle;
}


function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( "class" ) || "",
			applyClassChange,
			allAnimations = o.children ? animated.find( "*" ).andSelf() : animated;

		// map the animated objects to store the original styles.
		allAnimations = allAnimations.map(function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles.call( this )
			};
		});

		// apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function(i, action) {
				if ( value[ action ] ) {
					animated[ action + "Class" ]( value[ action ] );
				}
			});
		};
		applyClassChange();

		// map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map(function() {
			this.end = getElementStyles.call( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		});

		// apply original class
		animated.attr( "class", baseClass );

		// map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map(function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = jQuery.extend({}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				});

			this.el.animate( this.diff, opts );
			return dfd.promise();
		});

		// once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done(function() {

			// set the final class
			applyClassChange();

			// for each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function(key) {
					el.css( key, '' );
				});
			});

			// this is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		});
	});
};

$.fn.extend({
	_addClass: $.fn.addClass,
	/**
	 * @method addClass 扩展了JQuery的addClass方法，当往元素增加一个css样式的时候，允许实现动画效果，包括文本缩进、字母间隔、宽度、高度、内外补丁、字体大小。
	 * @param {String}  classNames
	 * @param {Object}   [duration]
	 */
	addClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ add: classNames }, speed, easing, callback ) :
			this._addClass( classNames );
	},

	_removeClass: $.fn.removeClass,
	/**
	 * @method removeClass 扩展了JQuery的removeClass方法，当往元素移除一个css样式的时候，允许实现动画效果，包括文本缩进、字母间隔、宽度、高度、内外补丁、字体大小。
	 * @param {String}  classNames
	 * @param {Object}   [duration]
	 */
	removeClass: function( classNames, speed, easing, callback ) {
		return speed ?
			$.effects.animateClass.call( this,
				{ remove: classNames }, speed, easing, callback ) :
			this._removeClass( classNames );
	},

	_toggleClass: $.fn.toggleClass,
	/**
	 * @method toggleClass 扩展了JQuery的toggleClass方法，当启用和禁用样式时，允许执行动画效果。
	 * @param {String}  classNames
	 * @param {Object}   [duration]
	 */
	toggleClass: function( classNames, force, speed, easing, callback ) {
		if ( typeof force === "boolean" || force === undefined ) {
			if ( !speed ) {
				// without speed parameter
				return this._toggleClass( classNames, force );
			} else {
				return $.effects.animateClass.call( this,
					(force ? { add: classNames } : { remove: classNames }),
					speed, easing, callback );
			}
		} else {
			// without force parameter
			return $.effects.animateClass.call( this,
				{ toggle: classNames }, force, speed, easing );
		}
	},
	/**
	 * @method switchClass 扩展了JQuery的switchClass方法，当切换调用两个函数时，允许执行动画效果。
	 * @param {String}  classNames
	 * @param {Object}   [duration]
	 */
	switchClass: function( remove, add, speed, easing, callback) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
});

})();

/*EFFECTS*/

(function() {

$.extend( $.effects, {
	version: "1.9.2",

	// Saves a set of properties in a data storage
	save: function( element, set ) {
		for( var i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
			}
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function( element, set ) {
		var val, i;
		for( i=0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				val = element.data( dataSpace + set[ i ] );
				// support: jQuery 1.6.2
				// http://bugs.jquery.com/ticket/9917
				// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
				// We can't differentiate between "" and 0 here, so we just assume
				// empty string since it's likely to be a more common value...
				if ( val === undefined ) {
					val = "";
				}
				element.css( set[ i ], val );
			}
		}
	},

	setMode: function( el, mode ) {
		if (mode === "toggle") {
			mode = el.is( ":hidden" ) ? "show" : "hide";
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	// this should be a little more flexible in the future to handle a string & hash
	getBaseline: function( origin, original ) {
		var y, x;
		switch ( origin[ 0 ] ) {
			case "top": y = 0; break;
			case "middle": y = 0.5; break;
			case "bottom": y = 1; break;
			default: y = origin[ 0 ] / original.height;
		}
		switch ( origin[ 1 ] ) {
			case "left": x = 0; break;
			case "center": x = 0.5; break;
			case "right": x = 1; break;
			default: x = origin[ 1 ] / original.width;
		}
		return {
			x: x,
			y: y
		};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function( element ) {

		// if the element is already wrapped, return it
		if ( element.parent().is( ".ui-effects-wrapper" )) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				"float": element.css( "float" )
			},
			wrapper = $( "<div></div>" )
				.addClass( "ui-effects-wrapper" )
				.css({
					fontSize: "100%",
					background: "transparent",
					border: "none",
					margin: 0,
					padding: 0
				}),
			// Store the size in case width/height are defined in % - Fixes #5245
			size = {
				width: element.width(),
				height: element.height()
			},
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}

		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if ( element.css( "position" ) === "static" ) {
			wrapper.css({ position: "relative" });
			element.css({ position: "relative" });
		} else {
			$.extend( props, {
				position: element.css( "position" ),
				zIndex: element.css( "z-index" )
			});
			$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
				props[ pos ] = element.css( pos );
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
					props[ pos ] = "auto";
				}
			});
			element.css({
				position: "relative",
				top: 0,
				left: 0,
				right: "auto",
				bottom: "auto"
			});
		}
		element.css(size);

		return wrapper.css( props ).show();
	},

	removeWrapper: function( element ) {
		var active = document.activeElement;

		if ( element.parent().is( ".ui-effects-wrapper" ) ) {
			element.parent().replaceWith( element );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
		}


		return element;
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] > 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		});
		return value;
	}
});

// return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// convert to an object
	effect = { effect: effect };

	// catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// catch (effect, speed, ?)
	if ( typeof options === "number" || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === "number" ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardSpeed( speed ) {
	// valid standard speeds
	if ( !speed || typeof speed === "number" || $.fx.speeds[ speed ] ) {
		return true;
	}

	// invalid strings - treat as "normal" speed
	if ( typeof speed === "string" && !$.effects.effect[ speed ] ) {
		// TODO: remove in 2.0 (#7115)
		if ( backCompat && $.effects[ speed ] ) {
			return false;
		}
		return true;
	}

	return false;
}

/**
 * @cfg {String} blind 从下至上收起来，直到隐藏
 */
/**
 * @cfg {String} bounce 上下晃动元素
 */
/**
 * @cfg {String} clip 上下同时收起来，直到隐藏
 */
/**
 * @cfg {String} drop 向左边移动并升高透明度，直到隐藏
 */
/**
 * @cfg {String} explode 将元素拆分成9宫，向外扩展并升高表明度，直到隐藏
 */
/**
 * @cfg {String} fold 向上收起，再向左收起，直到隐藏
 */
/**
 * @cfg {String} highlight 高亮某个元素
 */
/**
 * @cfg {String} puff 扩大元素宽高度并升高透明度，直到隐藏
 */
/**
 * @cfg {String} pulsate 闪烁元素
 */
/**
 * @cfg {String} scale 从右下向左上收起，直到隐藏  
 * options = { percent: 0 }
 */
/**
 * @cfg {String} shake 左右晃动元素
 */
/**
 * @cfg {String} size 将元素缩至最小  
 * options = { to: { width: 200, height: 60 } };
 */
/**
 * @cfg {String} slide 从左往右滑动元素，直到全部显示
 */
/**
 * @cfg {String} transfer 缩小并迁移元素至触发事件的HTML元素  
 * options = { to: "#button", className: "ui-effects-transfer" };
 */
$.fn.extend({
	/**
	 * 显示特效
	 * @method effect
	 * @param {String} effect 效果显示方式,详见cfg参数
	 * @param {Object} [options] 部分效果需要有参数控制,在不同的effect中包含不同的option
	 * @param {number} [speed] 显示速度,可以是数值，单位是ms，也可以是"slow","normal", 和 "fast"
	 * @param {Function} [callback] 执行完动画后的回调方法
	 */
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			mode = args.mode,
			queue = args.queue,
			effectMethod = $.effects.effect[ args.effect ],

			// DEPRECATED: remove in 2.0 (#7115)
			oldEffectMethod = !effectMethod && backCompat && $.effects[ args.effect ];

		if ( $.fx.off || !( effectMethod || oldEffectMethod ) ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, args.complete );
			} else {
				return this.each( function() {
					if ( args.complete ) {
						args.complete.call( this );
					}
				});
			}
		}

		function run( next ) {
			var elem = $( this ),
				complete = args.complete,
				mode = args.mode;

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[0] );
				}
				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// if the element is hiddden and mode is hide,
			// or element is visible and mode is show
			if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
				done();
			} else {
				effectMethod.call( elem[0], args, done );
			}
		}

		// TODO: remove this check in 2.0, effectMethod will always be true
		if ( effectMethod ) {
			return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
		} else {
			// DEPRECATED: remove in 2.0 (#7115)
			return oldEffectMethod.call(this, {
				options: args,
				duration: args.duration,
				callback: args.complete,
				mode: args.mode
			});
		}
	},

	_show: $.fn.show,
	/**
	 * @method 扩展了JQuery的show方法，当显示一个元素时，允许执行动画效果。
	 * @param  {Object} arguments 如果参数只是显示速度，则调用jquery原生的$.fn.show;否则使用effect特效方法
	 */
	show: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._show.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "show";
			return this.effect.call( this, args );
		}
	},

	_hide: $.fn.hide,
	/**
	 * @method 扩展了JQuery的hide方法，当隐藏一个元素时，允许执行动画效果。
	 * @param  {Object} arguments 如果参数只是隐藏速度，则调用jquery原生的$.fn.hide;否则使用effect特效方法
	 */
	hide: function( speed ) {
		if ( standardSpeed( speed ) ) {
			return this._hide.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "hide";
			return this.effect.call( this, args );
		}
	},

	// jQuery core overloads toggle and creates _toggle
	__toggle: $.fn.toggle,
	/**
	 * @method 扩展了JQuery的toggle方法，在显示和隐藏元素时，允许执行动画效果。
	 * @param  {Object} arguments 如果参数是速度、boolean值或者Function，则调用jquery原生的$.fn.toggle;否则使用effect特效方法
	 */
	toggle: function( speed ) {
		if ( standardSpeed( speed ) || typeof speed === "boolean" || $.isFunction( speed ) ) {
			return this.__toggle.apply( this, arguments );
		} else {
			var args = _normalizeArguments.apply( this, arguments );
			args.mode = "toggle";
			return this.effect.call( this, args );
		}
	},

	// helper functions
	cssUnit: function(key) {
		var style = this.css( key ),
			val = [];

		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
			if ( style.indexOf( unit ) > 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		});
		return val;
	}
});

})();

/*EASING*/

(function() {

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function ( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function ( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function ( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
});

})();

})(jQuery));
/*!
 * jQuery UI Effects Blind 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/blind-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

var rvertical = /up|down|vertical/,
	rpositivemotion = /up|left|vertical|horizontal/;

$.effects.effect.blind = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		direction = o.direction || "up",
		vertical = rvertical.test( direction ),
		ref = vertical ? "height" : "width",
		ref2 = vertical ? "top" : "left",
		motion = rpositivemotion.test( direction ),
		animation = {},
		show = mode === "show",
		wrapper, distance, margin;

	// if already wrapped, the wrapper's properties are my property. #6245
	if ( el.parent().is( ".ui-effects-wrapper" ) ) {
		$.effects.save( el.parent(), props );
	} else {
		$.effects.save( el, props );
	}
	el.show();
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	distance = wrapper[ ref ]();
	margin = parseFloat( wrapper.css( ref2 ) ) || 0;

	animation[ ref ] = show ? distance : 0;
	if ( !motion ) {
		el
			.css( vertical ? "bottom" : "right", 0 )
			.css( vertical ? "top" : "left", "auto" )
			.css({ position: "absolute" });

		animation[ ref2 ] = show ? margin : distance + margin;
	}

	// start at 0 if we are showing
	if ( show ) {
		wrapper.css( ref, 0 );
		if ( ! motion ) {
			wrapper.css( ref2, margin + distance );
		}
	}

	// Animate
	wrapper.animate( animation, {
		duration: o.duration,
		easing: o.easing,
		queue: false,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);

/*!
 * jQuery UI Effects Bounce 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/bounce-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.bounce = function( o, done ) {
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],

		// defaults:
		mode = $.effects.setMode( el, o.mode || "effect" ),
		hide = mode === "hide",
		show = mode === "show",
		direction = o.direction || "up",
		distance = o.distance,
		times = o.times || 5,

		// number of internal animations
		anims = times * 2 + ( show || hide ? 1 : 0 ),
		speed = o.duration / anims,
		easing = o.easing,

		// utility:
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ),
		i,
		upAnim,
		downAnim,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	// Avoid touching opacity to prevent clearType and PNG issues in IE
	if ( show || hide ) {
		props.push( "opacity" );
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el ); // Create Wrapper

	// default distance for the BIGGEST bounce is the outer Distance / 3
	if ( !distance ) {
		distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
	}

	if ( show ) {
		downAnim = { opacity: 1 };
		downAnim[ ref ] = 0;

		// if we are showing, force opacity 0 and set the initial position
		// then do the "first" animation
		el.css( "opacity", 0 )
			.css( ref, motion ? -distance * 2 : distance * 2 )
			.animate( downAnim, speed, easing );
	}

	// start at the smallest distance if we are hiding
	if ( hide ) {
		distance = distance / Math.pow( 2, times - 1 );
	}

	downAnim = {};
	downAnim[ ref ] = 0;
	// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
	for ( i = 0; i < times; i++ ) {
		upAnim = {};
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing )
			.animate( downAnim, speed, easing );

		distance = hide ? distance * 2 : distance / 2;
	}

	// Last Bounce when Hiding
	if ( hide ) {
		upAnim = { opacity: 0 };
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing );
	}

	el.queue(function() {
		if ( hide ) {
			el.hide();
		}
		$.effects.restore( el, props );
		$.effects.removeWrapper( el );
		done();
	});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);

/*!
 * jQuery UI Effects Clip 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/clip-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.clip = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "vertical",
		vert = direction === "vertical",
		size = vert ? "height" : "width",
		position = vert ? "top" : "left",
		animation = {},
		wrapper, animate, distance;

	// Save & Show
	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
	distance = animate[ size ]();

	// Shift
	if ( show ) {
		animate.css( size, 0 );
		animate.css( position, distance / 2 );
	}

	// Create Animation Object:
	animation[ size ] = show ? distance : 0;
	animation[ position ] = show ? 0 : distance / 2;

	// Animate
	animate.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( !show ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);

/*!
 * jQuery UI Effects Drop 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/drop-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.drop = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
		animation = {
			opacity: show ? 1 : 0
		},
		distance;

	// Adjust
	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	distance = o.distance || el[ ref === "top" ? "outerHeight": "outerWidth" ]( true ) / 2;

	if ( show ) {
		el
			.css( "opacity", 0 )
			.css( ref, motion === "pos" ? -distance : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( motion === "pos" ? "+=" : "-=" ) :
		( motion === "pos" ? "-=" : "+=" ) ) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);

/*!
 * jQuery UI Effects Explode 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/explode-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.explode = function( o, done ) {

	var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
		cells = rows,
		el = $( this ),
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",

		// show and then visibility:hidden the element before calculating offset
		offset = el.show().css( "visibility", "hidden" ).offset(),

		// width and height of a piece
		width = Math.ceil( el.outerWidth() / cells ),
		height = Math.ceil( el.outerHeight() / rows ),
		pieces = [],

		// loop
		i, j, left, top, mx, my;

	// children animate complete:
	function childComplete() {
		pieces.push( this );
		if ( pieces.length === rows * cells ) {
			animComplete();
		}
	}

	// clone the element for each row and cell.
	for( i = 0; i < rows ; i++ ) { // ===>
		top = offset.top + i * height;
		my = i - ( rows - 1 ) / 2 ;

		for( j = 0; j < cells ; j++ ) { // |||
			left = offset.left + j * width;
			mx = j - ( cells - 1 ) / 2 ;

			// Create a clone of the now hidden main element that will be absolute positioned
			// within a wrapper div off the -left and -top equal to size of our pieces
			el
				.clone()
				.appendTo( "body" )
				.wrap( "<div></div>" )
				.css({
					position: "absolute",
					visibility: "visible",
					left: -j * width,
					top: -i * height
				})

			// select the wrapper - make it overflow: hidden and absolute positioned based on
			// where the original was located +left and +top equal to the size of pieces
				.parent()
				.addClass( "ui-effects-explode" )
				.css({
					position: "absolute",
					overflow: "hidden",
					width: width,
					height: height,
					left: left + ( show ? mx * width : 0 ),
					top: top + ( show ? my * height : 0 ),
					opacity: show ? 0 : 1
				}).animate({
					left: left + ( show ? 0 : mx * width ),
					top: top + ( show ? 0 : my * height ),
					opacity: show ? 1 : 0
				}, o.duration || 500, o.easing, childComplete );
		}
	}

	function animComplete() {
		el.css({
			visibility: "visible"
		});
		$( pieces ).remove();
		if ( !show ) {
			el.hide();
		}
		done();
	}
};

})(jQuery);

/*!
 * jQuery UI Effects Fade 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/fade-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.fade = function( o, done ) {
	var el = $( this ),
		mode = $.effects.setMode( el, o.mode || "toggle" );

	el.animate({
		opacity: mode
	}, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: done
	});
};

})( jQuery );

/*!
 * jQuery UI Effects Fold 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/fold-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.fold = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		hide = mode === "hide",
		size = o.size || 15,
		percent = /([0-9]+)%/.exec( size ),
		horizFirst = !!o.horizFirst,
		widthFirst = show !== horizFirst,
		ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
		duration = o.duration / 2,
		wrapper, distance,
		animation1 = {},
		animation2 = {};

	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	distance = widthFirst ?
		[ wrapper.width(), wrapper.height() ] :
		[ wrapper.height(), wrapper.width() ];

	if ( percent ) {
		size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
	}
	if ( show ) {
		wrapper.css( horizFirst ? {
			height: 0,
			width: size
		} : {
			height: size,
			width: 0
		});
	}

	// Animation
	animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
	animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;

	// Animate
	wrapper
		.animate( animation1, duration, o.easing )
		.animate( animation2, duration, o.easing, function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

};

})(jQuery);

/*!
 * jQuery UI Effects Highlight 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/highlight-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.highlight = function( o, done ) {
	var elem = $( this ),
		props = [ "backgroundImage", "backgroundColor", "opacity" ],
		mode = $.effects.setMode( elem, o.mode || "show" ),
		animation = {
			backgroundColor: elem.css( "backgroundColor" )
		};

	if (mode === "hide") {
		animation.opacity = 0;
	}

	$.effects.save( elem, props );

	elem
		.show()
		.css({
			backgroundImage: "none",
			backgroundColor: o.color || "#ffff99"
		})
		.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					elem.hide();
				}
				$.effects.restore( elem, props );
				done();
			}
		});
};

})(jQuery);

/*!
 * jQuery UI Effects Pulsate 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/pulsate-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.pulsate = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "show" ),
		show = mode === "show",
		hide = mode === "hide",
		showhide = ( show || mode === "hide" ),

		// showing or hiding leaves of the "last" animation
		anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
		duration = o.duration / anims,
		animateTo = 0,
		queue = elem.queue(),
		queuelen = queue.length,
		i;

	if ( show || !elem.is(":visible")) {
		elem.css( "opacity", 0 ).show();
		animateTo = 1;
	}

	// anims - 1 opacity "toggles"
	for ( i = 1; i < anims; i++ ) {
		elem.animate({
			opacity: animateTo
		}, duration, o.easing );
		animateTo = 1 - animateTo;
	}

	elem.animate({
		opacity: animateTo
	}, duration, o.easing);

	elem.queue(function() {
		if ( hide ) {
			elem.hide();
		}
		done();
	});

	// We just queued up "anims" animations, we need to put them next in the queue
	if ( queuelen > 1 ) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	elem.dequeue();
};

})(jQuery);

/*!
 * jQuery UI Effects Scale 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/scale-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.puff = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "hide" ),
		hide = mode === "hide",
		percent = parseInt( o.percent, 10 ) || 150,
		factor = percent / 100,
		original = {
			height: elem.height(),
			width: elem.width(),
			outerHeight: elem.outerHeight(),
			outerWidth: elem.outerWidth()
		};

	$.extend( o, {
		effect: "scale",
		queue: false,
		fade: true,
		mode: mode,
		complete: done,
		percent: hide ? percent : 100,
		from: hide ?
			original :
			{
				height: original.height * factor,
				width: original.width * factor,
				outerHeight: original.outerHeight * factor,
				outerWidth: original.outerWidth * factor
			}
	});

	elem.effect( o );
};

$.effects.effect.scale = function( o, done ) {

	// Create element
	var el = $( this ),
		options = $.extend( true, {}, o ),
		mode = $.effects.setMode( el, o.mode || "effect" ),
		percent = parseInt( o.percent, 10 ) ||
			( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
		direction = o.direction || "both",
		origin = o.origin,
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		},
		factor = {
			y: direction !== "horizontal" ? (percent / 100) : 1,
			x: direction !== "vertical" ? (percent / 100) : 1
		};

	// We are going to pass this effect to the size effect:
	options.effect = "size";
	options.queue = false;
	options.complete = done;

	// Set default origin and restore for show/hide
	if ( mode !== "effect" ) {
		options.origin = origin || ["middle","center"];
		options.restore = true;
	}

	options.from = o.from || ( mode === "show" ? {
		height: 0,
		width: 0,
		outerHeight: 0,
		outerWidth: 0
	} : original );
	options.to = {
		height: original.height * factor.y,
		width: original.width * factor.x,
		outerHeight: original.outerHeight * factor.y,
		outerWidth: original.outerWidth * factor.x
	};

	// Fade option to support puff
	if ( options.fade ) {
		if ( mode === "show" ) {
			options.from.opacity = 0;
			options.to.opacity = 1;
		}
		if ( mode === "hide" ) {
			options.from.opacity = 1;
			options.to.opacity = 0;
		}
	}

	// Animate
	el.effect( options );

};

$.effects.effect.size = function( o, done ) {

	// Create element
	var original, baseline, factor,
		el = $( this ),
		props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],

		// Always restore
		props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],

		// Copy for children
		props2 = [ "width", "height", "overflow" ],
		cProps = [ "fontSize" ],
		vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
		hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

		// Set options
		mode = $.effects.setMode( el, o.mode || "effect" ),
		restore = o.restore || mode !== "effect",
		scale = o.scale || "both",
		origin = o.origin || [ "middle", "center" ],
		position = el.css( "position" ),
		props = restore ? props0 : props1,
		zero = {
			height: 0,
			width: 0,
			outerHeight: 0,
			outerWidth: 0
		};

	if ( mode === "show" ) {
		el.show();
	}
	original = {
		height: el.height(),
		width: el.width(),
		outerHeight: el.outerHeight(),
		outerWidth: el.outerWidth()
	};

	if ( o.mode === "toggle" && mode === "show" ) {
		el.from = o.to || zero;
		el.to = o.from || original;
	} else {
		el.from = o.from || ( mode === "show" ? zero : original );
		el.to = o.to || ( mode === "hide" ? zero : original );
	}

	// Set scaling factor
	factor = {
		from: {
			y: el.from.height / original.height,
			x: el.from.width / original.width
		},
		to: {
			y: el.to.height / original.height,
			x: el.to.width / original.width
		}
	};

	// Scale the css box
	if ( scale === "box" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( vProps );
			el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
		}

		// Horizontal props scaling
		if ( factor.from.x !== factor.to.x ) {
			props = props.concat( hProps );
			el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
			el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
		}
	}

	// Scale the content
	if ( scale === "content" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( cProps ).concat( props2 );
			el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
		}
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );
	el.css( "overflow", "hidden" ).css( el.from );

	// Adjust
	if (origin) { // Calculate baseline shifts
		baseline = $.effects.getBaseline( origin, original );
		el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
		el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
		el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
		el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
	}
	el.css( el.from ); // set top & left

	// Animate
	if ( scale === "content" || scale === "both" ) { // Scale the children

		// Add margins/font-size
		vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
		hProps = hProps.concat([ "marginLeft", "marginRight" ]);
		props2 = props0.concat(vProps).concat(hProps);

		el.find( "*[width]" ).each( function(){
			var child = $( this ),
				c_original = {
					height: child.height(),
					width: child.width(),
					outerHeight: child.outerHeight(),
					outerWidth: child.outerWidth()
				};
			if (restore) {
				$.effects.save(child, props2);
			}

			child.from = {
				height: c_original.height * factor.from.y,
				width: c_original.width * factor.from.x,
				outerHeight: c_original.outerHeight * factor.from.y,
				outerWidth: c_original.outerWidth * factor.from.x
			};
			child.to = {
				height: c_original.height * factor.to.y,
				width: c_original.width * factor.to.x,
				outerHeight: c_original.height * factor.to.y,
				outerWidth: c_original.width * factor.to.x
			};

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
				child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
			}

			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
				child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
			}

			// Animate children
			child.css( child.from );
			child.animate( child.to, o.duration, o.easing, function() {

				// Restore children
				if ( restore ) {
					$.effects.restore( child, props2 );
				}
			});
		});
	}

	// Animate
	el.animate( el.to, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( el.to.opacity === 0 ) {
				el.css( "opacity", el.from.opacity );
			}
			if( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			if ( !restore ) {

				// we need to calculate our new positioning based on the scaling
				if ( position === "static" ) {
					el.css({
						position: "relative",
						top: el.to.top,
						left: el.to.left
					});
				} else {
					$.each([ "top", "left" ], function( idx, pos ) {
						el.css( pos, function( _, str ) {
							var val = parseInt( str, 10 ),
								toRef = idx ? el.to.left : el.to.top;

							// if original was "auto", recalculate the new value from wrapper
							if ( str === "auto" ) {
								return toRef + "px";
							}

							return val + toRef + "px";
						});
					});
				}
			}

			$.effects.removeWrapper( el );
			done();
		}
	});

};

})(jQuery);

/*!
 * jQuery UI Effects Shake 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/shake-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.shake = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "effect" ),
		direction = o.direction || "left",
		distance = o.distance || 20,
		times = o.times || 3,
		anims = times * 2 + 1,
		speed = Math.round(o.duration/anims),
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		animation = {},
		animation1 = {},
		animation2 = {},
		i,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	// Animation
	animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
	animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
	animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

	// Animate
	el.animate( animation, speed, o.easing );

	// Shakes
	for ( i = 1; i < times; i++ ) {
		el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
	}
	el
		.animate( animation1, speed, o.easing )
		.animate( animation, speed / 2, o.easing )
		.queue(function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};

})(jQuery);

/*!
 * jQuery UI Effects Slide 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/slide-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.slide = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
		mode = $.effects.setMode( el, o.mode || "show" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		distance,
		animation = {};

	// Adjust
	$.effects.save( el, props );
	el.show();
	distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );

	$.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	if ( show ) {
		el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( positiveMotion ? "+=" : "-=") :
		( positiveMotion ? "-=" : "+=")) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};

})(jQuery);

/*!
 * jQuery UI Effects Transfer 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/transfer-effect/
 *
 * Depends:
 *	jquery.ui.effect.js
 */
(function( $, undefined ) {

$.effects.effect.transfer = function( o, done ) {
	var elem = $( this ),
		target = $( o.to ),
		targetFixed = target.css( "position" ) === "fixed",
		body = $("body"),
		fixTop = targetFixed ? body.scrollTop() : 0,
		fixLeft = targetFixed ? body.scrollLeft() : 0,
		endPosition = target.offset(),
		animation = {
			top: endPosition.top - fixTop ,
			left: endPosition.left - fixLeft ,
			height: target.innerHeight(),
			width: target.innerWidth()
		},
		startPosition = elem.offset(),
		transfer = $( '<div class="ui-effects-transfer"></div>' )
			.appendTo( document.body )
			.addClass( o.className )
			.css({
				top: startPosition.top - fixTop ,
				left: startPosition.left - fixLeft ,
				height: elem.innerHeight(),
				width: elem.innerWidth(),
				position: targetFixed ? "fixed" : "absolute"
			})
			.animate( animation, o.duration, o.easing, function() {
				transfer.remove();
				done();
			});
};

})(jQuery);

/*! Copyright (c) 2013 Brandon Aaron (http://brandon.aaron.sh)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Version: 3.1.12
 *
 * Requires: jQuery 1.2.2+
 */

(function (factory) {
    if ( typeof define === 'function' && define.amd ) {
        // AMD. Register as an anonymous module.
        define('jquery.mousewheel',['jquery'], factory);
    } else if (typeof exports === 'object') {
        // Node/CommonJS style for Browserify
        module.exports = factory;
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var toFix  = ['wheel', 'mousewheel', 'DOMMouseScroll', 'MozMousePixelScroll'],
        toBind = ( 'onwheel' in document || document.documentMode >= 9 ) ?
                    ['wheel'] : ['mousewheel', 'DomMouseScroll', 'MozMousePixelScroll'],
        slice  = Array.prototype.slice,
        nullLowestDeltaTimeout, lowestDelta;

    if ( $.event.fixHooks ) {
        for ( var i = toFix.length; i; ) {
            $.event.fixHooks[ toFix[--i] ] = $.event.mouseHooks;
        }
    }

    var special = $.event.special.mousewheel = {
        version: '3.1.12',

        setup: function() {
            if ( this.addEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.addEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = handler;
            }
            // Store the line height and page height for this particular element
            $.data(this, 'mousewheel-line-height', special.getLineHeight(this));
            $.data(this, 'mousewheel-page-height', special.getPageHeight(this));
        },

        teardown: function() {
            if ( this.removeEventListener ) {
                for ( var i = toBind.length; i; ) {
                    this.removeEventListener( toBind[--i], handler, false );
                }
            } else {
                this.onmousewheel = null;
            }
            // Clean up the data we added to the element
            $.removeData(this, 'mousewheel-line-height');
            $.removeData(this, 'mousewheel-page-height');
        },

        getLineHeight: function(elem) {
            var $elem = $(elem),
                $parent = $elem['offsetParent' in $.fn ? 'offsetParent' : 'parent']();
            if (!$parent.length) {
                $parent = $('body');
            }
            return parseInt($parent.css('fontSize'), 10) || parseInt($elem.css('fontSize'), 10) || 16;
        },

        getPageHeight: function(elem) {
            return $(elem).height();
        },

        settings: {
            adjustOldDeltas: true, // see shouldAdjustOldDeltas() below
            normalizeOffset: true  // calls getBoundingClientRect for each event
        }
    };

    $.fn.extend({
        mousewheel: function(fn) {
            return fn ? this.bind('mousewheel', fn) : this.trigger('mousewheel');
        },

        unmousewheel: function(fn) {
            return this.unbind('mousewheel', fn);
        }
    });


    function handler(event) {
        var orgEvent   = event || window.event,
            args       = slice.call(arguments, 1),
            delta      = 0,
            deltaX     = 0,
            deltaY     = 0,
            absDelta   = 0,
            offsetX    = 0,
            offsetY    = 0;
        event = $.event.fix(orgEvent);
        event.type = 'mousewheel';

        // Old school scrollwheel delta
        if ( 'detail'      in orgEvent ) { deltaY = orgEvent.detail * -1;      }
        if ( 'wheelDelta'  in orgEvent ) { deltaY = orgEvent.wheelDelta;       }
        if ( 'wheelDeltaY' in orgEvent ) { deltaY = orgEvent.wheelDeltaY;      }
        if ( 'wheelDeltaX' in orgEvent ) { deltaX = orgEvent.wheelDeltaX * -1; }

        // Firefox < 17 horizontal scrolling related to DOMMouseScroll event
        if ( 'axis' in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
            deltaX = deltaY * -1;
            deltaY = 0;
        }

        // Set delta to be deltaY or deltaX if deltaY is 0 for backwards compatabilitiy
        delta = deltaY === 0 ? deltaX : deltaY;

        // New school wheel delta (wheel event)
        if ( 'deltaY' in orgEvent ) {
            deltaY = orgEvent.deltaY * -1;
            delta  = deltaY;
        }
        if ( 'deltaX' in orgEvent ) {
            deltaX = orgEvent.deltaX;
            if ( deltaY === 0 ) { delta  = deltaX * -1; }
        }

        // No change actually happened, no reason to go any further
        if ( deltaY === 0 && deltaX === 0 ) { return; }

        // Need to convert lines and pages to pixels if we aren't already in pixels
        // There are three delta modes:
        //   * deltaMode 0 is by pixels, nothing to do
        //   * deltaMode 1 is by lines
        //   * deltaMode 2 is by pages
        if ( orgEvent.deltaMode === 1 ) {
            var lineHeight = $.data(this, 'mousewheel-line-height');
            delta  *= lineHeight;
            deltaY *= lineHeight;
            deltaX *= lineHeight;
        } else if ( orgEvent.deltaMode === 2 ) {
            var pageHeight = $.data(this, 'mousewheel-page-height');
            delta  *= pageHeight;
            deltaY *= pageHeight;
            deltaX *= pageHeight;
        }

        // Store lowest absolute delta to normalize the delta values
        absDelta = Math.max( Math.abs(deltaY), Math.abs(deltaX) );

        if ( !lowestDelta || absDelta < lowestDelta ) {
            lowestDelta = absDelta;

            // Adjust older deltas if necessary
            if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
                lowestDelta /= 40;
            }
        }

        // Adjust older deltas if necessary
        if ( shouldAdjustOldDeltas(orgEvent, absDelta) ) {
            // Divide all the things by 40!
            delta  /= 40;
            deltaX /= 40;
            deltaY /= 40;
        }

        // Get a whole, normalized value for the deltas
        delta  = Math[ delta  >= 1 ? 'floor' : 'ceil' ](delta  / lowestDelta);
        deltaX = Math[ deltaX >= 1 ? 'floor' : 'ceil' ](deltaX / lowestDelta);
        deltaY = Math[ deltaY >= 1 ? 'floor' : 'ceil' ](deltaY / lowestDelta);

        // Normalise offsetX and offsetY properties
        if ( special.settings.normalizeOffset && this.getBoundingClientRect ) {
            var boundingRect = this.getBoundingClientRect();
            offsetX = event.clientX - boundingRect.left;
            offsetY = event.clientY - boundingRect.top;
        }

        // Add information to the event object
        event.deltaX = deltaX;
        event.deltaY = deltaY;
        event.deltaFactor = lowestDelta;
        event.offsetX = offsetX;
        event.offsetY = offsetY;
        // Go ahead and set deltaMode to 0 since we converted to pixels
        // Although this is a little odd since we overwrite the deltaX/Y
        // properties with normalized deltas.
        event.deltaMode = 0;

        // Add event and delta to the front of the arguments
        args.unshift(event, delta, deltaX, deltaY);

        // Clearout lowestDelta after sometime to better
        // handle multiple device types that give different
        // a different lowestDelta
        // Ex: trackpad = 3 and mouse wheel = 120
        if (nullLowestDeltaTimeout) { clearTimeout(nullLowestDeltaTimeout); }
        nullLowestDeltaTimeout = setTimeout(nullLowestDelta, 200);

        return ($.event.dispatch || $.event.handle).apply(this, args);
    }

    function nullLowestDelta() {
        lowestDelta = null;
    }

    function shouldAdjustOldDeltas(orgEvent, absDelta) {
        // If this is an older event and the delta is divisable by 120,
        // then we are assuming that the browser is treating this as an
        // older mouse wheel event and that we should divide the deltas
        // by 40 to try and get a more usable deltaFactor.
        // Side note, this actually impacts the reported scroll distance
        // in older browsers and can cause scrolling to be slower than native.
        // Turn this off by setting $.event.special.mousewheel.settings.adjustOldDeltas to false.
        return special.settings.adjustOldDeltas && orgEvent.type === 'mousewheel' && absDelta % 120 === 0;
    }

}));

/*! Copyright (c) 2011 Piotr Rochala (http://rocha.la)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 *
 * Version: 1.3.3
 *
 */
(function($) {

  $.fn.extend({
    slimScroll: function(options) {

      var defaults = {

        // width in pixels of the visible scroll area
        width : 'auto',

        // height in pixels of the visible scroll area
        height : '250px',

        // width in pixels of the scrollbar and rail
        size : '7px',

        // scrollbar color, accepts any hex/color value
        color: '#000',

        // scrollbar position - left/right
        position : 'right',

        // distance in pixels between the side edge and the scrollbar
        distance : '1px',

        // default scroll position on load - top / bottom / $('selector')
        start : 'top',

        // sets scrollbar opacity
        opacity : .4,

        // enables always-on mode for the scrollbar
        alwaysVisible : false,

        // check if we should hide the scrollbar when user is hovering over
        disableFadeOut : false,

        // sets visibility of the rail
        railVisible : false,

        // sets rail color
        railColor : '#333',

        // sets rail opacity
        railOpacity : .2,

        // whether  we should use jQuery UI Draggable to enable bar dragging
        railDraggable : true,

        // defautlt CSS class of the slimscroll rail
        railClass : 'slimScrollRail',

        // defautlt CSS class of the slimscroll bar
        barClass : 'slimScrollBar',

        // defautlt CSS class of the slimscroll wrapper
        wrapperClass : 'slimScrollDiv',

        // check if mousewheel should scroll the window if we reach top/bottom
        allowPageScroll : false,

        // scroll amount applied to each mouse wheel step
        wheelStep : 20,

        // scroll amount applied when user is using gestures
        touchScrollStep : 200,

        // sets border radius
        borderRadius: '7px',

        // sets border radius of the rail
        railBorderRadius : '7px'
      };

      var o = $.extend(defaults, options);

      // do it for every element that matches selector
      this.each(function(){

      var isOverPanel, isOverBar, isDragg, queueHide, touchDif,
        barHeight, percentScroll, lastScroll,
        divS = '<div></div>',
        minBarHeight = 30,
        releaseScroll = false;

        // used in event handlers and for better minification
        var me = $(this);

        // ensure we are not binding it again
        if (me.parent().hasClass(o.wrapperClass))
        {
            // start from last bar position
            var offset = me.scrollTop();

            // find bar and rail
            bar = me.parent().find('.' + o.barClass);
            rail = me.parent().find('.' + o.railClass);

            getBarHeight();

            // check if we should scroll existing instance
            if ($.isPlainObject(options))
            {
              // Pass height: auto to an existing slimscroll object to force a resize after contents have changed
              if ( 'height' in options && options.height == 'auto' ) {
                me.parent().css('height', 'auto');
                me.css('height', 'auto');
                var height = me.parent().parent().height();
                me.parent().css('height', height);
                me.css('height', height);
              }

              if ('scrollTo' in options)
              {
                // jump to a static point
                offset = parseInt(o.scrollTo);
              }
              else if ('scrollBy' in options)
              {
                // jump by value pixels
                offset += parseInt(o.scrollBy);
              }
              else if ('destroy' in options)
              {
                // remove slimscroll elements
                bar.remove();
                rail.remove();
                me.unwrap();
                return;
              }

              // scroll content by the given offset
              scrollContent(offset, false, true);
            }

            return;
        }
        else if ($.isPlainObject(options))
        {
            if ('destroy' in options)
            {
            	return;
            }
        }

        // optionally set height to the parent's height
        o.height = (o.height == 'auto') ? me.parent().height() : o.height;

        // wrap content
        var wrapper = $(divS)
          .addClass(o.wrapperClass)
          .css({
            position: 'relative',
            overflow: 'hidden',
            width: o.width,
            height: o.height
          });

        // update style for the div
        me.css({
          overflow: 'hidden',
          width: o.width,
          height: o.height
        });

        // create scrollbar rail
        var rail = $(divS)
          .addClass(o.railClass)
          .css({
            width: o.size,
            height: '100%',
            position: 'absolute',
            top: 0,
            display: (o.alwaysVisible && o.railVisible) ? 'block' : 'none',
            'border-radius': o.railBorderRadius,
            background: o.railColor,
            opacity: o.railOpacity,
            zIndex: 90
          });

        // create scrollbar
        var bar = $(divS)
          .addClass(o.barClass)
          .css({
            background: o.color,
            width: o.size,
            position: 'absolute',
            top: 0,
            opacity: o.opacity,
            display: o.alwaysVisible ? 'block' : 'none',
            'border-radius' : o.borderRadius,
            BorderRadius: o.borderRadius,
            MozBorderRadius: o.borderRadius,
            WebkitBorderRadius: o.borderRadius,
            zIndex: 99
          });

        // set position
        var posCss = (o.position == 'right') ? { right: o.distance } : { left: o.distance };
        rail.css(posCss);
        bar.css(posCss);

        // wrap it
        me.wrap(wrapper);

        // append to parent div
        me.parent().append(bar);
        me.parent().append(rail);

        // make it draggable and no longer dependent on the jqueryUI
        if (o.railDraggable){
          bar.bind("mousedown", function(e) {
            var $doc = $(document);
            isDragg = true;
            t = parseFloat(bar.css('top'));
            pageY = e.pageY;

            $doc.bind("mousemove.slimscroll", function(e){
              currTop = t + e.pageY - pageY;
              bar.css('top', currTop);
              scrollContent(0, bar.position().top, false);// scroll content
            });

            $doc.bind("mouseup.slimscroll", function(e) {
              isDragg = false;hideBar();
              $doc.unbind('.slimscroll');
            });
            return false;
          }).bind("selectstart.slimscroll", function(e){
            e.stopPropagation();
            e.preventDefault();
            return false;
          });
        }

        // on rail over
        rail.hover(function(){
          showBar();
        }, function(){
          hideBar();
        });

        // on bar over
        bar.hover(function(){
          isOverBar = true;
        }, function(){
          isOverBar = false;
        });

        // show on parent mouseover
        me.hover(function(){
          isOverPanel = true;
          showBar();
          hideBar();
        }, function(){
          isOverPanel = false;
          hideBar();
        });

        // support for mobile
        me.bind('touchstart', function(e,b){
          if (e.originalEvent.touches.length)
          {
            // record where touch started
            touchDif = e.originalEvent.touches[0].pageY;
          }
        });

        me.bind('touchmove', function(e){
          // prevent scrolling the page if necessary
          if(!releaseScroll)
          {
  		      e.originalEvent.preventDefault();
		      }
          if (e.originalEvent.touches.length)
          {
            // see how far user swiped
            var diff = (touchDif - e.originalEvent.touches[0].pageY) / o.touchScrollStep;
            // scroll content
            scrollContent(diff, true);
            touchDif = e.originalEvent.touches[0].pageY;
          }
        });

        // set up initial height
        getBarHeight();

        // check start position
        if (o.start === 'bottom')
        {
          // scroll content to bottom
          bar.css({ top: me.outerHeight() - bar.outerHeight() });
          scrollContent(0, true);
        }
        else if (o.start !== 'top')
        {
          // assume jQuery selector
          scrollContent($(o.start).position().top, null, true);

          // make sure bar stays hidden
          if (!o.alwaysVisible) { bar.hide(); }
        }

        // attach scroll events
        attachWheel();

        function _onWheel(e)
        {
          // use mouse wheel only when mouse is over
          if (!isOverPanel) { return; }

          var e = e || window.event;

          var delta = 0;
          if (e.wheelDelta) { delta = -e.wheelDelta/120; }
          if (e.detail) { delta = e.detail / 3; }

          var target = e.target || e.srcTarget || e.srcElement;
          if ($(target).closest('.' + o.wrapperClass).is(me.parent())) {
            // scroll content
            scrollContent(delta, true);
          }

          // stop window scroll
          if (e.preventDefault && !releaseScroll) { e.preventDefault(); }
          if (!releaseScroll) { e.returnValue = false; }
        }

        function scrollContent(y, isWheel, isJump)
        {
          releaseScroll = false;
          var delta = y;
          var maxTop = me.outerHeight() - bar.outerHeight();

          if (isWheel)
          {
            // move bar with mouse wheel
            delta = parseInt(bar.css('top')) + y * parseInt(o.wheelStep) / 100 * bar.outerHeight();

            // move bar, make sure it doesn't go out
            delta = Math.min(Math.max(delta, 0), maxTop);

            // if scrolling down, make sure a fractional change to the
            // scroll position isn't rounded away when the scrollbar's CSS is set
            // this flooring of delta would happened automatically when
            // bar.css is set below, but we floor here for clarity
            delta = (y > 0) ? Math.ceil(delta) : Math.floor(delta);

            // scroll the scrollbar
            bar.css({ top: delta + 'px' });
          }

          // calculate actual scroll amount
          percentScroll = parseInt(bar.css('top')) / (me.outerHeight() - bar.outerHeight());
          delta = percentScroll * (me[0].scrollHeight - me.outerHeight());

          if (isJump)
          {
            delta = y;
            var offsetTop = delta / me[0].scrollHeight * me.outerHeight();
            offsetTop = Math.min(Math.max(offsetTop, 0), maxTop);
            bar.css({ top: offsetTop + 'px' });
          }

          // scroll content
          me.scrollTop(delta);

          // fire scrolling event
          me.trigger('slimscrolling', ~~delta);

          // ensure bar is visible
          showBar();

          // trigger hide when scroll is stopped
          hideBar();
        }

        function attachWheel()
        {
          if (window.addEventListener)
          {
            this.addEventListener('DOMMouseScroll', _onWheel, false );
            this.addEventListener('mousewheel', _onWheel, false );
          }
          else
          {
            document.attachEvent("onmousewheel", _onWheel)
          }
        }

        function getBarHeight()
        {
          // calculate scrollbar height and make sure it is not too small
          barHeight = Math.max((me.outerHeight() / me[0].scrollHeight) * me.outerHeight(), minBarHeight);
          bar.css({ height: barHeight + 'px' });

          // hide scrollbar if content is not long enough
          var display = barHeight == me.outerHeight() ? 'none' : 'block';
          bar.css({ display: display });
        }

        function showBar()
        {
          // recalculate bar height
          getBarHeight();
          clearTimeout(queueHide);

          // when bar reached top or bottom
          if (percentScroll == ~~percentScroll)
          {
            //release wheel
            releaseScroll = o.allowPageScroll;

            // publish approporiate event
            if (lastScroll != percentScroll)
            {
                var msg = (~~percentScroll == 0) ? 'top' : 'bottom';
                me.trigger('slimscroll', msg);
            }
          }
          else
          {
            releaseScroll = false;
          }
          lastScroll = percentScroll;

          // show only when required
          if(barHeight >= me.outerHeight()) {
            //allow window scroll
            releaseScroll = true;
            return;
          }
          bar.stop(true,true).fadeIn('fast');
          if (o.railVisible) { rail.stop(true,true).fadeIn('fast'); }
        }

        function hideBar()
        {
          // only hide when options allow it
          if (!o.alwaysVisible)
          {
            queueHide = setTimeout(function(){
              if (!(o.disableFadeOut && isOverPanel) && !isOverBar && !isDragg)
              {
                bar.fadeOut('slow');
                rail.fadeOut('slow');
              }
            }, 1000);
          }
        }

      });

      // maintain chainability
      return this;
    }
  });

  $.fn.extend({
    slimscroll: $.fn.slimScroll
  });

})(jQuery);

/**
 * Title: fish-zh.js
 * Description: fish-zh.js
 * Author: huang.xinghui
 * Created Date: 14-8-21 下午2:55
 * Copyright: Copyright 2014 ZTESOFT, Inc.
 */
!function ($) {
  fish.locale['en'] = $.extend(fish.locale['en'], {
    alert: {
      ok: 'OK',
      cancel: 'Cancel',
      confirm: 'Confirm',
      information: 'Information',
      success: 'Success',
      warn: 'Warning',
      error: 'Error',
      prompt: 'Prompt'
    }
  });
}(jQuery);
/**
 * Title: blockui.en.js
 * Description: blockui.en.js
 * Author: huang.xinghui
 * Created Date: 14-8-29 上午11:10
 * Copyright: Copyright 2014 ZTESOFT, Inc.
 */
!function () {
    fish.locale['en'] = $.extend(fish.locale['en'], {
        blockUI: {
            loading: 'Loading...'
        }
    });
}();
/**
 * Title: fish-zh.js
 * Description: fish-zh.js
 * Author: huang.xinghui
 * Created Date: 14-8-21 下午2:55
 * Copyright: Copyright 2014 ZTESOFT, Inc.
 */
!function () {
  fish.locale['en'] = $.extend(fish.locale['en'], {
    datetimepicker: {
      'days': ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"],
      'daysShort': ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
      'daysMin': ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa", "Su"],
      'months': ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
      'monthsShort': ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
      'meridian': ["am", "pm"],
      'suffix': ["st", "nd", "rd", "th"],
      'today': "Today"
    }
  });
}();
!function ($) {
  $.jgrid = $.jgrid || {};
  $.extend($.jgrid, {
    defaults: {
      recordtext: "View {0} - {1} of {2}",
      emptyrecords: "No records to view",
      // loadtext: "Loading...",
      pgtext: "Page {0} of {1}"
    },
    search: {
      caption: "Search...",
      Find: "Find",
      Reset: "Reset",
      odata: [
        { oper: 'eq', text: 'equal'},
        { oper: 'ne', text: 'not equal'},
        { oper: 'lt', text: 'less'},
        { oper: 'le', text: 'less or equal'},
        { oper: 'gt', text: 'greater'},
        { oper: 'ge', text: 'greater or equal'},
        { oper: 'bw', text: 'begins with'},
        { oper: 'bn', text: 'does not begin with'},
        { oper: 'in', text: 'is in'},
        { oper: 'ni', text: 'is not in'},
        { oper: 'ew', text: 'ends with'},
        { oper: 'en', text: 'does not end with'},
        { oper: 'cn', text: 'contains'},
        { oper: 'nc', text: 'does not contain'}
      ],
      groupOps: [
        { op: "AND", text: "all" },
        { op: "OR", text: "any" }
      ]
    },
    edit: {
      addCaption: "Add Record",
      editCaption: "Edit Record",
      bSubmit: "Submit",
      bCancel: "Cancel",
      bClose: "Close",
      saveData: "Data has been changed! Save changes?",
      bYes: "Yes",
      bNo: "No",
      bExit: "Cancel",
      msg: {
        required: "Field is required",
        number: "Please, enter valid number",
        minValue: "value must be greater than or equal to ",
        maxValue: "value must be less than or equal to",
        email: "is not a valid e-mail",
        integer: "Please, enter valid integer value",
        date: "Please, enter valid date value",
        url: "is not a valid URL. Prefix required ('http://' or 'https://')",
        nodefined: " is not defined!",
        novalue: " return value is required!",
        customarray: "Custom function should return array!",
        customfcheck: "Custom function should be present in case of custom checking!"

      }
    },
    view: {
      caption: "View Record",
      bClose: "Close"
    },
    del: {
      caption: "Delete",
      msg: "Delete selected record(s)?",
      bSubmit: "Delete",
      bCancel: "Cancel"
    },
    nav: {
      edittext: "",
      edittitle: "Edit selected row",
      addtext: "",
      addtitle: "Add new row",
      deltext: "",
      deltitle: "Delete selected row",
      searchtext: "",
      searchtitle: "Find records",
      refreshtext: "",
      refreshtitle: "Reload Grid",
      alertcap: "Warning",
      alerttext: "Please, select row",
      viewtext: "",
      viewtitle: "View selected row"
    },
    col: {
      caption: "Select columns",
      bSubmit: "Ok",
      bCancel: "Cancel"
    },
    errors: {
      errcap: "Error",
      nourl: "No url is set",
      norecords: "No records to process",
      model: "Length of colNames <> colModel!"
    },
    formatter: {
      integer: {thousandsSeparator: ",", defaultValue: '0'},
      number: {decimalSeparator: ".", thousandsSeparator: ",", decimalPlaces: 2, defaultValue: '0.00'},
      currency: {decimalSeparator: ".", thousandsSeparator: ",", decimalPlaces: 2, prefix: "", suffix: "", defaultValue: '0.00'},
      date: {
        dayNames: [
          "Sun", "Mon", "Tue", "Wed", "Thr", "Fri", "Sat",
          "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
        ],
        monthNames: [
          "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
          "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
        ],
        AmPm: ["am", "pm", "AM", "PM"],
        S: function (j) {
          return j < 11 || j > 13 ? ['st', 'nd', 'rd', 'th'][Math.min((j - 1) % 10, 3)] : 'th';
        },
        srcformat: 'Y-m-d',
        newformat: 'n/j/Y',
        parseRe: /[Tt\\\/:_;.,\t\s-]/,
        masks: {
          // see http://php.net/manual/en/function.date.php for PHP format used in jqGrid
          // and see http://docs.jquery.com/UI/Datepicker/formatDate
          // and https://github.com/jquery/globalize#dates for alternative formats used frequently
          // one can find on https://github.com/jquery/globalize/tree/master/lib/cultures many
          // information about date, time, numbers and currency formats used in different countries
          // one should just convert the information in PHP format
          ISO8601Long: "Y-m-d H:i:s",
          ISO8601Short: "Y-m-d",
          // short date:
          //    n - Numeric representation of a month, without leading zeros
          //    j - Day of the month without leading zeros
          //    Y - A full numeric representation of a year, 4 digits
          // example: 3/1/2012 which means 1 March 2012
          ShortDate: "n/j/Y", // in jQuery UI Datepicker: "M/d/yyyy"
          // long date:
          //    l - A full textual representation of the day of the week
          //    F - A full textual representation of a month
          //    d - Day of the month, 2 digits with leading zeros
          //    Y - A full numeric representation of a year, 4 digits
          LongDate: "l, F d, Y", // in jQuery UI Datepicker: "dddd, MMMM dd, yyyy"
          // long date with long time:
          //    l - A full textual representation of the day of the week
          //    F - A full textual representation of a month
          //    d - Day of the month, 2 digits with leading zeros
          //    Y - A full numeric representation of a year, 4 digits
          //    g - 12-hour format of an hour without leading zeros
          //    i - Minutes with leading zeros
          //    s - Seconds, with leading zeros
          //    A - Uppercase Ante meridiem and Post meridiem (AM or PM)
          FullDateTime: "l, F d, Y g:i:s A", // in jQuery UI Datepicker: "dddd, MMMM dd, yyyy h:mm:ss tt"
          // month day:
          //    F - A full textual representation of a month
          //    d - Day of the month, 2 digits with leading zeros
          MonthDay: "F d", // in jQuery UI Datepicker: "MMMM dd"
          // short time (without seconds)
          //    g - 12-hour format of an hour without leading zeros
          //    i - Minutes with leading zeros
          //    A - Uppercase Ante meridiem and Post meridiem (AM or PM)
          ShortTime: "g:i A", // in jQuery UI Datepicker: "h:mm tt"
          // long time (with seconds)
          //    g - 12-hour format of an hour without leading zeros
          //    i - Minutes with leading zeros
          //    s - Seconds, with leading zeros
          //    A - Uppercase Ante meridiem and Post meridiem (AM or PM)
          LongTime: "g:i:s A", // in jQuery UI Datepicker: "h:mm:ss tt"
          SortableDateTime: "Y-m-d\\TH:i:s",
          UniversalSortableDateTime: "Y-m-d H:i:sO",
          // month with year
          //    Y - A full numeric representation of a year, 4 digits
          //    F - A full textual representation of a month
          YearMonth: "F, Y" // in jQuery UI Datepicker: "MMMM, yyyy"
        },
        reformatAfterEdit: true
      },
      baseLinkUrl: '',
      showAction: '',
      target: '',
      checkbox: {disabled: true},
      idName: 'id'
    }
  });
}(jQuery);
// 1. When defining a culture, all fields are required except the ones stated as optional.
// 2. Each culture should have a ".calendars" object with at least one calendar named "standard"
//    which serves as the default calendar in use by that culture.
// 3. Each culture should have a ".calendar" object which is the current calendar being used,
//    it may be dynamically changed at any time to one of the calendars in ".calendars".
! function($) {
     fish.locale['en'] = $.extend(fish.locale['en'], {
        spinner: {
            // A unique name for the culture in the form <language code>-<country/region code>
            name: "en",
            // the name of the culture in the english language
            englishName: "English",
            // the name of the culture in its own language
            nativeName: "English",
            // whether the culture uses right-to-left text
            isRTL: false,
            // "language" is used for so-called "specific" cultures.
            // For example, the culture "es-CL" means "Spanish, in Chili".
            // It represents the Spanish-speaking culture as it is in Chili,
            // which might have different formatting rules or even translations
            // than Spanish in Spain. A "neutral" culture is one that is not
            // specific to a region. For example, the culture "es" is the generic
            // Spanish culture, which may be a more generalized version of the language
            // that may or may not be what a specific culture expects.
            // For a specific culture like "es-CL", the "language" field refers to the
            // neutral, generic culture information for the language it is using.
            // This is not always a simple matter of the string before the dash.
            // For example, the "zh-Hans" culture is netural (Simplified Chinese).
            // And the "zh-SG" culture is Simplified Chinese in Singapore, whose lanugage
            // field is "zh-CHS", not "zh".
            // This field should be used to navigate from a specific culture to it's
            // more general, neutral culture. If a culture is already as general as it
            // can get, the language may refer to itself.
            language: "en",
            // numberFormat defines general number formatting rules, like the digits in
            // each grouping, the group separator, and how negative numbers are displayed.
            numberFormat: {
                // [negativePattern]
                // Note, numberFormat.pattern has no "positivePattern" unlike percent and currency,
                // but is still defined as an array for consistency with them.
                //   negativePattern: one of "(n)|-n|- n|n-|n -"
                pattern: ["-n"],
                // number of decimal places normally shown
                decimals: 2,
                // string that separates number groups, as in 1,000,000
                ",": ",",
                // string that separates a number from the fractional portion, as in 1.99
                ".": ".",
                // array of numbers indicating the size of each number group.
                // TODO: more detailed description and example
                groupSizes: [3],
                // symbol used for positive numbers
                "+": "+",
                // symbol used for negative numbers
                "-": "-",
                // symbol used for NaN (Not-A-Number)
                "NaN": "NaN",
                // symbol used for Negative Infinity
                negativeInfinity: "-Infinity",
                // symbol used for Positive Infinity
                positiveInfinity: "Infinity",
                percent: {
                    // [negativePattern, positivePattern]
                    //   negativePattern: one of "-n %|-n%|-%n|%-n|%n-|n-%|n%-|-% n|n %-|% n-|% -n|n- %"
                    //   positivePattern: one of "n %|n%|%n|% n"
                    pattern: ["-n %", "n %"],
                    // number of decimal places normally shown
                    decimals: 2,
                    // array of numbers indicating the size of each number group.
                    // TODO: more detailed description and example
                    groupSizes: [3],
                    // string that separates number groups, as in 1,000,000
                    ",": ",",
                    // string that separates a number from the fractional portion, as in 1.99
                    ".": ".",
                    // symbol used to represent a percentage
                    symbol: "%"
                },
                currency: {
                    // [negativePattern, positivePattern]
                    //   negativePattern: one of "($n)|-$n|$-n|$n-|(n$)|-n$|n-$|n$-|-n $|-$ n|n $-|$ n-|$ -n|n- $|($ n)|(n $)"
                    //   positivePattern: one of "$n|n$|$ n|n $"
                    pattern: ["($n)", "$n"],
                    // number of decimal places normally shown
                    decimals: 2,
                    // array of numbers indicating the size of each number group.
                    // TODO: more detailed description and example
                    groupSizes: [3],
                    // string that separates number groups, as in 1,000,000
                    ",": ",",
                    // string that separates a number from the fractional portion, as in 1.99
                    ".": ".",
                    // symbol used to represent currency
                    symbol: "$"
                }
            },
            // calendars defines all the possible calendars used by this culture.
            // There should be at least one defined with name "standard", and is the default
            // calendar used by the culture.
            // A calendar contains information about how dates are formatted, information about
            // the calendar's eras, a standard set of the date formats,
            // translations for day and month names, and if the calendar is not based on the Gregorian
            // calendar, conversion functions to and from the Gregorian calendar.
            calendar: {
                // name that identifies the type of calendar this is
                name: "Gregorian_USEnglish",
                // separator of parts of a date (e.g. "/" in 11/05/1955)
                "/": "/",
                // separator of parts of a time (e.g. ":" in 05:44 PM)
                ":": ":",
                // the first day of the week (0 = Sunday, 1 = Monday, etc)
                firstDay: 0,
                days: {
                    // full day names
                    names: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                    // abbreviated day names
                    namesAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                    // shortest day names
                    namesShort: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
                },
                months: {
                    // full month names (13 months for lunar calendards -- 13th month should be "" if not lunar)
                    names: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December", ""],
                    // abbreviated month names
                    namesAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec", ""]
                },
                // AM and PM designators in one of these forms:
                // The usual view, and the upper and lower case versions
                //   [ standard, lowercase, uppercase ]
                // The culture does not use AM or PM (likely all standard date formats use 24 hour time)
                //   null
                AM: ["AM", "am", "AM"],
                PM: ["PM", "pm", "PM"],
                eras: [
                    // eras in reverse chronological order.
                    // name: the name of the era in this culture (e.g. A.D., C.E.)
                    // start: when the era starts in ticks (gregorian, gmt), null if it is the earliest supported era.
                    // offset: offset in years from gregorian calendar
                    {
                        "name": "A.D.",
                        "start": null,
                        "offset": 0
                    }
                ],
                // when a two digit year is given, it will never be parsed as a four digit
                // year greater than this year (in the appropriate era for the culture)
                // Set it as a full year (e.g. 2029) or use an offset format starting from
                // the current year: "+19" would correspond to 2029 if the current year 2010.
                twoDigitYearMax: 2029,
                // set of predefined date and time patterns used by the culture
                // these represent the format someone in this culture would expect
                // to see given the portions of the date that are shown.
                patterns: {
                    // short date pattern
                    d: "M/d/yyyy",
                    // long date pattern
                    D: "dddd, MMMM dd, yyyy",
                    // short time pattern
                    t: "h:mm tt",
                    // long time pattern
                    T: "h:mm:ss tt",
                    // long date, short time pattern
                    f: "dddd, MMMM dd, yyyy h:mm tt",
                    // long date, long time pattern
                    F: "dddd, MMMM dd, yyyy h:mm:ss tt",
                    // month/day pattern
                    M: "MMMM dd",
                    // month/year pattern
                    Y: "yyyy MMMM",
                    // S is a sortable format that does not vary by culture
                    S: "yyyy\u0027-\u0027MM\u0027-\u0027dd\u0027T\u0027HH\u0027:\u0027mm\u0027:\u0027ss"
                }
            },
            // For localized strings
            messages: {}
        }
    })
}(jQuery);

  //validator message & validator rule
! function($) {
   fish.locale['en'] = $.extend(fish.locale['en'], {
    validator: {
      'msg': {
        defaultMsg: "This field is not valid.",
        loadingMsg: "Validating...",
        digits: "Please enter only digits.",
        required: "This field is required.",
        remote: "Please try another name.",
        integer: {
          nzp: "Please enter an integer.",
          p: "Please enter a positive integer.",
          pz: "Please enter a positive integer or 0.",
          n: "Please enter a negative integer.",
          nz: "Please enter a negative integer or 0."
        },
        match: {
          eq: "{0} must be equal to {1}.",
          neq: "{0} must be not equal to {1}.",
          lt: "{0} must be less than {1}.",
          gt: "{0} must be greater than {1}.",
          lte: "{0} must be less than or equal to {1}.",
          gte: "{0} must be greater than or equal to {1}."
        },
        range: {
          rg: "Please enter a number between {1} and {2}.",
          gte: "Please enter a number greater than or equal to {1}.",
          lte: "Please enter a number less than or equal to {1}."
        },
        checked: {
          eq: "Please check {1} items.",
          rg: "Please check between {1} and {2} items.",
          gte: "Please check at least {1} items.",
          lte: "Please check no more than {1} items."
        },
        length: {
          eq: "Please enter {1} characters.",
          rg: "Please enter a value between {1} and {2} characters long.",
          gte: "Please enter at least {1} characters.",
          lte: "Please enter no more than {1} characters."
        }
      },
      'rules': {
        letters: [/^[a-z]+$/i, "{0} can only enter letters"], //纯字母
        tel: [/^(?:(?:0\d{2,3}[\- ]?[1-9]\d{6,7})|(?:[48]00[\- ]?[1-9]\d{6}))$/, "Telephone format is incorrect"], //办公或家庭电话
        mobile: [/^1[3-9]\d{9}$/, "Phone number format is incorrect"], //移动电话
        email: [/^[\w\+\-]+(\.[\w\+\-]+)*@[a-z\d\-]+(\.[a-z\d\-]+)*\.([a-z]{2,4})$/i, 'E-mail format is incorrect'],
        qq: [/^[1-9]\d{4,}$/, "QQ number format is incorrect"],
        date: [/^\d{4}-\d{1,2}-\d{1,2}$/, "Please enter the correct date[yyyy-mm-dd]"],
        time: [/^([01]\d|2[0-3])(:[0-5]\d){1,2}$/, "Enter the correct time[hh:ii(:ss)]"],
        datetime:[/^\d{4}-\d{1,2}-\d{1,2} ([01]\d|2[0-3])(:[0-5]\d){1,2}$/, "Please enter the correct datetime[yyyy-mm-dd hh:ii(:ss)]"],
        ID_card: [/^[1-9]\d{5}[1-9]\d{3}((0\d)|(1[0-2]))(([0|1|2]\d)|3[0-1])((\d{4})|\d{3}[A-Z])$/, "Please enter the correct ID number"],
        url: [/^(https?|ftp):\/\/[^\s]+$/i, "URL format is incorrect"],
        postcode: [/^[1-9]\d{5}$/, "ZIP format is incorrect"],
        chinese: [/^[\u0391-\uFFE5]+$/, "Please enter the Chinese"],
        username: [/^\w{3,12}$/, "Please enter 3-12 digits, letters, underscores"], //用户名
        password: [/^[0-9a-zA-Z]{6,16}$/, "Password from 6-16 digits, letters"], //密码
        //可接受的后缀名
        accept: function(element, params) {
          if (!params) return true;
          var ext = params[0];
          return (ext === '*') ||
            (new RegExp(".(?:" + (ext || "png|jpg|jpeg|gif") + ")$", "i")).test(element.value) ||
            this.renderMsg("{1} suffix only accept", ext.replace('|', ','));
        }
      }
    }
  })
}(jQuery);
/*
 * jQuery UI Accordion 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/accordion/
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 */

! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.accordion', factory);
    } else {
        factory();
    }
}(function() {

    'use strict';

    var uid = 0,
        hideProps = {},
        showProps = {};

    hideProps.height = hideProps.paddingTop = hideProps.paddingBottom =
        hideProps.borderTopWidth = hideProps.borderBottomWidth = "hide";
    showProps.height = showProps.paddingTop = showProps.paddingBottom =
        showProps.borderTopWidth = showProps.borderBottomWidth = "show";

    $.widget("ui.accordion", {
        widgetEventPrefix: '',
        options: {
            active: 0,
            animate: null, //默认值由{}修改成null,取消默认动画效果
            collapsible: false,
            event: "click",
            header: "> li > :first-child,.panel-heading", //li的第一个子元素或者含有panel-heading样式
            // header: "> li > :first-child,> :not(li):even",//li的第一个子元素或者1,3,5子元素h、div间隔布局
            heightStyle: "auto",
            icons: {
                activeHeader: "arrow-down",
                header: "arrow-left"
            },
            // callbacks
            activate: null,
            beforeActivate: null
        },

        _create: function() {
            var accordionId = this.accordionId = "ui-accordion-" +
                (this.element.attr("id") || ++uid),
                options = this.options;

            this.prevShow = this.prevHide = $();
            this.element.addClass("ui-accordion"); // ui-helper-reset

            this.headers = this.element.find(options.header)
                .addClass("ui-accordion-header"); // ui-helper-reset panel-heading
            this._hoverable(this.headers);
            this._focusable(this.headers);

            this.headers.next()
                .addClass("ui-accordion-content") // ui-helper-reset ui-widget-content ui-corner-bottom
                .hide();

            // don't allow collapsible: false and active: false / null
            if (!options.collapsible && (options.active === false || options.active == null)) {
                options.active = 0;
            }
            // handle negative values
            if (options.active < 0) {
                options.active += this.headers.length;
            }
            this.active = this._findActive(options.active)
                .addClass("ui-accordion-header-active") // ui-state-active
                // .toggleClass( "ui-corner-all ui-corner-top" );
            this.active.next()
                .addClass("ui-accordion-content-active")
                .show();

            this._createIcons();
            this.refresh();

            // ARIA
            this.element.attr("role", "tablist");

            this.headers
                .attr("role", "tab")
                .each(function(i) {
                    var header = $(this),
                        headerId = header.attr("id"),
                        panel = header.parent().next(),
                        panelId = panel.attr("id");
                    if (!headerId) {
                        headerId = accordionId + "-header-" + i;
                        header.attr("id", headerId);
                    }
                    if (!panelId) {
                        panelId = accordionId + "-panel-" + i;
                        panel.attr("id", panelId);
                    }
                    header.attr("aria-controls", panelId);
                    panel.attr("aria-labelledby", headerId);
                })
                .next()
                .attr("role", "tabpanel");

            this.headers
                .not(this.active)
                .attr({
                    "aria-selected": "false",
                    tabIndex: -1
                })
                .next()
                .attr({
                    "aria-expanded": "false",
                    "aria-hidden": "true"
                })
                .hide();

            // make sure at least one header is in the tab order
            if (!this.active.length) {
                this.headers.eq(0).attr("tabIndex", 0);
            } else {
                this.active.attr({
                        "aria-selected": "true",
                        tabIndex: 0
                    })
                    .next()
                    .attr({
                        "aria-expanded": "true",
                        "aria-hidden": "false"
                    });
            }

            this._setupEvents(options.event);
        },
        //create事件的参数
        _getCreateEventData: function() {
            return {
                header: this.active,
                content: !this.active.length ? $() : this.active.next()
            };
        },

        _createIcons: function() {
            var icons = this.options.icons;
            if (icons) {
                $("<span>")
                    .addClass("ui-accordion-header-icon " + icons.header)
                    .prependTo(this.headers);
                this.active.children(".ui-accordion-header-icon")
                    .removeClass(icons.header)
                    .addClass(icons.activeHeader);
                this.headers.addClass("ui-accordion-icons");
            }
        },

        _destroyIcons: function() {
            this.headers
                .removeClass("ui-accordion-icons")
                .children(".ui-accordion-header-icon")
                .remove();
        },

        _destroy: function() {
            var contents;
            // clean up main element
            this.element
                .removeClass("ui-accordion") //ui-helper-reset
                .removeAttr("role");

            // clean up headers
            this.headers
                .removeClass("ui-accordion-header") // ui-helper-reset ui-state-active ui-state-disabled
                .removeAttr("role")
                .removeAttr("aria-selected")
                .removeAttr("aria-controls")
                .removeAttr("tabIndex")
                .each(function() {
                    if (/^ui-accordion/.test(this.id)) {
                        this.removeAttribute("id");
                    }
                });
            this._destroyIcons();

            // clean up content panels
            contents = this.headers.next()
                .css("display", "")
                .removeAttr("role")
                .removeAttr("aria-expanded")
                .removeAttr("aria-hidden")
                .removeAttr("aria-labelledby")
                .removeClass("ui-accordion-content ui-accordion-content-active") //ui-helper-reset ui-widget-content ui-corner-bottom ui-state-disabled
                .each(function() {
                    if (/^ui-accordion/.test(this.id)) {
                        this.removeAttribute("id");
                    }
                });
            if (this.options.heightStyle !== "content") {
                contents.css("height", "");
            }
        },

        _setOption: function(key, value) {
            if (key === "active") {
                // _activate() will handle invalid values and update this.options
                this._activate(value);
                return;
            }

            if (key === "event") {
                if (this.options.event) {
                    this._off(this.headers, this.options.event);
                }
                this._setupEvents(value);
            }

            this._super(key, value);

            // setting collapsible: false while collapsed; open first panel
            if (key === "collapsible" && !value && this.options.active === false) {
                this._activate(0);
            }

            // if (key === "icons") { //不支持修改
            //     this._destroyIcons();
            //     if (value) {
            //         this._createIcons();
            //     }
            // }

            // #5332 - opacity doesn't cascade to positioned elements in IE
            // so we need to add the disabled class to the headers and panels
            if (key === "disabled") {
                this.headers.add(this.headers.next())
                    .toggleClass("ui-state-disabled", !!value);
            }
        },
        //用于
        refresh: function() {
            var maxHeight, overflow,
                heightStyle = this.options.heightStyle,
                parent = this.element.parent();


            if (heightStyle === "fill") {
                maxHeight = parent.height();
                this.element.siblings(":visible").each(function() {
                    var elem = $(this),
                        position = elem.css("position");

                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });
                if (overflow) {
                    parent.css("overflow", overflow);
                }

                this.headers.each(function() {
                    maxHeight -= $(this).outerHeight(true);
                });

                this.headers.next()
                    .each(function() {
                        $(this).height(Math.max(0, maxHeight -
                            $(this).innerHeight() + $(this).height()));
                    })
                    .css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.headers.next()
                    .each(function() {
                        maxHeight = Math.max(maxHeight, $(this).css("height", "").height());
                    })
                    .height(maxHeight);
            }
        },

        _activate: function(index) {
            var active = this._findActive(index)[0];

            // trying to activate the already active panel
            if (active === this.active[0]) {
                return;
            }

            // trying to collapse, simulate a click on the currently active header
            active = active || this.active[0];

            this._eventHandler({
                target: active,
                currentTarget: active,
                preventDefault: $.noop
            });
        },

        _findActive: function(selector) {
            return typeof selector === "number" ? this.headers.eq(selector) : $();
        },

        _setupEvents: function(event) {
            var events = {};
            if (!event) {
                return;
            }
            $.each(event.split(" "), function(index, eventName) {
                events[eventName] = "_eventHandler";
            });
            this._on(this.headers, events);
        },

        _eventHandler: function(event) {
            var options = this.options,
                active = this.active,
                clicked = $(event.currentTarget),
                clickedIsActive = clicked[0] === active[0],
                collapsing = clickedIsActive && options.collapsible,
                toShow = collapsing ? $() : clicked.next(),
                toHide = active.next(),
                eventData = {
                    oldHeader: active,
                    oldPanel: toHide,
                    newHeader: collapsing ? $() : clicked,
                    newPanel: toShow
                };

            event.preventDefault();

            if (
                // click on active header, but not collapsible
                (clickedIsActive && !options.collapsible) ||
                // allow canceling activation
                (this._trigger("beforeActivate", event, eventData) === false)) {
                return;
            }

            options.active = collapsing ? false : this.headers.index(clicked);

            // when the call to ._toggle() comes after the class changes
            // it causes a very odd bug in IE 8 (see #6720)
            this.active = clickedIsActive ? $() : clicked;
            this._toggle(eventData);

            // switch classes
            // corner classes on the previously active header stay after the animation
            active.removeClass("ui-accordion-header-active"); // ui-state-active
            if (options.icons) {
                active.children(".ui-accordion-header-icon")
                    .removeClass(options.icons.activeHeader)
                    .addClass(options.icons.header);
            }

            if (!clickedIsActive) {
                clicked
                // .removeClass("ui-corner-all")
                    .addClass("ui-accordion-header-active"); // ui-state-active ui-corner-top
                if (options.icons) {
                    clicked.children(".ui-accordion-header-icon")
                        .removeClass(options.icons.header)
                        .addClass(options.icons.activeHeader);
                }

                clicked
                    .next()
                    .addClass("ui-accordion-content-active");
            }
        },

        _toggle: function(data) {
            var toShow = data.newPanel,
                toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

            // handle activating a panel during the animation for another activation
            this.prevShow.add(this.prevHide).stop(true, true);
            this.prevShow = toShow;
            this.prevHide = toHide;
            if (this.options.animate) {
                this._animate(toShow, toHide, data);
            } else {
                toHide.hide();
                toShow.show();
                this._toggleComplete(data);
            }

            toHide.attr({
                "aria-expanded": "false",
                "aria-hidden": "true"
            });
            toHide.prev().attr("aria-selected", "false");
            // if we're switching panels, remove the old header from the tab order
            // if we're opening from collapsed state, remove the previous header from the tab order
            // if we're collapsing, then keep the collapsing header in the tab order
            if (toShow.length && toHide.length) {
                toHide.prev().attr("tabIndex", -1);
            } else if (toShow.length) {
                this.headers.filter(function() {
                        return $(this).attr("tabIndex") === 0;
                    })
                    .attr("tabIndex", -1);
            }

            toShow
                .attr({
                    "aria-expanded": "true",
                    "aria-hidden": "false"
                })
                .prev()
                .attr({
                    "aria-selected": "true",
                    tabIndex: 0
                });
        },

        _animate: function(toShow, toHide, data) {
            var total, easing, duration,
                that = this,
                adjust = 0,
                down = toShow.length &&
                (!toHide.length || (toShow.index() < toHide.index())),
                animate = this.options.animate || {},
                options = down && animate.down || animate,
                complete = function() {
                    that._toggleComplete(data);
                };

            if (typeof options === "number") {
                duration = options;
            }
            if (typeof options === "string") {
                easing = options;
            }
            // fall back from options to animation in case of partial down settings
            easing = easing || options.easing || animate.easing;
            duration = duration || options.duration || animate.duration;

            if (!toHide.length) {
                return toShow.animate(showProps, duration, easing, complete);
            }
            if (!toShow.length) {
                return toHide.animate(hideProps, duration, easing, complete);
            }

            total = toShow.show().outerHeight();
            toHide.animate(hideProps, {
                duration: duration,
                easing: easing,
                step: function(now, fx) {
                    fx.now = Math.round(now);
                }
            });
            toShow
                .hide()
                .animate(showProps, {
                    duration: duration,
                    easing: easing,
                    complete: complete,
                    step: function(now, fx) {
                        fx.now = Math.round(now);
                        if (fx.prop !== "height") {
                            adjust += fx.now;
                        } else if (that.options.heightStyle !== "content") {
                            fx.now = Math.round(total - toHide.outerHeight() - adjust);
                            adjust = 0;
                        }
                    }
                });
        },

        _toggleComplete: function(data) {
            var toHide = data.oldPanel;

            toHide
                .removeClass("ui-accordion-content-active")
                .prev()
                // .removeClass( "ui-corner-top" )
                // .addClass( "ui-corner-all" );

            // Work around for rendering bug in IE (#5421)
            if (toHide.length) {
                toHide.parent()[0].className = toHide.parent()[0].className;
            }

            this._trigger("activate", null, data);
        }
    });

});


/**
 * Accordion Widget
 * @class fish.desktop.widget.Accordion
 * @extends fish.desktop.widget
 * <pre>
 *   $(element).accordion(option);
 * </pre>
 */

/**
 * @cfg {Number} active=0
 * 默认展开第一个页签
 * The zero-based index of the panel that is active (open).
 * A negative value selects panels going backward from the last panel.
 * Setting active to false will collapse all panels. This requires the collapsible option to be true.
 */

/**
 * @cfg {Object} animate=null
 * 可支持动画效果
 * settings with easing and duration properties.
 *   Multiple types supported:
 *   Boolean: A value of false will disable animations.
 *   Number: Duration in milliseconds with default easing.
 *   String: Name of easing to use with default duration.
 */
/**
 * @cfg {Boolean} collapsible=false
 * 点击是否能够收缩已展开的面板
 * Whether all the sections can be closed at once. Allows collapsing the active section.
 */
/**
 * @cfg {Boolean} disabled=false
 * Disables the accordion if set to true.
 */
/**
 * @cfg {String} event="click"
 * 默认为鼠标点击事件,支持mouseover
 * The event that accordion headers will react to in order to activate the associated panel. Multiple events can be specified, separated by a space.
 */
/**
 * @cfg {selector} header="> li > :first-child,.panel-heading"
 * li的第一个子元素或者含有panel-heading样式
 * Selector for the header element, applied via .find() on the main accordion element. Content panels must be the sibling immedately after their associated headers.
 */
/**
 * @cfg {String} heightStyle="auto"
 * panel的高度控制
 * Controls the height of the accordion and each panel. Possible values:
 * "auto": All panels will be set to the height of the tallest panel.
 * "fill": Expand to the available height based on the accordion's parent height.
 * "content": Each panel will be only as tall as its content.
 */

/**
 * @method refresh
 * Process any headers and panels that were added or removed directly in the DOM and recompute the height of the accordion panels. Results depend on the content and the heightStyle option.
 */

/**
 * Triggered after a panel has been activated (after animation completes).
 * If the accordion was previously collapsed, ui.oldHeader and ui.oldPanel will be empty jQuery objects.
 * If the accordion is collapsing, ui.newHeader and ui.newPanel will be empty jQuery objects.
 * Note: Since the activate event is only fired on panel activation, it is not fired for the initial panel when the accordion widget is created. If you need a hook for widget creation use the create event.
 * @event activate
 * @param  {Object} event
 * @param  {Object} ui ui.newHeader,The header that was just activated;ui.oldHeader,The header that was just deactivated;ui.newPanel,The panel that was just activated; ui.oldPanel,The panel that was just deactivated.
 */

/**
 * Triggered directly before a panel is activated.
 * Can be canceled to prevent the panel from activating.
 * If the accordion is currently collapsed, ui.oldHeader and ui.oldPanel will be empty jQuery objects. If the accordion is collapsing, ui.newHeader and ui.newPanel will be empty jQuery objects.
 * @event beforeActivate
 * @param  {Object} event
 * @param  {Object} ui ui.newHeader,The header that is about to be activated;ui.oldHeader,The header that is about to be deactivated;ui.newPanel,The panel that is about to be activated; ui.oldPanel,The panel that is about to be deactivated.
 */

/**
 * Triggered when the accordion is created.
 * If the accordion is collapsed, ui.header and ui.panel will be empty jQuery objects.
 * @event create
 * @param  {Object} event
 * @param  {Object} ui ui.header,The active header;ui.panel,The active panel.
 */

/* ========================================================================
 * Bootstrap: affix.js v3.2.0
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.affix', factory);
    } else {
        factory();
    }
}(function() {

    'use strict';

    /**
     * Affix Widget
     * @class fish.desktop.widget.Affix
     * <pre>
     *   $(element).affix(option);
     * </pre>
     */
    $.widget("ui.affix", {
        options: {
            /**
             * Pixels to offset from screen when calculating position of scroll.
             * If a single number is provided, the offset will be applied in both top and bottom directions.
             * To provide a unique, bottom and top offset just provide an object offset: { top: 10 } or offset: { top: 10, bottom: 5 }.
             * Use a function when you need to dynamically calculate an offset.
             * @cfg {Object} offset=0
             */
            offset: 0,
            /**
             * Specifies the target element of the affix.
             * @cfg {selector} target=window type:selector | node | jQuery element
             */
            target: window

        },
        //bootstrap原生控件命名方式不变
        widgetEventPrefix: "",

        _create: function() {
            this.$target = $(this.options.target)
                .on('scroll', $.proxy(this._checkPosition, this)) //.bs.affix.data-api
                .on('click', $.proxy(this._checkPositionWithEventLoop, this)); //TODO IE8下window不能响应chick事件,这里先忽略

            this.$element = $(this.element);
            this.pinnedOffset = null;
            this._checkPosition();
        },
        _getPinnedOffset: function() {
            if (this.pinnedOffset) return this.pinnedOffset;
            this.$element.removeClass('affix affix-top affix-bottom').addClass('affix');
            var scrollTop = this.$target.scrollTop();
            var position = this.$element.offset();
            return (this.pinnedOffset = position.top - scrollTop);
        },

        _checkPositionWithEventLoop: function() {
            setTimeout($.proxy(this._checkPosition, this), 1)
        },

        _checkPosition: function() {
            if (!this.$element.is(':visible')) return;

            var scrollHeight = $(document).height();
            var scrollTop = this.$target.scrollTop();
            var position = this.$element.offset();
            var offset = this.options.offset;
            var offsetTop = offset.top;
            var offsetBottom = offset.bottom;

            if (typeof offset != 'object') offsetBottom = offsetTop = offset;
            if (typeof offsetTop == 'function') offsetTop = offset.top(this.$element);
            if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element);

            var affix = this.unpin != null && (scrollTop + this.unpin <= position.top) ? false :
                offsetBottom != null && (position.top + this.$element.height() >= scrollHeight - offsetBottom) ? 'bottom' :
                offsetTop != null && (scrollTop <= offsetTop) ? 'top' : false;

            if (this.affixed === affix) return;
            if (this.unpin != null) this.$element.css('top', '');

            var affixType = 'affix' + (affix ? '-' + affix : '');

            if (!this._trigger(affixType)) return;

            // var e = $.Event(affixType) //+ '.bs.affix'

            // this.$element.trigger(e)

            // if (e.isDefaultPrevented()) return

            this.affixed = affix
            this.unpin = affix == 'bottom' ? this._getPinnedOffset() : null

            this.$element
                .removeClass('affix affix-top affix-bottom')
                .addClass(affixType);

            this._trigger(affixType.replace('affix', 'affixed'));

            // .trigger($.Event(affixType.replace('affix', 'affixed')))

            if (affix == 'bottom') {
                this.$element.offset({
                    top: scrollHeight - this.$element.height() - offsetBottom
                })
            }
        }

    });


    /**
     * This event fires immediately before the element has been affixed.
     * @event affix
     */
    /**
     * This event is fired after the element has been affixed.
     * @event affixed
     */
    /**
     * This event fires immediately before the element has been affixed-top.
     * @event affix-top
     */
    /**
     * This event is fired after the element has been affixed-top.
     * @event affixed-top
     */
    /**
     * This event fires immediately before the element has been affixed-bottom.
     * @event affix-bottom
     */
    /**
     * This event is fired after the element has been affixed-bottom.
     * @event affixed-bottom
     */

});

/*
 * fish Alerts
 *
 * Depends:
 *
 *  fish.js
 *  fish.dialog.js
 */
! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.alert', ['fish.dialog'], factory);
    } else {
        factory();
    }
}(function() {

    'use strict';
    /**
     * Alert Widget
     * 此方法直接挂载在fish对象下面，可直接使用
     * @class fish.desktop.widget.Alert
     * <pre>
        fish.showInfo(message);
     * </pre>
     */
    var dialog = {},
        increments = 0,
        tpl = {},
        tplCache = {};

    var basicOption = {
        autoOpen: true,
        buttons: {},
        closeOnEscape: true,
        draggable: true,
        height: "auto",
        maxHeight: false,
        maxWidth: false,
        minHeight: 150,
        minWidth: 400,
        resizable: false,
        modal: true,
        closeOnClickOverlay: true,
        useIcon: true, //默认使用图标
        show: {
            effect: 'fade',
            duration: 300
        }
    };

    tpl.info = '<div class="modal-header"><h4 class="modal-title">{{title}}</h4></div><div class="modal-body"></div><div class="modal-footer"><button type="button" class="btn btn-primary">{{btnOk}}</button></div>';

    tpl.confirm = '<div class="modal-header"><h4 class="modal-title">{{title}}</h4></div><div class="modal-body"></div><div class="modal-footer"></div>';

    tpl.prompt = '<div class="modal-header"><h4 class="modal-title">{{title}}</h4></div><div class="modal-body"><div></div><input type="text" class="form-control"></div><div class="modal-footer"></div>';

    /*
     * 创建Dialog
     * @param tplName
     * @param tplParam
     * @param opts
     */
    function createBaseDialog(tplName, tplParam, opts) {
        if (!tplCache[tplName]) {
            var params = $.extend({
                title: fish.getResource('alert.information'),
                btnOk: fish.getResource('alert.ok')
            }, tplParam);
            tplCache[tplName] = Handlebars.compile(tpl[tplName] || tpl.info)(params);
        }

        var $dialog = $('<div class="ui-dialog">').attr('id', 'ui-alert-' + increments++).append(tplCache[tplName]);

        var body = (opts.useIcon ? getIcon(tplName).get(0).outerHTML : '') + '<span>' + (opts.content || '') + '</span>';

        $dialog.find('.modal-body').html(body);
        $dialog.find('button').on('click', function() {
            $dialog.dialog('close');
        });
        $dialog.appendTo('body').dialog(opts);
        $dialog.on("dialogclose", function(event, ui) {
            _.defer(function() {
                $dialog.dialog('destroy');
            });
        });
    }

    /*
     * 解析参数
     * @param defaultOpts
     * @param args
     * @returns {*}
     */
    function parseArgs(defaultOpts, args) {
        var opts;
        switch ($.type(args[0])) {
            case 'undefined':
            case 'string':
                opts = {
                    content: args[0] || '',
                    title: args[1] || ''
                };
                opts = $.extend({}, defaultOpts, opts);
                break;
            case 'object':
                opts = $.extend({}, defaultOpts, args[0]);
                break;
        }
        return opts;
    }

    /*
     * 获取图标节点
     * @param type
     * @returns {$|*|jQuery|HTMLElement}
     */
    function getIcon(type) {
        var $span = $('<span>');
        switch (type) {
            case 'info':
                $span.addClass('glyphicon glyphicon-send');
                break;
            case 'suc':
                $span.addClass('glyphicon glyphicon-ok');
                break;
            case 'warn':
                $span.addClass('glyphicon glyphicon-flash');
                break;
            case 'error':
                $span.addClass('glyphicon glyphicon-remove');
                break;
        }
        return $span;
    }

    /**
     * 提示信息
     * @method showInfo
     * @param {Object} arguments
     */
    dialog.showInfo = function() {
        var opts = parseArgs(basicOption, arguments);
        opts.dialogClass = ' ui-alert ui-alert-info';

        createBaseDialog('info', {
            title: fish.getResource('alert.information')
        }, opts);
    };

    /**
     * 操作成功
     * @method showSuccess
     * @param {Object} arguments
     */
    dialog.showSuccess = function() {
        var opts = parseArgs(basicOption, arguments);
        opts.dialogClass = ' ui-alert ui-alert-suc';

        createBaseDialog('suc', {
            title: fish.getResource('alert.success')
        }, opts);
    };

    /**
     * 警告提示
     * @method showWarn
     * @param {Object} arguments
     */
    dialog.showWarn = function() {
        var opts = parseArgs(basicOption, arguments);
        opts.dialogClass = ' ui-alert ui-alert-warn';

        createBaseDialog('warn', {
            title: fish.getResource('alert.warn')
        }, opts);
    };

    /**
     * 错误提示
     * @method showError
     * @param {Object} arguments
     */
    dialog.showError = function() {
        var opts = parseArgs(basicOption, arguments);
        opts.dialogClass = ' ui-alert ui-alert-error';
        opts.closeOnEscape = false;
        opts.backdrop = false;

        createBaseDialog('error', {
            title: fish.getResource('alert.error')
        }, opts);
    };

    /**
     * 确认提示
     * @method showConfirm
     * @param {Object} arguments
     * <pre>
     *   fish.showConfirm({});//options
     *   fish.showConfirm(message,callback1,callback2);
     *   fish.showConfrim(content,title,callback1,callback2);
     * </pre>
     */
    dialog.showConfirm = function() {
        var opts = {};
        switch ($.type(arguments[0])) {
            case 'undefined':
            case 'string':
                var title, callback1, callback2;
                if ($.type(arguments[1]) == 'function') {
                    callback1 = arguments[1];
                    callback2 = arguments[2];
                } else if ($.type(arguments[1] == 'string')) {
                    title = arguments[1];
                    callback1 = arguments[2];
                    callback2 = arguments[3];
                }
                opts = {
                    content: arguments[0] || '',
                    title: title || ''
                };
                opts = $.extend({}, basicOption, opts);

                opts.buttons = [{
                    label: fish.getResource('alert.confirm'),
                    callback: callback1 || $.noop
                }, {
                    label: fish.getResource('alert.cancel'),
                    callback: callback2 || $.noop
                }];

                break;
            case 'object':
                opts = $.extend({}, basicOption, arguments[0]);
                break;
        }

        opts.dialogClass = ' ui-alert ui-alert-confirm';
        opts.backdrop = false;
        opts.closeOnEscape = false;

        var params = {
            title: fish.getResource('alert.confirm')
        };
        tplCache.confirm = Handlebars.compile(tpl.confirm)(params);

        var $dialog = $('<div>').attr('id', 'ui-alert-' + increments++).append(tplCache.confirm);

        $.each(opts.buttons, function(index, obj) {
            var $button = $('<button type="button">').addClass('btn btn-primary ui-alert-confirm' + index).text(obj.label);
            $button.on('click', function() {
                $dialog.dialog('close');
                obj.callback && obj.callback.call($dialog);
            });
            $dialog.find('.modal-footer').append($button);
        });

        $dialog.find('.modal-body').html(opts.content || '');

        $dialog.appendTo('body').dialog(opts);
        $dialog.on("dialogclose", function(event, ui) {
            setTimeout(function(){
                $dialog.dialog('destroy');
            },0)
        });
    };

    /**
     * 阻塞式确认框
     * @method showConfirm2
     * @param e 事件对象
     * <pre>
     *   fish.showConfirm2(e,message)
     *   fish.showConfrim2(e,message,title);
     * </pre>
     */
    dialog.showConfirm2 = function(e) {
        e = $.event.fix(e);
        var me = e.target;
        if (me.confirmResult) { //相当于调用了两次
            me.confirmResult = false;
            return true;
        }
        dialog.showConfirm(arguments[1], arguments[2], function() {
            me.confirmResult = true;
            if (me.click) me.click(e);
            return false;
        });
        return false;
    }

    /**
     * 请求输入值
     * @method showPrompt
     * <pre>
     *   fish.showPrompt(message,title,callback)
     *   fish.showPrompt(message,callback)
     * </pre>
     */
    dialog.showPrompt = function(message, title, callback) {
        if ($.type(title) == 'function') {
            callback = title;
            title = '';
        }

        var opts = {
            content: message || '',
            title: title || ''
        };
        opts = $.extend({}, basicOption, opts);

        opts.buttons = [{
            label: fish.getResource('alert.confirm'),
            callback: callback || $.noop
        }, {
            label: fish.getResource('alert.cancel'),
            callback: $.noop
        }];

        opts.dialogClass = ' ui-alert ui-alert-prompt';
        opts.backdrop = false;
        opts.closeOnEscape = false;

        if (!tplCache.prompt) {
            tplCache.prompt = Handlebars.compile(tpl.prompt)({
                title: fish.getResource('alert.prompt')
            });
        }

        var $dialog = $('<div>').attr('id', 'ui-alert-' + increments++).append(tplCache.prompt);

        $.each(opts.buttons, function(index, obj) {
            var $button = $('<button type="button">').addClass('btn btn-primary ui-alert-confirm' + index).text(obj.label);
            $button.on('click', function() {
                $dialog.dialog('close');
                obj.callback && obj.callback.call($dialog, $.trim($dialog.find('input').val()) || '');
            });
            $dialog.find('.modal-footer').append($button);
        });

        $dialog.find('.modal-body').children().first().html(opts.content || '');

        $dialog.appendTo('body').dialog(opts);
        $dialog.on("dialogclose", function(event, ui) {
            setTimeout(function(){
                $dialog.dialog('destroy');
            },0)
        });
    }


    /*Toast */
    var $toasts = null,
        toastConfig = {};

    /*
     *
     * @type {{config: {}}}
     *        config
     *          width:toast宽度
     *          align: left | right | center //TODO
     *
     */
    dialog.toast = {
        config: {}
    }; //全局配置
    /**
     * Toast
     * @method Toast
     * @param {String} message 展示的内容
     * @param {Object} opts 参数对象
     *            type: default | info | success | warn | error， toast类型
     *            duration: 5000,显示时间
     *            sticky: false（默认值）,boolean 是否固定
     *            closeForStickyOnly：false(默认值)；hide场景：只有不是固定的li，才可以不显示x按钮，其他情况都要显示x按钮
     *
     */
    dialog.showToast = function(message, opts) {

        // fix option type
        opts = $.extend({
            duration: 5000,
            sticky: false,
            'type': ''
        }, opts);

        typeof opts.duration === 'number' || (opts.duration = 5000);
        typeof opts.sticky === 'boolean' || (opts.sticky = false);
        typeof opts.type === 'string' || (opts.type = '');

        // create host on first call。 (toast containers)
        if (!$toasts) {
            // get/fix config
            toastConfig = dialog.toast.config;
            $toasts = $('<ul></ul>').addClass('ui-alert-toast').appendTo(document.body).hide();
            typeof toastConfig.width === 'number' || (toastConfig.width = 500);
            typeof toastConfig.align === 'string' || (toastConfig.align = 'center');
            typeof toastConfig.closeForStickyOnly === 'boolean' || (toastConfig.closeForStickyOnly = false);
            $toasts.width(toastConfig.width);


            if (toastConfig.align === 'left' || toastConfig.align === 'right') {
                $toasts.css('margin', '5px').css(toastConfig.align, '0')
            } else {
                $toasts.css({
                    left: '50%',
                    margin: '5px 0 0 -' + (toastConfig.width / 2) + 'px'
                });
            }
        }
        // create toast
        var ti = $('<li></li>').hide().html(message).appendTo($toasts),
            cb = $('<button>&times;</button>').addClass('close').prependTo(ti), //×
            to = null;

        var _closeToasts = function(){
            clearTimeout(to);
            ti.animate({
                height: 0,
                opacity: 0
            }, 'fast', function() {
                ti.remove();
                $toasts.children().length || $toasts.removeClass('active').hide();
            });
        }
        // setup close button
        cb.on("click",_closeToasts);

        //hide场景：只有不是固定的li，才可以不显示x按钮，其他情况都要显示x按钮
        toastConfig.closeForStickyOnly && !opts.sticky && cb.hide();

        // add type class
        opts.type !== '' && ti.addClass(opts.type);

        // show host if necessary
        !$toasts.hasClass('active') && $toasts.addClass('active').show();
        // setup timeout unless sticky
        !opts.sticky && opts.duration > 0 && (to = setTimeout(function() {
            _closeToasts();
        }, opts.duration));

        // show toast
        ti.fadeIn('normal');
    }


    //API
    $.extend(fish, dialog);
});

/*
 * Autocomplete
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 *  jquery.ui.position.js
 *  jquery.ui.menu.js
 */

! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.autocomplete', ['fish.menu'], factory);
    } else {
        factory();
    }
}(function() {
    'use strict';
    /**
     * Autocomplete Widget
     * @class fish.desktop.widget.Autocomplete
     * @extends fish.desktop.widget
     * <pre>
        $(element).autocomplete(option);
     * </pre>
     */
    $.widget("ui.autocomplete", {
        widgetEventPrefix: '',
        defaultElement: "<input>",
        options: {
            /**
             * Which element the menu should be appended to.
             * Override this when the autocomplete is inside a position: fixed element. Otherwise the popup menu would still scroll with the page.
             * @cfg {selector} appendTo
             */
            appendTo: null,
            /**
             * If set to true the first item will automatically be focused when the menu is shown.
             * 显示下拉菜单的时候是否自动选中第一个
             * @cfg {Boolean} autoFocus=false
             */
            autoFocus: false,
            /**
             * The delay in milliseconds between when a keystroke occurs and when a search is performed.
             * A zero-delay makes sense for local data (more responsive), but can produce a lot of load for remote data, while being less responsive.
             * @cfg {Number} delay=300
             */
            delay: 300,
            /**
             * Disables the autocomplete if set to true.
             * @cfg {Boolean} disabled=false
             */
            /**
             * The minimum number of characters a user must type before a search is performed.
             * Zero is useful for local data with just a few items, but a higher value should be used when a single character search could match a few thousand items.
             * 输入多少个字符时出现自动提示,0表示不用输入就能出现下拉菜单,1表示首字母匹配,2表示匹配前两个字符...
             * @cfg {Number} minLength=1
             */
            minLength: 1,
            /**
             * Identifies the position of the suggestions menu in relation to the associated input element.
             * The of option defaults to the input element, but you can specify another element to position against.
             * 菜单的显示位置,默认是下拉菜单的左上角跟input元素的左下角对齐
             * @cfg {Object} position = { my: "left top", at: "left bottom", collision: "none" }
             */
            position: {
                my: "left top",
                at: "left bottom",
                collision: "none"
            },
            /**
             * Defines the data to use, must be specified.
             * 下拉菜单的数据源
             * @cfg {*} source Type:Array|String|Function(request,response(Object data))
             * <pre>
             *   $(element).autocomplete({ source: [ "c++", "java", "php", "coldfusion", "javascript", "asp", "ruby" ] });
             * </pre>
             */
            source: null,
            /**
             * Add class to the suggestions menu.Such as set Maxheight
             * 可以自定义下拉菜单的高度等样式
             * @cfg {String} customClass
             */

            /**
             * Triggered when the field is blurred, if the value has changed.
             * @cfg {Function} change
             */
            change: null,
            /**
             * Triggered when the menu is hidden.
             * Not every close event will be accompanied by a change event.
             * @cfg {Function} close
             */
            close: null,
            /**
             * Triggered when focus is moved to an item (not selecting).
             * The default action is to replace the text field's value with the value of the focused item, though only if the event was triggered by a keyboard interaction.
             * @cfg {Function} focus
             */
            focus: null,
            /**
             * Triggered when the autocomplete is created.
             * @cfg {Function} open
             */
            open: null,
            /**
             * Triggered when the suggestion menu is opened or updated.
             * @cfg {Function} create
             */
            /**
             * Triggered after a search completes, before the menu is shown.
             * Useful for local manipulation of suggestion data, where a custom source option callback is not required.
             * This event is always triggered when a search completes, even if the menu will not be shown because there are no results or the Autocomplete is disabled.
             * @cfg {Function} response
             */
            response: null,
            /**
             * Triggered before a search is performed, after minLength and delay are met.
             * If canceled, then no request will be started and no items suggested.
             * @cfg {Function} search
             */
            search: null,
            /**
             * Triggered when an item is selected from the menu.
             * The default action is to replace the text field's value with the value of the selected item.
             * @cfg {Function} select
             */
            select: null
        },

        requestIndex: 0,
        pending: 0,

        _create: function() {
            // Some browsers only repeat keydown events, not keypress events,
            // so we use the suppressKeyPress flag to determine if we've already
            // handled the keydown event. #7269
            // Unfortunately the code for & in keypress is the same as the up arrow,
            // so we use the suppressKeyPressRepeat flag to avoid handling keypress
            // events when we know the keydown event was used to modify the
            // search term. #7799
            var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
                nodeName = this.element[0].nodeName.toLowerCase(),
                isTextarea = nodeName === "textarea",
                isInput = nodeName === "input";

            this.isMultiLine =
                // Textareas are always multi-line
                isTextarea ? true :
                // Inputs are always single-line, even if inside a contentEditable element
                // IE also treats inputs as contentEditable
                isInput ? false :
                // All other element types are determined by whether or not they're contentEditable
                this.element.prop("isContentEditable");

            this.valueMethod = this.element[isTextarea || isInput ? "val" : "text"];
            this.isNewMenu = true;

            this.element.addClass("ui-autocomplete-input ui-widget-create").attr("autocomplete", "off");

            //input element
            this._on(this.element, {
                /*
                 * keydown事件
                 * @param event
                 */
                keydown: function(event) {
                    if (this.element.prop("readOnly")) {
                        suppressKeyPress = true;
                        suppressInput = true;
                        suppressKeyPressRepeat = true;
                        return;
                    }

                    suppressKeyPress = false;
                    suppressInput = false;
                    suppressKeyPressRepeat = false;
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                        case keyCode.PAGE_UP:
                            suppressKeyPress = true;
                            this._move("previousPage", event);
                            break;
                        case keyCode.PAGE_DOWN:
                            suppressKeyPress = true;
                            this._move("nextPage", event);
                            break;
                        case keyCode.UP:
                            suppressKeyPress = true;
                            this._keyEvent("previous", event);
                            break;
                        case keyCode.DOWN:
                            suppressKeyPress = true;
                            this._keyEvent("next", event);
                            break;
                        case keyCode.ENTER:
                        case keyCode.NUMPAD_ENTER:
                            // when menu is open and has focus
                            if (this.menu.active) {
                                // #6055 - Opera still allows the keypress to occur
                                // which causes forms to submit
                                suppressKeyPress = true;
                                event.preventDefault();
                                this.menu.select(event);
                            }
                            break;
                        case keyCode.TAB:
                            if (this.menu.active) {
                                this.menu.select(event);
                            }
                            break;
                        case keyCode.ESCAPE:
                            if (this.menu.element.is(":visible")) {
                                this._value(this.term);
                                this.close(event);
                                // Different browsers have different default behavior for escape
                                // Single press can mean undo or clear
                                // Double press in IE means clear the whole form
                                event.preventDefault();
                            }
                            break;
                        default:
                            suppressKeyPressRepeat = true;
                            // search timeout should be triggered before the input value is changed
                            this._searchTimeout(event);
                            break;
                    }
                },
                /*
                 * keypress 事件
                 * @param event
                 */
                keypress: function(event) {
                    if (suppressKeyPress) {
                        suppressKeyPress = false;
                        if (!this.isMultiLine || this.menu.element.is(":visible")) {
                            event.preventDefault();
                        }
                        return;
                    }
                    if (suppressKeyPressRepeat) {
                        return;
                    }

                    // replicate some key handlers to allow them to repeat in Firefox and Opera
                    var keyCode = $.ui.keyCode;
                    switch (event.keyCode) {
                        case keyCode.PAGE_UP:
                            this._move("previousPage", event);
                            break;
                        case keyCode.PAGE_DOWN:
                            this._move("nextPage", event);
                            break;
                        case keyCode.UP:
                            this._keyEvent("previous", event);
                            break;
                        case keyCode.DOWN:
                            this._keyEvent("next", event);
                            break;
                    }
                },
                /*
                 * 输入事件
                 * @param event
                 */
                input: function(event) {
                    if (suppressInput) {
                        suppressInput = false;
                        event.preventDefault();
                        return;
                    }
                    this._searchTimeout(event);
                },
                /*
                 * 聚焦事件
                 */
                focus: function() {
                    this.selectedItem = null;
                    this.previous = this._value();
                },
                /*
                 * 失去焦点事件
                 * @param event
                 */
                blur: function(event) {
                    if (this.cancelBlur) {
                        delete this.cancelBlur;
                        return;
                    }

                    clearTimeout(this.searching);
                    this.close(event);
                    this._change(event);
                }
            });

            this._initSource();
            this.menu = $("<ul>")
                .addClass("ui-autocomplete ui-front")
                .appendTo(this._appendTo())
                .menu({
                    // disable ARIA support, the live region takes care of that
                    role: null
                })
                .hide()
                .data("ui-menu");

            //menu instance
            this._on(this.menu.element, {
                /*
                 * 鼠标按键
                 * @param event
                 */
                mousedown: function(event) {
                    // prevent moving focus out of the text field
                    event.preventDefault();

                    // IE doesn't prevent moving focus even with event.preventDefault()
                    // so we set a flag to know when we should ignore the blur event
                    this.cancelBlur = true;
                    this._delay(function() {
                        delete this.cancelBlur;
                    });

                    // clicking on the scrollbar causes focus to shift to the body
                    // but we can't detect a mouseup or a click immediately afterward
                    // so we have to track the next mousedown and close the menu if
                    // the user clicks somewhere outside of the autocomplete
                    var menuElement = this.menu.element[0];
                    if (!$(event.target).closest(".ui-menu-item").length) {
                        this._delay(function() {
                            var that = this;
                            this.document.one("mousedown", function(event) {
                                if (event.target !== that.element[0] &&
                                    event.target !== menuElement && !$.contains(menuElement, event.target)) {
                                    that.close();
                                }
                            });
                        });
                    }
                },
                /*
                 * 弹出菜单聚焦事件
                 * ui.widget.js _trigger('focus'), event.type='menufocus'
                 * @param event
                 * @param ui
                 */
                menufocus: function(event, ui) {
                    // support: Firefox
                    // Prevent accidental activation of menu items in Firefox (#7024 #9118)
                    if (this.isNewMenu) {
                        this.isNewMenu = false;
                        if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
                            this.menu.blur();

                            this.document.one("mousemove", function() {
                                $(event.target).trigger(event.originalEvent);
                            });

                            return;
                        }
                    }

                    var item = ui.item.data("ui-autocomplete-item");
                    if (false !== this._trigger("focus", event, {
                            item: item
                        })) {
                        // use value to match what will end up in the input, if it was a key event
                        if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
                            this._value(item.value);
                        }
                    } else {
                        // Normally the input is populated with the item's value as the
                        // menu is navigated, causing screen readers to notice a change and
                        // announce the item. Since the focus event was canceled, this doesn't
                        // happen, so we update the live region so that screen readers can
                        // still notice the change and announce it.
                        this.liveRegion.text(item.value);
                    }
                },
                /*
                 * 弹出菜单选择事件
                 * @param event
                 * @param ui
                 */
                menuselect: function(event, ui) {

                    var item = ui.item.data("ui-autocomplete-item"),
                        previous = this.previous;

                    // only trigger when focus was lost (click on menu)
                    if (this.element[0] !== this.document[0].activeElement) {
                        this.element.focus();
                        this.previous = previous;
                        // #6109 - IE triggers two focus events and the second
                        // is asynchronous, so we need to reset the previous
                        // term synchronously and asynchronously :-(
                        this._delay(function() {
                            this.previous = previous;
                            this.selectedItem = item;
                        });
                    }

                    if (false !== this._trigger("select", event, {
                            item: item
                        })) {
                        this._value(item.value);
                    }
                    // reset the term after the select event
                    // this allows custom select handling to work properly
                    this.term = this._value();

                    this.close(event);
                    this.selectedItem = item;
                }
            }); //end menu instance event handlers

            this.liveRegion = $("<span>", {
                    role: "status",
                    "aria-live": "polite"
                })
                .addClass("ui-helper-hidden-accessible")
                .insertBefore(this.element);

            // turning off autocomplete prevents the browser from remembering the
            // value when navigating through history, so we re-enable autocomplete
            // if the page is unloaded before the widget is destroyed. #7790
            this._on(this.window, {
                beforeunload: function() {
                    this.element.removeAttr("autocomplete");
                }
            });
        },

        _destroy: function() {
            clearTimeout(this.searching);
            this.element
                .removeClass("ui-autocomplete-input")
                .removeAttr("autocomplete");
            this.menu.element.remove();
            this.liveRegion.remove();
        },

        _setOption: function(key, value) {
            this._super(key, value);
            if (key === "source") {
                this._initSource();
            }
            if (key === "appendTo") {
                this.menu.element.appendTo(this._appendTo());
            }
            if (key === "disabled" && value && this.xhr) {
                this.xhr.abort();
            }
        },

        _appendTo: function() {
            var element = this.options.appendTo;

            if (element) {
                element = element.jquery || element.nodeType ?
                    $(element) :
                    this.document.find(element).eq(0);
            }

            if (!element) {
                element = this.element.closest(".ui-front");
            }

            if (!element.length) {
                element = this.document[0].body;
            }

            return element;
        },

        /*
         * 提示的数据源
         * @private
         */
        _initSource: function() {
            var array, url,
                that = this;
            if ($.isArray(this.options.source)) {

                array = this.options.source;
                /*
                 * 数组类型source
                 * @param request
                 * @param response
                 */
                this.source = function(request, response) {
                    response($.ui.autocomplete.filter(array, request.term));
                };

            } else if (typeof this.options.source === "string") {
                url = this.options.source;
                /*
                 * ajax source
                 * @param request
                 * @param response
                 */
                this.source = function(request, response) {
                    if (that.xhr) {
                        that.xhr.abort();
                    }
                    that.xhr = $.ajax({
                        url: url,
                        data: request,
                        dataType: "json",
                        success: function(data) {
                            response(data);
                        },
                        error: function() {
                            response([]);
                        }
                    });

                    //          when using promise, it is the same with up function
                    //          that.xhr = $.ajax({url: url, data: request, dataType: 'json'})
                    //            .done(function (data) {
                    //              response(data)
                    //            }).fail(function (data) {
                    //              response([]);
                    //            });
                };

            } else {
                this.source = this.options.source;
            }
        },

        /*
         * 延迟搜索内容
         * @param event
         * @private
         */
        _searchTimeout: function(event) {
            clearTimeout(this.searching);
            this.searching = this._delay(function() {
                // only search if the value has changed
                if (this.term !== this._value()) {
                    this.selectedItem = null;
                    this.search(null, event);
                }
            }, this.options.delay);
        },


        /*
         * Triggers a search event and invokes the data source if the event is not canceled.
         * Can be used by a selectbox-like button to open the suggestions when clicked.
         * When invoked with no parameters, the current input's value is used.
         * Can be called with an empty string and minLength: 0 to display all items.
         * @method search
         * @param  {String} value
         */
        search: function(value, event) {
            value = value != null ? value : this._value();

            // always save the actual value, not the one passed as an argument
            this.term = this._value();

            if (value.length < this.options.minLength) {
                return this.close(event);
            }

            if (this._trigger("search", event) === false) {
                return;
            }

            return this._search(value);
        },

        /*
         * 搜索
         * @param value
         * @private
         */
        _search: function(value) {
            this.pending++;
            this.element.addClass("ui-autocomplete-loading");
            this.cancelSearch = false;

            this.source({
                term: value
            }, this._response());
        },

        _response: function() {
            var index = ++this.requestIndex;

            return $.proxy(function(content) {
                if (index === this.requestIndex) {
                    this.__response(content);
                }

                this.pending--;
                if (!this.pending) {
                    this.element.removeClass("ui-autocomplete-loading");
                }
            }, this);
        },

        __response: function(content) {
            if (content) {
                content = this._normalize(content);
            }
            this._trigger("response", null, {
                content: content
            });
            if (!this.options.disabled && content && content.length && !this.cancelSearch) {
                this._suggest(content);
                this._trigger("open");
            } else {
                // use ._close() instead of .close() so we don't cancel future searches
                this._close();
            }
        },

        /*
         * Closes the Autocomplete menu. Useful in combination with the search method, to close the open menu.
         * @method close
         */
        close: function(event) {
            this.cancelSearch = true;
            this._close(event);
        },

        /*
         *隐藏弹出menu
         * @param event
         * @private
         */
        _close: function(event) {
            if (this.menu.element.is(":visible")) {
                this.menu.element.hide();
                this.menu.blur();
                this.isNewMenu = true;
                this._trigger("close", event);
            }
        },

        _change: function(event) {
            if (this.previous !== this._value()) {
                this._trigger("change", event, {
                    item: this.selectedItem
                });
            }
        },

        /*
         * 转换成内部标准的[{label:xx,value:yy}]
         * @param items
         * @returns {*}
         * @private
         */
        _normalize: function(items) {
            // assume all items have the right format when the first item is complete
            if (items.length && items[0].label && items[0].value) {
                return items;
            }
            return $.map(items, function(item) {
                if (typeof item === "string") {
                    return {
                        label: item,
                        value: item
                    };
                }

                return $.extend({
                    label: item.label || item.value,
                    value: item.value || item.label
                }, item);

            });
        },

        /*
         * 显示相匹配的内容
         * @param items
         * @private
         */
        _suggest: function(items) {
            var ul = this.menu.element.empty();
            this._renderMenu(ul, items);
            this.isNewMenu = true;
            this.menu.refresh();

            // size and position menu
            ul.show();
            this._resizeMenu();
            ul.position($.extend({
                of: this.element
            }, this.options.position));

            if (this.options.autoFocus) {
                this.menu.next();
            }

        },

        _resizeMenu: function() {
            var ul = this.menu.element;
            ul.outerWidth(Math.max(
                // Firefox wraps long text (possibly a rounding bug)
                // so we add 1px to avoid the wrapping (#7513)
                ul.width("").outerWidth() + 1,
                this.element.outerWidth()
            ));
        },

        _renderMenu: function(ul, items) {
            var that = this;
            $.each(items, function(index, item) {
                that._renderItemData(ul, item);
            });
        },

        _renderItemData: function(ul, item) {
            return this._renderItem(ul, item).data("ui-autocomplete-item", item);
        },

        _renderItem: function(ul, item) {
            return $("<li>").append($("<a>").text(item.label)).appendTo(ul);
        },

        _move: function(direction, event) {
            if (!this.menu.element.is(":visible")) {
                this.search(null, event);
                return;
            }
            if (this.menu.isFirstItem() && /^previous/.test(direction) ||
                this.menu.isLastItem() && /^next/.test(direction)) {
                this._value(this.term);
                this.menu.blur();
                return;
            }
            this.menu[direction](event);
        },

        /*
         * 对象实例
         */
        widget: function() {
            return this.menu.element;
        },

        /*
         * 取值 | 设值
         * @param newVal
         * @returns {valueMethod|*}
         */
        value: function() {
            return this.valueMethod.apply(this.element, arguments);
        },

        /*
         * 内部使用取值
         * @returns {valueMethod|*}
         * @private
         */
        _value: function() {
            return this.valueMethod.apply(this.element, arguments);
        },

        _keyEvent: function(keyEvent, event) {
            if (!this.isMultiLine || this.menu.element.is(":visible")) {
                this._move(keyEvent, event);

                // prevents moving cursor to beginning/end of the text field in some browsers
                event.preventDefault();
            }
        }
    });

    $.extend($.ui.autocomplete, {
        escapeRegex: function(value) {
            return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
        },
        filter: function(array, term) {
            var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
            return $.grep(array, function(value) {
                return matcher.test(value.label || value.value || value);
            });
        }
    });


    // live region extension, adding a `messages` option
    // NOTE: This is an experimental API. We are still investigating
    // a full solution for string manipulation and internationalization.
    $.widget("ui.autocomplete", $.ui.autocomplete, {
        options: {
            messages: {
                noResults: "No search results.",
                results: function(amount) {
                    return amount + (amount > 1 ? " results are" : " result is") +
                        " available, use up and down arrow keys to navigate.";
                }
            }
        },

        __response: function(content) {
            var message;
            this._superApply(arguments);
            if (this.options.disabled || this.cancelSearch) {
                return;
            }
            if (content && content.length) {
                message = this.options.messages.results(content.length);
            } else {
                message = this.options.messages.noResults;
            }
            this.liveRegion.text(message);
        }
    });


});

/*
 * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $
 *
 *  Licensed under the MIT license.
 *    http://opensource.org/licenses/mit-license
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */

! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.base64', factory)
    } else {
        factory();
    }
}(function() {
    'use strict';
    // constants
    var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6)) + fromCharCode(0x80 | (cc & 0x3f))) : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f)) + fromCharCode(0x80 | ((cc >>> 6) & 0x3f)) + fromCharCode(0x80 | (cc & 0x3f)));
        } else {
            var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07)) + fromCharCode(0x80 | ((cc >>> 12) & 0x3f)) + fromCharCode(0x80 | ((cc >>> 6) & 0x3f)) + fromCharCode(0x80 | (cc & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
            ord = ccc.charCodeAt(0) << 16 | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8) | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
            chars = [
                b64chars.charAt(ord >>> 18),
                b64chars.charAt((ord >>> 12) & 63),
                padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
                padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
            ];
        return chars.join('');
    };
    var btoa = window.btoa ? function(b) {
        return window.btoa(b);
    } : function(b) {
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = function(u) {
        return btoa(utob(u))
    };
    var encode = function(u, urisafe) {
        return !urisafe ? _encode(u) : _encode(u).replace(/[+\/]/g, function(m0) {
            return m0 == '+' ? '-' : '_';
        }).replace(/=/g, '');
    };
    var encodeURI = function(u) {
        return encode(u, true)
    };
    // decoder stuff
    var re_btou = new RegExp([
        '[\xC0-\xDF][\x80-\xBF]',
        '[\xE0-\xEF][\x80-\xBF]{2}',
        '[\xF0-\xF7][\x80-\xBF]{3}'
    ].join('|'), 'g');
    var cb_btou = function(cccc) {
        switch (cccc.length) {
            case 4:
                var cp = ((0x07 & cccc.charCodeAt(0)) << 18) | ((0x3f & cccc.charCodeAt(1)) << 12) | ((0x3f & cccc.charCodeAt(2)) << 6) | (0x3f & cccc.charCodeAt(3)),
                    offset = cp - 0x10000;
                return (fromCharCode((offset >>> 10) + 0xD800) + fromCharCode((offset & 0x3FF) + 0xDC00));
            case 3:
                return fromCharCode(
                    ((0x0f & cccc.charCodeAt(0)) << 12) | ((0x3f & cccc.charCodeAt(1)) << 6) | (0x3f & cccc.charCodeAt(2))
                );
            default:
                return fromCharCode(
                    ((0x1f & cccc.charCodeAt(0)) << 6) | (0x3f & cccc.charCodeAt(1))
                );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
            padlen = len % 4,
            n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0),
            chars = [
                fromCharCode(n >>> 16),
                fromCharCode((n >>> 8) & 0xff),
                fromCharCode(n & 0xff)
            ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var atob = window.atob ? function(a) {
        return window.atob(a);
    } : function(a) {
        return a.replace(/[\s\S]{1,4}/g, cb_decode);
    };
    var _decode = function(a) {
        return btou(atob(a))
    };
    var decode = function(a) {
        return _decode(
            a.replace(/[-_]/g, function(m0) {
                return m0 == '-' ? '+' : '/'
            })
            .replace(/[^A-Za-z0-9\+\/]/g, '')
        );
    };

    /**
     * Base64加密算法
     * @class fish.desktop.util.Base64
     * <pre>
     *   fish.Base64.encode(src);
     * </pre>
     */
    fish.Base64 = {
        // VERSION: version,
        /**
         * @ignore
         */
        atob: atob,
        /**
         * @ignore
         */
        btoa: btoa,
        /**
         * 使用base64解密，等同于decode
         * @method
         * @param {String} dst 密文
         * @return {String} 原文
         */
        fromBase64: decode,
        /**
         * 使用base64加密，等同于encode
         * @method
         * @param {String} src 原文
         * @return {String} 密文
         */
        toBase64: encode,
        /**
         * @ignore
         */
        utob: utob,
        /**
         * 使用base64加密
         * @method
         * @param {String} src 原文
         * @return {String} 密文
         */
        encode: encode,
        /**
         * 使用base64加密url
         * @method
         * @param {String} url 原文
         * @return {String} 密文
         */
        encodeURI: encodeURI,
        /**
         * @ignore
         */
        btou: btou,
        /**
         * 使用base64解密
         * @method
         * @param {String} dst 密文
         * @return {String} 原文
         */
        decode: decode
    };
});

/*!
 * jQuery blockUI plugin
 * Version 2.66.0-2013.10.09
 * Requires jQuery v1.7 or later
 *
 * Examples at: http://malsup.com/jquery/block/
 * Copyright (c) 2007-2013 M. Alsup
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 *
 * Thanks to Amir-Hossein Sobhi for some excellent contributions!
 */

/**
 * 遮罩<br>
 * @class fish.desktop.widget.BlockUI
 *
 * 用法：
 * <pre>
 *  $.unblockUI();// for whole page
 *  $.blockUI();
 *  $('selector').blockUI(); // for element
 *  $('selector').unblockUI();
 * </pre>
 *
 */
! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.blockui', factory);
    } else {
        factory();
    }
}(function() {
    'use strict';

    /**
     * global $ methods for blocking the entire page
     * 创建页面遮罩,此方法直接挂在jquery对象上
     * @method blockUI
     * @param {Object} opts
     */
    $.blockUI = function(opts) {
        create(window, opts);
    };
    /**
     * global $ methods for unblocking the entire page
     * 取消页面遮罩,此方法直接挂在jquery对象上
     * @method unblockUI
     * @param {Object} opts
     */
    $.unblockUI = function() {
        remove(window);
    };

    /**
     * plugin method for blocking element content
     * 创建局部遮罩,用于遮挡元素本身
     * @method blockUI
     * @param {Object} opts
     * @returns {Object} jQuery Object
     */
    $.fn.blockUI = function(opts) {
        if (this[0] === window) { //如果是window对象,直接调用
            $.blockUI(opts);
            return this;
        }
        var fullOpts = $.extend({}, $.blockUI.defaults, opts || {});
        this.each(function() {
            var $el = $(this);
            if (fullOpts.ignoreIfBlocked && $el.data('blockUI.isBlocked')) {
                return; //原来已经存在遮罩,在有ignoreIfBlocked参数为true的情况下直接返回
            }
            $el.unblockUI(); //这一步是不是需要判断下,有遮罩的时候再执行? TODO
        });

        return this.each(function() {
            if ($.css(this, 'position') == 'static') {
                this.style.position = 'relative';
                $(this).data('blockUI.static', true);
            }
            this.style.zoom = 1; // force 'hasLayout' in ie
            create(this, opts);
        });
    };

    /**
     * plugin method for unblocking element content
     * 取消局部遮罩
     * @method unblockUI
     * @returns {Object} jQuery Object
     */
    $.fn.unblockUI = function() {
        if (this[0] === window) {
            $.unblockUI();
            return this;
        }
        return this.each(function() {
            remove(this);
        });
    };



    var tpl = '<div class="blockUI blockOverlay ui-widget-overlay" style="position: {{#if full}}fixed{{else}}absolute{{/if}}; z-index: {{baseZ}}"></div>' +
        '<div class="blockUI {{opts.blockMsgClass}} {{#if full}}blockPage{{else}}blockElement{{/if}}" style="position: {{#if full}}fixed{{else}}absolute{{/if}}; z-index: {{baseZ2}}">' +
        '<span class="loading"></span><span class="blockUI-content {{#if iconOnly}}blockUI-iconOnly{{/if}}">{{msg}}</span></div>';

    // override these in your code to change the default behavior and style
    $.blockUI.defaults = {
        /**
         * @cfg message='Loading...'|'加载中...'
         * 遮罩的显示文字,设置为空则页面只有一个小圈圈在转
         * message displayed when blocking (use null for no message)
         */
        message: fish.getResource('blockUI.loading') || 'Please wait...',
        /**
         * z-index for the blocking overlay
         * @cfg baseZ=1000
         */
        baseZ: 1000,
        /**
         * @cfg timeout=0 time in millis to wait before auto-unblocking; set to 0 to disable auto-unblock
         * 多长时间遮罩会自动消失,单位毫秒;默认值0表示不会自动消失
         */
        timeout: 0,
        /**
         * class name of the message block
         * 用于给遮罩提示加上自定义样式
         * @cfg blockMsgClass=''
         */
        blockMsgClass: '',
        /**
         * @cfg ignoreIfBlocked=false if it is already blocked, then ignore it (don't unblock and reblock)
         * 如果已经存在遮罩,再次加上遮罩的话;会将原来的遮罩去掉再加上新的;此参数设置为true则不再覆盖原遮罩
         */
        ignoreIfBlocked: false
    };

    function create(el, opts) {
        var full = (el == window),
            $el = $(el),
            msg, isBlocked = $el.data('blockUI.isBlocked');
        opts = $.extend({}, $.blockUI.defaults, opts);
        msg = opts.message;

        if (opts.ignoreIfBlocked && isBlocked) { //如果已存在遮罩,此条件下直接返回,不覆盖原遮罩
            return;
        }
        // remove the current block (if there is one) 如果已存在全屏遮罩,则remove掉
        if (full && isBlocked) {
            remove(window, {
                fadeOut: 0
            });
        }

        var handlebarsOpt = {
            full: full,
            baseZ: opts.baseZ++,
            baseZ2: opts.baseZ + 10
        };
        msg ? handlebarsOpt.msg = msg : handlebarsOpt.iconOnly = true;
        tpl = tpl.replace(/\>\s+\</g, "><").replace(/\>\s+\{\{/g, ">{{").replace(/\}\}\s+\</g, "}}<");
        var fhtml = Handlebars.compile(tpl)(handlebarsOpt);

        var $par = full ? $('body') : $(el);
        $par.append(fhtml);
        var $loadContent;
        if (full) {
            $loadContent = $par.find(".blockPage");
            $loadContent.css('margin-left', -($loadContent.outerWidth() / 2) + 'px');
        } else {
            $loadContent = $par.find(".blockElement");
            center($loadContent[0]);
        }

        $el.data('blockUI.isBlocked', true);
        //延迟多少时间自动取消遮罩
        if (opts.timeout) {
            var to = setTimeout(function() {
                $el.unblockUI(opts);
            }, opts.timeout);
            $el.data('blockUI.timeout', to);
        }
    }

    // remove the block
    function remove(el) {
        var full = (el == window),
            $el = $(el);
        //解除延迟
        var to = $el.data('blockUI.timeout');
        if (to) {
            clearTimeout(to);
            $el.removeData('blockUI.timeout');
        }

        $el.data('blockUI.isBlocked', false);

        var $par = full ? $('body') : $(el);
        var els = $par.find('>.blockUI');

        //还原dom
        els.each(function(i, o) {
            if (this.parentNode) {
                this.parentNode.removeChild(this);
            }
        });
        if ($el.data('blockUI.static')) {
            $el.css('position', 'static'); // #22
        }
    }

    function center(el) {
        var p = el.parentNode,
            s = el.style;
        var l = ((p.offsetWidth - el.offsetWidth) / 2) - parseInt($.css(p, 'borderLeftWidth'), 10) || 0;
        var t = ((p.offsetHeight - el.offsetHeight) / 2) - parseInt($.css(p, 'borderTopWidth'), 10) || 0;
        s.left = l > 0 ? (l + 'px') : '0';
        s.top = t > 0 ? (t + 'px') : '0';
    }

});

/*
 * carouse.js
 *
 * deps:
 *  juery.ui.core
 *
 */
!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.carousel', factory)
    } else {
        factory();
    }
}(function () {
    'use strict';

    var PREVIOUS_TEMPLATE = '<div class="left carousel-control" role="button" data-slide="prev">' +
            '<span class="glyphicon glyphicon-chevron-left" aria-hidden="true"></span>' +
            '<span class="sr-only">Previous</span>' +
            '</div>',
        NEXT_TEMPLATE = '<div class="right carousel-control" role="button" data-slide="next">' +
            '<span class="glyphicon glyphicon-chevron-right" aria-hidden="true"></span>' +
            '<span class="sr-only">Next</span>' +
            '</div>';
    /**
     * 图片轮播插件
     * @class fish.desktop.widget.Carousel
     * <pre>
     *  $(element).carousel(option);
     * </pre>
     */
    $.widget("ui.carousel", {
        options: {
            /**
             * 一页显示条数，默认是1条
             * @cfg items=1
             */
            items: 1,
            /**
             * 自动播放间隔，默认是3s
             * @cfg interval=3000
             */
            interval: 3000,
            /**
             * 是否支持自动播放，默认不支持
             * @cfg autoPlay=false
             */
            autoPlay: false,

            /**
             * 是否支持循环播放，默认支持
             * @cfg loop=true
             */
            loop: true,
            /**
             * 是否支持按钮导航，默认支持
             * @cfg navigation=true
             */
            navigation: true,
            /**
             * 是否支持分页提示，默认支持
             * @cfg pagination=true
             */
            pagination: true
        },

        _create: function () {
            this.element.attr('role', 'carousel');

            this.$container = this.element.find('.carousel-inner');
            this.$items = this.$container.find('.item');
            this.itemsAmount = this.$items.length;
            this.itemWidth = Math.round(this.element.width() / this.options.items);

            if (this.options.pagination) {
                this._buildPagination();
            }

            if (this.options.navigation) {
                this._buildNavigation();
            }

            this._delegateEvent();
        },

        _init: function () {
            var that = this,
                roundPages = 0,
                elWidth = 0,
                lastItem = this.itemsAmount - this.options.items,
                i;

            this.$container.css({
                'width': this.itemsAmount * this.itemWidth * 2,
                'left': 0
            });

            this.$items.each(function (index) {
                var $this = $(this);
                $this.css({"width": that.itemWidth})
                    .data("item", Number(index));

                if (index % that.options.items === 0 || index === lastItem) {
                    if (!(index > lastItem)) {
                        roundPages += 1;
                    }
                }
                $this.data("slidePage", roundPages);
            });

            this.positionsInArray = [0];

            for (i = 0; i < this.itemsAmount; i += 1) {
                elWidth += this.itemWidth;
                this.positionsInArray.push(-elWidth);
            }

            this.currentItem = 0;
            this.currentPage = 1;
            this.maximumPage = roundPages;

            if (this.options.items > this.itemsAmount) {
                this.maximumItem = 0;
            } else {
                this.maximumItem = this.itemsAmount - this.options.items;
            }

            this.play();
        },

        _buildNavigation: function () {
            this.$prev = $(PREVIOUS_TEMPLATE);
            this.$next = $(NEXT_TEMPLATE);
            this.element.append(this.$prev).append(this.$next);
        },

        _buildPagination: function () {
            var counter = 0,
                $li,
                lastPage,
                lastItem,
                i;

            this.$indicators = $('<ol class="carousel-indicators"></ol>');

            lastPage = this.itemsAmount - this.itemsAmount % this.options.items;

            for (i = 0; i < this.itemsAmount; i++) {
                if (i % this.options.items === 0) {
                    $li = $('<li></li>');
                    counter++;

                    if (i === 0) {
                        $li.addClass('active');
                    }

                    if (lastPage === i) {
                        lastItem = this.itemsAmount - this.options.items;
                    }

                    $li.data("slideTo", lastPage === i ? lastItem : i);
                    $li.data("slidePage", counter);
                    this.$indicators.append($li);
                }
            }

            this.element.append(this.$indicators);
        },

        _delegateEvent: function () {
            var that = this;

            if (this.options.pagination) {
                this._on(this.$indicators, {
                    'click': '_onIndicatorsClick'
                });
            }

            if (this.options.navigation) {
                this._on(this.$prev, {
                    click: function (event) {
                        that.prev();
                        event.preventDefault();
                    }
                });
                this._on(this.$next, {
                    click: function (event) {
                        that.next();
                        event.preventDefault();
                    }
                });
            }

            if (this.options.autoPlay) {
                this.element.on("mouseover", function () {
                    that.pause();
                });
                this.element.on("mouseout", function () {
                    that.play();
                });
            }
        },

        /*
         * 将DOM节点还原，关闭事件监听
         * @private
         */
        _destroy: function () {
            var $element = this.element;
            $element.removeClass('carousel slide ' + this.options.carouselClass).removeAttr('role');
            //$element.find('.carousel-inner').children().first().removeClass('active');
            //我们希望要显示一个
            $element.find('ol').remove();
            if (this.options.showControl) {
                $element.find('.carousel-control').remove();
            }
            this.pause();
            this._off(this.element);
        },

        next: function () {
            if (this.sliding) {
                return false;
            }

            this.currentPage += 1;

            if (this.currentPage === this.maximumPage) {
                this.currentItem = this.maximumItem;
            } else if (this.currentPage > this.maximumPage) {
                if (this.options.loop == true) {
                    this.currentItem = 0;
                    this.currentPage = 0;
                } else {
                    this.currentItem = this.maximumItem;
                    this.currentPage = this.maximumPage;
                    return false;
                }
            } else {
                this.currentItem += this.options.items;
            }

            this.to(this.currentItem);
        },

        prev: function () {
            if (this.sliding) {
                return false;
            }

            this.currentPage -= 1;

            if (this.currentPage === 1) {
                this.currentItem = 0;
            } else if (this.currentPage < 1) {
                if (this.options.loop === true) {
                    this.currentItem = this.maximumItem;
                    this.currentPage = this.maximumPage;
                } else {
                    this.currentItem = 0;
                    this.currentPage = 0;
                    return false;
                }
            } else {
                this.currentItem -= this.options.items;
            }

            this.to(this.currentItem);
        },

        to: function (position) {
            if (this.sliding) {
                return false;
            }

            this._trigger('beforeSlide');

            if (position >= this.maximumItem) {
                position = this.maximumItem;
            } else if (position <= 0) {
                position = 0;
            }

            this.currentItem = position;
            this.currentPage = this.$items.eq(this.currentItem).data('slidePage');

            this._slide(this.positionsInArray[this.currentItem]);
        },

        play: function () {
            var that = this;

            this.playStatus = 'play';
            if (this.options.autoPlay === false) {
                return false;
            }

            clearInterval(this.playInterval);
            this.playInterval = setInterval(function () {
                that.next();
            }, this.options.interval);
        },

        pause: function () {
            this.playStatus = 'stop';
            clearInterval(this.playInterval);
        },

        _onIndicatorsClick: function (event) {
            if (event.target.nodeName == 'LI') {
                var $li = $(event.target);

                if ($li.hasClass('active')) return;

                this.to($li.data('slideTo'));
            }
        },

        _slide: function (value) {
            var that = this;

            this.sliding = true;

            this.$container.stop(true, false).animate({
                "left": value
            }, 300, function () {
                that.sliding = false;
                that._afterSlide();
            });
        },

        _afterSlide: function () {
            this._trigger('afterSlide');
            this._checkPagination();
            this._checkNavigation();
        },

        _checkPagination: function () {
            var that = this,
                $li;

            if (this.options.pagination === false) {
                return false;
            }

            $li = this.$indicators.find('.active');
            if ($li.data('slidePage') !== this.currentPage) {
                $li.removeClass('active');
                $(this.$indicators.children()[this.currentPage - 1]).addClass('active');
            }
        },

        _checkNavigation: function () {
            if (this.options.navigation === false || this.options.loop) {
                return false;
            }

            if (this.currentItem === 0 && this.maximumItem === 0) {
                this.$prev.addClass("disabled");
                this.$next.addClass("disabled");
            } else if (this.currentItem === 0 && this.maximumItem !== 0) {
                this.$prev.addClass("disabled");
                this.$next.removeClass("disabled");
            } else if (this.currentItem === this.maximumItem) {
                this.$prev.removeClass("disabled");
                this.$next.addClass("disabled");
            } else if (this.currentItem !== 0 && this.currentItem !== this.maximumItem) {
                this.$prev.removeClass("disabled");
                this.$next.removeClass("disabled");
            }
        }
    });
});

/* =============================================================
 * bootstrap-combobox.js v1.1.6
 * =============================================================
 * Copyright 2012 Daniel Farrell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ============================================================ */

/*
 * fish combobox *
 * 2014-8-3 20:40:36
 */
! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.combobox', factory)
    } else {
        factory();
    }
}(function() {

    'use strict';

    var TEMPLATE = '<div class="input-group combobox-container"> ' +
        '<input type="text" autocomplete="off" class="form-control"/> ' +
        '<span class="input-group-addon"> ' +
        '<span class="caret" />' +
        '<span class="glyphicon glyphicon-remove" style="display: none;" />' +
        '</span>' +
        '</div>',
        MENU = '<ul class="typeahead-long dropdown-menu"></ul>',
        MENU_ITEM = '<li><a href="javascript:void(0);"></a></li>';

    /**
     * 下拉框控件
     * @class fish.desktop.widget.Combobox
     * @extends fish.desktop.widget
     * <pre>
     *   $(element).combobox(option);
     * </pre>
     */

    $.widget("ui.combobox", {
        widgetEventPrefix: "",
        options: {
            text: null,
            value: null,
            dataTextField: "name",
            dataValueField: "value",
            dataSource: [],
            placeholder: ""
                // suggest: false, //这两个参数没用到
                // ignoreCase: true
        },
        _create: function() {
            this.$container = $(TEMPLATE);
            this.element.hide().before(this.$container);
            this.$input = this.$container.find('input').first();
            this.$button = this.$container.find('.input-group-addon');
            this.$caret = this.$button.find('.caret');
            this.$remove = this.$button.find('.glyphicon-remove');
            this.$menu = $(MENU).appendTo('body');
            this._delegateEvent();
        },

        _init: function() {
            this.shown = false;
            this.selected = false;
            if (!this.options.dataSource || this.options.dataSource.length === 0) { //参数没有配置dataSource
                this.options.dataSource = this._parse(); //解析select原始值
            }

            if (!this.selected) {
                this.value(this.options.value);
            }

            this.transferAttributes();
        },
        _validateHandler: function() {
            var $element = this.element,that = this , $warp ;
            $element.on('change.valid blur.valid', function() {
                if (that._getValidFlag()) {
                    $element.isValid();
                }
            });
            this.$input.on('focus.valid', function(){
                if($element.hasClass('n-invalid')){
                    $element.resetElement();
                }
            })
        },

        _setOption: function(key, value) {
            this._super(key, value);

            if (key === 'disabled') {
                this.$input.prop('disabled', value);
                this.$button.attr('disabled', value);
            }
        },

        text: function(text) {
            if (text === undefined) {
                return this.$input.val();
            } else {
                this.$input.val(text);
            }
        },

        /**
         * @method value 取值或者赋值
         * @param  {String} [value] 设置值选中,为空则取控件值
         * @return {String} 控件值,赋值操作则没有返回值
         */
        value: function(value) {
            var options = this.options,
                target;
            if (value === undefined) {
                return this.element.val();
            } else {
                target = _.find(options.dataSource, function(item) {
                    if (item[options.dataValueField] === value) {
                        return true;
                    }
                });

                this._select(target);
            }
        },

        clear: function() {
            this._select(null);
        },

        /**
         * @method destroy
         * 销毁控件
         */
        _destroy: function() {
            this.element.prev().remove();
            this.element.show();
        },

        _parse: function() {
            var that = this,
                source = [],
                item,
                option;

            if (this.element.is('select')) {
                this.element.find('option').each(function() {
                    option = $(this);
                    item = {};
                    if (option.val() === '') {
                        that.options.placeholder = option.text();
                        return;
                    }
                    item[that.options.dataTextField] = option.text();
                    item[that.options.dataValueField] = option.val();
                    source.push(item);
                    if (option.prop('selected')) {
                        that.options.text = item[that.options.dataTextField];
                        that.options.value = item[that.options.dataValueField];
                        that._setSelected(true);
                        that.$input.val(that.options.text);
                    }
                });
            }
            return source;
        },
        transferAttributes: function() {
            this.options.placeholder = this.options.placeholder || this.element.attr('data-placeholder');
            this.$input.attr('placeholder', this.options.placeholder);
            this.$input.attr('title', this.element.attr('title'));
            this.$input.attr('tabindex', this.element.attr('tabindex'));
            this.element.removeAttr('tabindex');
            if (this.element.attr('disabled') !== undefined)
                this.disable();
        },

        _setDataSource: function(dataSource) {
            this.options.dataSource = dataSource;
        },

        show: function() {
            var pos = $.extend({}, this.$input.position(), {
                height: this.$input[0].offsetHeight
            });

            var offset = this.$input.offset();
            var _height = offset.top - $(document).scrollTop() + pos.height + this.$menu.height();
            var parentTop = _height > $(window).height() ? -this.$menu.outerHeight() : (pos.top + pos.height);

            this.$menu
                .insertAfter(this.$input)
                .css({
                    top: parentTop,
                    left: pos.left
                })
                .show();

            this.$menu.on('mousedown', $.proxy(this._scrollSafety, this));

            this.shown = true;
            this._trigger('open');
        },

        hide: function() {
            this.$menu.hide();
            this.$menu.off('mousedown', $.proxy(this._scrollSafety, this));
            this.shown = false;
            this._trigger('close');
        },

        lookup: function(event) {
            var that = this,
                query = this.$input.val(),
                items = $.grep(this.options.dataSource, function(item) {
                    return that.matcher(item, query)
                })

            items = this.sorter(items, query);

            if (!items.length) {
                return this.shown ? this.hide() : this;
            }

            return this.render(items, query).show();
        },

        matcher: function(item, query) {
            return ~item[this.options.dataTextField].toLowerCase().indexOf(query.toLowerCase()); //转换成数字0 以及非0
        },

        sorter: function(items, query) {
            var beginswith = [],
                caseSensitive = [],
                caseInsensitive = [],
                item;

            while (item = items.shift()) {
                if (!item[this.options.dataTextField].toLowerCase().indexOf(query.toLowerCase())) {
                    beginswith.push(item);
                } else if (~item[this.options.dataTextField].indexOf(query)) {
                    caseSensitive.push(item);
                } else {
                    caseInsensitive.push(item);
                }
            }

            return beginswith.concat(caseSensitive, caseInsensitive);
        },

        /*
         * 高亮显示
         * @param item
         */
        highlighter: function(item, query) {
            query = query.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
            return item.replace(new RegExp('(' + query + ')', 'ig'), function($1, match) {
                return '<strong>' + match + '</strong>';
            })
        },

        render: function(items, query) {
            var that = this;

            items = $(items).map(function(i, item) {
                i = $(MENU_ITEM).data('value', item);
                i.find('a').html(that.highlighter(item[that.options.dataTextField], query));
                return i[0];
            })

            items.first().addClass('active');
            this.$menu.html(items);
            return this;
        },

        move: function(e) {
            if (!this.shown) {
                return;
            }

            switch (e.keyCode) {
                case 9: // tab
                case 13: // enter
                case 27: // escape
                    e.preventDefault();
                    break;

                case 38: // up arrow
                    e.preventDefault();
                    this.prev();
                    break;

                case 40: // down arrow
                    e.preventDefault();
                    this.next();
                    break;
            }

            e.stopPropagation();
        },

        next: function(event) {
            var active = this.$menu.find('.active').removeClass('active'),
                next = active.next();

            if (!next.length) {
                next = $(this.$menu.find('li')[0]);
            }

            next.addClass('active');
        },

        prev: function(event) {
            var active = this.$menu.find('.active').removeClass('active'),
                prev = active.prev();

            if (!prev.length) {
                prev = this.$menu.find('li').last();
            }

            prev.addClass('active');
        },

        reset: function() {
            if (this.options.disabled) return;

            if (this.selected) {
                this.clearTarget();
                this.clearElement();
                this._triggerChange();
            } else {
                if (this.shown) {
                    this.hide();
                } else {
                    this.clearElement();
                }
            }
        },

        _scrollSafety: function(e) {
            if (e.target.tagName == 'UL') {
                this.$input.off('blur');
            }
        },
        clearElement: function() {
            this.$input.val('').focus();
        },
        clearTarget: function() {
            this.element.val('');
            this._setSelected(false);
        },

        _setSelected: function(selected) {
            if (selected) {
                this.$caret.hide();
                this.$remove.show();
            } else {
                this.$caret.show();
                this.$remove.hide();
            }
            this.selected = selected;
        },

        _delegateEvent: function() {
            this.$input
                .on('focus', $.proxy(this._onFocus, this))
                .on('blur', $.proxy(this._onBlur, this))
                .on('keypress', $.proxy(this._onKeyPress, this))
                .on('keyup', $.proxy(this._onKeyUp, this))
                .on('keydown', $.proxy(this._onKeyDown, this));

            this.$menu
                .on('click', $.proxy(this._onMenuClick, this))
                .on('mouseenter', 'li', $.proxy(this._onMenuMouseEnter, this))
                .on('mouseleave', 'li', $.proxy(this._onMenuMouseLeave, this));

            this.$button
                .on('click', $.proxy(this._onButtonToggle, this));
        },

        _onFocus: function(e) {
            this.focused = true;
        },

        _onBlur: function(e) {
            var that = this;
            this.focused = false;
            if (!this.mousedover && this.shown) {
                setTimeout(function() {
                    that.hide();
                }, 10);
            }
            if (!this.mousedover) { //input离开的时候,触发comboboxblur供检验用
                this._trigger('blur');
            }
        },

        _onKeyDown: function(e) {
            this.suppressKeyPressRepeat = ~$.inArray(e.keyCode, [40, 38, 9, 13, 27]);
            this.move(e);
        },
        _onKeyPress: function(e) {
            if (this.suppressKeyPressRepeat) {
                return;
            }
            this.move(e);
        },
        _onKeyUp: function(e) {
            switch (e.keyCode) {
                case 40: // down arrow
                case 39: // right arrow
                case 38: // up arrow
                case 37: // left arrow
                case 36: // home
                case 35: // end
                case 16: // shift
                case 17: // ctrl
                case 18: // alt
                    break;

                case 9: // tab
                case 13: // enter
                    if (!this.shown) {
                        return;
                    }
                    this._onMenuSelect();
                    break;

                case 27: // escape
                    if (!this.shown) {
                        return;
                    }
                    this.hide();
                    break;

                default:
                    this.clearTarget();
                    this.lookup();
            }

            e.stopPropagation();
            e.preventDefault();
        },

        _onMenuClick: function(e) {
            e.stopPropagation();
            this._onMenuSelect();
            this.$input.focus();
        },

        _onMenuMouseEnter: function(e) {
            this.mousedover = true;
            this.$menu.find('.active').removeClass('active');
            $(e.currentTarget).addClass('active');
        },

        _onMenuMouseLeave: function(e) {
            this.mousedover = false;
        },

        _onButtonToggle: function() {
            if (this.options.disabled) return;
            this.$input.focus();//让input获取焦点
            if (this.selected) {
                this.clear();
            } else {
                if (this.shown) {
                    this.hide();
                } else {
                    this.lookup();
                }
            }
        },

        _onMenuSelect: function() {
            var item = this.$menu.find('.active').data('value');
            this._select(item);
            this.hide();
        },
        //与_select的区别在于old == item.value;form会优先执行reset,clear,setvalue操作
        _update: function() {
            var options = this.options,
                target,
                value = this.element.val();
            if (value) {
                target = _.find(options.dataSource, function(item) {
                    if (item[options.dataValueField] === value) {
                        return true;
                    }
                });
                this.$input.val(target[options.dataTextField]);
                this._setSelected(true);
            } else {
                this.$input.val('');
                this._setSelected(false);
            }
        },
        _select: function(item) {
            var options = this.options,
                old = this.element.val();
            if (item && item[options.dataValueField] !== old) {
                this.$input.val(item[options.dataTextField]);
                this.element.val(item[options.dataValueField]);
                this._setSelected(true);
                this._triggerChange();
            } else if (this.selected && !item) {
                this.$input.val('');
                this.element.val('');
                this._setSelected(false);
                this._triggerChange();
            }
        },

        _triggerChange: function() {
            this._trigger('change');
        }
    });
});

/**
 * 改变下拉框值时触发的事件
 * @event change
 * <pre>
 * $(element).on('change', function() {
 *   //do something
 * })
 * </pre>
 */

/**
 * 显示下拉框选项时触发的事件
 * @event open
 * <pre>
 * $(element).on('open', function() {
 *   //do something
 * })
 * </pre>
 */

/**
 * 关闭下拉框选项时触发的事件
 * @event close
 * <pre>
 * $(element).on('close', function() {
 *   //do something
 * })
 * </pre>
 */

/**
 * @cfg {Function} create 创建控件时触发的事件
 */

/**
 * Cookie工具
 * @class fish.desktop.util.Cookies
 * <pre>
 *   fish.cookies.set("username","test");
 *   fish.cookies.get("username");
 * </pre>
 */

! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.cookies', factory)
    } else {
        factory();
    }
}(function() {
    'use strict';
    var pluses = /\+/g,
        fish = window.fish,
        cookies = fish.cookies = {
            /**
             * 设置cookie记录
             * @param {String} key
             * @param {Object} value
             * @param {Object} [options] 设置cookie的参数，如失效时长
             */
            set: function(key, value, options) {
                if (value !== undefined && !$.isFunction(value)) {
                    options = $.extend({}, options);

                    if (typeof options.expires === 'number') {
                        var days = options.expires,
                            t = options.expires = new Date();
                        t.setDate(t.getDate() + days);
                    }

                    return (document.cookie = [
                        encode(key), '=', stringifyCookieValue(value),
                        options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
                        options.path ? '; path=' + options.path : '',
                        options.domain ? '; domain=' + options.domain : '',
                        options.secure ? '; secure' : ''
                    ].join(''));
                }
            },
            /**
             * 获取cookie记录
             * @param {String} key
             * @param {Function} [converter] 自定义解析cookie值的方法
             * @return {Object} key对应的cookie记录
             */
            get: function(key, converter) {
                var result = key ? undefined : {};

                var cookies = document.cookie ? document.cookie.split('; ') : [];

                for (var i = 0, l = cookies.length; i < l; i++) {
                    var parts = cookies[i].split('=');
                    var name = decode(parts.shift());
                    var cookie = parts.join('=');

                    if (key && key === name) {
                        // If second argument (value) is a function it's a converter...
                        result = read(cookie, converter);
                        break;
                    }

                    // Prevent storing a cookie that we couldn't decode.
                    if (!key && (cookie = read(cookie)) !== undefined) {
                        result[name] = cookie;
                    }
                }

                return result;
            },
            /**
             * 使cookie立即失效
             * @param  {String} key
             * @param  {Object} [options] 设置cookie的参数
             * @return {Boolean} 如果key值不在cookie内，返回false表示操作失败
             */
            remove: function(key, options) {
                if (this.get(key) !== undefined) {
                    // Must not alter options, thus extending a fresh object...
                    this.set(key, '', $.extend({}, options, {
                        expires: -1
                    }));
                    return true;
                }
                return false;
            }
        };

    function encode(s) {
        return encodeURIComponent(s);
    }

    function decode(s) {
        return decodeURIComponent(s);
    }

    function stringifyCookieValue(value) {
        return JSON.stringify(value);
    }

    function parseCookieValue(s) {
        if (s.indexOf('"') === 0) {
            // This is a quoted cookie as according to RFC2068, unescape...
            s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
        }

        try {
            // Replace server-side written pluses with spaces.
            // If we can't decode the cookie, ignore it, it's unusable.
            s = decodeURIComponent(s.replace(pluses, ' '));
        } catch (e) {
            return;
        }

        try {
            // If we can't parse the cookie, ignore it, it's unusable.
            return JSON.parse(s);
        } catch (e) {}
    }

    function read(s, converter) {
        var value = parseCookieValue(s);
        return $.isFunction(converter) ? converter(value) : value;
    }
});

/* =========================================================
 * bootstrap-datetimepicker.js
 * =========================================================
 * Copyright 2012 Stefan Petre
 * Improvements by Andrew Rowls
 * Improvements by Sébastien Malot
 * Improvements by Yun Lai
 * Project URL : http://www.malot.fr/bootstrap-datetimepicker
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ========================================================= */

/*
 * Improvement by CuGBabyBeaR @ 2013-09-12
 * Make it work in bootstrap v3
 */


!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.datetimepicker', ['fish.dateutil', 'underscore'], factory);
    } else {
        factory(fish.dateutil, _);
    }
}(function (DateUtil) {

    'use strict';

    var DPGlobal = {
        viewType: {
            'datetime': 'yyyy-mm-dd hh:ii:ss',
            'date': 'yyyy-mm-dd',
            'time': 'hh:ii:ss'
        },
        modes: [{
            clsName: 'minutes',
            navFnc: 'Hours',
            navStep: 1
        }, {
            clsName: 'hours',
            navFnc: 'Date',
            navStep: 1
        }, {
            clsName: 'days',
            navFnc: 'Month',
            navStep: 1
        }, {
            clsName: 'months',
            navFnc: 'FullYear',
            navStep: 1
        }, {
            clsName: 'years',
            navFnc: 'FullYear',
            navStep: 10
        }],
        convertViewMode: function (viewMode) {
            switch (viewMode) {
                case 4:
                case 'decade':
                    viewMode = 4;
                    break;
                case 3:
                case 'year':
                    viewMode = 3;
                    break;
                case 2:
                case 'month':
                    viewMode = 2;
                    break;
                case 1:
                case 'day':
                    viewMode = 1;
                    break;
                case 0:
                case 'hour':
                    viewMode = 0;
                    break;
            }

            return viewMode;
        },
        headTemplate: '<thead>' +
        '<tr>' +
        '<th class="prev"><i class="glyphicon glyphicon-arrow-left"></i></th>' +
        '<th colspan="5" class="switch"></th>' +
        '<th class="next"><i class="glyphicon glyphicon-arrow-right"></i></th>' +
        '</tr>' +
        '</thead>',
        contTemplate: '<tbody><tr><td colspan="7"></td></tr></tbody>',
        footTemplate: '<tfoot><tr><th colspan="7" class="today"></th></tr></tfoot>'
    };

    DPGlobal.template = '<div class="datetimepicker datetimepicker-dropdown-bottom-left dropdown-menu">' +
    '<div class="datetimepicker-minutes">' +
    '<table class=" table-condensed">' +
    DPGlobal.headTemplate +
    DPGlobal.contTemplate +
    DPGlobal.footTemplate +
    '</table>' +
    '</div>' +
    '<div class="datetimepicker-hours">' +
    '<table class=" table-condensed">' +
    DPGlobal.headTemplate +
    DPGlobal.contTemplate +
    DPGlobal.footTemplate +
    '</table>' +
    '</div>' +
    '<div class="datetimepicker-days">' +
    '<table class=" table-condensed">' +
    DPGlobal.headTemplate +
    '<tbody></tbody>' +
    DPGlobal.footTemplate +
    '</table>' +
    '</div>' +
    '<div class="datetimepicker-months">' +
    '<table class="table-condensed">' +
    DPGlobal.headTemplate +
    DPGlobal.contTemplate +
    DPGlobal.footTemplate +
    '</table>' +
    '</div>' +
    '<div class="datetimepicker-years">' +
    '<table class="table-condensed">' +
    DPGlobal.headTemplate +
    DPGlobal.contTemplate +
    DPGlobal.footTemplate +
    '</table>' +
    '</div>' +
    '</div>';

    /**
     * 日期时间控件
     * @class fish.desktop.widget.Datetimepicker
     * @extends fish.desktop.widget
     * <pre>
     *   $(element).datetimepicker(option);
     * </pre>
     */

    $.widget("ui.datetimepicker", {
        options: {
            /**
             * 提供默认的时间类型:日期格式date与时间格式time;默认值为datetime,此时可以自定义时间控件
             * @cfg {String} viewType='datetime'
             */
            viewType: 'datetime',
            /** @cfg {String} buttonIcon='remove th' 是否显示图标;remove表示显示清空按钮,th表示显示点击弹出日期时间选择层,th可选值calendar、time可表示日历、时间选择器;当然可以使用任意的glyphicon图标
             */
            buttonIcon: 'remove th',
            /** @cfg {String} format = 'yyyy-mm-dd hh:ii' 时间格式化方式。
             *  日期格式， p, P, h, hh, i, ii, s, ss, d, dd, m, mm, M, MM, yy, yyyy 的任意组合。
             *  <pre>
             *    p : meridian in lower case ('am' or 'pm') - according to locale file
             P : meridian in upper case ('AM' or 'PM') - according to locale file
             s : seconds without leading zeros
             ss : seconds, 2 digits with leading zeros
             i : minutes without leading zeros
             ii : minutes, 2 digits with leading zeros
             h : hour without leading zeros - 24-hour format
             hh : hour, 2 digits with leading zeros - 24-hour format
             H : hour without leading zeros - 12-hour format
             HH : hour, 2 digits with leading zeros - 12-hour format
             d : day of the month without leading zeros
             dd : day of the month, 2 digits with leading zeros
             m : numeric representation of month without leading zeros
             mm : numeric representation of the month, 2 digits with leading zeros
             M : short textual representation of a month, three letters
             MM : full textual representation of a month, such as January or March
             yy : two digit representation of a year
             yyyy : full numeric representation of a year, 4 digits
             *  </pre>
             */
            format: 'yyyy-mm-dd hh:ii:ss',
            /** @cfg {Number} minuteStep = 5 此数值被当做步进值用于构建小时视图。会间隔minuteStep生成一组预设时间（分钟）用于选择。
             */
            minuteStep: 5,
            /** @cfg {Boolean} showMeridian=false 是否区分上下午
             */
            showMeridian: false,
            /** @cfg {String} 初始化的时间值
             */
            initialDate: null,
            /** @cfg {Number} minView=0|'hour' 能显示的最小视图
             */
            minView: 0,
            /** @cfg {Number} maxView=4|'decade' 能显示的最大视图
             */
            maxView: DPGlobal.modes.length - 1,
            /** @cfg {Number} startView=2|'month' 开始显示的视图
             */
            startView: 2,
            /** @cfg {Boolean} autoClose=false 当选择一个日期之后是否立即关闭此日期时间选择器
             */
            autoClose: true,
            /** @cfg {Boolean} todayBtn=false 在日期时间选择器组件的底部显示一个 "Today" 按钮用以选择当前日期。可选值true表示能出现按钮，可选值"linked"，则当天日期将会被选中。
             */
            todayBtn: false,
            /** @cfg {Boolean} todayHighlight=true 高亮当前日期。
             */
            todayHighlight: true,
            /** @cfg {Number} weekStart=0 一周从哪一天开始。0（星期日）到6（星期六）。
             */
            weekStart: 0,
            /** @cfg {String} startDate 能选择的开始时间，之前的时间全部失效;默认是无穷小
             */
            startDate: new Date(1900, 0, 1),
            /** @cfg {String} endDate 能选择的结束时间，之后的时间全部失效;默认是无穷大
             */
            endDate: new Date(2099, 11, 31),
            /** @cfg {String} daysOfWeekDisabled 一周的哪几天不能选择，譬如‘0,6’表示周日和周六禁止选择
             */
            daysOfWeekDisabled: null
        },
        //datetimepicker原生控件命名方式不变
        widgetEventPrefix: "",
        //初始化参数
        _getCreateOptions: function () {
            var $element = this.element;
            return {
                format: $element.data('format'),
                minuteStep: $element.data('minute-step'),
                minView: $element.data('min-view'),
                maxView: $element.data('max-view'),
                autoClose: $element.data('auto-close'),
                todayBtn: $element.data('today-btn'),
                todayHighlight: $element.data('today-highlight'),
                weekStart: $element.data('week-start'),
                daysOfWeekDisabled: $element.data('days-of-week-disabled'),
                viewType: $element.data('view-type')
            };
        },

        _create: function () {
            var options = this.options,
                $element = this.element;

            this.isVisible = false;
            $element.addClass('ui-widget-input');

            this._praseViewType();
            this._createIcon();

            this.minView = DPGlobal.convertViewMode(options.minView);
            this.maxView = DPGlobal.convertViewMode(options.maxView);
            this.startViewMode = DPGlobal.convertViewMode(options.startView);

            this.picker = $(DPGlobal.template).appendTo('body');

            this.weekStart = (options.weekStart % 7);
            this.weekEnd = ((this.weekStart + 6) % 7);
            this.startDate = options.startDate;
            this.endDate = options.endDate;
            this.setDaysOfWeekDisabled(options.daysOfWeekDisabled);

            this._parseSelectedDate();
            this._fillDow();
            this._setMode(this.startViewMode);

            this._delegateEvent();
        },

        _parseSelectedDate: function () {
            var date;

            if (this.options.initialDate) {
                date = this.options.initialDate;
            } else {
                date = this.element.data('date') || this.element.val();
            }

            this.selectedDate = DateUtil.parse(date, DPGlobal.viewType[this.options.viewType]);
            this.viewDate = this.selectedDate ? this.selectedDate : new Date();
        },

        //根据图标属性的配置创建图标
        _createIcon: function () {
            var options = this.options,
                $element = this.element,
                $icon = "",
                icons = options.buttonIcon.split(" ");

            if (options.buttonIcon) {
                for (var i = 0; i < icons.length; i++) {
                    $icon += ' <span class="input-group-addon"><span class="glyphicon glyphicon-' + icons[i] + '"></span></span>'
                }
                $element.after($icon);

                this.component = $element.nextAll('.input-group-addon').filter(function (index) {
                    return !$(this).children('.glyphicon').hasClass('glyphicon-remove');
                });
                this.componentReset = $element.nextAll('.input-group-addon').filter(function (index) {
                    return $(this).children('.glyphicon').hasClass('glyphicon-remove');
                });
                this.component = this.component.length ? this.component : false;
                this.componentReset = this.componentReset.length ? this.componentReset : false;
            }
        },
        //解析viewtype属性,生成默认值
        _praseViewType: function () {
            var options = this.options;
            switch (options.viewType) {
                case 'time':
                    $.extend(options, {
                        buttonIcon: 'remove time',
                        startView: 1,
                        minView: 0,
                        maxView: 1,
                        format: 'hh:ii'
                    });
                    break;
                case 'date':
                    $.extend(options, {
                        buttonIcon: 'remove calendar',
                        startView: 2,
                        minView: 2,
                        format: 'yyyy-mm-dd'
                    });
                    break;
            }
        },
        //datetimepicker提交数据的时候,界面值不是实际值,需要重写getValue方法
        _formHandler: function ($form) {//增加对form的支持
            var that = this;
            $form.on('getvalue'+this.uuid+'.form', function(e){
                console.log(that.widgetName + " getFormValue:" + that.value());
                return that.value();
            });
        },
        //form内置方法,根据HTML原值同步界面
        _update : function (value) {
            var format = DPGlobal.viewType[this.options.viewType],
                date;
            if(value === undefined){
                this._parseSelectedDate()// reset
            } else if (value === null) {//clear
                this.viewDate = new Date();
                this.selectedDate = null;
            } else {//setValue
                date = DateUtil.parse(value, format);
                if (date.valueOf() >= this.startDate.valueOf() && date <= this.endDate.valueOf()) {
                    this.viewDate = this.selectedDate = date;
                    this._setElementValue();
                } else {
                    this._trigger('outOfRange', null, {
                        date: date,
                        startDate: this.startDate,
                        endDate: this.endDate
                    });
                    value = '';
                    this.viewDate = this.selectedDate = date;//超过的时候如何处理?
                    return false;
                }
            }
            this.update();//更新弹出内容
        },

        _validateHandler: function () {
            var $element = this.element,that = this , $warp ;
            $element.on('changedate.valid', function () {
                if (that._getValidFlag()) {
                    console.log('changedate.valid');
                    $element.isValid();
                }
            });
        },

        _setOption: function (key, value) {
            this._super(key, value);

            if (key === 'disabled') {
                this.element.attr("disabled", value);
            }
        },

        _delegateEvent: function () {
            var that = this;

            this._on(this.element, {
                'focus': 'show',
                'change': '_onChange',
                'blur': '_onBlur'
            });

            if (this.component) {
                this.component.on('click', $.proxy(this.show, this));
            }
            if (this.componentReset) {
                this.componentReset.on('click', $.proxy(this.reset, this));
            }

            this.picker.on('click', $.proxy(this._onClick, this));

            $(document).on('mousedown', function (e) {
                // Clicked outside the datetimepicker, hide it
                if ($(e.target).closest('.datetimepicker').length === 0) {
                    that.hide();
                }
            });
        },

        value: function (value) {
            var format = DPGlobal.viewType[this.options.viewType];

            if (value === undefined) {
                return DateUtil.format(this.selectedDate, format)
            } else {
                this.setDate(DateUtil.parse(value, format));
            }
        },

        /**
         * 显示日期时间选择器。
         * @method show
         * @param  {Object} e 事件对象
         */
        show: function (e) {
            if (e) {
                e.stopPropagation();
                e.preventDefault();
            }

            if (this.options.disabled) {
                return false;
            }

            this.picker.show();
            this._place();

            this.isVisible = true;
            this._trigger('show', e, {
                date: this.selectedDate
            });
        },
        /**
         * 隐藏日期时间选择器。
         * @method hide
         * @param  {Object} e 事件对象
         */
        hide: function (e) {
            if (!this.isVisible) return;

            this.picker.hide();
            this._setMode(this.startViewMode);
            this.isVisible = false;
            this._trigger('hide', e, {
                date: this.selectedDate
            });
        },
        /**
         * @method remove
         * 移除日期时间选择器。同时移除已经绑定的event、内部绑定的对象和HTML元素。
         */
        remove: function () {
            this._detachEvents();
            this.picker.remove();
            delete this.picker;
            delete this.element.data().datetimepicker;
        },
        /**
         * 返回时间对象
         * @method getDate
         * @return {Date} date
         */
        getDate: function () {
            return this.selectedDate;
        },
        /**
         * 设置时间对象
         * @method setDate
         * @param {Date} d
         */
        setDate: function (date) {
            this._setDate(date);
            this.update();
        },

        _setDate: function (date,flag) {
            if (this.selectedDate != date) {
                if (date == null) {
                    this.viewDate = new Date();
                    this.selectedDate = date;
                } else if (date.valueOf() >= this.startDate.valueOf() && date <= this.endDate.valueOf()) {
                    this.viewDate = this.selectedDate = date;
                } else {
                    this._trigger('outOfRange', null, {
                        date: date, //带时区的?
                        startDate: this.startDate,
                        endDate: this.endDate
                    });
                    return false;
                }

                this._setElementValue();
                this._trigger('changeDate', null, {
                    date: date
                });
            }
        },

        _setElementValue: function () {
            var value = DateUtil.format(this.selectedDate, this.options.format);
            this.element.val(value);
        },

        /**
         * 设置一周的哪几天不能选择
         * @method setDaysOfWeekDisabled
         * @param {String} daysOfWeekDisabled 0-6分别表示周日到周六，用逗号隔开;也可以传入数组
         */
        setDaysOfWeekDisabled: function (daysOfWeekDisabled) {
            this.daysOfWeekDisabled = daysOfWeekDisabled || [];
            if (!$.isArray(this.daysOfWeekDisabled)) {
                this.daysOfWeekDisabled = this.daysOfWeekDisabled.split(/,\s*/);
            }
            this.daysOfWeekDisabled = $.map(this.daysOfWeekDisabled, function (d) {
                return parseInt(d, 10);
            });
        },

        _place: function () {
            var index_highest = 0;
            $('div').each(function () {
                var index_current = parseInt($(this).css("zIndex"), 10);
                if (index_current > index_highest) {
                    index_highest = index_current;
                }
            });
            var zIndex = index_highest + 10,
                pickerHeight = this.picker.outerHeight(),
                offset, top, left, outWindow;

            if (this.component) {
                offset = this.component.offset();
                left = offset.left + this.component.outerWidth() - this.picker.outerWidth();
            } else {
                offset = this.element.offset();
                left = offset.left;
            }

            top = offset.top + this.element.outerHeight();

            // out off window
            if (top + pickerHeight > $(document).height()) {
                this.picker.removeClass('datetimepicker-dropdown-bottom-left')
                    .addClass('datetimepicker-dropdown-top-left');
                top = offset.top - pickerHeight;
            } else if (this.picker.hasClass('datetimepicker-dropdown-top-left')){
                this.picker.addClass('datetimepicker-dropdown-bottom-left')
                    .removeClass('datetimepicker-dropdown-top-left');
            }

            this.picker.css({
                top: top,
                left: left,
                zIndex: zIndex
            });
        },

        _fillDow: function () {
            var dowCnt = this.weekStart,
                daysMin = fish.getResource('datetimepicker.daysMin'),
                html = '<tr>';
            while (dowCnt < this.weekStart + 7) {
                html += '<th class="dow">' + daysMin[(dowCnt++) % 7] + '</th>';
            }
            html += '</tr>';
            this.picker.find('.datetimepicker-days thead').append(html);
        },

        _fillYears: function (date) {
            var year = date.getFullYear(),
                startYear = this.startDate.getFullYear(),
                endYear = this.endDate.getFullYear(),
                currentYear = this.viewDate.getFullYear(),
                html = '';

            year = parseInt(year / 10, 10) * 10;
            var yearCont = this.picker.find('.datetimepicker-years')
                .find('th:eq(1)')
                .text(year + '-' + (year + 9))
                .end()
                .find('td');
            year -= 1;
            for (var i = -1; i < 11; i++) {
                html += '<span class="year' + (i == -1 || i == 10 ? ' old' : '') + (currentYear == year ? ' active' : '') + (year < startYear || year > endYear ? ' disabled' : '') + '">' + year + '</span>';
                year += 1;
            }
            yearCont.html(html);
        },

        _fillMonths: function (date) {
            var html = '',
                monthsShort = fish.getResource('datetimepicker.monthsShort'),
                year = date.getFullYear(),
                currentYear = this.viewDate.getFullYear(),
                currentMonth = this.viewDate.getMonth(),
                startYear = this.startDate.getFullYear(),
                startMonth = this.startDate.getMonth(),
                endYear = this.endDate.getFullYear(),
                endMonth = this.endDate.getMonth(),
                i = 0,
                months;
            while (i < 12) {
                html += '<span class="month">' + monthsShort[i++] + '</span>';
            }
            this.picker.find('.datetimepicker-months td').html(html);

            months = this.picker.find('.datetimepicker-months')
                .find('th:eq(1)')
                .text(year)
                .end()
                .find('span').removeClass('active');
            if (currentYear == year) {
                months.eq(currentMonth).addClass('active');
            }
            if (year < startYear || year > endYear) {
                months.addClass('disabled');
            }
            if (year == startYear) {
                months.slice(0, startMonth).addClass('disabled');
            }
            if (year == endYear) {
                months.slice(endMonth + 1).addClass('disabled');
            }
        },

        _fillDays: function (date) {
            var months = fish.getResource('datetimepicker.months'),
                date = DateUtil.getStartOfDay(date),
                prevMonth = DateUtil.addMonths(date, -1),
                currentDate = DateUtil.getStartOfDay(this.viewDate),
                day = DateUtil.getDaysInMonth(prevMonth.getFullYear(), prevMonth.getMonth()),
                today = DateUtil.getStartOfDay(new Date()),
                year = date.getFullYear(),
                month = date.getMonth();
            prevMonth.setDate(day);
            prevMonth.setDate(day - (prevMonth.getDay() - this.weekStart + 7) % 7);

            this.picker.find('.datetimepicker-days thead th:eq(1)')
                .text(months[month] + ' ' + year);

            var nextMonth = DateUtil.addDays(prevMonth, 42).valueOf(),
                html = [],
                clsName;

            while (prevMonth.valueOf() < nextMonth) {
                if (prevMonth.getDay() == this.weekStart) {
                    html.push('<tr>');
                }
                clsName = '';
                if (prevMonth.getFullYear() < year || (prevMonth.getFullYear() == year && prevMonth.getMonth() < month)) {
                    clsName += ' old';
                } else if (prevMonth.getFullYear() > year || (prevMonth.getFullYear() == year && prevMonth.getMonth() > month)) {
                    clsName += ' new';
                }
                // Compare internal  date with local today, not  today
                if (this.options.todayHighlight &&
                    prevMonth == today) {
                    clsName += ' today';
                }
                if (prevMonth.valueOf() == currentDate.valueOf()) {
                    clsName += ' active';
                }
                if ((prevMonth.valueOf() + 86400000) <= this.startDate.valueOf() ||
                    prevMonth.valueOf() > this.endDate.valueOf() ||
                    $.inArray(prevMonth.getDay(), this.daysOfWeekDisabled) !== -1) {
                    clsName += ' disabled';
                }
                html.push('<td class="day' + clsName + '">' + prevMonth.getDate() + '</td>');
                if (prevMonth.getDay() == this.weekEnd) {
                    html.push('</tr>');
                }
                prevMonth.setDate(prevMonth.getDate() + 1);
            }
            this.picker.find('.datetimepicker-days tbody').empty().append(html.join(''));
        },

        _fillHours: function (date) {
            var meridians = fish.getResource('datetimepicker.meridian'),
                months = fish.getResource('datetimepicker.months'),
                year = date.getFullYear(),
                month = date.getMonth(),
                dayMonth = date.getDate(),
                hours = date.getHours(),
                minutes = date.getMinutes(),
                html = [],
                txt = '',
                meridian = '',
                meridianOld = '',
                clsName;

            if (this.viewType == "time") {
                var hourConverted = hours % 12 ? hours % 12 : 12;
                var hoursDisplay = (hourConverted < 10 ? '0' : '') + hourConverted;
                var minutesDisplay = (minutes < 10 ? '0' : '') + minutes;
                var meridianDisplay = meridians[hours < 12 ? 0 : 1];
                this.picker.find('.datetimepicker-minutes thead th:eq(1)')
                    .text(hoursDisplay + ':' + minutesDisplay + ' ' + meridianDisplay.toUpperCase());
            } else {
                this.picker.find('.datetimepicker-hours thead th:eq(1)')
                    .text(dayMonth + ' ' + months[month] + ' ' + year);
            }

            for (var i = 0; i < 24; i++) {
                var actual = new Date(year, month, dayMonth, i);
                clsName = '';
                // We want the previous hour for the startDate
                if ((actual.valueOf() + 3600000) <= this.startDate.valueOf() || actual.valueOf() > this.endDate.valueOf()) {
                    clsName += ' disabled';
                } else if (hours == i) {
                    clsName += ' active';
                }
                if (this.showMeridian && meridians.length == 2) {
                    meridian = (i < 12 ? meridians[0] : meridians[1]);
                    if (meridian != meridianOld) {
                        if (meridianOld != '') {
                            html.push('</fieldset>');
                        }
                        html.push('<fieldset class="hour"><legend>' + meridian.toUpperCase() + '</legend>');
                    }
                    meridianOld = meridian;
                    txt = (i % 12 ? i % 12 : 12);
                    html.push('<span class="hour' + clsName + ' hour_' + (i < 12 ? 'am' : 'pm') + '">' + txt + '</span>');
                    if (i == 23) {
                        html.push('</fieldset>');
                    }
                } else {
                    txt = i + ':00';
                    html.push('<span class="hour' + clsName + '">' + txt + '</span>');
                }
            }

            this.picker.find('.datetimepicker-hours td').html(html.join(''));
        },

        _fillMinutes: function (date) {
            var meridians = fish.getResource('datetimepicker.meridian'),
                months = fish.getResource('datetimepicker.months'),
                year = date.getFullYear(),
                month = date.getMonth(),
                dayMonth = date.getDate(),
                hours = date.getHours(),
                minutes = date.getMinutes(),
                html = [],
                txt = '',
                meridian = '',
                meridianOld = '',
                clsName;

            if (this.viewType == "time") {
                var hourConverted = hours % 12 ? hours % 12 : 12;
                var hoursDisplay = (hourConverted < 10 ? '0' : '') + hourConverted;
                var minutesDisplay = (minutes < 10 ? '0' : '') + minutes;
                var meridianDisplay = meridians[hours < 12 ? 0 : 1];
                this.picker.find('.datetimepicker-minutes thead th:eq(1)')
                    .text(hoursDisplay + ':' + minutesDisplay + ' ' + meridianDisplay.toUpperCase());
            } else {
                this.picker.find('.datetimepicker-minutes thead th:eq(1)')
                    .text(dayMonth + ' ' + months[month] + ' ' + year);
            }

            for (var i = 0; i < 60; i += this.options.minuteStep) {
                var actual = new Date(year, month, dayMonth, hours, i, 0).valueOf();
                clsName = '';
                if (actual < this.startDate.valueOf() || actual > this.endDate.valueOf()) {
                    clsName += ' disabled';
                } else if (Math.floor(minutes / this.options.minuteStep) == Math.floor(i / this.options.minuteStep)) {
                    clsName += ' active';
                }
                if (this.showMeridian && meridians.length == 2) {
                    meridian = (hours < 12 ? meridians[0] : meridians[1]);
                    if (meridian != meridianOld) {
                        if (meridianOld != '') {
                            html.push('</fieldset>');
                        }
                        html.push('<fieldset class="minute"><legend>' + meridian.toUpperCase() + '</legend>');
                    }
                    meridianOld = meridian;
                    txt = (hours % 12 ? hours % 12 : 12);
                    //html.push('<span class="minute'+clsName+' minute_'+(hours<12?'am':'pm')+'">'+txt+'</span>');
                    html.push('<span class="minute' + clsName + '">' + txt + ':' + (i < 10 ? '0' + i : i) + '</span>');
                    if (i == 59) {
                        html.push('</fieldset>');
                    }
                } else {
                    txt = i + ':00';
                    //html.push('<span class="hour'+clsName+'">'+txt+'</span>');
                    html.push('<span class="minute' + clsName + '">' + hours + ':' + (i < 10 ? '0' + i : i) + '</span>');
                }
            }
            this.picker.find('.datetimepicker-minutes td').html(html.join(''));
        },

        update: function () {
            this.picker.find('tfoot th.today')
                .text(fish.getResource('datetimepicker.today'))
                .toggle(this.todayBtn !== false);

            this.updateNavArrows();

            switch (this.viewMode) {
                case 4:
                    this._fillYears(this.viewDate);
                    break;
                case 3:
                    this._fillMonths(this.viewDate);
                    break;
                case 2:
                    this._fillDays(this.viewDate);
                    break;
                case 1:
                    this._fillHours(this.viewDate);
                    break;
                case 0:
                    this._fillMinutes(this.viewDate);
                    break;
            }

            this._place();
        },

        updateNavArrows: function () {
            var d = this.viewDate,
                year = d.getFullYear(),
                month = d.getMonth(),
                day = d.getDate(),
                hour = d.getHours();
            switch (this.viewMode) {
                case 0:
                    if (year <= this.startDate.getFullYear() && month <= this.startDate.getMonth() && day <= this.startDate.getDate() && hour <= this.startDate.getHours()) {
                        this.picker.find('.prev').addClass('disabled');
                    } else {
                        this.picker.find('.prev').removeClass('disabled');
                    }
                    if (year >= this.endDate.getFullYear() && month >= this.endDate.getMonth() && day >= this.endDate.getDate() && hour >= this.endDate.getHours()) {
                        this.picker.find('.next').addClass('disabled');
                    } else {
                        this.picker.find('.next').removeClass('disabled');
                    }
                    break;
                case 1:
                    if (year <= this.startDate.getFullYear() && month <= this.startDate.getMonth() && day <= this.startDate.getDate()) {
                        this.picker.find('.prev').addClass('disabled');
                    } else {
                        this.picker.find('.prev').removeClass('disabled');
                    }
                    if (year >= this.endDate.getFullYear() && month >= this.endDate.getMonth() && day >= this.endDate.getDate()) {
                        this.picker.find('.next').addClass('disabled');
                    } else {
                        this.picker.find('.next').removeClass('disabled');
                    }
                    break;
                case 2:
                    if (year <= this.startDate.getFullYear() && month <= this.startDate.getMonth()) {
                        this.picker.find('.prev').addClass('disabled');
                    } else {
                        this.picker.find('.prev').removeClass('disabled');
                    }
                    if (year >= this.endDate.getFullYear() && month >= this.endDate.getMonth()) {
                        this.picker.find('.next').addClass('disabled');
                    } else {
                        this.picker.find('.next').removeClass('disabled');
                    }
                    break;
                case 3:
                case 4:
                    if (year <= this.startDate.getFullYear()) {
                        this.picker.find('.prev').addClass('disabled');
                    } else {
                        this.picker.find('.prev').removeClass('disabled');
                    }
                    if (year >= this.endDate.getFullYear()) {
                        this.picker.find('.next').addClass('disabled');
                    } else {
                        this.picker.find('.next').removeClass('disabled');
                    }
                    break;
            }
        },

        _onChange: function (e) {
            if (!this.inputChanged) {
                this.inputChanged = true;
            }
        },

        _onBlur: function (e) {
            if (this.inputChanged) {
                this.inputChanged = false;
                var date = this.element.val();
                date = date.replace(/^\s+|\s+$/g, '');
                date = DateUtil.parse(date, this.options.format);

                this.setDate(date);
            }
        },

        _onClick: function (e) {
            e.stopPropagation();
            e.preventDefault();
            var target = $(e.target).closest('span, td, th, legend');
            if (target.length == 1) {
                if (target.is('.disabled')) {
                    this._trigger('outOfRange', e, {
                        date: this.viewDate,
                        startDate: this.startDate,
                        endDate: this.endDate
                    });
                    return;
                }
                switch (target[0].nodeName.toLowerCase()) {
                    case 'th':
                        switch (target[0].className) {
                            case 'switch':
                                this._addMode(1);
                                break;
                            case 'prev':
                            case 'next':
                                var dir = DPGlobal.modes[this.viewMode].navStep * (target[0].className == 'prev' ? -1 : 1);
                                switch (this.viewMode) {
                                    case 0:
                                        this.viewDate = DateUtil.addHours(this.viewDate, dir);
                                        break;
                                    case 1:
                                        this.viewDate = DateUtil.addDays(this.viewDate, dir);
                                        break;
                                    case 2:
                                        this.viewDate = DateUtil.addMonths(this.viewDate, dir);
                                        break;
                                    case 3:
                                    case 4:
                                        this.viewDate = DateUtil.addYears(this.viewDate, dir);
                                        break;
                                }
                                this.update();
                                break;
                            case 'today':
                                var date = new Date();
                                // Respect startDate and endDate.
                                if (date < this.startDate) date = this.startDate;
                                else if (date > this.endDate) date = this.endDate;

                                this._setDate(date);
                                this.hide();
                                break;
                        }
                        break;
                    case 'span':
                        if (!target.is('.disabled')) {
                            var year = this.viewDate.getFullYear(),
                                month = this.viewDate.getMonth(),
                                day = this.viewDate.getDate(),
                                hours = this.viewDate.getHours(),
                                minutes = this.viewDate.getMinutes(),
                                seconds = this.viewDate.getSeconds();

                            if (target.is('.month')) {
                                month = target.parent().find('span').index(target);
                                day = this.viewDate.getDate();
                                this.viewDate.setMonth(month);
                                this._trigger('changeMonth', e, {
                                    date: this.viewDate
                                });
                                if (this.minView === 3) {
                                    this._setDate(new Date(year, month, day, hours, minutes, seconds, 0));
                                    this.hide();
                                } else {
                                    this._addMode(-1);
                                }
                            } else if (target.is('.year')) {
                                year = parseInt(target.text(), 10) || 0;
                                this.viewDate.setFullYear(year);
                                this._trigger('changeYear', e, {
                                    date: this.viewDate
                                });
                                if (this.minView === 4) {
                                    this._setDate(new Date(year, month, day, hours, minutes, seconds, 0));
                                    this.hide();
                                } else {
                                    this._addMode(-1);
                                }
                            } else if (target.is('.hour')) {
                                hours = parseInt(target.text(), 10) || 0;
                                if (target.hasClass('hour_am') || target.hasClass('hour_pm')) {
                                    if (hours == 12 && target.hasClass('hour_am')) {
                                        hours = 0;
                                    } else if (hours != 12 && target.hasClass('hour_pm')) {
                                        hours += 12;
                                    }
                                }
                                this.viewDate.setHours(hours);
                                this._trigger('changeHour', e, {
                                    date: this.viewDate
                                });
                                if (this.minView === 1) {
                                    this._setDate(new Date(year, month, day, hours, minutes, seconds, 0));
                                    this.hide();
                                } else {
                                    this._addMode(-1);
                                }
                            } else if (target.is('.minute')) {
                                minutes = parseInt(target.text().substr(target.text().indexOf(':') + 1), 10) || 0;
                                this.viewDate.setMinutes(minutes);
                                this._trigger('changeMinute', e, {
                                    date: this.viewDate
                                });
                                if (this.minView === 0) {
                                    this._setDate(new Date(year, month, day, hours, minutes, seconds, 0));
                                    this.hide();
                                } else {
                                    this._addMode(-1);
                                }
                            }
                        }
                        break;
                    case 'td':
                        if (target.is('.day') && !target.is('.disabled')) {
                            var day = parseInt(target.text(), 10) || 1;
                            var year = this.viewDate.getFullYear(),
                                month = this.viewDate.getMonth(),
                                hours = this.viewDate.getHours(),
                                minutes = this.viewDate.getMinutes(),
                                seconds = this.viewDate.getSeconds();
                            if (target.is('.old')) {
                                if (month === 0) {
                                    month = 11;
                                    year -= 1;
                                } else {
                                    month -= 1;
                                }
                            } else if (target.is('.new')) {
                                if (month == 11) {
                                    month = 0;
                                    year += 1;
                                } else {
                                    month += 1;
                                }
                            }
                            this.viewDate.setFullYear(year);
                            this.viewDate.setMonth(month, day);
                            this._trigger('changeDay', e, {
                                date: this.viewDate
                            });
                            if (this.minView === 2) {
                                this._setDate(new Date(year, month, day, hours, minutes, seconds, 0));
                                this.hide();
                            } else {
                                this._addMode(-1);
                            }
                        }
                        break;
                }
            }
        },

        _addMode: function (dir) {
            var newViewMode = Math.max(this.minView, Math.min(this.maxView, this.viewMode + dir));
            this._setMode(newViewMode);
        },

        _setMode: function (mode) {
            if (this.viewMode !== mode) {
                this._trigger('changeMode', {
                    date: this.viewDate,
                    oldViewMode: this.viewMode,
                    newViewMode: mode
                });
            }

            this.viewMode = mode;
            this.picker.find('>div').hide().filter('.datetimepicker-' + DPGlobal.modes[this.viewMode].clsName).css('display', 'block');
            this.update();
        },

        reset: function (e) {
            if (this.options.disabled) {
                return false;
            }
            this.setDate(null);
        }
    });

    /**
     * 当选择器显示时被触发。
     * @event show
     * @param {event} [e] 事件对象
     * @param {Object} [value] 回调参数,value.date为当前值
     */
    /**
     * 当选择器隐藏时被触发。
     * @event hide
     * @param {event} [e] 事件对象
     * @param {Object} [value] 回调参数,value.date为当前值
     */
    /**
     * 当日期被改变时被触发。
     * @event changeDate
     * @param {event} [e] 事件对象
     * @param {Object} [value] 回调参数,value.date为当前值
     */
    /**
     * 当十年视图上的年视图view被改变时触发。
     * @event changeYear
     * @param {event} [e] 事件对象
     * @param {Object} [value] 回调参数,value.date为当前值
     */
    /**
     * 当年视图上的月视图view被改变时触发。
     * @event changeMonth
     * @param {event} [e] 事件对象
     * @param {Object} [value] 回调参数,value.date为当前值
     */
    /**
     * 当月视图上的日视图view被改变时触发。
     * @event changeDay
     * @param {event} [e] 事件对象
     * @param {Object} [value] 回调参数,value.date为当前值
     */
    /**
     * 当日视图上的小时视图view被改变时触发。
     * @event changeHour
     * @param {event} [e] 事件对象
     * @param {Object} [value] 回调参数,value.date为当前值
     */
    /**
     * 当小时视图上的值被改变时触发。
     * @event changeMinute
     * @param {event} [e] 事件对象
     * @param {Object} [value] 回调参数,value.date为当前值
     */
    /**
     * 当用户选择的日期超出startDate 或endDate 时被触发
     * @event outOfRange
     * @param {event} [e] 事件对象
     * @param {Object} [value] 回调参数,value.date为当前值,value.startDate 开始时间,value.endDate 结束时间
     */
});

//Paul Tero, July 2001
//http://www.tero.co.uk/des/
//
//Optimised for performance with large blocks by Michael Hayworth, November 2001
//http://www.netdealing.com
//

//des
//this takes the key, the message, and whether to encrypt or decrypt

/**
 * DES加密算法
 * @class fish.desktop.util.DES
 * <pre>
 *   fish.DES.encrypt(key,message);
 * </pre>
 */
! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.des', factory)
    } else {
        factory();
    }
}(function() {
    'use strict';

    function des(key, message, encrypt, mode, iv, padding) {
            //declaring this locally speeds things up a bit
            var spfunction1 = new Array(0x1010400, 0, 0x10000, 0x1010404, 0x1010004, 0x10404, 0x4, 0x10000, 0x400, 0x1010400, 0x1010404, 0x400, 0x1000404, 0x1010004, 0x1000000, 0x4, 0x404, 0x1000400, 0x1000400, 0x10400, 0x10400, 0x1010000, 0x1010000, 0x1000404, 0x10004, 0x1000004, 0x1000004, 0x10004, 0, 0x404, 0x10404, 0x1000000, 0x10000, 0x1010404, 0x4, 0x1010000, 0x1010400, 0x1000000, 0x1000000, 0x400, 0x1010004, 0x10000, 0x10400, 0x1000004, 0x400, 0x4, 0x1000404, 0x10404, 0x1010404, 0x10004, 0x1010000, 0x1000404, 0x1000004, 0x404, 0x10404, 0x1010400, 0x404, 0x1000400, 0x1000400, 0, 0x10004, 0x10400, 0, 0x1010004);
            var spfunction2 = new Array(-0x7fef7fe0, -0x7fff8000, 0x8000, 0x108020, 0x100000, 0x20, -0x7fefffe0, -0x7fff7fe0, -0x7fffffe0, -0x7fef7fe0, -0x7fef8000, -0x80000000, -0x7fff8000, 0x100000, 0x20, -0x7fefffe0, 0x108000, 0x100020, -0x7fff7fe0, 0, -0x80000000, 0x8000, 0x108020, -0x7ff00000, 0x100020, -0x7fffffe0, 0, 0x108000, 0x8020, -0x7fef8000, -0x7ff00000, 0x8020, 0, 0x108020, -0x7fefffe0, 0x100000, -0x7fff7fe0, -0x7ff00000, -0x7fef8000, 0x8000, -0x7ff00000, -0x7fff8000, 0x20, -0x7fef7fe0, 0x108020, 0x20, 0x8000, -0x80000000, 0x8020, -0x7fef8000, 0x100000, -0x7fffffe0, 0x100020, -0x7fff7fe0, -0x7fffffe0, 0x100020, 0x108000, 0, -0x7fff8000, 0x8020, -0x80000000, -0x7fefffe0, -0x7fef7fe0, 0x108000);
            var spfunction3 = new Array(0x208, 0x8020200, 0, 0x8020008, 0x8000200, 0, 0x20208, 0x8000200, 0x20008, 0x8000008, 0x8000008, 0x20000, 0x8020208, 0x20008, 0x8020000, 0x208, 0x8000000, 0x8, 0x8020200, 0x200, 0x20200, 0x8020000, 0x8020008, 0x20208, 0x8000208, 0x20200, 0x20000, 0x8000208, 0x8, 0x8020208, 0x200, 0x8000000, 0x8020200, 0x8000000, 0x20008, 0x208, 0x20000, 0x8020200, 0x8000200, 0, 0x200, 0x20008, 0x8020208, 0x8000200, 0x8000008, 0x200, 0, 0x8020008, 0x8000208, 0x20000, 0x8000000, 0x8020208, 0x8, 0x20208, 0x20200, 0x8000008, 0x8020000, 0x8000208, 0x208, 0x8020000, 0x20208, 0x8, 0x8020008, 0x20200);
            var spfunction4 = new Array(0x802001, 0x2081, 0x2081, 0x80, 0x802080, 0x800081, 0x800001, 0x2001, 0, 0x802000, 0x802000, 0x802081, 0x81, 0, 0x800080, 0x800001, 0x1, 0x2000, 0x800000, 0x802001, 0x80, 0x800000, 0x2001, 0x2080, 0x800081, 0x1, 0x2080, 0x800080, 0x2000, 0x802080, 0x802081, 0x81, 0x800080, 0x800001, 0x802000, 0x802081, 0x81, 0, 0, 0x802000, 0x2080, 0x800080, 0x800081, 0x1, 0x802001, 0x2081, 0x2081, 0x80, 0x802081, 0x81, 0x1, 0x2000, 0x800001, 0x2001, 0x802080, 0x800081, 0x2001, 0x2080, 0x800000, 0x802001, 0x80, 0x800000, 0x2000, 0x802080);
            var spfunction5 = new Array(0x100, 0x2080100, 0x2080000, 0x42000100, 0x80000, 0x100, 0x40000000, 0x2080000, 0x40080100, 0x80000, 0x2000100, 0x40080100, 0x42000100, 0x42080000, 0x80100, 0x40000000, 0x2000000, 0x40080000, 0x40080000, 0, 0x40000100, 0x42080100, 0x42080100, 0x2000100, 0x42080000, 0x40000100, 0, 0x42000000, 0x2080100, 0x2000000, 0x42000000, 0x80100, 0x80000, 0x42000100, 0x100, 0x2000000, 0x40000000, 0x2080000, 0x42000100, 0x40080100, 0x2000100, 0x40000000, 0x42080000, 0x2080100, 0x40080100, 0x100, 0x2000000, 0x42080000, 0x42080100, 0x80100, 0x42000000, 0x42080100, 0x2080000, 0, 0x40080000, 0x42000000, 0x80100, 0x2000100, 0x40000100, 0x80000, 0, 0x40080000, 0x2080100, 0x40000100);
            var spfunction6 = new Array(0x20000010, 0x20400000, 0x4000, 0x20404010, 0x20400000, 0x10, 0x20404010, 0x400000, 0x20004000, 0x404010, 0x400000, 0x20000010, 0x400010, 0x20004000, 0x20000000, 0x4010, 0, 0x400010, 0x20004010, 0x4000, 0x404000, 0x20004010, 0x10, 0x20400010, 0x20400010, 0, 0x404010, 0x20404000, 0x4010, 0x404000, 0x20404000, 0x20000000, 0x20004000, 0x10, 0x20400010, 0x404000, 0x20404010, 0x400000, 0x4010, 0x20000010, 0x400000, 0x20004000, 0x20000000, 0x4010, 0x20000010, 0x20404010, 0x404000, 0x20400000, 0x404010, 0x20404000, 0, 0x20400010, 0x10, 0x4000, 0x20400000, 0x404010, 0x4000, 0x400010, 0x20004010, 0, 0x20404000, 0x20000000, 0x400010, 0x20004010);
            var spfunction7 = new Array(0x200000, 0x4200002, 0x4000802, 0, 0x800, 0x4000802, 0x200802, 0x4200800, 0x4200802, 0x200000, 0, 0x4000002, 0x2, 0x4000000, 0x4200002, 0x802, 0x4000800, 0x200802, 0x200002, 0x4000800, 0x4000002, 0x4200000, 0x4200800, 0x200002, 0x4200000, 0x800, 0x802, 0x4200802, 0x200800, 0x2, 0x4000000, 0x200800, 0x4000000, 0x200800, 0x200000, 0x4000802, 0x4000802, 0x4200002, 0x4200002, 0x2, 0x200002, 0x4000000, 0x4000800, 0x200000, 0x4200800, 0x802, 0x200802, 0x4200800, 0x802, 0x4000002, 0x4200802, 0x4200000, 0x200800, 0, 0x2, 0x4200802, 0, 0x200802, 0x4200000, 0x800, 0x4000002, 0x4000800, 0x800, 0x200002);
            var spfunction8 = new Array(0x10001040, 0x1000, 0x40000, 0x10041040, 0x10000000, 0x10001040, 0x40, 0x10000000, 0x40040, 0x10040000, 0x10041040, 0x41000, 0x10041000, 0x41040, 0x1000, 0x40, 0x10040000, 0x10000040, 0x10001000, 0x1040, 0x41000, 0x40040, 0x10040040, 0x10041000, 0x1040, 0, 0, 0x10040040, 0x10000040, 0x10001000, 0x41040, 0x40000, 0x41040, 0x40000, 0x10041000, 0x1000, 0x40, 0x10040040, 0x1000, 0x41040, 0x10001000, 0x40, 0x10000040, 0x10040000, 0x10040040, 0x10000000, 0x40000, 0x10001040, 0, 0x10041040, 0x40040, 0x10000040, 0x10040000, 0x10001000, 0x10001040, 0, 0x10041040, 0x41000, 0x41000, 0x1040, 0x1040, 0x40040, 0x10000000, 0x10041000);

            //create the 16 or 48 subkeys we will need
            var keys = des_createKeys(key);
            var m = 0,
                i, j, temp, temp2, right1, right2, left, right, looping;
            var cbcleft, cbcleft2, cbcright, cbcright2
            var endloop, loopinc;
            var len = message.length;
            var chunk = 0;
            //set up the loops for single and triple des
            var iterations = keys.length == 32 ? 3 : 9; //single or triple des
            if (iterations == 3) {
                looping = encrypt ? new Array(0, 32, 2) : new Array(30, -2, -2);
            } else {
                looping = encrypt ? new Array(0, 32, 2, 62, 30, -2, 64, 96, 2) : new Array(94, 62, -2, 32, 64, 2, 30, -2, -2);
            }

            //pad the message depending on the padding parameter
            if (padding == 2) message += "        "; //pad the message with spaces
            else if (padding == 1) {
                temp = 8 - (len % 8);
                message += String.fromCharCode(temp, temp, temp, temp, temp, temp, temp, temp);
                if (temp == 8) len += 8;
            } //PKCS7 padding
            else if (!padding) message += "\0\0\0\0\0\0\0\0"; //pad the message out with null bytes

            //store the result here
            result = "";
            tempresult = "";

            if (mode == 1) { //CBC mode
                cbcleft = (iv.charCodeAt(m++) << 24) | (iv.charCodeAt(m++) << 16) | (iv.charCodeAt(m++) << 8) | iv.charCodeAt(m++);
                cbcright = (iv.charCodeAt(m++) << 24) | (iv.charCodeAt(m++) << 16) | (iv.charCodeAt(m++) << 8) | iv.charCodeAt(m++);
                m = 0;
            }

            //loop through each 64 bit chunk of the message
            while (m < len) {
                left = (message.charCodeAt(m++) << 24) | (message.charCodeAt(m++) << 16) | (message.charCodeAt(m++) << 8) | message.charCodeAt(m++);
                right = (message.charCodeAt(m++) << 24) | (message.charCodeAt(m++) << 16) | (message.charCodeAt(m++) << 8) | message.charCodeAt(m++);

                //for Cipher Block Chaining mode, xor the message with the previous result
                if (mode == 1) {
                    if (encrypt) {
                        left ^= cbcleft;
                        right ^= cbcright;
                    } else {
                        cbcleft2 = cbcleft;
                        cbcright2 = cbcright;
                        cbcleft = left;
                        cbcright = right;
                    }
                }

                //first each 64 but chunk of the message must be permuted according to IP
                temp = ((left >>> 4) ^ right) & 0x0f0f0f0f;
                right ^= temp;
                left ^= (temp << 4);
                temp = ((left >>> 16) ^ right) & 0x0000ffff;
                right ^= temp;
                left ^= (temp << 16);
                temp = ((right >>> 2) ^ left) & 0x33333333;
                left ^= temp;
                right ^= (temp << 2);
                temp = ((right >>> 8) ^ left) & 0x00ff00ff;
                left ^= temp;
                right ^= (temp << 8);
                temp = ((left >>> 1) ^ right) & 0x55555555;
                right ^= temp;
                left ^= (temp << 1);

                left = ((left << 1) | (left >>> 31));
                right = ((right << 1) | (right >>> 31));

                //do this either 1 or 3 times for each chunk of the message
                for (j = 0; j < iterations; j += 3) {
                    endloop = looping[j + 1];
                    loopinc = looping[j + 2];
                    //now go through and perform the encryption or decryption  
                    for (i = looping[j]; i != endloop; i += loopinc) { //for efficiency
                        right1 = right ^ keys[i];
                        right2 = ((right >>> 4) | (right << 28)) ^ keys[i + 1];
                        //the result is attained by passing these bytes through the S selection functions
                        temp = left;
                        left = right;
                        right = temp ^ (spfunction2[(right1 >>> 24) & 0x3f] | spfunction4[(right1 >>> 16) & 0x3f] | spfunction6[(right1 >>> 8) & 0x3f] | spfunction8[right1 & 0x3f] | spfunction1[(right2 >>> 24) & 0x3f] | spfunction3[(right2 >>> 16) & 0x3f] | spfunction5[(right2 >>> 8) & 0x3f] | spfunction7[right2 & 0x3f]);
                    }
                    temp = left;
                    left = right;
                    right = temp; //unreverse left and right
                } //for either 1 or 3 iterations

                //move then each one bit to the right
                left = ((left >>> 1) | (left << 31));
                right = ((right >>> 1) | (right << 31));

                //now perform IP-1, which is IP in the opposite direction
                temp = ((left >>> 1) ^ right) & 0x55555555;
                right ^= temp;
                left ^= (temp << 1);
                temp = ((right >>> 8) ^ left) & 0x00ff00ff;
                left ^= temp;
                right ^= (temp << 8);
                temp = ((right >>> 2) ^ left) & 0x33333333;
                left ^= temp;
                right ^= (temp << 2);
                temp = ((left >>> 16) ^ right) & 0x0000ffff;
                right ^= temp;
                left ^= (temp << 16);
                temp = ((left >>> 4) ^ right) & 0x0f0f0f0f;
                right ^= temp;
                left ^= (temp << 4);

                //for Cipher Block Chaining mode, xor the message with the previous result
                if (mode == 1) {
                    if (encrypt) {
                        cbcleft = left;
                        cbcright = right;
                    } else {
                        left ^= cbcleft2;
                        right ^= cbcright2;
                    }
                }
                tempresult += String.fromCharCode((left >>> 24), ((left >>> 16) & 0xff), ((left >>> 8) & 0xff), (left & 0xff), (right >>> 24), ((right >>> 16) & 0xff), ((right >>> 8) & 0xff), (right & 0xff));

                chunk += 8;
                if (chunk == 512) {
                    result += tempresult;
                    tempresult = "";
                    chunk = 0;
                }
            } //for every 8 characters, or 64 bits in the message

            //return the result as an array
            return result + tempresult;
        } //end of des


    //des_createKeys
    //this takes as input a 64 bit key (even though only 56 bits are used)
    //as an array of 2 integers, and returns 16 48 bit keys
    function des_createKeys(key) {
            //declaring this locally speeds things up a bit
            pc2bytes0 = new Array(0, 0x4, 0x20000000, 0x20000004, 0x10000, 0x10004, 0x20010000, 0x20010004, 0x200, 0x204, 0x20000200, 0x20000204, 0x10200, 0x10204, 0x20010200, 0x20010204);
            pc2bytes1 = new Array(0, 0x1, 0x100000, 0x100001, 0x4000000, 0x4000001, 0x4100000, 0x4100001, 0x100, 0x101, 0x100100, 0x100101, 0x4000100, 0x4000101, 0x4100100, 0x4100101);
            pc2bytes2 = new Array(0, 0x8, 0x800, 0x808, 0x1000000, 0x1000008, 0x1000800, 0x1000808, 0, 0x8, 0x800, 0x808, 0x1000000, 0x1000008, 0x1000800, 0x1000808);
            pc2bytes3 = new Array(0, 0x200000, 0x8000000, 0x8200000, 0x2000, 0x202000, 0x8002000, 0x8202000, 0x20000, 0x220000, 0x8020000, 0x8220000, 0x22000, 0x222000, 0x8022000, 0x8222000);
            pc2bytes4 = new Array(0, 0x40000, 0x10, 0x40010, 0, 0x40000, 0x10, 0x40010, 0x1000, 0x41000, 0x1010, 0x41010, 0x1000, 0x41000, 0x1010, 0x41010);
            pc2bytes5 = new Array(0, 0x400, 0x20, 0x420, 0, 0x400, 0x20, 0x420, 0x2000000, 0x2000400, 0x2000020, 0x2000420, 0x2000000, 0x2000400, 0x2000020, 0x2000420);
            pc2bytes6 = new Array(0, 0x10000000, 0x80000, 0x10080000, 0x2, 0x10000002, 0x80002, 0x10080002, 0, 0x10000000, 0x80000, 0x10080000, 0x2, 0x10000002, 0x80002, 0x10080002);
            pc2bytes7 = new Array(0, 0x10000, 0x800, 0x10800, 0x20000000, 0x20010000, 0x20000800, 0x20010800, 0x20000, 0x30000, 0x20800, 0x30800, 0x20020000, 0x20030000, 0x20020800, 0x20030800);
            pc2bytes8 = new Array(0, 0x40000, 0, 0x40000, 0x2, 0x40002, 0x2, 0x40002, 0x2000000, 0x2040000, 0x2000000, 0x2040000, 0x2000002, 0x2040002, 0x2000002, 0x2040002);
            pc2bytes9 = new Array(0, 0x10000000, 0x8, 0x10000008, 0, 0x10000000, 0x8, 0x10000008, 0x400, 0x10000400, 0x408, 0x10000408, 0x400, 0x10000400, 0x408, 0x10000408);
            pc2bytes10 = new Array(0, 0x20, 0, 0x20, 0x100000, 0x100020, 0x100000, 0x100020, 0x2000, 0x2020, 0x2000, 0x2020, 0x102000, 0x102020, 0x102000, 0x102020);
            pc2bytes11 = new Array(0, 0x1000000, 0x200, 0x1000200, 0x200000, 0x1200000, 0x200200, 0x1200200, 0x4000000, 0x5000000, 0x4000200, 0x5000200, 0x4200000, 0x5200000, 0x4200200, 0x5200200);
            pc2bytes12 = new Array(0, 0x1000, 0x8000000, 0x8001000, 0x80000, 0x81000, 0x8080000, 0x8081000, 0x10, 0x1010, 0x8000010, 0x8001010, 0x80010, 0x81010, 0x8080010, 0x8081010);
            pc2bytes13 = new Array(0, 0x4, 0x100, 0x104, 0, 0x4, 0x100, 0x104, 0x1, 0x5, 0x101, 0x105, 0x1, 0x5, 0x101, 0x105);

            //how many iterations (1 for des, 3 for triple des)
            var iterations = key.length > 8 ? 3 : 1; //changed by Paul 16/6/2007 to use Triple DES for 9+ byte keys
            //stores the return keys
            var keys = new Array(32 * iterations);
            //now define the left shifts which need to be done
            var shifts = new Array(0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0);
            //other variables
            var lefttemp, righttemp, m = 0,
                n = 0,
                temp;

            for (var j = 0; j < iterations; j++) { //either 1 or 3 iterations
                left = (key.charCodeAt(m++) << 24) | (key.charCodeAt(m++) << 16) | (key.charCodeAt(m++) << 8) | key.charCodeAt(m++);
                right = (key.charCodeAt(m++) << 24) | (key.charCodeAt(m++) << 16) | (key.charCodeAt(m++) << 8) | key.charCodeAt(m++);

                temp = ((left >>> 4) ^ right) & 0x0f0f0f0f;
                right ^= temp;
                left ^= (temp << 4);
                temp = ((right >>> -16) ^ left) & 0x0000ffff;
                left ^= temp;
                right ^= (temp << -16);
                temp = ((left >>> 2) ^ right) & 0x33333333;
                right ^= temp;
                left ^= (temp << 2);
                temp = ((right >>> -16) ^ left) & 0x0000ffff;
                left ^= temp;
                right ^= (temp << -16);
                temp = ((left >>> 1) ^ right) & 0x55555555;
                right ^= temp;
                left ^= (temp << 1);
                temp = ((right >>> 8) ^ left) & 0x00ff00ff;
                left ^= temp;
                right ^= (temp << 8);
                temp = ((left >>> 1) ^ right) & 0x55555555;
                right ^= temp;
                left ^= (temp << 1);

                //the right side needs to be shifted and to get the last four bits of the left side
                temp = (left << 8) | ((right >>> 20) & 0x000000f0);
                //left needs to be put upside down
                left = (right << 24) | ((right << 8) & 0xff0000) | ((right >>> 8) & 0xff00) | ((right >>> 24) & 0xf0);
                right = temp;

                //now go through and perform these shifts on the left and right keys
                for (var i = 0; i < shifts.length; i++) {
                    //shift the keys either one or two bits to the left
                    if (shifts[i]) {
                        left = (left << 2) | (left >>> 26);
                        right = (right << 2) | (right >>> 26);
                    } else {
                        left = (left << 1) | (left >>> 27);
                        right = (right << 1) | (right >>> 27);
                    }
                    left &= -0xf;
                    right &= -0xf;

                    //now apply PC-2, in such a way that E is easier when encrypting or decrypting
                    //this conversion will look like PC-2 except only the last 6 bits of each byte are used
                    //rather than 48 consecutive bits and the order of lines will be according to 
                    //how the S selection functions will be applied: S2, S4, S6, S8, S1, S3, S5, S7
                    lefttemp = pc2bytes0[left >>> 28] | pc2bytes1[(left >>> 24) & 0xf] | pc2bytes2[(left >>> 20) & 0xf] | pc2bytes3[(left >>> 16) & 0xf] | pc2bytes4[(left >>> 12) & 0xf] | pc2bytes5[(left >>> 8) & 0xf] | pc2bytes6[(left >>> 4) & 0xf];
                    righttemp = pc2bytes7[right >>> 28] | pc2bytes8[(right >>> 24) & 0xf] | pc2bytes9[(right >>> 20) & 0xf] | pc2bytes10[(right >>> 16) & 0xf] | pc2bytes11[(right >>> 12) & 0xf] | pc2bytes12[(right >>> 8) & 0xf] | pc2bytes13[(right >>> 4) & 0xf];
                    temp = ((righttemp >>> 16) ^ lefttemp) & 0x0000ffff;
                    keys[n++] = lefttemp ^ temp;
                    keys[n++] = righttemp ^ (temp << 16);
                }
            } //for each iterations
            //return the keys we've created
            return keys;
        } //end of des_createKeys


    fish.DES = {
        /**
         * des基础方法
         * @method
         * @param {String} key 密钥
         * @param {String} message 明文
         * @param {Boolean} encrypt 是否是加密；true：加密；false：解密
         * @param {Number} [mode=0]  0:ECB; 1:CBC; 关于ECB,CBS请参考：http://www.tero.co.uk/des/explain.php
         * @param {Number} [iv]  an optional 8 character string input vector (not used in ECB mode)
         * @param {Number} [padding] 关于参考：http://www.tero.co.uk/des/explain.php
         * @returns {String} 密文
         */
        des: des,
        /**
         * 使用指定的密钥加密
         * @method
         * @param {String} key 密钥
         * @param {String} message 明文
         * @returns {String} 密文
         */
        encrypt: function(key, message) {
            return this.des(key, message, true, 0);
        },

        /**
         * 使用指定的密钥解密
         * @method
         * @param {String} key 密钥
         * @param {String} message 明文
         * @returns {String} 密文
         */
        decrypt: function(key, message) {
            return this.des(key, message, false, 0);
        },

        /**
         * 将字符串转换成十六进制字符串
         * @method
         * @param {String} str 字符串
         * @returns {string} 十六进制字符串
         */
        stringToHex: function(s) {
            var r = "0x";
            var hexes = new Array("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f");
            for (var i = 0; i < s.length; i++) {
                r += hexes[s.charCodeAt(i) >> 4] + hexes[s.charCodeAt(i) & 0xf];
            }
            return r;
        },

        /**
         * 将十六进制转换成字符串
         * @method
         * @param {String} hexStr 十六进制字符串
         * @returns {string} 字符串
         */
        hexToString: function(h) {
            var r = "";
            for (var i = (h.substr(0, 2) == "0x") ? 2 : 0; i < h.length; i += 2) {
                r += String.fromCharCode(parseInt(h.substr(i, 2), 16));
            }
            return r;
        }
    };
});

/*!
 * jQuery UI Dialog 1.9.2
 * http://api.jqueryui.com/dialog/
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 *  jquery.ui.button.js
 *  jquery.ui.draggable.js
 *  jquery.ui.mouse.js
 *  jquery.ui.position.js
 *  jquery.ui.resizable.js
 */

/**
 * 弹出框<br/>
 *
 * @class fish.desktop.widget.Dialog
 * @extends fish.desktop.widget
 */
!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.dialog', factory);
    } else {
        factory();
    }
}(function () {
    'use strict';

    var sizeRelatedOptions = {
            // buttons: true,
            height: true,
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true,
            width: true
        },
        resizableRelatedOptions = {
            maxHeight: true,
            maxWidth: true,
            minHeight: true,
            minWidth: true
        };

    $.widget("ui.dialog", {
        options: {
            /**
             * @cfg {Boolean} [autoOpen=true] 是否自动打开
             */
            autoOpen: true,
            /**
             * @cfg {Boolean} [closeOnEscape=true] ESC键是否退出
             */
            closeOnEscape: true,

            /**
             * @cfg {Boolean} [closeOnClickOverlay=false] 点击遮罩层是否退出
             */
            closeOnClickOverlay: false,
            /**
             * @cfg {String} [draggable=true] 是否可以拖动
             */
            draggable: true,
            /**
             * @cfg {*} [hide=null] type:Boolean,Number,String,Object
             *
             * If and how to animate the hiding of the dialog.<br/>
             * Multiple types supported:<br/>
             * <b>Boolean</b>: When set to false, no animation will be used and the dialog will be hidden immediately.
             * When set to true, the dialog will fade out with the default duration and the default easing.<br/>
             * <b>Number</b>: The dialog will fade out with the specified duration and the default easing.<br/>
             * <b>String</b>: The dialog will be hidden using the specified effect. The value can either be the name
             * of a built-in jQuery animation method, such as "slideUp", or the name of a jQuery UI effect, such as "fold".
             * In either case the effect will be used with the default duration and the default easing.<br/>
             * <b>Object</b>: If the value is an object, then effect, delay, duration, and easing properties may be provided.
             * If the effect property contains the name of a jQuery method, then that method will be used; otherwise it
             * is assumed to be the name of a jQuery UI effect. When using a jQuery UI effect that supports additional
             * settings, you may include those settings in the object and they will be passed to the effect. If duration or
             * easing is omitted, then the default values will be used. If effect is omitted, then "fadeOut" will be used.
             * If delay is omitted, then no delay is used.<br/>
             */
            hide: null,
            /**
             * @cfg {*} [height='auto'] type:Number,String
             *
             * The height of the dialog.<br/>
             * Multiple types supported:<br/>
             * Number: The height in pixels.<br/>
             * String: The only supported string value is "auto" which will allow the dialog height to adjust based on its content<br/>
             */
            height: "auto",
            /**
             * @cfg {String} [maxHeight=null]
             * The maximum height to which the dialog can be resized, in pixels.
             */
            maxHeight: null,
            /**
             * @cfg {String} [maxWidth=null]
             * The maximum width to which the dialog can be resized, in pixels.
             */
            maxWidth: null,
            /**
             * @cfg {String} [minHeight=150]
             * The minimum height to which the dialog can be resized, in pixels.
             */
            minHeight: 150,
            /**
             * @cfg {String} [minWidth=150]
             * The minimum width to which the dialog can be resized, in pixels.
             */
            minWidth: 150,
            /**
             * @cfg {*} [width='auto'] type:Number,String
             *
             * The width of the dialog.<br/>
             * Multiple types supported:<br/>
             * Number: The width in pixels.<br/>
             * String: The only supported string value is "auto" which will allow the dialog width to adjust based on its content<br/>
             */
            width: 300,
            /**
             * @cfg {String} [modal=false]
             * If set to true, the dialog will have modal behavior; other items on the page will be disabled, i.e.,
             * cannot be interacted with. Modal dialogs create an overlay below the dialog but above other page elements.<br/>
             */
            modal: false,
            /**
             * @cfg {Object} [position={ my: "center", at: "center", of: window, collision:"fit" }]
             * Specifies where the dialog should be displayed when opened. The dialog will handle collisions such that as much
             * of the dialog is visible as possible.<br/>
             * The of property defaults to the window, but you can specify another element to position against. You can refer
             * to the jQuery UI Position utility for more details about the available properties.<br/>
             */
            position: {
                my: "center",
                at: "center",
                of: window,
                collision: "fit",
                // ensure that the titlebar is never outside the document
                using: function (pos) {
                    var topOffset = $(this).css(pos).offset().top;
                    if (topOffset < 0) {
                        $(this).css("top", pos.top - topOffset);
                    }
                }
            },
            /**
             * @cfg {String} [resizable=false]
             * If set to true, the dialog will be resizable.
             */
            resizable: false, //默认值修改成false

            /**
             * @cfg {*} [show=null] type:Boolean,Number,String,Object
             *
             * If and how to animate the showing of the dialog.
             * Multiple types supported:
             * <b>Boolean</b>: When set to false, no animation will be used and the dialog will be shown immediately. When set to
             * true, the dialog will fade in with the default duration and the default easing.<br/>
             * <b>Number</b>: The dialog will fade in with the specified duration and the default easing.<br/>
             * <b>String</b>: The dialog will be shown using the specified effect. The value can either be the name of a built-in
             * jQuery animation method, such as "slideDown", or the name of a jQuery UI effect, such as "fold". In either case
             * the effect will be used with the default duration and the default easing.<br/>
             * <b>Object</b>: If the value is an object, then effect, delay, duration, and easing properties may be provided. If the
             * effect property contains the name of a jQuery method, then that method will be used; otherwise it is assumed
             * to be the name of a jQuery UI effect. When using a jQuery UI effect that supports additional settings, you may
             * include those settings in the object and they will be passed to the effect. If duration or easing is omitted,
             * then the default values will be used. If effect is omitted, then "fadeIn" will be used. If delay is omitted,
             * then no delay is used.<br/>
             */
            show: null,

            // callbacks
            // 如果想配置成cfg级别可以使用 //@cfg {Function} xxx
            /**
             * @event beforeClose
             *
             * Triggered when a dialog is about to close. If canceled, the dialog will not close.
             * @param {Event} event Event Object
             * @param {Object} ui The ui object is empty but included for consistency with other events.
             *
             *     @example
             *     Initialize the dialog with the beforeClose callback specified:
             *        $(".selector").dialog({
             *          beforeClose: function(event, ui) {}
             *        });
             *     Bind an event listener to the dialogbeforeclose event:
             *        $(".selector").on("dialogbeforeclose", function(event, ui) {});
             */
            beforeClose: null,
            /**
             * @event close
             *
             * Triggered when the dialog is closed.
             * @param {Event} event Event Object
             * @param {Object} ui The ui object is empty but included for consistency with other events.
             *
             *     @example
             *     Initialize the dialog with the resizeStop callback specified:
             *        $(".selector").dialog({
             *          close: function(event, ui) {}
             *        });
             *
             *     Bind an event listener to the dialogresizestop event:
             *        $(".selector").on("dialogclose", function(event, ui) {});
             */
            close: null,
            /**
             * @event drag
             *
             * Triggered while the dialog is being dragged.
             * @param {Event} event Event Object
             * @param {Object} ui The ui object is empty but included for consistency with other events.
             *
             *     @example
             *     Initialize the dialog with the resizeStop callback specified:
             *        $(".selector").dialog({
             *          drag: function(event, ui) {}
             *        });
             *
             *     Bind an event listener to the dialogresizestop event:
             *        $(".selector").on("dialogdrag", function(event, ui) {});
             */
            drag: null,
            /**
             * @event dragStart
             *
             * Triggered when the user starts dragging the dialog.
             * @param {Event} event Event Object
             * @param {Object} ui
             * @param {Object} ui.position The current CSS position of the dialog.
             * @param {Object} ui.offset The current offset position of the dialog.
             *
             *     @example
             *     Initialize the dialog with the resizeStop callback specified:
             *        $(".selector").dialog({
             *          dragStart: function(event, ui) {}
             *        });
             *
             *     Bind an event listener to the dialogresizestop event:
             *        $(".selector").on("dialogdragstart", function(event, ui) {});
             */
            dragStart: null,
            /**
             * @event dragStop
             *
             * Triggered after the dialog has been dragged.
             * @param {Event} event Event Object
             * @param {Object} ui
             * @param {Object} ui.position The current CSS position of the dialog.
             * @param {Object} ui.offset The current offset position of the dialog.
             *
             *     @example
             *     Initialize the dialog with the resizeStop callback specified:
             *        $(".selector").dialog({
             *          dragStop: function(event, ui) {}
             *        });
             *
             *     Bind an event listener to the dialogresizestop event:
             *        $(".selector").on("dialogdragstop", function(event, ui) {});
             */
            dragStop: null,
            /**
             * @event focus
             *
             * Triggered when the dialog gains focus.
             * @param {Event} event Event Object
             * @param {Object} ui The ui object is empty but included for consistency with other events.
             *
             *     @example
             *     Initialize the dialog with the resizeStop callback specified:
             *        $(".selector").dialog({
             *          focus: function(event, ui) {}
             *        });
             *
             *     Bind an event listener to the dialogresizestop event:
             *        $(".selector").on("dialogfocus", function(event, ui) {});
             */
            focus: null,
            /**
             * @event open
             *
             * Triggered when the dialog is opened.
             * @param {Event} event Event Object
             * @param {Object} ui The ui object is empty but included for consistency with other events.
             *
             *     @example
             *     Initialize the dialog with the resizeStop callback specified:
             *        $(".selector").dialog({
             *          open: function(event, ui) {}
             *        });
             *
             *     Bind an event listener to the dialogresizestop event:
             *        $(".selector").on("dialogopen", function(event, ui) {});
             */
            open: null,
            /**
             * @event resize
             *
             * Triggered while the dialog is being resized.
             * @param {Event} event Event Object
             * @param {Object} ui
             * @param {Object} ui.originalPosition The CSS position of the dialog prior to being resized.
             * @param {Object} ui.position The current CSS position of the dialog.
             * @param {Object} ui.originalSize The size of the dialog prior to being resized.
             * @param {Object} ui.size The current size of the dialog.
             *
             *     @example
             *     Initialize the dialog with the resizeStop callback specified:
             *        $(".selector").dialog({
             *          resize: function(event, ui) {}
             *        });
             *
             *     Bind an event listener to the dialogresizestop event:
             *        $(".selector").on("dialogresize", function(event, ui) {});
             */
            resize: null,
            /**
             * @event resizeStart
             *
             * Triggered when the user starts resizing the dialog.
             * @param {Event} event Event Object
             * @param {Object} ui
             * @param {Object} ui.originalPosition The CSS position of the dialog prior to being resized.
             * @param {Object} ui.position The current CSS position of the dialog.
             * @param {Object} ui.originalSize The size of the dialog prior to being resized.
             * @param {Object} ui.size The current size of the dialog.
             *
             *     @example
             *     Initialize the dialog with the resizeStop callback specified:
             *        $(".selector").dialog({
             *          resizeStart: function(event, ui) {}
             *        });
             *
             *     Bind an event listener to the dialogresizestop event:
             *        $(".selector").on("dialogresizestart", function(event, ui) {});
             */
            resizeStart: null,
            /**
             * @event resizeStop
             *
             * Triggered after the dialog has been resized.
             * @param {Event} event Event Object
             * @param {Object} ui
             * @param {Object} ui.originalPosition The CSS position of the dialog prior to being resized.
             * @param {Object} ui.position The current CSS position of the dialog.
             * @param {Object} ui.originalSize The size of the dialog prior to being resized.
             * @param {Object} ui.size The current size of the dialog.
             *
             *     @example
             *     Initialize the dialog with the resizeStop callback specified:
             *        $(".selector").dialog({
             *          resizeStop: function(event, ui) {}
             *        });
             *
             *     Bind an event listener to the dialogresizestop event:
             *        $(".selector").on("dialogresizestop", function(event, ui) {});
             */
            resizeStop: null,
            /**
             * 弹出层自定义样式,alert控件内部使用
             */
            dialogClass: "",
            initValue: null //popedit等控件弹出层时需要传进初始化参数
        },

        _create: function () {
            var options = this.options;

            this.element.addClass("ui-dialog" + options.dialogClass);
            this.element.attr({
                tabIndex: -1,
                role: "dialog"
            });

            this.$header = this.element.find('.modal-header');
            this.$body = this.element.find('.modal-body');
            this.$footer = this.element.find('.modal-footer');
            this.$close = $("<button type='button' class='close' tabindex='-1' role='button'><span aria-hidden='true'>&times;</span></button>");
            this.$header.prepend(this.$close);

            if (options.draggable && $.fn.draggable) {
                this._makeDraggable();
            }
            if (options.resizable && $.fn.resizable) {
                this._makeResizable();
            }

            this._isOpen = false;
            this._delegateEvent();
            this._trackFocus();
        },

        _init: function () {
            if (this.options.autoOpen) {
                this.open();
            }
        },

        _delegateEvent: function () {
            this._on(this.element, {
                keydown: function (event) {
                    if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
                        event.keyCode === $.ui.keyCode.ESCAPE) {
                        event.preventDefault();
                        this.close(event);
                        return;
                    }

                    // prevent tabbing out of dialogs
                    if (event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented()) {
                        return;
                    }
                    var tabbables = this.element.find(":tabbable"),
                        first = tabbables.filter(":first"),
                        last = tabbables.filter(":last");

                    if (( event.target === last[0] || event.target === this.element[0] ) && !event.shiftKey) {
                        this._delay(function () {
                            first.focus();
                        });
                        event.preventDefault();
                    } else if (( event.target === first[0] || event.target === this.element[0] ) && event.shiftKey) {
                        this._delay(function () {
                            last.focus();
                        });
                        event.preventDefault();
                    }
                },
                mousedown: function (event) {
                    if (this._moveToTop(event)) {
                        this._focusTabbable();
                    }
                }
            });

            this._on(this.$close, {
                click: function (event) {
                    event.preventDefault();
                    this.close(event);
                }
            });
        },

        /**
         * Removes the dialog functionality completely. This will return the element back to its pre-init state.
         * This method does not accept any arguments.
         * @method destroy
         */
        _destroy: function () {
            this._destroyOverlay();
            //需要的时候再补充,可以保留原内容
            this.element.remove();
        },

        /**
         * Closes the dialog.
         * This method does not accept any arguments.
         * @method close
         * @chainable
         * @returns {Object} jQuery widget
         */
        close: function (event) {
            var activeElement,
                that = this;

            if (!this._isOpen || this._trigger("beforeClose", event) === false) {
                return;
            }

            this._isOpen = false;
            this._focusedElement = null;
            this._destroyOverlay();
            this._untrackInstance();

            if (!this.opener.filter(":focusable").focus().length) {

                // support: IE9
                // IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
                try {
                    activeElement = this.document[0].activeElement;

                    // Support: IE9, IE10
                    // If the <body> is blurred, IE will switch windows, see #4520
                    if (activeElement && activeElement.nodeName.toLowerCase() !== "body") {

                        // Hiding a focused element doesn't trigger blur in WebKit
                        // so in case we have nothing to focus on, explicitly blur the active element
                        // https://bugs.webkit.org/show_bug.cgi?id=47182
                        $(activeElement).blur();
                    }
                } catch (error) {
                }
            }

            this._hide(this.element, this.options.hide, function () {
                that._trigger("close", event);
            });
        },

        /**
         * Whether the dialog is currently open.     This method does not accept any arguments.
         * @method
         * @returns {Boolean}
         */
        isOpen: function () {
            return this._isOpen;
        },

        moveToTop: function () {
            this._moveToTop();
        },

        _moveToTop: function (event, silent) {
            var moved = false,
                zIndicies = this.element.siblings(".ui-dialog:visible").map(function () {
                    return +$(this).css("z-index");
                }).get(),
                zIndexMax = Math.max.apply(null, zIndicies);

            if (zIndexMax >= +this.element.css("z-index")) {
                this.element.css("z-index", zIndexMax + 1);
                moved = true;
            }

            if (moved && !silent) {
                this._trigger("focus", event);
            }
            return moved;
        },

        /**
         * Opens the dialog.
         * @method
         * @returns {Object} jQuery widget
         */
        open: function () {
            var that = this;
            if (this._isOpen) {
                if (this._moveToTop()) {
                    this._focusTabbable();
                }
                return;
            }

            this.opener = $(this.document[0].activeElement);

            this._size();
            this._position();
            this._createOverlay();
            this._moveToTop(null, true);

            // Ensure the overlay is moved to the top with the dialog, but only when
            // opening. The overlay shouldn't move after the dialog is open so that
            // modeless dialogs opened after the modal dialog stack properly.
            if (this.overlay) {
                this.overlay.css("z-index", this.element.css("z-index") - 1);
            }

            this._show(this.element, this.options.show, function () {
                that._focusTabbable();
                that._trigger("focus");
            });
            this._isOpen = true;
            // Track the dialog immediately upon openening in case a focus event
            // somehow occurs outside of the dialog before an element inside the
            // dialog is focused (#10152)
            this._makeFocusTarget();

            this._trigger("open");
        },

        _focusTabbable: function () {
            // Set focus to the first match:
            // 1. An element that was focused previously
            // 2. First element inside the dialog matching [autofocus]
            // 3. Tabbable element inside the content element
            // 4. Tabbable element inside the buttonpane
            // 5. The close button
            // 6. The dialog itself
            var hasFocus = this._focusedElement;
            if (!hasFocus) {
                hasFocus = this.element.find("[autofocus]");
            }
            if (!hasFocus.length) {
                hasFocus = this.element.find(":tabbable");
            }
            if (!hasFocus.length) {
                hasFocus = this.element;
            }
            hasFocus.eq(0).focus();
        },

        _keepFocus: function (event) {
            function checkFocus() {
                var activeElement = this.document[0].activeElement,
                    isActive = this.element[0] === activeElement ||
                        $.contains(this.element[0], activeElement);
                if (!isActive) {
                    this._focusTabbable();
                }
            }

            event.preventDefault();
            checkFocus.call(this);
            // support: IE
            // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
            // so we check again later
            this._delay(checkFocus);
        },

        _makeDraggable: function () {
            var that = this,
                options = this.options;

            function filteredUi(ui) {
                return {
                    position: ui.position,
                    offset: ui.offset
                };
            }

            this.element.draggable({
                cancel: ".modal-body, .close",
                handle: ".modal-header",
                containment: "document",
                start: function (event, ui) {
                    $(this).addClass("ui-dialog-dragging");
                    that._trigger("dragStart", event, filteredUi(ui));
                },
                drag: function (event, ui) {
                    that._trigger("drag", event, filteredUi(ui));
                },
                stop: function (event, ui) {
                    var left = ui.offset.left - that.document.scrollLeft(),
                        top = ui.offset.top - that.document.scrollTop();

                    options.position = {
                        my: "left top",
                        at: "left" + (left >= 0 ? "+" : "") + left + " " +
                        "top" + (top >= 0 ? "+" : "") + top,
                        of: that.window
                    };
                    $(this).removeClass("ui-dialog-dragging");
                    that._trigger("dragStop", event, filteredUi(ui));
                }
            });
        },

        _makeResizable: function () {
            var that = this,
                options = this.options,
                handles = options.resizable,
            // .ui-resizable has position: relative defined in the stylesheet
            // but dialogs have to use absolute or fixed positioning
                position = this.element.css("position"),
                resizeHandles = typeof handles === "string" ?
                    handles :
                    "n,e,s,w,se,sw,ne,nw";

            function filteredUi(ui) {
                return {
                    originalPosition: ui.originalPosition,
                    originalSize: ui.originalSize,
                    position: ui.position,
                    size: ui.size
                };
            }

            this.element.resizable({
                cancel: ".modal-body",
                containment: "document",
                alsoResize: this.element.find(".modal-body"),
                maxWidth: options.maxWidth,
                maxHeight: options.maxHeight,
                minWidth: options.minWidth,
                minHeight: this._minHeight(),
                handles: resizeHandles,
                start: function (event, ui) {
                    $(this).addClass("ui-dialog-resizing");
                    that._trigger("resizeStart", event, filteredUi(ui));
                },
                resize: function (event, ui) {
                    that._trigger("resize", event, filteredUi(ui));
                },
                stop: function (event, ui) {
                    var offset = that.element.offset(),
                        left = offset.left - that.document.scrollLeft(),
                        top = offset.top - that.document.scrollTop();

                    options.height = that.element.height();
                    options.width = that.element.width();
                    options.position = {
                        my: "left top",
                        at: "left" + (left >= 0 ? "+" : "") + left + " " +
                        "top" + (top >= 0 ? "+" : "") + top,
                        of: that.window
                    };
                    $(this).removeClass("ui-dialog-resizing");
                    that._trigger("resizeStop", event, filteredUi(ui));
                }
            }).css("position", position);
        },

        _trackFocus: function () {
            this._on(this.widget(), {
                focusin: function (event) {
                    this._makeFocusTarget();
                    this._focusedElement = $(event.target);
                }
            });
        },
        _makeFocusTarget: function () {
            this._untrackInstance();
            this._trackingInstances().unshift(this);
        },

        _untrackInstance: function () {
            var instances = this._trackingInstances(),
                exists = $.inArray(this, instances);
            if (exists !== -1) {
                instances.splice(exists, 1);
            }
        },

        _trackingInstances: function () {
            var instances = this.document.data("ui-dialog-instances");
            if (!instances) {
                instances = [];
                this.document.data("ui-dialog-instances", instances);
            }
            return instances;
        },

        _minHeight: function () {
            var options = this.options;

            return options.height === "auto" ?
                options.minHeight :
                Math.min(options.minHeight, options.height);
        },

        _position: function (position) {
            // Need to show the dialog to get the actual offset in the position plugin
            var isVisible = this.element.is(":visible");
            if (!isVisible) {
                this.element.show();
            }
            this.element.position(this.options.position);
            if (!isVisible) {
                this.element.hide();
            }
        },

        _setOptions: function (options) {
            var that = this,
                resizableOptions = {},
                resize = false;

            $.each(options, function (key, value) {
                that._setOption(key, value);

                if (key in sizeRelatedOptions) {
                    resize = true;
                }
                if (key in resizableRelatedOptions) {
                    resizableOptions[key] = value;
                }
            });

            if (resize) {
                this._size();
                this._position();
            }
            if (this.element.is(":data(resizable)")) {
                this.element.resizable("option", resizableOptions);
            }
        },

        _setOption: function (key, value) {
            var isDraggable, isResizable,
                uiDialog = this.element;

            switch (key) {
                case "disabled":
                    return;
                case "draggable":
                    isDraggable = uiDialog.is(":data(draggable)");
                    if (isDraggable && !value) {
                        uiDialog.draggable("destroy");
                    }

                    if (!isDraggable && value) {
                        this._makeDraggable();
                    }
                    break;
                case "position":
                    this._position(value);
                    break;
                case "resizable":
                    // currently resizable, becoming non-resizable
                    isResizable = uiDialog.is(":data(resizable)");
                    if (isResizable && !value) {
                        uiDialog.resizable("destroy");
                    }

                    // currently resizable, changing handles
                    if (isResizable && typeof value === "string") {
                        uiDialog.resizable("option", "handles", value);
                    }

                    // currently non-resizable, becoming resizable
                    if (!isResizable && value !== false) {
                        this._makeResizable(value);
                    }
                    break;
            }

            this._super(key, value);
        },

        _size: function () {
            /* If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
             * divs will both have width and height set, so we need to reset them
             */
            var autoHeight,
                options = this.options,
                isVisible = this.element.is(":visible");

            this.element.show();
            options.width =  Math.max(options.width, options.minWidth) ;
            this.element.width(options.width);
            this.$body.outerWidth(options.width);
            if (options.height === "auto") {
                autoHeight = this.$body.css("height", "auto").height();
                this.$body.height(Math.max(autoHeight, options.minHeight));
            } else {
                var height = Math.max(options.height, options.minHeight);
                this.element.height(height);
                this.$body.outerHeight(height - this.$header.outerHeight() - this.$footer.outerHeight());
            }

            if (!isVisible) {
                this.element.hide();
            }

            if (this.element.is(":data(resizable)")) {
                this.element.resizable("option", "minHeight", this._minHeight());
            }
        },

        _allowInteraction: function (event) {
            if ($(event.target).closest(".ui-dialog").length) {
                return true;
            }
        },

        _createOverlay: function () {
            if (!this.options.modal) {
                return;
            }

            // We use a delay in case the overlay is created from an
            // event that we're going to be cancelling (#2804)
            var isOpening = true;
            this._delay(function () {
                isOpening = false;
            });

            if (!this.document.data("ui-dialog-overlays")) {

                // Prevent use of anchors and inputs
                // Using _on() for an event handler shared across many instances is
                // safe because the dialogs stack and must be closed in reverse order
                this._on(this.document, {
                    focusin: function (event) {
                        if (isOpening) {
                            return;
                        }

                        if (!this._allowInteraction(event)) {
                            event.preventDefault();
                            this._trackingInstances()[0]._focusTabbable();
                        }
                    }
                });
            }

            this.overlay = $("<div>")
                .addClass("ui-widget-overlay")
                .appendTo(document.body);
            this._on(this.overlay, {
                mousedown: "_keepFocus"
            });

            if (this.options.closeOnClickOverlay) {
                this._on(this.overlay, {
                    mousedown: "close"
                });
            }

            this.document.data("ui-dialog-overlays",
                (this.document.data("ui-dialog-overlays") || 0) + 1);
        },

        _destroyOverlay: function () {
            if (!this.options.modal) {
                return;
            }

            if (this.overlay) {
                var overlays = this.document.data("ui-dialog-overlays") - 1;

                if (!overlays) {
                    this.document
                        .unbind("focusin")
                        .removeData("ui-dialog-overlays");
                } else {
                    this.document.data("ui-dialog-overlays", overlays);
                }

                this.overlay.remove();
                this.overlay = null;
            }
        },

        //提供returnValue,initValue方法支持popedit
        setReturnValue: function (value) {
            this.element.trigger('change', value);
        },

        setTitle: function(title) {
            this.$header.find('.modal-title').text(title);
        }
    });
});

/*
 * @preserve
 * Project: Bootstrap Hover Dropdown
 * Author: Cameron Spear
 * Version: v2.0.11
 * Contributors: Mattia Larentis
 * Dependencies: Bootstrap's Dropdown plugin, jQuery
 * Description: A simple plugin to enable Bootstrap dropdowns to active on hover and provide a nice user experience.
 * License: MIT
 * Homepage: http://cameronspear.com/blog/bootstrap-dropdown-on-hover-plugin/
 */

! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.dropdown', factory);
    } else {
        factory();
    }
}(function() {

    'use strict';
    /**
     * Dropdown Widget
     * @class fish.desktop.widget.Dropdown
     * <pre>
     *   $(element).dropdown(option);
     * </pre>
     */
    /**
     * 显示出下拉菜单触发的事件
     * @event show
     */
    /**
     * 显示出下拉菜单之前触发的事件,返回false则不会显示
     * @event beforeShow
     */
    /**
     * 隐下拉菜单触发的事件
     * @event hide
     */
    /**
     * 隐藏下拉菜单之前触发的事件,返回false则不会隐藏
     * @event beforeHide
     */

    $.widget("ui.dropdown", {
        options: {
            /**
             * 鼠标移开当前下拉菜单时,隐藏下拉菜单的延时时间
             * @cfg {Number} delay=500
             */
            delay: 200,
            /**
             * 点击其他下拉菜单是否立即关闭其他正在显示的下拉菜单
             * @cfg {Boolean} closeOthers=true
             */
            closeOthers: true
        },
        _create: function() {
            var that = this,
                $this = $(this.element),
                $parent = $this.parent();

            //绑定父节点的hover离开事件,离开父节点消失;弹出层在父节点内部,保证鼠标在弹出层内不消失
            $parent.hover($.noop, function() {
                that.timeout_ = window.setTimeout(function() {
                    if (!that._trigger("beforeHide")) return;
                    $parent.removeClass('open');
                    that._trigger("hide");
                }, that.options.delay);
            });
            //绑定hover事件,移到目标弹出内容
            $this.hover(function(event) {
                if (!$parent.hasClass('open') && !$this.is(event.target)) {
                    return true;
                }
                that._openDropdown(event);
            });

            // handle submenus
            $parent.find('.dropdown-submenu').each(function() {
                var $this = $(this);
                var subTimeout;
                $this.hover(function() {
                    window.clearTimeout(subTimeout);
                    $this.children('.dropdown-menu').show();
                    // always close submenu siblings instantly
                    $this.siblings().children('.dropdown-menu').hide();
                }, function() {
                    var $submenu = $this.children('.dropdown-menu');
                    subTimeout = window.setTimeout(function() {
                        $submenu.hide();
                    }, that.options.delay);
                });
            });
        },
        _openDropdown: function(event) {
            if (!this._trigger("beforeShow")) return;
            var $allDropdowns = $(":ui-dropdown").parent();
            $allDropdowns.find(':focus').blur();
            if (this.options.closeOthers === true)
                $allDropdowns.removeClass('open');
            window.clearTimeout(this.timeout_);
            $(this.element).parent().addClass('open');
            this._trigger("show");
        }
    });

});

/**
 * 表单<br>
 * @class fish.desktop.widget.Form
 *
 * Use ajaxForm when you want the plugin to manage all the event binding for you.  For example,
 *
 *  $(document).ready(function() {
 *    $('#myForm').form();
 *  });
 * When using ajaxForm, the ajaxSubmit function will be invoked for you at the appropriate time.
 *
 *
 */
! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.form', factory);
    } else {
        factory();
    }
}(function() {
    "use strict";

    //Feature detection
    var feature = {};
    feature.fileapi = $("<input type='file'/>").get(0).files !== undefined;
    feature.formdata = window.FormData !== undefined;


    $.widget("ui.form", {
        options: {
            /**
             * form提交是否自动加上遮罩
             * @cfg {Boolean} showMask=false
             */
            showMask: true,
            /**
             * form是否自动检验及何时检验，需要校验控件支持; 0:不校验;1:初始化form的时候检验;2:提交的时候再检验
             * @cfg {Number} validate=2
             */
            validate: 2, //0:never;1:init;2:submit
            /*
             * @cfg {String} delegation true to enable support for event delegation requires
             */
            //delegation
            /**
             * @cfg {String} type form method
             */
            type: "post", //$.ajaxSettings.type
            //type
            /**
             * @cfg {String} url form action
             */
            url: '', //将要提交form数据URL，默认值：form动作属性
            dataType: 'json', //默认返回json格式
            traditional: true, //$.ajaxSettings.traditional,
            target: '', //更新到服务器响应的元素标识符，这个值可以指定为一个JQUERY选择器字符串，一个JQUERY对象，或一个DOM元素。

            clearForm: false, //(可选参数) true，提交成功后清除表单所有字段
            resetForm: false, //(可选参数) 提交成功后重置表单.
            beforeSubmit: $.noop, //(可选参数) 提交前的callback
            success: $.noop//, //(可选参数) 提交成功后的callback $.ajaxSettings.success
            //semantic: false //(可选参数) 是否严格语义提交
                // timeout : 0//(可选参数) 超时
        },
        _create: function() {
            // this._unbindEvent();
            this.options.initData = this.options.data; //保存初始值,post或get时会覆盖data属性
            this._on({
                'submit': '_doAjaxSubmit',
                'click': '_captureSubmittingElement'
            });
            if (!$.fn.validator) this.options.validate = 0; //validator需控件支持
            if (this.options.validate === 1) this.element.validator();
        },
        _getCreateOptions: function() {
            var options = {};
            var type = this.element.attr('method');
            type ? options.type = type : "";
            var url = this.element.attr('action');
            url ? options.url = url : "";
            return options;
        },

        /**
         * 取消已绑定事件
         * @method
         */
        _unbindEvent: function() {
            this.element.unbind('submit.fish-form click.fish-form');
        },
        _doAjaxSubmit: function(e) {
            console.log('do ajaxSubmit');
            if (!e.isDefaultPrevented()) { // if event has been canceled, don't proceed
                e.preventDefault();
                if(!this.submitting){
                    //响应没回来的时候,不再往后台提交数据
                    this.submitting= true;
                    this.ajaxSubmit(e); // #365
                }
            }
        },
        ajaxSubmit: function(e) {
            var options = this.options,that = this;
            // fast fail if nothing selected (http://dev.jquery.com/ticket/2752)

            var method, action, url, $form = this.element;

            if (typeof options == 'function') {
                options = {
                    success: options
                };
            } else if (options === undefined) {
                options = {};
            }

            method = options.type;
            action = options.url;

            url = (typeof action === 'string') ? $.trim(action) : '';
            url = url || window.location.href || '';
            if (url) {
                // clean url (don't include hash vaue)
                url = (url.match(/^([^#]+)/) || [])[1];
            }

            // provide opportunity to alter form data before it is serialized
            if (this._trigger("beforeSerialize") === false) {
                console.log('ajaxSubmit: submit aborted via beforeSerialize callback');
                return;
            }

            var traditional = options.traditional || $.ajaxSettings.traditional;

            var elements = [];
            var qx, a = this.formToArray(elements);
            for (var i = 0; i < a.length; i++) {
                this._addWidgetValue(a[i]);
            }
            if (options.initData) {
                options.extraData = options.data; //干嘛的?与initData作用一样?
                qx = $.param(options.initData, traditional);
            }

            // give pre-submit callback an opportunity to abort the submit
            if (this._trigger("beforeSubmit", e, [a]) === false) {
                console.log('ajaxSubmit: submit aborted via beforeSubmit callback');
                return;
            }
            if (this.options.validate === 2) this.element.validator();
            if (this.options.validate && !this.element.isValid()) return;

            //先起遮罩,由于单线程特性,在ajax与后台交互的时候才会显示出来
            if (options.showMask && fish._active++ === 0) {
                $.blockUI && $.blockUI();
            }

            var q = $.param(a, traditional);
            if (qx) {
                q = (q ? (q + '&' + qx) : qx);
            }
            if (options.type.toUpperCase() == 'GET') {
                options.url += (options.url.indexOf('?') >= 0 ? '&' : '?') + q;
                options.data = null; // data is null for 'get'
            } else {
                options.data = q; // data is the query string for 'post'
            }

            var callbacks = [];
            if (options.resetForm) {
                callbacks.push(function() {
                    $form.resetForm();
                });
            }
            if (options.clearForm) {
                callbacks.push(function() {
                    $form.clearForm(options.includeHidden);
                });
            }

            if (options.success) {
                callbacks.push(options.success);
            }

            var ajaxOption = $.extend(true, {}, options);

            ajaxOption.success = function(data, status, xhr) { // jQuery 1.4+ passes xhr as 3rd arg
                var context = options.context || this; // jQuery 1.4+ supports scope context
                for (var i = 0, max = callbacks.length; i < max; i++) {
                    callbacks[i].apply(context, [data, status, xhr || $form, $form]);
                }
            };

            // if (options.error) {
                var oldError = options.error;
                ajaxOption.error = function(xhr, status, error) {
                    var context = options.context || this;
                    oldError && oldError.apply(context, [xhr, status, error, $form]);
                };
            // }

            // if (options.complete) {
            var oldComplete = options.complete;
            ajaxOption.complete = function(xhr, status) {
                var context = options.context || this;
                oldComplete && oldComplete.apply(context, [xhr, status, $form]);
                if (options.showMask && (--fish._active === 0)) {
                    $.unblockUI && $.unblockUI();
                }
                that.submitting=false;

            };
            // }

            var jqxhr = $.ajax(ajaxOption);

            $form.removeData('jqxhr').data('jqxhr', jqxhr);

            // clear element array
            for (var k = 0; k < elements.length; k++) {
                elements[k] = null;
            }
        },
        /*
         * 返回form的参数值,数组形式，
         * @param  {[type]} elements [description]
         * @return {[type]}          [description]
         */
        formToArray: function(elements) {
            var a = [];
            if (this.length === 0) {
                return a;
            }

            var form = this.element[0];
            var els = form.elements;

            if (!els || !els.length) {
                return a;
            }

            var i, j, n, v, el, max, jmax;
            for (i = 0, max = els.length; i < max; i++) {
                el = els[i];
                n = el.name;
                //      if (!n || el.disabled) {
                //        continue;
                //      }
                if (!n) {
                    continue;
                }

                v = $.fieldValue(el, true);
                if (v && v.constructor == Array) {
                    if (elements) {
                        elements.push(el);
                    }
                    for (j = 0, jmax = v.length; j < jmax; j++) {
                        a.push({
                            name: n,
                            value: v[j]
                        });
                    }
                } else if (feature.fileapi && el.type == 'file') {
                    if (elements) {
                        elements.push(el);
                    }
                    var files = el.files;
                    if (files.length) {
                        for (j = 0; j < files.length; j++) {
                            a.push({
                                name: n,
                                value: files[j],
                                type: el.type
                            });
                        }
                    } else {
                        // #180
                        a.push({
                            name: n,
                            value: '',
                            type: el.type
                        });
                    }
                } else if (v !== null && typeof v != 'undefined') {
                    if (elements) {
                        elements.push(el);
                    }
                    a.push({
                        name: n,
                        value: v,
                        type: el.type,
                        required: el.required
                    });
                }
            }

            if (form.clk) {
                // input type=='image' are not found in elements array! handle it here
                var $input = $(form.clk),
                    input = $input[0];
                n = input.name;
                if (n  && input.type == 'image') { //&& !input.disabled
                    a.push({
                        name: n,
                        value: $input.val()
                    });
                    a.push({
                        name: n + '.x',
                        value: form.clk_x
                    }, {
                        name: n + '.y',
                        value: form.clk_y
                    });
                }
            }
            return a;
        },
        _captureSubmittingElement: function(e) { //干嘛的? TODO
            /*jshint validthis:true */
            var target = e.target;
            var $el = $(target);
            if (!($el.is("[type=submit],[type=image]"))) {
                // is this a child element of the submit el?  (ex: a span within a button)
                var t = $el.closest('[type=submit]');
                if (t.length === 0) {
                    return;
                }
                target = t[0];
            }
            var form = this.element[0];
            form.clk = target;
            if (target.type == 'image') {
                if (e.offsetX !== undefined) {
                    form.clk_x = e.offsetX;
                    form.clk_y = e.offsetY;
                } else if (typeof $.fn.offset == 'function') {
                    var offset = $el.offset();
                    form.clk_x = e.pageX - offset.left;
                    form.clk_y = e.pageY - offset.top;
                } else {
                    form.clk_x = e.pageX - target.offsetLeft;
                    form.clk_y = e.pageY - target.offsetTop;
                }
            }
            // clear form vars
            setTimeout(function() {
                form.clk = form.clk_x = form.clk_y = null;
            }, 100);
        },
        /*
         * @deprecated 基本用不到
         * 获取form参数序列化后的值,参数间通过&分开,如userName=tanyl&userCode=13770793735&password=123456
         * @return {String} 参数序列化之后的值
         */
        serialize: function() {
            return $.param(this.formToArray());
        },
        /**
         * 如果存在参数对象,进行form的设值操作;否则返回form的参数值,对象形式，如Object {userName: "tanyl", userCode: "13770793735", password: "123456"…}
         * @return {Object} 参数对象
         */
        value: function(newVal) {
            if (newVal) {
                this._setValue(newVal);
            } else {
                return this._getValue();
            }
        },
        _addWidgetValue:function(obj){
            var key = obj.name,$element = this.element,widget;
            //有控件需要覆盖objArr[i].value值--
            var $el = $element.find('[name=' + key + ']');
            if(!$el[0]) return;
            widget = $.data($el[0], "uuid");//目前没有处理控件组(如icheck控件)的概念
            if (widget) {
                var value = $element.triggerHandler("getvalue"+widget.uuid+".form");//需要有返回值
                if(value) {
                    obj.value = value;
                }
            }
        },
        _getValue: function() {
            var objArr = this.formToArray(),
                re = {},widget,$element = this.element,
                key;
            for (var i = 0; i < objArr.length; i++) {
                key = objArr[i].name;
                this._addWidgetValue(objArr[i]);
                if (re[key] === undefined) {
                    re[key] = objArr[i].value;
                } else if (!$.isArray(re[key])) { //已经存在了
                    var temp = [re[key]];
                    temp.push(objArr[i].value)
                    re[key] = temp;
                } else {
                    re[key].push(objArr[i].value)
                }
            }
            return re;
        },
        _setValue: function(newVal) {
            if ($.type(newVal) !== 'object') return;

            var $element = this.element,widget;
            for (var key in newVal) {
                var $el = $element.find('[name=' + key + ']');
                if(!$el[0]) continue;
                //普通元素
                try {
                    $element.find('[name=' + key + ']').val(newVal[key]);
                } catch (e) {
                    $.error('copy value to form field error,please check');
                }
                //控件增加,覆盖方式;先处理普通元素,spinner控件可以不需要监听setValue事件
                for(var i=0;i<$el.length;i++){//checkbox存在多个
                    widget = $.data($el[i], "uuid");
                    if (widget) {
                        $element.triggerHandler("setvalue"+widget.uuid+".form",[newVal[key]]);
                        // widget._formFieldHandler(newVal[key]); //改成事件派发方式,不必在widget工厂增加接口方法
                    }
                }
            }
        },
        /**
         * 清空表单值
         * @method
         */
        clear: function(includeHidden) {
            this.element.each(function() {
                $('input,select,textarea', this).clearFields(true);
            });
            this.element.triggerHandler('clear.form');
        },
        /**
         * 禁用表单
         * @method
         */
        disable: function () {
            var objArr = this.formToArray(),
                $element = this.element,
                key,$el;
            for (var i = 0; i < objArr.length; i++) {
                key = objArr[i].name;
                $el = $element.find('[name=' + key + ']');
                $el.attr('disabled', true);
            }
            $element.triggerHandler("disable.form");
        },
        /**
         * 启用表单
         * @method
         */
        enable: function () {
            var objArr = this.formToArray(),
                $element = this.element,
                key,$el;
            for (var i = 0; i < objArr.length; i++) {
                key = objArr[i].name;
                $el = $element.find('[name=' + key + ']');
                $el.attr('disabled', false);
            }
            $element.triggerHandler("enable.form");
        }
    })

    /*
     * Returns the value of the field element.
     */
    $.fieldValue = function(el, successful) {
        var n = el.name,
            t = el.type,
            tag = el.tagName.toLowerCase();
        if (successful === undefined) {
            successful = true;
        }
        // || el.disabled 也取出来
        if (successful && (!n || t == 'reset' || t == 'button' ||
                (t == 'checkbox' || t == 'radio') && !el.checked ||
                (t == 'submit' || t == 'image') && el.form && el.form.clk != el ||
                tag == 'select' && el.selectedIndex == -1)) {
            return null;
        }

        if (tag == 'select') {
            var index = el.selectedIndex;
            if (index < 0) {
                return null;
            }
            var a = [];
            var ops = el.options;
            var one = (t == 'select-one');
            var max = (one ? index + 1 : ops.length);
            for (var i = (one ? index : 0); i < max; i++) {
                var op = ops[i];
                if (op.selected) {
                    var v = op.value;
                    if (!v) { // extra pain for IE...
                        v = (op.attributes && op.attributes.value && !(op.attributes.value.specified)) ? op.text : op.value;
                    }
                    if (one) {
                        return v;
                    }
                    a.push(v);
                }
            }
            return a;
        }
        return $(el).val();
    };
    // Clears the selected form elements.
    $.fn.clearFields = function () {
      var re = /^(?:color|date|datetime|email|month|number|password|range|search|tel|text|time|url|week|hidden)$/i;
      return this.each(function () {
        var t = this.type,
            tag = this.tagName.toLowerCase();

        if (!!!this.name) {
          return true;
        }
        if (re.test(t) || tag == 'textarea') {
          this.value = '';
        } else if (t == 'checkbox' || t == 'radio') {
          this.checked = false;
        } else if (tag == 'select') {
          this.selectedIndex = -1;
        } else if (t == "file") {
          if (/MSIE/.test(navigator.userAgent)) {
            $(this).replaceWith($(this).clone(true));
          } else {
            $(this).val('');
          }
        }
      });
    };
});

/*
 * Created by tanyl on 2014/12/16.
 */
!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.grid.util', factory);
    } else {
        factory();
    }
}(function() {

    'use strict';

    $.jgrid = $.jgrid || {};
    $.extend($.jgrid, {
        htmlDecode: function (value) {
            if (value && (value === '&nbsp;' || value === '&#160;' || (value.length === 1 && value.charCodeAt(0) === 160))) {
                return "";
            }
            return !value ? value : String(value).replace(/&gt;/g, ">").replace(/&lt;/g, "<").replace(/&quot;/g, '"').replace(/&amp;/g, "&");
        },
        htmlEncode: function (value) {
            return !value ? value : String(value).replace(/&/g, "&amp;").replace(/\"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        },
        format: function (format) { //jqgformat
            var args = $.makeArray(arguments).slice(1);
            if (format == null) {
                format = "";
            }
            return format.replace(/\{(\d+)\}/g, function (m, i) {
                return args[i];
            });
        },
        getCellIndex: function (cell) {
            var c = $(cell);
            if (c.is('tr')) {
                return -1;
            }
            c = (!c.is('td') && !c.is('th') ? c.closest("td,th") : c)[0];
            // ie support cellIndex
            return c.cellIndex;
        },
        stripHtml: function (v) {
            v = String(v);
            var regexp = /<("[^"]*"|'[^']*'|[^'">])*>/gi;
            if (v) {
                v = v.replace(regexp, "");
                return (v && v !== '&nbsp;' && v !== '&#160;') ? v.replace(/\"/g, "'") : "";
            }
            return v;
        },
        stripPref: function (pref, id) {
            var obj = $.type(pref);
            if (obj === "string" || obj === "number") {
                pref = String(pref);
                id = pref !== "" ? String(id).replace(String(pref), "") : id;
            }
            return id;
        },
        parse: function (jsonString) {
            var js = jsonString;
            if (js.substr(0, 9) === "while(1);") {
                js = js.substr(9);
            }
            if (js.substr(0, 2) === "/*") {
                js = js.substr(2, js.length - 4);
            }
            if (!js) {
                js = "{}";
            }
            return ($.jgrid.useJSON === true && typeof JSON === 'object' && typeof JSON.parse === 'function') ?
                JSON.parse(js) :
                eval('(' + js + ')');
        },
        parseDate: function (format, date, newformat, opts) {
            var token = /\\.|[dDjlNSwzWFmMntLoYyaABgGhHisueIOPTZcrU]/g,
                timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
                timezoneClip = /[^-+\dA-Z]/g,
                msDateRegExp = new RegExp("^\/Date\\((([-+])?[0-9]+)(([-+])([0-9]{2})([0-9]{2}))?\\)\/$"),
                msMatch = ((typeof date === 'string') ? date.match(msDateRegExp) : null),
                pad = function (value, length) {
                    value = String(value);
                    length = parseInt(length, 10) || 2;
                    while (value.length < length) {
                        value = '0' + value;
                    }
                    return value;
                },
                ts = {
                    m: 1,
                    d: 1,
                    y: 1970,
                    h: 0,
                    i: 0,
                    s: 0,
                    u: 0
                },
                timestamp = 0,
                dM, k, hl,
                h12to24 = function (ampm, h) {
                    if (ampm === 0) {
                        if (h === 12) {
                            h = 0;
                        }
                    } else {
                        if (h !== 12) {
                            h += 12;
                        }
                    }
                    return h;
                };
            if (opts === undefined) {
                opts = $.jgrid.formatter.date;
            }
            // old lang files
            if (opts.parseRe === undefined) {
                opts.parseRe = /[Tt\\\/:_;.,\t\s-]/;
            }
            if (opts.masks.hasOwnProperty(format)) {
                format = opts.masks[format];
            }
            if (date && date != null) {
                if (!isNaN(date - 0) && String(format).toLowerCase() === "u") {
                    //Unix timestamp
                    timestamp = new Date(parseFloat(date) * 1000);
                } else if (date.constructor === Date) {
                    timestamp = date;
                    // Microsoft date format support
                } else if (msMatch !== null) {
                    timestamp = new Date(parseInt(msMatch[1], 10));
                    if (msMatch[3]) {
                        var offset = Number(msMatch[5]) * 60 + Number(msMatch[6]);
                        offset *= ((msMatch[4] === '-') ? 1 : -1);
                        offset -= timestamp.getTimezoneOffset();
                        timestamp.setTime(Number(Number(timestamp) + (offset * 60 * 1000)));
                    }
                } else {
                    date = String(date).replace(/\\T/g, "T").replace(/\\t/, "t").split(opts.parseRe);
                    format = format.replace(/\\T/g, "T").replace(/\\t/, "t").split(opts.parseRe);
                    // parsing for month names
                    for (k = 0, hl = format.length; k < hl; k++) {
                        if (format[k] === 'M') {
                            dM = $.inArray(date[k], opts.monthNames);
                            if (dM !== -1 && dM < 12) {
                                date[k] = dM + 1;
                                ts.m = date[k];
                            }
                        }
                        if (format[k] === 'F') {
                            dM = $.inArray(date[k], opts.monthNames, 12);
                            if (dM !== -1 && dM > 11) {
                                date[k] = dM + 1 - 12;
                                ts.m = date[k];
                            }
                        }
                        if (format[k] === 'a') {
                            dM = $.inArray(date[k], opts.AmPm);
                            if (dM !== -1 && dM < 2 && date[k] === opts.AmPm[dM]) {
                                date[k] = dM;
                                ts.h = h12to24(date[k], ts.h);
                            }
                        }
                        if (format[k] === 'A') {
                            dM = $.inArray(date[k], opts.AmPm);
                            if (dM !== -1 && dM > 1 && date[k] === opts.AmPm[dM]) {
                                date[k] = dM - 2;
                                ts.h = h12to24(date[k], ts.h);
                            }
                        }
                        if (format[k] === 'g') {
                            ts.h = parseInt(date[k], 10);
                        }
                        if (date[k] !== undefined) {
                            ts[format[k].toLowerCase()] = parseInt(date[k], 10);
                        }
                    }
                    if (ts.f) {
                        ts.m = ts.f;
                    }
                    if (ts.m === 0 && ts.y === 0 && ts.d === 0) {
                        return "&#160;";
                    }
                    ts.m = parseInt(ts.m, 10) - 1;
                    var ty = ts.y;
                    if (ty >= 70 && ty <= 99) {
                        ts.y = 1900 + ts.y;
                    } else if (ty >= 0 && ty <= 69) {
                        ts.y = 2000 + ts.y;
                    }
                    timestamp = new Date(ts.y, ts.m, ts.d, ts.h, ts.i, ts.s, ts.u);
                }
            } else {
                timestamp = new Date(ts.y, ts.m, ts.d, ts.h, ts.i, ts.s, ts.u);
            }
            if (newformat === undefined) {
                return timestamp;
            }
            if (opts.masks.hasOwnProperty(newformat)) {
                newformat = opts.masks[newformat];
            } else if (!newformat) {
                newformat = 'Y-m-d';
            }
            var
                G = timestamp.getHours(),
                i = timestamp.getMinutes(),
                j = timestamp.getDate(),
                n = timestamp.getMonth() + 1,
                o = timestamp.getTimezoneOffset(),
                s = timestamp.getSeconds(),
                u = timestamp.getMilliseconds(),
                w = timestamp.getDay(),
                Y = timestamp.getFullYear(),
                N = (w + 6) % 7 + 1,
                z = (new Date(Y, n - 1, j) - new Date(Y, 0, 1)) / 86400000,
                flags = {
                    // Day
                    d: pad(j),
                    D: opts.dayNames[w],
                    j: j,
                    l: opts.dayNames[w + 7],
                    N: N,
                    S: opts.S(j),
                    //j < 11 || j > 13 ? ['st', 'nd', 'rd', 'th'][Math.min((j - 1) % 10, 3)] : 'th',
                    w: w,
                    z: z,
                    // Week
                    W: N < 5 ? Math.floor((z + N - 1) / 7) + 1 : Math.floor((z + N - 1) / 7) || ((new Date(Y - 1, 0, 1).getDay() + 6) % 7 < 4 ? 53 : 52),
                    // Month
                    F: opts.monthNames[n - 1 + 12],
                    m: pad(n),
                    M: opts.monthNames[n - 1],
                    n: n,
                    t: '?',
                    // Year
                    L: '?',
                    o: '?',
                    Y: Y,
                    y: String(Y).substring(2),
                    // Time
                    a: G < 12 ? opts.AmPm[0] : opts.AmPm[1],
                    A: G < 12 ? opts.AmPm[2] : opts.AmPm[3],
                    B: '?',
                    g: G % 12 || 12,
                    G: G,
                    h: pad(G % 12 || 12),
                    H: pad(G),
                    i: pad(i),
                    s: pad(s),
                    u: u,
                    // Timezone
                    e: '?',
                    I: '?',
                    O: (o > 0 ? "-" : "+") + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                    P: '?',
                    T: (String(timestamp).match(timezone) || [""]).pop().replace(timezoneClip, ""),
                    Z: '?',
                    // Full Date/Time
                    c: '?',
                    r: '?',
                    U: Math.floor(timestamp / 1000)
                };
            return newformat.replace(token, function ($0) {
                return flags.hasOwnProperty($0) ? flags[$0] : $0.substring(1);
            });
        },
        jqID: function (sid) {
            return String(sid).replace(/[!"#$%&'()*+,.\/:; <=>?@\[\\\]\^`{|}~]/g, "\\$&");
        },
        guid: 1,
        uidPref: 'jqg',
        randId: function (prefix) {
            return (prefix || $.jgrid.uidPref) + ($.jgrid.guid++);
        },
        getAccessor: function (obj, expr) {
            var ret, p, prm = [],
                i;
            if (typeof expr === 'function') {
                return expr(obj);
            }
            ret = obj[expr];
            if (ret === undefined) {
                try {
                    if (typeof expr === 'string') {
                        prm = expr.split('.');
                    }
                    i = prm.length;
                    if (i) {
                        ret = obj;
                        while (ret && i--) {
                            p = prm.shift();
                            ret = ret[p];
                        }
                    }
                } catch (e) {
                }
            }
            return ret;
        },
        cellWidth: function () {
            var $testDiv = $("<div class='ui-jqgrid' style='left:10000px'><table class='ui-jqgrid-btable' style='width:5px;'><tr class='jqgrow'><td style='width:5px;display:block;'></td></tr></table></div>"),
                testCell = $testDiv.appendTo("body")
                    .find("td")
                    .width();
            $testDiv.remove();
            return Math.abs(testCell - 5) > 0.1;
        },
        cell_width: true,
        ajaxOptions: {},
        from: function (source) {
            // Original Author Hugo Bonacci
            // License MIT http://jlinq.codeplex.com/license
            var QueryObject = function (d, q) {
                if (typeof d === "string") {
                    d = $.data(d);
                }
                var self = this,
                    _data = d,
                    _usecase = true,
                    _trim = false,
                    _query = q,
                    _stripNum = /[\$,%]/g,
                    _lastCommand = null,
                    _lastField = null,
                    _orDepth = 0,
                    _negate = false,
                    _queuedOperator = "",
                    _sorting = [],
                    _useProperties = true;
                if (typeof d === "object" && d.push) {
                    if (d.length > 0) {
                        if (typeof d[0] !== "object") {
                            _useProperties = false;
                        } else {
                            _useProperties = true;
                        }
                    }
                } else {
                    throw "data provides is not an array";
                }
                this._hasData = function () {
                    return _data === null ? false : _data.length === 0 ? false : true;
                };
                this._getStr = function (s) {
                    var phrase = [];
                    if (_trim) {
                        phrase.push("jQuery.trim(");
                    }
                    phrase.push("String(" + s + ")");
                    if (_trim) {
                        phrase.push(")");
                    }
                    if (!_usecase) {
                        phrase.push(".toLowerCase()");
                    }
                    return phrase.join("");
                };
                this._strComp = function (val) {
                    if (typeof val === "string") {
                        return ".toString()";
                    }
                    return "";
                };
                this._group = function (f, u) {
                    return ({
                        field: f.toString(),
                        unique: u,
                        items: []
                    });
                };
                this._toStr = function (phrase) {
                    if (_trim) {
                        phrase = $.trim(phrase);
                    }
                    phrase = phrase.toString().replace(/\\/g, '\\\\').replace(/\"/g, '\\"');
                    return _usecase ? phrase : phrase.toLowerCase();
                };
                this._funcLoop = function (func) {
                    var results = [];
                    $.each(_data, function (i, v) {
                        results.push(func(v));
                    });
                    return results;
                };
                this._append = function (s) {
                    var i;
                    if (_query === null) {
                        _query = "";
                    } else {
                        _query += _queuedOperator === "" ? " && " : _queuedOperator;
                    }
                    for (i = 0; i < _orDepth; i++) {
                        _query += "(";
                    }
                    if (_negate) {
                        _query += "!";
                    }
                    _query += "(" + s + ")";
                    _negate = false;
                    _queuedOperator = "";
                    _orDepth = 0;
                };
                this._setCommand = function (f, c) {
                    _lastCommand = f;
                    _lastField = c;
                };
                this._resetNegate = function () {
                    _negate = false;
                };
                this._repeatCommand = function (f, v) {
                    if (_lastCommand === null) {
                        return self;
                    }
                    if (f !== null && v !== null) {
                        return _lastCommand(f, v);
                    }
                    if (_lastField === null) {
                        return _lastCommand(f);
                    }
                    if (!_useProperties) {
                        return _lastCommand(f);
                    }
                    return _lastCommand(_lastField, f);
                };
                this._equals = function (a, b) {
                    return (self._compare(a, b, 1) === 0);
                };
                this._compare = function (a, b, d) {
                    var toString = Object.prototype.toString;
                    if (d === undefined) {
                        d = 1;
                    }
                    if (a === undefined) {
                        a = null;
                    }
                    if (b === undefined) {
                        b = null;
                    }
                    if (a === null && b === null) {
                        return 0;
                    }
                    if (a === null && b !== null) {
                        return 1;
                    }
                    if (a !== null && b === null) {
                        return -1;
                    }
                    if (toString.call(a) === '[object Date]' && toString.call(b) === '[object Date]') {
                        if (a < b) {
                            return -d;
                        }
                        if (a > b) {
                            return d;
                        }
                        return 0;
                    }
                    if (!_usecase && typeof a !== "number" && typeof b !== "number") {
                        a = String(a);
                        b = String(b);
                    }
                    if (a < b) {
                        return -d;
                    }
                    if (a > b) {
                        return d;
                    }
                    return 0;
                };
                this._performSort = function () {
                    if (_sorting.length === 0) {
                        return;
                    }
                    _data = self._doSort(_data, 0);
                };
                this._doSort = function (d, q) {
                    var by = _sorting[q].by,
                        dir = _sorting[q].dir,
                        type = _sorting[q].type,
                        dfmt = _sorting[q].datefmt;
                    if (q === _sorting.length - 1) {
                        return self._getOrder(d, by, dir, type, dfmt);
                    }
                    q++;
                    var values = self._getGroup(d, by, dir, type, dfmt),
                        results = [],
                        i, j, sorted;
                    for (i = 0; i < values.length; i++) {
                        sorted = self._doSort(values[i].items, q);
                        for (j = 0; j < sorted.length; j++) {
                            results.push(sorted[j]);
                        }
                    }
                    return results;
                };
                this._getOrder = function (data, by, dir, type, dfmt) {
                    var sortData = [],
                        _sortData = [],
                        newDir = dir === "a" ? 1 : -1,
                        i, ab, j,
                        findSortKey;

                    if (type === undefined) {
                        type = "text";
                    }
                    if (type === 'float' || type === 'number' || type === 'currency' || type === 'numeric') {
                        findSortKey = function ($cell) {
                            var key = parseFloat(String($cell).replace(_stripNum, ''));
                            return isNaN(key) ? 0.00 : key;
                        };
                    } else if (type === 'int' || type === 'integer') {
                        findSortKey = function ($cell) {
                            return $cell ? parseFloat(String($cell).replace(_stripNum, '')) : 0;
                        };
                    } else if (type === 'date' || type === 'datetime') {
                        findSortKey = function ($cell) {
                            return $.jgrid.parseDate(dfmt, $cell).getTime();
                        };
                    } else if ($.isFunction(type)) {
                        findSortKey = type;
                    } else {
                        findSortKey = function ($cell) {
                            $cell = $cell ? $.trim(String($cell)) : "";
                            return _usecase ? $cell : $cell.toLowerCase();
                        };
                    }
                    $.each(data, function (i, v) {
                        ab = by !== "" ? $.jgrid.getAccessor(v, by) : v;
                        if (ab === undefined) {
                            ab = "";
                        }
                        ab = findSortKey(ab, v);
                        _sortData.push({
                            'vSort': ab,
                            'index': i
                        });
                    });

                    _sortData.sort(function (a, b) {
                        a = a.vSort;
                        b = b.vSort;
                        return self._compare(a, b, newDir);
                    });
                    j = 0;
                    var nrec = data.length;
                    // overhead, but we do not change the original data.
                    while (j < nrec) {
                        i = _sortData[j].index;
                        sortData.push(data[i]);
                        j++;
                    }
                    return sortData;
                };
                this._getGroup = function (data, by, dir, type, dfmt) {
                    var results = [],
                        group = null,
                        last = null,
                        val;
                    $.each(self._getOrder(data, by, dir, type, dfmt), function (i, v) {
                        val = $.jgrid.getAccessor(v, by);
                        if (val == null) {
                            val = "";
                        }
                        if (!self._equals(last, val)) {
                            last = val;
                            if (group !== null) {
                                results.push(group);
                            }
                            group = self._group(by, val);
                        }
                        group.items.push(v);
                    });
                    if (group !== null) {
                        results.push(group);
                    }
                    return results;
                };
                this.ignoreCase = function () {
                    _usecase = false;
                    return self;
                };
                this.useCase = function () {
                    _usecase = true;
                    return self;
                };
                this.trim = function () {
                    _trim = true;
                    return self;
                };
                this.noTrim = function () {
                    _trim = false;
                    return self;
                };
                this.execute = function () {
                    var match = _query,
                        results = [];
                    if (match === null) {
                        return self;
                    }
                    $.each(_data, function () {
                        if (eval(match)) {
                            results.push(this);
                        }
                    });
                    _data = results;
                    return self;
                };
                this.data = function () {
                    return _data;
                };
                this.select = function (f) {
                    self._performSort();
                    if (!self._hasData()) {
                        return [];
                    }
                    self.execute();
                    if ($.isFunction(f)) {
                        var results = [];
                        $.each(_data, function (i, v) {
                            results.push(f(v));
                        });
                        return results;
                    }
                    return _data;
                };
                this.hasMatch = function () {
                    if (!self._hasData()) {
                        return false;
                    }
                    self.execute();
                    return _data.length > 0;
                };
                this.andNot = function (f, v, x) {
                    _negate = !_negate;
                    return self.and(f, v, x);
                };
                this.orNot = function (f, v, x) {
                    _negate = !_negate;
                    return self.or(f, v, x);
                };
                this.not = function (f, v, x) {
                    return self.andNot(f, v, x);
                };
                this.and = function (f, v, x) {
                    _queuedOperator = " && ";
                    if (f === undefined) {
                        return self;
                    }
                    return self._repeatCommand(f, v, x);
                };
                this.or = function (f, v, x) {
                    _queuedOperator = " || ";
                    if (f === undefined) {
                        return self;
                    }
                    return self._repeatCommand(f, v, x);
                };
                this.orBegin = function () {
                    _orDepth++;
                    return self;
                };
                this.orEnd = function () {
                    if (_query !== null) {
                        _query += ")";
                    }
                    return self;
                };
                this.isNot = function (f) {
                    _negate = !_negate;
                    return self.is(f);
                };
                this.is = function (f) {
                    self._append('this.' + f);
                    self._resetNegate();
                    return self;
                };
                this._compareValues = function (func, f, v, how, t) {
                    var fld;
                    if (_useProperties) {
                        fld = 'jQuery.jgrid.getAccessor(this,\'' + f + '\')';
                    } else {
                        fld = 'this';
                    }
                    if (v === undefined) {
                        v = null;
                    }
                    //var val=v===null?f:v,
                    var val = v,
                        swst = t.stype === undefined ? "text" : t.stype;
                    if (v !== null) {
                        switch (swst) {
                            case 'int':
                            case 'integer':
                                val = (isNaN(Number(val)) || val === "") ? '0' : val; // To be fixed with more inteligent code
                                fld = 'parseInt(' + fld + ',10)';
                                val = 'parseInt(' + val + ',10)';
                                break;
                            case 'float':
                            case 'number':
                            case 'numeric':
                                val = String(val).replace(_stripNum, '');
                                val = (isNaN(Number(val)) || val === "") ? '0' : val; // To be fixed with more inteligent code
                                fld = 'parseFloat(' + fld + ')';
                                val = 'parseFloat(' + val + ')';
                                break;
                            case 'date':
                            case 'datetime':
                                val = String($.jgrid.parseDate(t.newfmt || 'Y-m-d', val).getTime());
                                fld = 'jQuery.jgrid.parseDate("' + t.srcfmt + '",' + fld + ').getTime()';
                                break;
                            default:
                                fld = self._getStr(fld);
                                val = self._getStr('"' + self._toStr(val) + '"');
                        }
                    }
                    self._append(fld + ' ' + how + ' ' + val);
                    self._setCommand(func, f);
                    self._resetNegate();
                    return self;
                };
                this.equals = function (f, v, t) {
                    return self._compareValues(self.equals, f, v, "==", t);
                };
                this.notEquals = function (f, v, t) {
                    return self._compareValues(self.equals, f, v, "!==", t);
                };
                this.isNull = function (f, v, t) {
                    return self._compareValues(self.equals, f, null, "===", t);
                };
                this.greater = function (f, v, t) {
                    return self._compareValues(self.greater, f, v, ">", t);
                };
                this.less = function (f, v, t) {
                    return self._compareValues(self.less, f, v, "<", t);
                };
                this.greaterOrEquals = function (f, v, t) {
                    return self._compareValues(self.greaterOrEquals, f, v, ">=", t);
                };
                this.lessOrEquals = function (f, v, t) {
                    return self._compareValues(self.lessOrEquals, f, v, "<=", t);
                };
                this.startsWith = function (f, v) {
                    var val = (v == null) ? f : v,
                        length = _trim ? $.trim(val.toString()).length : val.toString().length;
                    if (_useProperties) {
                        self._append(self._getStr('jQuery.jgrid.getAccessor(this,\'' + f + '\')') + '.substr(0,' + length + ') == ' + self._getStr('"' + self._toStr(v) + '"'));
                    } else {
                        length = _trim ? $.trim(v.toString()).length : v.toString().length;
                        self._append(self._getStr('this') + '.substr(0,' + length + ') == ' + self._getStr('"' + self._toStr(f) + '"'));
                    }
                    self._setCommand(self.startsWith, f);
                    self._resetNegate();
                    return self;
                };
                this.endsWith = function (f, v) {
                    var val = (v == null) ? f : v,
                        length = _trim ? $.trim(val.toString()).length : val.toString().length;
                    if (_useProperties) {
                        self._append(self._getStr('jQuery.jgrid.getAccessor(this,\'' + f + '\')') + '.substr(' + self._getStr('jQuery.jgrid.getAccessor(this,\'' + f + '\')') + '.length-' + length + ',' + length + ') == "' + self._toStr(v) + '"');
                    } else {
                        self._append(self._getStr('this') + '.substr(' + self._getStr('this') + '.length-"' + self._toStr(f) + '".length,"' + self._toStr(f) + '".length) == "' + self._toStr(f) + '"');
                    }
                    self._setCommand(self.endsWith, f);
                    self._resetNegate();
                    return self;
                };
                this.contains = function (f, v) {
                    if (_useProperties) {
                        self._append(self._getStr('jQuery.jgrid.getAccessor(this,\'' + f + '\')') + '.indexOf("' + self._toStr(v) + '",0) > -1');
                    } else {
                        self._append(self._getStr('this') + '.indexOf("' + self._toStr(f) + '",0) > -1');
                    }
                    self._setCommand(self.contains, f);
                    self._resetNegate();
                    return self;
                };
                this.groupBy = function (by, dir, type, datefmt) {
                    if (!self._hasData()) {
                        return null;
                    }
                    return self._getGroup(_data, by, dir, type, datefmt);
                };
                this.orderBy = function (by, dir, stype, dfmt) {
                    dir = dir == null ? "a" : $.trim(dir.toString().toLowerCase());
                    if (stype == null) {
                        stype = "text";
                    }
                    if (dfmt == null) {
                        dfmt = "Y-m-d";
                    }
                    if (dir === "desc" || dir === "descending") {
                        dir = "d";
                    }
                    if (dir === "asc" || dir === "ascending") {
                        dir = "a";
                    }
                    _sorting.push({
                        by: by,
                        dir: dir,
                        type: stype,
                        datefmt: dfmt
                    });
                    return self;
                };
                return self;
            };
            return new QueryObject(source, null);
        },
        //TODO 这两个方法可以去掉
        getMethod: function (grid,name) {
            return this.getAccessor(grid, name);
        },
        extend: function (grid,methods) {
            $.extend(grid, methods);
        }
    });
});
//grid 需要首先引入模板
!function (factory) {
  if (typeof define === 'function' && define.amd) {
    define('text!src/grid/grid.tpl', factory);
  } else {
    factory();
  }
}(function() {
    'use strict';

    $.jgrid = $.jgrid || {};

    $.jgrid.tpl = '<div class="ui-jqgrid" id="{{id}}">\r\n\t<div class="ui-jqgrid-view" id="gview_{{id}}">\r\n\t\t{{#if caption}}<div class="ui-jqgrid-titlebar ui-helper-clearfix">\r\n\t\t\t{{#if hidegrid}}\r\n\t\t\t<a role="link" class="ui-jqgrid-titlebar-close HeaderButton">\r\n\t\t\t\t<span class="ui-icon ui-icon-circle-triangle-n"></span>\r\n\t\t\t</a>\r\n\t\t\t{{/if}}\r\n\t\t\t<span class="ui-jqgrid-title">{{caption}}</span>\r\n\t\t</div>\r\n\t\t{{/if}}{{#if topbar}}\r\n\t\t<div class="ui-userdata ui-userdata-t" id="t_{{id}}"></div>\r\n\t\t{{/if}}\r\n\t\t<div class="ui-jqgrid-hdiv">\r\n\t\t\t<div class="ui-jqgrid-hbox">\r\n\t\t\t\t<table class="ui-jqgrid-htable" role="grid" aria-labelledby="{{id}}" cellspacing="0" cellpadding="0" border="0">\r\n\t\t\t\t\t<thead>\r\n\t\t\t\t\t\t<tr class="ui-jqgrid-labels" role="rowheader">\r\n\t\t\t\t\t\t\t{{#colModel}}\r\n\t\t\t\t\t\t\t<th id="{{../id}}_{{name}}" role="columnheader" class="ui-state-default ui-th-column" title="{{headertitle}}">\r\n\t\t\t\t\t\t\t\t{{#if resizable}}\r\n\t\t\t\t\t\t\t\t<span class="ui-jqgrid-resize" style="cursor: col-resize;">&nbsp;</span>\r\n\t\t\t\t\t\t\t\t{{/if}}\r\n\t\t\t\t\t\t\t\t<div id="jqgh_{{../id}}_{{name}}" class="{{#if ../isMSIE}}ui-th-div-ie{{/if}}">\r\n\t\t\t\t\t\t\t\t\t{{#if cb}}\r\n\t\t\t\t\t\t\t\t\t<input role="checkbox" id="cb_{{../../id}}" class="cbox" type="checkbox">\r\n\t\t\t\t\t\t\t\t\t{{else}}{{label}}{{/if}}\r\n\t\t\t\t\t\t\t\t\t<span class="s-ico" style="display:none">\r\n\t\t\t\t\t\t\t\t\t\t<span sort="asc" class="ui-grid-ico-sort ui-icon-asc ui-state-disabled ui-icon ui-icon-triangle-1-n"></span>\r\n\t\t\t\t\t\t\t\t\t\t<span sort="desc" class="ui-grid-ico-sort ui-icon-desc ui-state-disabled ui-icon ui-icon-triangle-1-s"></span>\r\n\t\t\t\t\t\t\t\t\t</span>\r\n\t\t\t\t\t\t\t\t</div>\r\n\t\t\t\t\t\t\t</th>\r\n\t\t\t\t\t\t\t{{/colModel}}\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t</thead>\r\n\t\t\t\t</table>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t<div class="ui-jqgrid-bdiv" style="height: {{height}}px;">\r\n\t\t\t<div style="position:relative;">\r\n\t\t\t\t<div></div>\r\n\t\t\t\t<table id="btable_{{id}}" tabindex="0" cellspacing="0" cellpadding="0" border="0" role="grid" aria-multiselectable="{{multiselect}}" aria-labelledby="{{id}}" class="ui-jqgrid-btable">\r\n\t\t\t\t\t<tbody>\r\n\t\t\t\t\t\t<tr class="jqgfirstrow" role="row" style="height:auto">\r\n\t\t\t\t\t\t\t{{#colModel}}\r\n\t\t\t\t\t\t\t<td role="gridcell" style="height:0.01px;"></td>\r\n\t\t\t\t\t\t\t{{/colModel}}\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t</tbody>\r\n\t\t\t\t</table>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t{{#if footerrow}}\r\n\t\t<div class="ui-jqgrid-sdiv">\r\n\t\t\t<div class="ui-jqgrid-hbox">\r\n\t\t\t\t<table role="grid" class="ui-jqgrid-ftable" cellspacing="0" cellpadding="0" border="0">\r\n\t\t\t\t\t<tbody>\r\n\t\t\t\t\t\t<tr role="row" class="footrow">\r\n\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t</tbody>\r\n\t\t\t\t</table>\r\n\t\t\t</div>\r\n\t\t</div>\r\n\t\t{{/if}}\r\n\t\t{{#if bottombar}}\r\n\t\t<div class="ui-userdata ui-userdata-tb" id="tb_{{id}}"></div>\r\n\t\t{{/if}}\r\n\t</div>\r\n\t<div class="ui-jqgrid-resize-mark" id="rs_m{{id}}">&nbsp;</div>\r\n\t{{#if pager}}\r\n\t<div id="{{id}}_pager" class="ui-jqgrid-pager">\r\n\t\t<div id="pg_{{id}}_pager" class="ui-pager-control" role="group">\r\n\t\t\t<table cellspacing="0" cellpadding="0" border="0" class="ui-pg-table" style="width:100%;table-layout:fixed;height:100%;" role="row">\r\n\t\t\t\t<tbody>\r\n\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t<td id="{{id}}_pager_left" align="left"></td>\r\n\t\t\t\t\t\t<td id="{{id}}_pager_center" align="center" style="white-space: pre;">\r\n\t\t\t\t\t\t\t<table cellspacing="0" cellpadding="0" border="0" style="table-layout:auto;" class="ui-pg-table">\r\n\t\t\t\t\t\t\t\t<tbody>\r\n\t\t\t\t\t\t\t\t\t<tr>\r\n\t\t\t\t\t\t\t\t\t\t<td id="first_{{id}}_pager" class="ui-pg-button" style="cursor: default;">\r\n\t\t\t\t\t\t\t\t\t\t\t<span class="ui-icon ui-icon-seek-first"></span>\r\n\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t\t\t\t\t\t\t\t\t<td id="prev_{{id}}_pager" class="ui-pg-button" style="cursor: default;">\r\n\t\t\t\t\t\t\t\t\t\t\t<span class="ui-icon ui-icon-seek-prev"></span>\r\n\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t\t\t\t\t\t\t\t\t<!-- <td class="ui-pg-button" style="width: 4px; cursor: default;">\r\n\t\t\t\t\t\t\t\t\t\t\t<span class="ui-separator"></span>\r\n\t\t\t\t\t\t\t\t\t\t</td> -->\r\n\t\t\t\t\t\t\t\t\t\t<td class="ui-separator">\r\n\t\t\t\t\t\t\t\t\t\t\t<input class="ui-pg-input" type="text" size="2" maxlength="7" value="0" role="textbox">\r\n\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t\t\t\t\t\t\t\t\t<!-- <td class="ui-pg-button" style="width:4px;">\r\n\t\t\t\t\t\t\t\t\t\t\t<span class="ui-separator"></span>\r\n\t\t\t\t\t\t\t\t\t\t</td> -->\r\n\t\t\t\t\t\t\t\t\t\t<td id="next_{{id}}_pager" class="ui-pg-button">\r\n\t\t\t\t\t\t\t\t\t\t\t<span class="ui-icon ui-icon-seek-next"></span>\r\n\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t\t\t\t\t\t\t\t\t<td id="last_{{id}}_pager" class="ui-pg-button">\r\n\t\t\t\t\t\t\t\t\t\t\t<span class="ui-icon ui-icon-seek-end"></span>\r\n\t\t\t\t\t\t\t\t\t\t</td>\r\n\t\t\t\t\t\t\t\t\t</tr>\r\n\t\t\t\t\t\t\t\t</tbody>\r\n\t\t\t\t\t\t\t</table>\r\n\t\t\t\t\t\t</td>\r\n\t\t\t\t\t\t<td id="{{id}}_pager_right" align="right">\r\n\t\t\t\t\t\t\t<div style="text-align:{{recordpos}}" class="ui-paging-info"></div>\r\n\t\t\t\t\t\t</td>\r\n\t\t\t\t\t</tr>\r\n\t\t\t\t</tbody>\r\n\t\t\t</table>\r\n\t\t</div>\r\n\t</div>\r\n\t{{/if}}\r\n</div>';

    return $.jgrid.tpl;
});
/*
 * Created by tanyl on 2014/12/16.
 */

!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.grid.formatter', factory);
    } else {
        factory();
    }
}(function () {

    'use strict';

//jquery.fmatter**********************************************/
    $.fmatter = {};
//opts can be id:row id for the row, rowdata:the data for the row, colmodel:the column model for this column
//example {id:1234,}
    $.extend($.fmatter, {
        isBoolean: function (o) {
            return typeof o === 'boolean';
        },
        isObject: function (o) {
            return (o && (typeof o === 'object' || $.isFunction(o))) || false;
        },
        isString: function (o) {
            return typeof o === 'string';
        },
        isNumber: function (o) {
            return typeof o === 'number' && isFinite(o);
        },
        isValue: function (o) {
            return (this.isObject(o) || this.isString(o) || this.isNumber(o) || this.isBoolean(o));
        },
        isEmpty: function (o) {
            if (!this.isString(o) && this.isValue(o)) {
                return false;
            }
            if (!this.isValue(o)) {
                return true;
            }
            o = $.trim(o).replace(/\&nbsp\;/ig, '').replace(/\&#160\;/ig, '');
            return o === "";
        }
    });
    $.fn.fmatter = function (formatType, cellval, opts, rwd, act) {
        // build main options before element iteration
        var v = cellval;
        opts = $.extend({}, $.jgrid.formatter, opts);

        try {
            v = $.fn.fmatter[formatType].call(this, cellval, opts, rwd, act);
        } catch (fe) {
        }
        return v;
    };
    $.fmatter.util = {
        // Taken from YAHOO utils
        NumberFormat: function (nData, opts) {
            if (!$.fmatter.isNumber(nData)) {
                nData *= 1;
            }
            if ($.fmatter.isNumber(nData)) {
                var bNegative = (nData < 0);
                var sOutput = String(nData);
                var sDecimalSeparator = opts.decimalSeparator || ".";
                var nDotIndex;
                if ($.fmatter.isNumber(opts.decimalPlaces)) {
                    // Round to the correct decimal place
                    var nDecimalPlaces = opts.decimalPlaces;
                    var nDecimal = Math.pow(10, nDecimalPlaces);
                    sOutput = String(Math.round(nData * nDecimal) / nDecimal);
                    nDotIndex = sOutput.lastIndexOf(".");
                    if (nDecimalPlaces > 0) {
                        // Add the decimal separator
                        if (nDotIndex < 0) {
                            sOutput += sDecimalSeparator;
                            nDotIndex = sOutput.length - 1;
                        }
                        // Replace the "."
                        else if (sDecimalSeparator !== ".") {
                            sOutput = sOutput.replace(".", sDecimalSeparator);
                        }
                        // Add missing zeros
                        while ((sOutput.length - 1 - nDotIndex) < nDecimalPlaces) {
                            sOutput += "0";
                        }
                    }
                }
                if (opts.thousandsSeparator) {
                    var sThousandsSeparator = opts.thousandsSeparator;
                    nDotIndex = sOutput.lastIndexOf(sDecimalSeparator);
                    nDotIndex = (nDotIndex > -1) ? nDotIndex : sOutput.length;
                    var sNewOutput = sOutput.substring(nDotIndex);
                    var nCount = -1, i;
                    for (i = nDotIndex; i > 0; i--) {
                        nCount++;
                        if ((nCount % 3 === 0) && (i !== nDotIndex) && (!bNegative || (i > 1))) {
                            sNewOutput = sThousandsSeparator + sNewOutput;
                        }
                        sNewOutput = sOutput.charAt(i - 1) + sNewOutput;
                    }
                    sOutput = sNewOutput;
                }
                // Prepend prefix
                sOutput = (opts.prefix) ? opts.prefix + sOutput : sOutput;
                // Append suffix
                sOutput = (opts.suffix) ? sOutput + opts.suffix : sOutput;
                return sOutput;

            }
            return nData;
        }
    };
    $.fn.fmatter.defaultFormat = function (cellval, opts) {
        return ($.fmatter.isValue(cellval) && cellval !== "" ) ? cellval : opts.defaultValue || "&#160;";
    };
    $.fn.fmatter.email = function (cellval, opts) {
        if (!$.fmatter.isEmpty(cellval)) {
            return "<a href=\"mailto:" + cellval + "\">" + cellval + "</a>";
        }
        return $.fn.fmatter.defaultFormat(cellval, opts);
    };
    $.fn.fmatter.checkbox = function (cval, opts) {
        var op = $.extend({}, opts.checkbox), ds;
        if (opts.colModel !== undefined && opts.colModel.formatoptions !== undefined) {
            op = $.extend({}, op, opts.colModel.formatoptions);
        }
        if (op.disabled === true) {
            ds = "disabled=\"disabled\"";
        } else {
            ds = "";
        }
        if ($.fmatter.isEmpty(cval) || cval === undefined) {
            cval = $.fn.fmatter.defaultFormat(cval, op);
        }
        cval = String(cval);
        cval = (cval + "").toLowerCase();
        var bchk = cval.search(/(false|f|0|no|n|off|undefined)/i) < 0 ? " checked='checked' " : "";
        return "<input type=\"checkbox\" " + bchk + " value=\"" + cval + "\" offval=\"no\" " + ds + "/>";
    };
    $.fn.fmatter.linkFunction = function (cellval, opts) {
        var op = {cssp: "linkfunction"};// ui-state-active
        if (opts.colModel !== undefined && opts.colModel.formatoptions !== undefined) {
            op = $.extend({}, op, opts.colModel.formatoptions);
        }
        if (!$.fmatter.isEmpty(cellval)) {
            var cssp = op.cssp;
            if (typeof cssp === 'string' && $.trim(cssp) != "") {
                cssp = "class=" + cssp;
            } else if (cssp) {
                var tmp = [];
                for (var key in cssp) {
                    tmp.push(key + ":" + cssp[key]);
                }
                cssp = "style=" + tmp.join(",");
            }
            return "<a " + cssp + " href=\"javascript:" + op.action + "\">" + cellval + "</a>";
        } else {
            return $.fn.fmatter.defaultFormat(cellval, opts);
        }
    };
// $.fn.fmatter.link = function(cellval, opts) {
// 	var op = {target:opts.target};
// 	var target = "";
// 	if(opts.colModel !== undefined && opts.colModel.formatoptions !== undefined) {
// 		op = $.extend({},op,opts.colModel.formatoptions);
// 	}
// 	if(op.target) {target = 'target=' + op.target;}
// 	if(!$.fmatter.isEmpty(cellval)) {
// 		return "<a "+target+" href=\"" + cellval + "\">" + cellval + "</a>";
// 	}
// 	return $.fn.fmatter.defaultFormat(cellval,opts);
// };
// $.fn.fmatter.showlink = function(cellval, opts) {
// 	var op = {baseLinkUrl: opts.baseLinkUrl,showAction:opts.showAction, addParam: opts.addParam || "", target: opts.target, idName: opts.idName},
// 	target = "", idUrl;
// 	if(opts.colModel !== undefined && opts.colModel.formatoptions !== undefined) {
// 		op = $.extend({},op,opts.colModel.formatoptions);
// 	}
// 	if(op.target) {target = 'target=' + op.target;}
// 	idUrl = op.baseLinkUrl+op.showAction + '?'+ op.idName+'='+opts.rowId+op.addParam;
// 	if($.fmatter.isString(cellval) || $.fmatter.isNumber(cellval)) {	//add this one even if its blank string
// 		return "<a "+target+" href=\"" + idUrl + "\">" + cellval + "</a>";
// 	}
// 	return $.fn.fmatter.defaultFormat(cellval,opts);
// };
    $.fn.fmatter.integer = function (cellval, opts) {
        var op = $.extend({}, opts.integer);
        if (opts.colModel !== undefined && opts.colModel.formatoptions !== undefined) {
            op = $.extend({}, op, opts.colModel.formatoptions);
        }
        if ($.fmatter.isEmpty(cellval)) {
            return op.defaultValue;
        }
        return $.fmatter.util.NumberFormat(cellval, op);
    };
    $.fn.fmatter.number = function (cellval, opts) {
        var op = $.extend({}, opts.number);
        if (opts.colModel !== undefined && opts.colModel.formatoptions !== undefined) {
            op = $.extend({}, op, opts.colModel.formatoptions);
        }
        if ($.fmatter.isEmpty(cellval)) {
            return op.defaultValue;
        }
        return $.fmatter.util.NumberFormat(cellval, op);
    };
    $.fn.fmatter.currency = function (cellval, opts) {
        var op = $.extend({}, opts.currency);
        if (opts.colModel !== undefined && opts.colModel.formatoptions !== undefined) {
            op = $.extend({}, op, opts.colModel.formatoptions);
        }
        if ($.fmatter.isEmpty(cellval)) {
            return op.defaultValue;
        }
        return $.fmatter.util.NumberFormat(cellval, op);
    };
    $.fn.fmatter.date = function (cellval, opts, rwd, act) {
        var op = $.extend({}, opts.date);
        if (opts.colModel !== undefined && opts.colModel.formatoptions !== undefined) {
            op = $.extend({}, op, opts.colModel.formatoptions);
        }
        if (!op.reformatAfterEdit && act === 'edit') {
            return $.fn.fmatter.defaultFormat(cellval, opts);
        }
        if (!$.fmatter.isEmpty(cellval)) {
            return $.jgrid.parseDate(op.srcformat, cellval, op.newformat, op);
        }
        return $.fn.fmatter.defaultFormat(cellval, opts);
    };
    $.fn.fmatter.select = function (cellval, opts) {
        // jqGrid specific
        cellval = String(cellval);
        var oSelect = false, ret = [], sep, delim;
        if (opts.colModel.formatoptions !== undefined) {
            oSelect = opts.colModel.formatoptions.value;
            sep = opts.colModel.formatoptions.separator === undefined ? ":" : opts.colModel.formatoptions.separator;
            delim = opts.colModel.formatoptions.delimiter === undefined ? ";" : opts.colModel.formatoptions.delimiter;
        } else if (opts.colModel.editoptions !== undefined) {
            oSelect = opts.colModel.editoptions.value;
            sep = opts.colModel.editoptions.separator === undefined ? ":" : opts.colModel.editoptions.separator;
            delim = opts.colModel.editoptions.delimiter === undefined ? ";" : opts.colModel.editoptions.delimiter;
        }
        if (oSelect) {
            var msl = opts.colModel.editoptions.multiple === true ? true : false,
                scell = [], sv;
            if (msl) {
                scell = cellval.split(",");
                scell = $.map(scell, function (n) {
                    return $.trim(n);
                });
            }
            if ($.fmatter.isString(oSelect)) {
                // mybe here we can use some caching with care ????
                var so = oSelect.split(delim), j = 0, i;
                for (i = 0; i < so.length; i++) {
                    sv = so[i].split(sep);
                    if (sv.length > 2) {
                        sv[1] = $.map(sv, function (n, i) {
                            if (i > 0) {
                                return n;
                            }
                        }).join(sep);
                    }
                    if (msl) {
                        if ($.inArray(sv[0], scell) > -1) {
                            ret[j] = sv[1];
                            j++;
                        }
                    } else if ($.trim(sv[0]) === $.trim(cellval)) {
                        ret[0] = sv[1];
                        break;
                    }
                }
            } else if ($.fmatter.isObject(oSelect)) {
                // this is quicker
                if (msl) {
                    ret = $.map(scell, function (n) {
                        return oSelect[n];
                    });
                } else {
                    ret[0] = oSelect[cellval] || "";
                }
            }
        }
        cellval = ret.join(", ");
        return cellval === "" ? $.fn.fmatter.defaultFormat(cellval, opts) : cellval;
    };
    $.fn.fmatter.rowactions = function (act) {
        var $tr = $(this).closest("tr.jqgrow"),
            rid = $tr.attr("id"),
            $id = $(this).closest("table.ui-jqgrid-btable").attr('id').replace(/_frozen([^_]*)$/, '$1'),
            $grid = $("#" + $id),
            $t = $grid[0],
            p = $t.p,
            cm = p.colModel[$.jgrid.getCellIndex(this)],
            $actionsDiv = cm.frozen ? $("tr#" + rid + " td:eq(" + $.jgrid.getCellIndex(this) + ") > div", $grid) : $(this).parent(),
            op = {
                keys: false,
                onEdit: null,
                onSuccess: null,
                afterSave: null,
                onError: null,
                afterRestore: null,
                extraparam: {},
                url: null,
                restoreAfterError: true,
                delOptions: {}//,
                // editOptions: {}
            },
            saverow = function (rowid, res) {
                if ($.isFunction(op.afterSave)) {
                    op.afterSave.call($t, rowid, res);
                }
                $actionsDiv.find("div.ui-inline-edit,div.ui-inline-del").show();
                $actionsDiv.find("div.ui-inline-save,div.ui-inline-cancel").hide();
            },
            restorerow = function (rowid) {
                if ($.isFunction(op.afterRestore)) {
                    op.afterRestore.call($t, rowid);
                }
                $actionsDiv.find("div.ui-inline-edit,div.ui-inline-del").show();
                $actionsDiv.find("div.ui-inline-save,div.ui-inline-cancel").hide();
            };

        if (cm.formatoptions !== undefined) {
            op = $.extend(op, cm.formatoptions);
        }
        // if (p.editOptions !== undefined) {
        // 	op.editOptions = p.editOptions;
        // }
        if (p.delOptions !== undefined) {
            op.delOptions = p.delOptions;
        }
        if ($tr.hasClass("jqgrid-new-row")) {
            op.extraparam[p.prmNames.oper] = p.prmNames.addoper;
        }
        var actop = {
            keys: op.keys,
            oneditfunc: op.onEdit,
            successfunc: op.onSuccess,
            url: op.url,
            extraparam: op.extraparam,
            aftersavefunc: saverow,
            errorfunc: op.onError,
            afterrestorefunc: restorerow,
            restoreAfterError: op.restoreAfterError
        };
        switch (act) {
            case 'edit':
                $grid.jqGrid('editRow', rid, actop);
                $actionsDiv.find("div.ui-inline-edit,div.ui-inline-del").hide();
                $actionsDiv.find("div.ui-inline-save,div.ui-inline-cancel").show();
                $grid._trigger("afterGridComplete");
                break;
            case 'save':
                if ($grid.jqGrid('saveRow', rid, actop)) {
                    $actionsDiv.find("div.ui-inline-edit,div.ui-inline-del").show();
                    $actionsDiv.find("div.ui-inline-save,div.ui-inline-cancel").hide();
                    $grid._trigger("afterGridComplete");
                }
                break;
            case 'cancel' :
                $grid.jqGrid('restoreRow', rid, restorerow);
                $actionsDiv.find("div.ui-inline-edit,div.ui-inline-del").show();
                $actionsDiv.find("div.ui-inline-save,div.ui-inline-cancel").hide();
                $grid._trigger("afterGridComplete");
                break;
            case 'del':
                $grid.jqGrid('delGridRow', rid, op.delOptions);
                break;
            // case 'formedit':
            // 	$grid.jqGrid('setSelection', rid);
            // 	$grid.jqGrid('editGridRow', rid, op.editOptions);
            // 	break;
        }
    };
    $.fn.fmatter.actions = function (cellval, opts) {
        var op = {keys: false, editbutton: true, delbutton: true, editformbutton: false},
            rowid = opts.rowId, str = "", ocl;
        if (opts.colModel.formatoptions !== undefined) {
            op = $.extend(op, opts.colModel.formatoptions);
        }
        if (rowid === undefined || $.fmatter.isEmpty(rowid)) {
            return "";
        }
        // if(op.editformbutton){
        // 	ocl = "id='jEditButton_"+rowid+"' onclick=jQuery.fn.fmatter.rowactions.call(this,'formedit'); onmouseover=jQuery(this).addClass('ui-state-hover'); onmouseout=jQuery(this).removeClass('ui-state-hover'); ";
        // 	str += "<div title='"+$.jgrid.nav.edittitle+"' style='float:left;cursor:pointer;' class='ui-pg-div ui-inline-edit' "+ocl+"><span class='ui-icon ui-icon-pencil'></span></div>";
        // } else
        if (op.editbutton) {
            ocl = "id='jEditButton_" + rowid + "' onclick=jQuery.fn.fmatter.rowactions.call(this,'edit'); onmouseover=jQuery(this).addClass('ui-state-hover'); onmouseout=jQuery(this).removeClass('ui-state-hover') ";
            str += "<div title='" + $.jgrid.nav.edittitle + "' style='float:left;cursor:pointer;' class='ui-pg-div ui-inline-edit' " + ocl + "><span class='ui-icon ui-icon-pencil'></span></div>";
        }
        if (op.delbutton) {
            ocl = "id='jDeleteButton_" + rowid + "' onclick=jQuery.fn.fmatter.rowactions.call(this,'del'); onmouseover=jQuery(this).addClass('ui-state-hover'); onmouseout=jQuery(this).removeClass('ui-state-hover'); ";
            str += "<div title='" + $.jgrid.nav.deltitle + "' style='float:left;margin-left:5px;' class='ui-pg-div ui-inline-del' " + ocl + "><span class='ui-icon ui-icon-trash'></span></div>";
        }
        ocl = "id='jSaveButton_" + rowid + "' onclick=jQuery.fn.fmatter.rowactions.call(this,'save'); onmouseover=jQuery(this).addClass('ui-state-hover'); onmouseout=jQuery(this).removeClass('ui-state-hover'); ";
        str += "<div title='" + $.jgrid.edit.bSubmit + "' style='float:left;display:none' class='ui-pg-div ui-inline-save' " + ocl + "><span class='ui-icon ui-icon-disk'></span></div>";
        ocl = "id='jCancelButton_" + rowid + "' onclick=jQuery.fn.fmatter.rowactions.call(this,'cancel'); onmouseover=jQuery(this).addClass('ui-state-hover'); onmouseout=jQuery(this).removeClass('ui-state-hover'); ";
        str += "<div title='" + $.jgrid.edit.bCancel + "' style='float:left;display:none;margin-left:5px;' class='ui-pg-div ui-inline-cancel' " + ocl + "><span class='ui-icon ui-icon-cancel'></span></div>";
        return "<div style='margin-left:8px;'>" + str + "</div>";
    };
    $.unformat = function (cellval, options, pos, cnt) {
        // specific for jqGrid only
        var ret, formatType = options.colModel.formatter,
            op = options.colModel.formatoptions || {}, sep,
            re = /([\.\*\_\'\(\)\{\}\+\?\\])/g,
            unformatFunc = options.colModel.unformat || ($.fn.fmatter[formatType] && $.fn.fmatter[formatType].unformat);
        if (unformatFunc !== undefined && $.isFunction(unformatFunc)) {
            ret = unformatFunc.call(this, $(cellval).text(), options, cellval);
        } else if (formatType !== undefined && $.fmatter.isString(formatType)) {
            var opts = $.jgrid.formatter || {}, stripTag;
            switch (formatType) {
                case 'integer' :
                    op = $.extend({}, opts.integer, op);
                    sep = op.thousandsSeparator.replace(re, "\\$1");
                    stripTag = new RegExp(sep, "g");
                    ret = $(cellval).text().replace(stripTag, '');
                    break;
                case 'number' :
                    op = $.extend({}, opts.number, op);
                    sep = op.thousandsSeparator.replace(re, "\\$1");
                    stripTag = new RegExp(sep, "g");
                    ret = $(cellval).text().replace(stripTag, "").replace(op.decimalSeparator, '.');
                    break;
                case 'currency':
                    op = $.extend({}, opts.currency, op);
                    sep = op.thousandsSeparator.replace(re, "\\$1");
                    stripTag = new RegExp(sep, "g");
                    ret = $(cellval).text();
                    if (op.prefix && op.prefix.length) {
                        ret = ret.substr(op.prefix.length);
                    }
                    if (op.suffix && op.suffix.length) {
                        ret = ret.substr(0, ret.length - op.suffix.length);
                    }
                    ret = ret.replace(stripTag, '').replace(op.decimalSeparator, '.');
                    break;
                case 'checkbox':
                    var cbv = (options.colModel.editoptions) ? options.colModel.editoptions.value.split(":") : ["Yes", "No"];
                    ret = $('input', cellval).is(":checked") ? cbv[0] : cbv[1];
                    break;
                case 'select' :
                    ret = $.unformat.select(cellval, options, pos, cnt);
                    break;
                case 'actions':
                    return "";
                default:
                    ret = $(cellval).text();
            }
        }
        return ret !== undefined ? ret : cnt === true ? $(cellval).text() : $.jgrid.htmlDecode($(cellval).html());
    };
    $.unformat.select = function (cellval, options, pos, cnt) {
        // Spacial case when we have local data and perform a sort
        // cnt is set to true only in sortDataArray
        var ret = [];
        var cell = $(cellval).text();
        if (cnt === true) {
            return cell;
        }
        var op = $.extend({}, options.colModel.formatoptions !== undefined ? options.colModel.formatoptions : options.colModel.editoptions),
            sep = op.separator === undefined ? ":" : op.separator,
            delim = op.delimiter === undefined ? ";" : op.delimiter;

        if (op.value) {
            var oSelect = op.value,
                msl = op.multiple === true ? true : false,
                scell = [], sv;
            if (msl) {
                scell = cell.split(",");
                scell = $.map(scell, function (n) {
                    return $.trim(n);
                });
            }
            if ($.fmatter.isString(oSelect)) {
                var so = oSelect.split(delim), j = 0, i;
                for (i = 0; i < so.length; i++) {
                    sv = so[i].split(sep);
                    if (sv.length > 2) {
                        sv[1] = $.map(sv, function (n, i) {
                            if (i > 0) {
                                return n;
                            }
                        }).join(sep);
                    }
                    if (msl) {
                        if ($.inArray(sv[1], scell) > -1) {
                            ret[j] = sv[0];
                            j++;
                        }
                    } else if ($.trim(sv[1]) === $.trim(cell)) {
                        ret[0] = sv[0];
                        break;
                    }
                }
            } else if ($.fmatter.isObject(oSelect) || $.isArray(oSelect)) {
                if (!msl) {
                    scell[0] = cell;
                }
                ret = $.map(scell, function (n) {
                    var rv;
                    $.each(oSelect, function (i, val) {
                        if (val === n) {
                            rv = i;
                            return false;
                        }
                    });
                    if (rv !== undefined) {
                        return rv;
                    }
                });
            }
            return ret.join(", ");
        }
        return cell || "";
    };
    $.unformat.date = function (cellval, opts) {
        var op = $.jgrid.formatter.date || {};
        if (opts.formatoptions !== undefined) {
            op = $.extend({}, op, opts.formatoptions);
        }
        if (!$.fmatter.isEmpty(cellval)) {
            return $.jgrid.parseDate(op.newformat, cellval, op.srcformat, op);
        }
        return $.fn.fmatter.defaultFormat(cellval, opts);
    };

});
/**
 * 数据表格插件
 * @class fish.desktop.widget.Grid
 * <pre>
    $(element).jqGrid(option);
    $(element).jqGrid(method);
 * </pre>
 * Created by tanyl on 2014/12/16.
 * Dependent:
 *      grid.util.js
 *      grid.formatter.js
 *      grid.tpl.js
 *      grid.en.js
 * ps:rowid因为需要做选择器用,不能含有.等具有含义的字符
 */
!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.grid.base', factory);
    } else {
        factory();
    }
}(function () {

    'use strict';

    var MAXROWNUM = 99999;

    $.widget("ui.grid", {
        options: {
            minHeight:150,
            page: 1,
            rowNum: MAXROWNUM,
            records: 0,
            pager: "",
            pgbuttons: true,
            pginput: true,
            colModel: [],
            // rowList: [],   //TODO 需支持
            sortorder: "asc",
            sortname: "",
            datatype: "local",
            altRows: false,                     // 是否启用斑马线样式
            altclass: 'ui-priority-secondary',  // 斑马线样式内容
            selrow: null,
            selarrrow: [],
            savedRow: [],                        // 单元格编辑保存的内容
            shrinkToFit: true,
            jsonReader : {
                root: "rows",
                page: "page",
                total: "total",
                records: "records",
                repeatitems: true,
                cell: "cell",
                id: "_id_",
                userdata: "userdata"
            },
            localReader : {
                root: "rows",
                page: "page",
                total: "total",
                records: "records",
                repeatitems: false,
                cell: "cell",
                id: "_id_",
                userdata: "userdata"
            },
            reccount: 0,
            lastpage: 0,
            lastsort: 0,
            viewrecords: true,
            multiselect: false,
            multikey: false,
            search: false,                     // 正在搜索模式
            caption: "", //TODO 为空就不应该显示
            hidegrid: false,
            hiddengrid: false,
            userData: {},
            treeGrid: false,
            treeReader: {},
            treeANode: -1,					// 跟节点标识,内部用 TODO ??
            ExpandColumn: null,
            ExpandColClick: false,
            tree_root_level: 0,            // 默认跟节点的等级
            prmNames: {
                page: "page",
                rows: "rows",
                sort: "sidx",
                order: "sord",
                search: "_search",
                nd: "nd",
                id: "id",
                oper: "oper",
                editoper: "edit",
                addoper: "add",
                deloper: "del",
                npage: null,
                totalrows: "totalrows"
            }, //内部用,单元格编辑的场景里面用到
            forceFit: false,
            gridstate: "visible",
            cellEdit: false,
            nv: 0,							// 内容用，功能不详 TODO ??
            toolbar: [false, ""],
            multiboxonly: false,
            deselectAfterSort: true,		//保留原选中记录
            scrollrows: true,
            autowidth: false,
            width: "100%",
            scrollOffset: 18,
            cellLayout: 5,
            multiselectWidth: 20,
            gridview: true,
            rownumWidth: 25,
            rownumbers: false,
            pagerpos: 'center',
            recordpos: 'right',
            footerrow: false,
            userDataOnFooter: false,
            hoverrows: true,
            resizeclass: '',				// 为列指定一个调整宽度时候的现实风格class,暂不放开
            autoencode: false,				// 单元格是否对html自动编码
            remapColumns: [],				// 内部用,在拖拽列的时候
            headertitles: true,
            data: [],
            _index: {},
            ignoreCase: false,				// 忽略大小写
            cmTemplate: {},
            idPrefix: "",					// 表格rowid值的前缀
            multiSort: false,
            cellAutoSave: true,
            leafChange: false,
            checkParent: false,
            checkChildren: false,
            treeDataFormat: 'child',
            showMask:false,//加载数据的时候允许出现loading遮罩
            fixWidth:false//用于隐藏列的时候不改变表格外层宽度
        },

        _getCreateOptions: function () {
            return $.jgrid.defaults;
        },

        _create: function () {
            var ts = this,//控件对象
                element = this.element[0],//表格整体
                $el = this.element,//表格整体的jquery形式
                p = this.options,//表格参数
                $tb;//表格核心的jquery形式
            ts.p = p;//别名p指向option
            if(!element.id) $el.uniqueId();//没有ID,生成一个
            ts.p.id = $.jgrid.jqID(element.id) ;//option 存入表格ID

            var grid = {
                headers: [],
                cols: [],
                footers: [],
                dragStart: function (i, x, y) {
                    var leftpos = $(ts.grid.hDiv).offset().left; //fix bootstrap css bug
                    this.resizing = {idx: i, startX: x.clientX - leftpos, sOL: x.clientX - leftpos};
                    this.hDiv.style.cursor = "col-resize";
                    this.curGbox = $("#rs_m" + ts.p.id, ts.element);
                    this.curGbox.css({display: "block", left: x.clientX - leftpos, top: y[1], height: y[2]});
                    ts._trigger("resizeStart", [x, i]);
                    document.onselectstart = function () {
                        return false;
                    };
                },
                dragMove: function (x) {
                    if (this.resizing) {
                        var leftpos = $(ts.grid.hDiv).offset().left; //fix bootstrap css bug
                        var diff = x.clientX - leftpos - this.resizing.startX,
                            h = this.headers[this.resizing.idx],
                            newWidth = h.width + diff, hn, nWn;
                        if (newWidth > 33) {
                            this.curGbox.css({left: this.resizing.sOL + diff});
                            if (p.forceFit === true) {
                                hn = this.headers[this.resizing.idx + p.nv];
                                nWn = hn.width - diff;
                                if (nWn > 33) {
                                    h.newWidth = newWidth;
                                    hn.newWidth = nWn;
                                }
                            } else {
                                this.newWidth = p.tblwidth + diff;
                                h.newWidth = newWidth;
                            }
                        }
                    }
                },
                dragEnd: function () {
                    this.hDiv.style.cursor = "default";
                    if (this.resizing) {
                        var idx = this.resizing.idx,
                            nw = this.headers[idx].newWidth || this.headers[idx].width;
                        nw = parseInt(nw, 10);
                        this.resizing = false;
                        $("#rs_m" + ts.p.id).css("display", "none");
                        p.colModel[idx].width = nw;
                        this.headers[idx].width = nw;
                        this.headers[idx].el.style.width = nw + "px";
                        this.cols[idx].style.width = nw + "px";
                        if (this.footers.length > 0) {
                            this.footers[idx].style.width = nw + "px";
                        }
                        if (p.forceFit === true) {
                            nw = this.headers[idx + p.nv].newWidth || this.headers[idx + p.nv].width;
                            this.headers[idx + p.nv].width = nw;
                            this.headers[idx + p.nv].el.style.width = nw + "px";
                            this.cols[idx + p.nv].style.width = nw + "px";
                            if (this.footers.length > 0) {
                                this.footers[idx + p.nv].style.width = nw + "px";
                            }
                            p.colModel[idx + p.nv].width = nw;
                        } else {
                            p.tblwidth = this.newWidth || p.tblwidth;
                            $('table:first', this.bDiv).css("width", p.tblwidth + "px");
                            $('table:first', this.hDiv).css("width", p.tblwidth + "px");
                            this.hDiv.scrollLeft = this.bDiv.scrollLeft;
                            if (p.footerrow) {
                                $('table:first', this.sDiv).css("width", p.tblwidth + "px");
                                this.sDiv.scrollLeft = this.bDiv.scrollLeft;
                            }
                        }
                        ts._trigger("resizeStop", [nw, idx]);
                    }
                    this.curGbox = null;
                    document.onselectstart = function () {
                        return true;
                    };
                },
                populateVisible: function () {
                    var dh = $(grid.bDiv).height();
                    if (!dh) {
                        return;
                    }
                    var table = $("table:first", grid.bDiv);
                    var rows, rh;
                    if (table[0].rows.length) {
                        try {
                            rows = table[0].rows[1];
                            rh = rows ? $(rows).outerHeight() || grid.prevRowHeight : grid.prevRowHeight;
                        } catch (pv) {
                            rh = grid.prevRowHeight;
                        }
                    }
                    if (!rh) {
                        return;
                    }
                    grid.prevRowHeight = rh;
                    var rn = p.rowNum;
                    var scrollTop = grid.scrollTop = grid.bDiv.scrollTop;
                    var ttop = Math.round(table.position().top) - scrollTop;
                    var tbot = ttop + table.height();
                    var div = rh * rn;
                    var page, npage, empty;
                    if (tbot < dh && ttop <= 0 &&
                        (p.lastpage === undefined || parseInt((tbot + scrollTop + div - 1) / div, 10) <= p.lastpage)) {
                        npage = parseInt((dh - tbot + div - 1) / div, 10);
                        if (tbot >= 0 || npage < 2 || p.scroll === true) {
                            page = Math.round((tbot + scrollTop) / div) + 1;
                            ttop = -1;
                        } else {
                            ttop = 1;
                        }
                    }
                    if (ttop > 0) {
                        page = parseInt(scrollTop / div, 10) + 1;
                        npage = parseInt((scrollTop + dh) / div, 10) + 2 - page;
                        empty = true;
                    }
                    if (npage) {
                        if (p.lastpage && (page > p.lastpage || p.lastpage === 1 || (page === p.page && page === p.lastpage))) {
                            return;
                        }
                        p.page = page;
                        if (empty) {
                            grid.selectionPreserver(table[0]);
                            ts.emptyRows(false, false);
                        }
                        ts.populate(npage);
                    }
                },
                scrollGrid: function (e) {
                    grid.hDiv.scrollLeft = grid.bDiv.scrollLeft;
                    if (p.footerrow) {
                        grid.sDiv.scrollLeft = grid.bDiv.scrollLeft;
                    }
                    if (e) {
                        e.stopPropagation();
                    }
                },
                selectionPreserver: function (ts) {
                    var p = ts.p,
                        sr = p.selrow, sra = p.selarrrow ? $.makeArray(p.selarrrow) : null,
                        left = ts.grid.bDiv.scrollLeft,
                        restoreSelection = function () {
                            var i;
                            p.selrow = null;
                            p.selarrrow = [];
                            if (p.multiselect && sra && sra.length > 0) {
                                for (i = 0; i < sra.length; i++) {
                                    if (sra[i] !== sr) {
                                        $(ts.element).jqGrid("setSelection", sra[i], false, null);
                                    }
                                }
                            }
                            if (sr) {
                                $(ts.element).jqGrid("setSelection", sr, false, null);
                            }
                            ts.grid.bDiv.scrollLeft = left;
                            $(ts).unbind('.selectionPreserver', restoreSelection);
                        };
                    ts._bind('gridComplete.selectionPreserver', restoreSelection);
                }
            };
            ts.grid = grid;
            var isMSIE = $.browser.msie;

            if (!p.height) {
                console.log("$el.parent().innerHeight:" + $el.parent().innerHeight());
                p.height = $el.height() || $el.parent().innerHeight();
                if(p.height< p.minHeight){
                    p.height = p.minHeight;
                }
            }

            p.useProp = !!$.fn.prop;
            var i;
            for (i = 0; i < p.colModel.length; i++) { //废弃colName属性,具体显示的值定义在colModel的label
                if(!p.colModel[i].label){
                    p.colModel[i].label = p.colModel[i].name;
                }
                if(!p.colModel[i].headertitle){
                    if(p.headertitles){
                        p.colModel[i].headertitle = $.jgrid.stripHtml(p.colModel[i].label);
                    }
                }
                if (p.colModel[i].resizable === undefined) {
                    p.colModel[i].resizable = true;
                }
                if (p.treeGrid){
                    p.colModel[i].sortable = false;
                }
            }
            // 新增ExpandColumn,ExpandColClick的别名 TODO 后续默认全部改成小写
            p.ExpandColumn = p.expandColumn || p.ExpandColumn;
            p.ExpandColClick = p.expandColClick || p.ExpandColClick;

            //opt
            if (p.multiselect) {
                p.colModel.unshift({
                    cb: true,
                    name: 'cb',
                    width: $.jgrid.cell_width ? p.multiselectWidth + p.cellLayout : p.multiselectWidth,
                    sortable: false,
                    resizable: false,
                    hidedlg: true,
                    search: false,
                    align: 'center',
                    fixed: true
                });
            }
            if (p.rownumbers) {
                p.colModel.unshift({
                    name: 'rn',
                    width: p.rownumWidth,
                    sortable: false,
                    resizable: false,
                    hidedlg: true,
                    search: false,
                    align: 'center',
                    fixed: true
                });
            }
            p.sortableCols === true ? p.sortable = true : "";

            // handlebarsopt
            var handlebarsOpt = {};
            $.extend(handlebarsOpt, p);
            handlebarsOpt.id = ts.p.id;
            handlebarsOpt.multiselect = !!p.multiselect;
            handlebarsOpt.isMSIE = isMSIE;
            //
            if (p.toolbar[0]) {
                if (p.toolbar[1] === 'top') handlebarsOpt.topbar = true;
                else if (p.toolbar[1] === 'bottom') handlebarsOpt.bottombar = true;
                else if (p.toolbar[1] === 'both') {
                    handlebarsOpt.bottombar = true;
                    handlebarsOpt.topbar = true;
                }
            }

            // 去除模板中的空白部分
            var tpl = $.jgrid.tpl.replace(/\>\s+\</g, "><").replace(/\>\s+\{\{/g, ">{{").replace(/\}\}\s+\</g, "}}<");
            var fhtml = Handlebars.compile(tpl)(handlebarsOpt);
            var $tmp = $(fhtml);
            $el.addClass($tmp[0].className).append($tmp.html());
            $tb = $("#btable_" + element.id);
            this.$tb = $tb;
            //修复高度,$el.outerHeight()中存在列头、分页栏及边框的高度
            p.height = p.height - ($el.outerHeight() - p.height);
            var $bDiv = $(".ui-jqgrid-bdiv", $el);
            var gridheight = isNaN(p.height) ? p.height : p.height + "px";
            $bDiv.css({height: gridheight});
            // add pager
            if (p.pager) {
                p.pager = "#" + ts.p.id + "_pager";
                p.rowNum = p.rowNum === MAXROWNUM ? 20 : p.rowNum; //分页情况下默认20条记录
            }

            if ($.inArray(ts.p.multikey, ["shiftKey", "altKey", "ctrlKey"]) === -1) {
                ts.p.multikey = false;
            }
            ts.p.keyIndex = false;
            ts.p.keyName = false;
            for (i = 0; i < ts.p.colModel.length; i++) {
                ts.p.colModel[i] = $.extend(true, {}, ts.p.cmTemplate, ts.p.colModel[i].template || {}, ts.p.colModel[i]);
                if (ts.p.keyIndex === false && ts.p.colModel[i].key === true) {
                    ts.p.keyIndex = i;
                    ts.p.keyName = ts.p.colModel[i].name;
                }
            }
            ts.p.sortorder = ts.p.sortorder.toLowerCase();
            $.jgrid.cell_width = $.jgrid.cellWidth();

            if (ts.p.treeGrid === true) {
                if(ts.p.keyName === false){
                    alert("treeGrid因为父子节点的关联，需要指定关联的列key=true");
                    return ;
                }
                ts.p.oldTreeData = ts.p.data;
                if (ts.p.treeDataFormat === "child") {//数据需要重组
                    ts.p.data = $.jgrid.childrenDataFormat(ts.p.data, ts.p.keyName);
                } else if (ts.p.treeDataFormat === "line") {
                    ts.p.data = $.jgrid.treeDataFormat(ts.p.data);
                }
                try {
                    $(ts.element).jqGrid("setTreeGrid");
                } catch (_) {
                }
            }

            // 如果没有设置keyName,则取localReader的配置
            if (ts.p.keyName === false) {
                ts.p.keyName = ts.p.datatype === "json"?ts.p.jsonReader.id:ts.p.localReader.id
            }

            var tdc, idn, w, res, sort,
                td, ptr, tbody, imgs, sortarr = [], sortord = [], sotmp = [];

            if (ts.p.shrinkToFit === true && ts.p.forceFit === true) {
                for (i = ts.p.colModel.length - 1; i >= 0; i--) {
                    if (!ts.p.colModel[i].hidden) {
                        ts.p.colModel[i].resizable = false;
                        break;
                    }
                }
            }

            if (ts.p.multiSort) {
                sortarr = ts.p.sortname.split(",");
                for (i = 0; i < sortarr.length; i++) {
                    sotmp = $.trim(sortarr[i]).split(" ");
                    sortarr[i] = $.trim(sotmp[0]);
                    sortord[i] = sotmp[1] ? $.trim(sotmp[1]) : ts.p.sortorder || "asc";
                }
            }


            for (i = 0; i < ts.p.colModel.length; i++) {
                if (!ts.p.colModel[i].width) {
                    ts.p.colModel[i].width = 150;
                }
                else {
                    ts.p.colModel[i].width = parseInt(ts.p.colModel[i].width, 10);
                }
                if (typeof ts.p.colModel[i].title !== "boolean") {
                    ts.p.colModel[i].title = true;
                }
                ts.p.colModel[i].lso = "";
                idn = ts.p.colModel[i].index || ts.p.colModel[i].name;
                if (idn === ts.p.sortname) {
                    ts.p.lastsort = i;
                }
                if (ts.p.multiSort) {
                    sotmp = $.inArray(idn, sortarr);
                    if (sotmp !== -1) {
                        ts.p.colModel[i].lso = sortord[sotmp];
                    }
                }
            }
            $("thead tr:first th", $tb).hover(function () {
                $(this).addClass('ui-state-hover');
            }, function () {
                $(this).removeClass('ui-state-hover');
            });
            if (ts.p.multiselect) {
                var emp = [], chk;
                $('#cb_' + ts.p.id, $el).bind('click', function () {
                    ts.p.selarrrow = [];
                    var froz = ts.p.frozenColumns === true ? ts.p.id + "_frozen" : "";
                    if (this.checked) {
                        $(ts.rows).each(function (i) {
                            if (i > 0) {
                                if (!$(this).hasClass("jqgroup") && !$(this).hasClass('ui-state-disabled')) {
                                    $("#jqg_" + ts.p.id + "_" + this.id)[ts.p.useProp ? 'prop' : 'attr']("checked", true);
                                    $(this).addClass("ui-state-highlight").attr("aria-selected", "true");
                                    ts.p.selarrrow.push(this.id);
                                    ts.p.selrow = this.id;
                                    if (froz) {
                                        $("#jqg_" + ts.p.id + "_" + this.id, ts.grid.fbDiv)[ts.p.useProp ? 'prop' : 'attr']("checked", true);
                                        $("#" + this.id, ts.grid.fbDiv).addClass("ui-state-highlight");
                                    }
                                }
                            }
                        });
                        chk = true;
                        emp = [];
                    }
                    else {
                        $(ts.rows).each(function (i) {
                            if (i > 0) {
                                if (!$(this).hasClass('ui-state-disabled')) {
                                    $("#jqg_" + ts.p.id + "_" + this.id)[ts.p.useProp ? 'prop' : 'attr']("checked", false);
                                    $(this).removeClass("ui-state-highlight").attr("aria-selected", "false");
                                    emp.push(this.id);
                                    if (froz) {
                                        $("#jqg_" + ts.p.id + "_" + this.id, ts.grid.fbDiv)[ts.p.useProp ? 'prop' : 'attr']("checked", false);
                                        $("#" + this.id, ts.grid.fbDiv).removeClass("ui-state-highlight");
                                    }
                                }
                            }
                        });
                        ts.p.selrow = null;
                        chk = false;
                    }
                    ts._trigger("onSelectAll", [chk ? ts.p.selarrrow : emp, chk]);
                });
            }
            if (ts.p.autowidth === true || ts.p.width === '100%') {
                if(ts.element.is("table")){
                    ts.element.css("width","100%");//table默认宽度不是100%
                }
                ts.p.autowidth = true;
                var pw = $el.innerWidth();
                ts.p.width = pw > 0 ? pw : 'nw';
            }

            ts.setColWidth();

            $("#gview_" + ts.p.id).css("width", grid.width + "px");
            $el.css("width", grid.width + "px");
            var tfoot = "";
            var thead = $("thead:first", $el),
                thr = $("tr:first", thead),
                tdr = $("tbody tr:first", $tb),
                ftd = null;
            ts.p.disableClick = false;
            $("th", thr).each(function (j) {

                ftd = tdr.find("td:eq(" + j + ")");
                w = ts.p.colModel[j].width;

                if (typeof ts.p.colModel[j].resizable === 'undefined') {
                    ts.p.colModel[j].resizable = true;
                }
                if (ts.p.colModel[j].resizable) {
                    $(this).addClass(ts.p.resizeclass);
                }

                $(this).css("width", w + "px");
                ftd.css("width", w + "px");
                if (ts.p.colModel[j].hidden) {
                    $(this).css("display", "none");
                    ftd.css("display", "none");
                }
                grid.headers[j] = {width: w, el: this};
                sort = ts.p.colModel[j].sortable;
                if (typeof sort !== 'boolean') {
                    ts.p.colModel[j].sortable = true;
                    sort = true;
                }
                var nm = ts.p.colModel[j].name;
                if (!(nm === 'cb' || nm === 'rn')) {
                    $(">div", this).addClass('ui-jqgrid-sortable');
                }
                if (sort) {
                    if (ts.p.multiSort) {
                        if (ts.p.colModel[j].lso) {
                            $("div span.s-ico", this).show();
                            $("div span.ui-icon-" + ts.p.colModel[j].lso, this).removeClass("ui-state-disabled");
                        }
                    } else {
                        if (j === ts.p.lastsort) {
                            $("div span.s-ico", this).show();
                            $("div span.ui-icon-" + ts.p.sortorder, this).removeClass("ui-state-disabled");
                        }
                    }
                }
                if (ts.p.footerrow) {
                    tfoot += "<td role='gridcell' " + ts.formatCol(j, 0, '', null, '', false) + ">&#160;</td>";
                }
            }).mousedown(function (e) {
                if ($(e.target).closest("th>span.ui-jqgrid-resize").length !== 1) {
                    return;
                }
                var ci = ts.getColumnHeaderIndex(this);
                if (ts.p.forceFit === true) {
                    ts.p.nv = ts.nextVisible(ci);
                }
                grid.dragStart(ci, e, ts.getOffset(ci));
                return false;
            }).click(function (e) {
                if (ts.p.disableClick) {
                    ts.p.disableClick = false;
                    return false;
                }
                var s = "th>div.ui-jqgrid-sortable", r, d;
                var t = $(e.target).closest(s);
                if (t.length !== 1) {
                    return;
                }
                var ci;
                if (ts.p.frozenColumns) {
                    var tid = $(this)[0].id.substring(ts.p.id.length + 1);
                    $(ts.p.colModel).each(function (i) {
                        if (this.name === tid) {
                            ci = i;
                            return false;
                        }
                    });
                } else {
                    ci = ts.getColumnHeaderIndex(this);
                }
                if (ci != null) {
                    ts.sortData($('div', this)[0].id, ci, r, d, this);
                }
                return false;
            });
            if (ts.p.sortable && $.fn.sortable) {
                try {
                    $(ts.element).jqGrid("sortableColumns", thr);
                } catch (e) {
                }
            }
            var hg = (ts.p.caption && ts.p.hiddengrid === true) ? true : false;
            $(".ui-jqgrid-htable", $el).css({width: ts.p.tblwidth + "px"});
            var $hDiv = $(".ui-jqgrid-hdiv", $el);
            grid.hDiv = $hDiv[0];
            $hDiv.css({width: grid.width + "px"});
            if (hg) {
                $hDiv.hide();
            }
            if (ts.p.pager) {
                // TBD -- escape ts.p.pager here?
                // if(typeof ts.p.pager === "string") {if(ts.p.pager.substr(0,1) !== "#") { ts.p.pager = "#"+ts.p.pager;} }
                // else { ts.p.pager = "#"+ $(ts.p.pager).attr("id");}
                $(ts.p.pager).css({width: grid.width + "px"});//.addClass('ui-state-default ui-jqgrid-pager ui-corner-bottom').appendTo(eg);
                if (hg) {
                    $(ts.p.pager).hide();
                }
                ts.setPager(ts.p.pager, '');
            }
            if (ts.p.cellEdit === false && ts.p.hoverrows === true) {
                $(ts).bind('mouseover', function (e) {
                    ptr = $(e.target).closest("tr.jqgrow");
                    $(ptr).addClass("ui-state-hover");
                }).bind('mouseout', function (e) {
                    ptr = $(e.target).closest("tr.jqgrow");
                    $(ptr).removeClass("ui-state-hover");
                });
            };

            var ri, ci, tdHtml;
            $tb.click(function (e) {
                td = e.target;
                ptr = $(td, ts.rows).closest("tr.jqgrow");
                if ($(ptr).length === 0 || ptr[0].className.indexOf('ui-state-disabled') > -1 || ($(td, ts.$tb).closest("table.ui-jqgrid-btable").attr('id') || '').replace("_frozen", "") !== "btable_" + ts.p.id) {
                    return this;
                }
                var scb = $(td).hasClass("cbox");
                if (!scb) {
                    var _cbox = $(td).children("input:first");
                    scb = $(td).children("input:first").hasClass("cbox");
                    if (!_cbox.attr("disabled")) //2014/8/25
                        _cbox[ts.p.useProp ? 'prop' : 'attr']("checked", !_cbox.is(":checked"));
                };

                var cSel = ts._trigger("beforeSelectRow", [ptr[0].id, e]);
                if (td.tagName === 'A' || ((td.tagName === 'INPUT' || td.tagName === 'TEXTAREA' || td.tagName === 'OPTION' || td.tagName === 'SELECT' ) && !scb)) {
                    return;
                }
                if (cSel !== false) {
                    ri = ptr[0].id;
                    ci = $.jgrid.getCellIndex(td);
                    tdHtml = $(td).closest("td,th").html();
                    ts._trigger("onCellSelect", [ri, ci, tdHtml, e]);
                    if (ts.p.cellEdit === true) {
                        if (ts.p.multiselect && scb) {
                            $(ts.element).jqGrid("setSelection", ri, true, e);
                        } else {
                            ri = ptr[0].rowIndex;
                            try {
                                $(ts.element).jqGrid("editCell", ri, ci, true);
                            } catch (_) {
                            }
                        }
                    } else if (!ts.p.multikey) {
                        if (ts.p.multiselect && ts.p.multiboxonly) {
                            if (scb) {
                                $(ts.element).jqGrid("setSelection", ri, true, e);
                            }
                            else {
                                var frz = ts.p.frozenColumns ? ts.p.id + "_frozen" : "";
                                $(ts.p.selarrrow).each(function (i, n) {
                                    var trid = $(ts.element).jqGrid('getGridRowById', n);
                                    $(trid).removeClass("ui-state-highlight");
                                    $("#jqg_" + ts.p.id + "_" + n)[ts.p.useProp ? 'prop' : 'attr']("checked", false);
                                    if (frz) {
                                        $("#" + n, "#" + frz).removeClass("ui-state-highlight");
                                        $("#jqg_" + ts.p.id + "_" + n, "#" + frz)[ts.p.useProp ? 'prop' : 'attr']("checked", false);
                                    }
                                });
                                ts.p.selarrrow = [];
                                $(ts.element).jqGrid("setSelection", ri, true, e);
                            }
                        } else {
                            $(ts.element).jqGrid("setSelection", ri, true, e);
                        }
                    } else {
                        if (e[ts.p.multikey]) {
                            $(ts.element).jqGrid("setSelection", ri, true, e);
                        } else if (ts.p.multiselect && scb) {
                            scb = $("#jqg_" + ts.p.id + "_" + ri).is(":checked");
                            $("#jqg_" + ts.p.id + "_" + ri)[ts.p.useProp ? 'prop' : 'attr']("checked", !scb);
                        }
                    }
                }
            }).dblclick(function (e) {
                td = e.target;
                ptr = $(td, ts.rows).closest("tr.jqgrow");
                if ($(ptr).length === 0) {
                    return;
                }
                ri = ptr[0].rowIndex;
                ci = $.jgrid.getCellIndex(td);
                ts._trigger("onDblClickRow", [$(ptr).attr("id"), ri, ci, e]);
            })
                .bind('contextmenu', function (e) {
                    td = e.target;
                    ptr = $(td, ts.rows).closest("tr.jqgrow");
                    if ($(ptr).length === 0) {
                        return;
                    }
                    if (!ts.p.multiselect) {
                        $(ts.element).jqGrid("setSelection", ptr[0].id, true, e);
                    }
                    ri = ptr[0].rowIndex;
                    ci = $.jgrid.getCellIndex(td);
                    ts._trigger("onRightClickRow", [$(ptr).attr("id"), ri, ci, e]);
                });

            $el.bind('reloadGrid', function (e, opts) {
                if (ts.p.treeGrid === true) {
                    ts.p.oldTreeData = ts.p.data;
                    if (ts.p.treeDataFormat === "child") {//数据需要重组
                        ts.p.data = $.jgrid.childrenDataFormat(ts.p.data, ts.p.keyName);
                    } else if (ts.p.treeDataFormat === "line") {
                        ts.p.data = $.jgrid.treeDataFormat(ts.p.data);
                    }
                }
                if (opts && opts.current) {
                    ts.grid.selectionPreserver(ts);
                }
                //if (ts.p.datatype === "local") {
                //    //$(ts.element).jqGrid("resetSelection");
                //    if (ts.p.data.length) {
                //        ts.refreshIndex();
                //    }
                //}
                //else
                if (!ts.p.treeGrid) {
                    ts.p.selrow = null;
                    if (ts.p.multiselect) {
                        ts.p.selarrrow = [];
                        ts.setHeadCheckBox(false);
                    }
                    ts.p.savedRow = [];
                }
                if (opts && opts.page) {
                    var page = opts.page;
                    if (page > ts.p.lastpage) {
                        page = ts.p.lastpage;
                    }
                    if (page < 1) {
                        page = 1;
                    }
                    ts.p.page = page;
                    if (ts.grid.prevRowHeight) {
                        ts.grid.bDiv.scrollTop = (page - 1) * ts.grid.prevRowHeight * ts.p.rowNum;
                    } else {
                        ts.grid.bDiv.scrollTop = 0;
                    }
                }
                ts.populate();
                return false;
            });
            if (isMSIE) {
                if (String(ts.p.height).toLowerCase() === "auto") {
                    ts.p.height = "100%";
                }
            }
            //移到前面处理 TODO ???
            grid.bDiv = $bDiv[0];
            $bDiv.css({width: (grid.width) + "px"})
                .scroll(grid.scrollGrid);

            $("table:first", $bDiv).css({width: ts.p.tblwidth + "px"});
            //修复单元格超长不换行的问题
            $(".ui-jqgrid-btable , .ui-jqgrid-htable", $el).css('table-layout', 'fixed');

            if (!$.support.tbody) { //IE
                if ($("tbody", $tb).length === 2) {
                    $("tbody:gt(0)", $tb).remove();
                }
            }
            if (ts.p.multikey) {
                if ($.browser.msie) {
                    $bDiv.bind("selectstart", function () {
                        return false;
                    });
                } else {
                    $bDiv.bind("mousedown", function () {
                        return false;
                    });
                }
            }
            if (hg) {
                $bDiv.hide();
            }

            if (ts.p.toolbar[0]) {
                if (hg) {
                    $(".ui-userdata", $el).hide();
                }
            }
            if (ts.p.toppager) {
                ts.p.toppager = ts.p.id + "_toppager";
                grid.topDiv = $("<div id='" + ts.p.toppager + "'></div>")[0];
                ts.p.toppager = "#" + ts.p.toppager;
                $(grid.topDiv).addClass('ui-jqgrid-toppager').width(grid.width).insertBefore(grid.hDiv);
                ts.setPager(ts.p.toppager, '_t');
            }
            if (ts.p.footerrow) {
                grid.sDiv = $(".ui-jqgrid-sdiv", $el)[0];
                $(grid.sDiv).width(grid.width - 2);
                $("table", grid.sDiv).width(ts.p.tblwidth);
                $(".footrow", grid.sDiv).html(tfoot);
                grid.footers = $(".ui-jqgrid-ftable", grid.sDiv)[0].rows[0].cells;
                // ----- 无法处理 2014/8/22
                $(grid.footers[0]).width($(grid.footers[0]).width() - 6);
                $(grid.footers[1]).width($(grid.footers[1]).width() - 3);
                //
                if (ts.p.rownumbers) {
                    grid.footers[0].className = 'jqgrid-rownum';
                }
                if (hg) {
                    $(grid.sDiv).hide();
                }
            }
            var hb = null;
            if (ts.p.caption) {
                //
                var $cDiv = $(".ui-jqgrid-titlebar", $el);
                grid.cDiv = $cDiv[0];
                $("a", $cDiv).hover(
                    function () {
                        $(this).addClass('ui-state-hover');
                    },
                    function () {
                        $(this).removeClass('ui-state-hover');
                    }
                ).css("right", "0px");

                var tdt = ts.p.datatype;
                if (ts.p.hidegrid === true) {
                    $(".ui-jqgrid-titlebar-close", grid.cDiv).click(function (e) {
                        var elems = ".ui-jqgrid-bdiv, .ui-jqgrid-hdiv, .ui-jqgrid-pager, .ui-jqgrid-sdiv ,.ui-userdata",
                            counter, self = this;
                        counter = $(elems, "#gview_" + ts.p.id).length;

                        if (ts.p.gridstate === 'visible') {
                            $(elems, ts.element).slideUp("fast", function () {
                                counter--;
                                if (counter === 0) {
                                    $("span", self).removeClass("ui-icon-circle-triangle-n").addClass("ui-icon-circle-triangle-s");
                                    ts.p.gridstate = 'hidden';
                                    if ($(ts.element).hasClass("ui-resizable")) {
                                        $(".ui-resizable-handle", ts.element).hide();
                                    }
                                    if (!hg) ts._trigger("onHeaderClick", [ts.p.gridstate, e]);
                                }
                            });
                        } else if (ts.p.gridstate === 'hidden') {
                            $(elems, ts.element).slideDown("fast", function () {
                                counter--;
                                if (counter === 0) {
                                    $("span", self).removeClass("ui-icon-circle-triangle-s").addClass("ui-icon-circle-triangle-n");
                                    if (hg) {
                                        ts.p.datatype = tdt;
                                        ts.populate();
                                        hg = false;
                                    }
                                    ts.p.gridstate = 'visible';
                                    if ($(ts.element).hasClass("ui-resizable")) {
                                        $(".ui-resizable-handle", ts.element).show();
                                    }
                                    if (!hg) ts._trigger("onHeaderClick", [ts.p.gridstate, e]);
                                }
                            });
                        }
                        return false;
                    });
                    if (hg) {
                        ts.p.datatype = "local";
                        $(".ui-jqgrid-titlebar-close", grid.cDiv).trigger("click");
                    }
                }
            }

            $(grid.hDiv).mousemove(function (e) {
                if (grid.resizing) {
                    grid.dragMove(e);
                    return false;
                }
            });
            $(".ui-jqgrid-labels", grid.hDiv).bind("selectstart", function () {
                return false;
            });
            $(document).bind("mouseup.jqGrid" + ts.p.id, function () {
                if (grid.resizing) {
                    grid.dragEnd();
                    return false;
                }
                return true;
            });

            //$.extend(ts.grid, {
            //    emptyRows: ts.emptyRows
            //});
            ts.rows = $tb[0].rows;
            ts.grid.cols = ts.rows[0].cells;
            ts._trigger("onInitGrid");
            ts.populate();
            ts.p.hiddengrid = false;
            ts.bindKeys();
        },
        //_trigger与_bind不做修改
        _trigger: function (type, data) {
            var ts = this,callback = ts.p[type];
            var res = this.element.triggerHandler(("grid" + type).toLowerCase(), data);//("grid"+type).toLowerCase()
            return !( $.isFunction(callback) &&
            callback.apply(ts, data || []) === false ||
            res === false );//这里写死控件名+:+事件名
        },
        //封装grid的事件绑定方法
        _bind: function (type, callback) {
            type = "grid" + type.toLowerCase();
            return this.element.bind(type, callback);
        },
        intNum: function (val, defval) {
            val = parseInt(val, 10);
            if (isNaN(val)) {
                return defval || 0;
            }
            return val;
        },
        formatCol: function (pos, rowInd, tv, rawObject, rowId, rdata) {
            var ts = this, cm = ts.p.colModel[pos],
                ral = cm.align, result = "style=\"", clas = cm.classes, nm = cm.name, celp, acp = [];
            if (ral) {
                result += "text-align:" + ral + ";";
            }
            if (cm.hidden === true) {
                result += "display:none;";
            }
            if (rowInd === 0) {
                result += "width: " + ts.grid.headers[pos].width + "px;";
            } else if (cm.cellattr && $.isFunction(cm.cellattr)) {
                celp = cm.cellattr.call(ts, rowId, tv, rawObject, cm, rdata);
                if (celp && typeof celp === "string") {
                    celp = celp.replace(/style/i, 'style').replace(/title/i, 'title');
                    if (celp.indexOf('title') > -1) {
                        cm.title = false;
                    }
                    if (celp.indexOf('class') > -1) {
                        clas = undefined;
                    }
                    acp = celp.replace('-style', '-sti').split(/style/);
                    if (acp.length === 2) {
                        acp[1] = $.trim(acp[1].replace('-sti', '-style').replace("=", ""));
                        if (acp[1].indexOf("'") === 0 || acp[1].indexOf('"') === 0) {
                            acp[1] = acp[1].substring(1);
                        }
                        result += acp[1].replace(/'/gi, '"');
                    } else {
                        result += "\"";
                    }
                }
            }
            if (!acp.length) {
                acp[0] = "";
                result += "\"";
            }
            result += (clas !== undefined ? (" class=\"" + clas + "\"") : "") + ((cm.title && tv) ? (" title=\"" + $.jgrid.stripHtml(tv) + "\"") : "");
            result += " aria-describedby=\"" + ts.p.id + "_" + nm + "\"";
            return result + acp[0];
        },
        cellVal: function (val) {
            var ts = this;
            return val == null || val === "" ? "&#160;" : (ts.p.autoencode ? $.jgrid.htmlEncode(val) : String(val));
        },
        formatter: function (rowId, cellval, colpos, rwdat, _act) {
            var ts = this;
            var cm = ts.p.colModel[colpos], v;
            if (cm.formatter !== undefined) {
                rowId = String(ts.p.idPrefix) !== "" ? $.jgrid.stripPref(ts.p.idPrefix, rowId) : rowId;
                var opts = {rowId: rowId, colModel: cm, gid: ts.p.id, pos: colpos};
                if ($.isFunction(cm.formatter)) {
                    v = cm.formatter.call(ts, cellval, opts, rwdat, _act);
                } else if ($.fmatter) {
                    v = $.fn.fmatter.call(ts, cm.formatter, cellval, opts, rwdat, _act);
                } else {
                    v = ts.cellVal(cellval);
                }
            } else {
                v = ts.cellVal(cellval);
            }
            return v;
        },
        addCell: function (rowId, cell, pos, irow, srvr, rdata) {
            var ts = this;
            var v, prp;
            v = ts.formatter(rowId, cell, pos, srvr, 'add');
            prp = ts.formatCol(pos, irow, v, srvr, rowId, rdata);
            return "<td role=\"gridcell\" " + prp + ">" + v + "</td>";
        },
        addMulti: function (rowid, pos, irow, checked) {
            var ts = this;
            var v = "<input role=\"checkbox\" type=\"checkbox\"" + " id=\"jqg_" + ts.p.id + "_" + rowid + "\" class=\"cbox\" name=\"jqg_" + ts.p.id + "_" + rowid + "\"" + (checked ? "checked=\"checked\"" : "") + "/>",
                prp = ts.formatCol(pos, irow, '', null, rowid, true);
            return "<td role=\"gridcell\" " + prp + ">" + v + "</td>";
        },
        addRowNum: function (pos, irow, pG, rN) {
            var ts = this;
            var v = (parseInt(pG, 10) - 1) * parseInt(rN, 10) + 1 + irow,
                prp = ts.formatCol(pos, irow, v, null, irow, true);
            return "<td role=\"gridcell\" class=\"jqgrid-rownum\" " + prp + ">" + v + "</td>";
        },
        reader: function (datatype) {
            var ts = this;
            var field, f = [], j = 0, i;
            for (i = 0; i < ts.p.colModel.length; i++) {
                field = ts.p.colModel[i];
                if (field.name !== 'cb' && field.name !== 'rn') {
                    f[j] = field.name;
                    j++;
                }
            }
            return f;
        },
        orderedCols: function (offset) {
            var ts = this;
            var order = ts.p.remapColumns;
            if (!order || !order.length) {
                order = $.map(ts.p.colModel, function (v, i) {
                    return i;
                });
            }
            if (offset) {
                order = $.map(order, function (v) {
                    return v < offset ? null : v - offset;
                });
            }
            return order;
        },
        emptyRows: function (scroll, locdata) {
            var firstrow;
            if (this.p.deepempty) {
                $(this.rows).slice(1).remove();
            } else {
                firstrow = this.rows.length > 0 ? this.rows[0] : null;
                $(this.$tb[0].children[0]).empty().append(firstrow);
            }
        },
        refreshIndex: function () {
            var ts = this;
            var datalen = ts.p.data.length, idname, i, val;
            idname = ts.p.keyName;
            for (i = 0; i < datalen; i++) {
                val = $.jgrid.getAccessor(ts.p.data[i], idname);
                if (val === undefined) {
                    //初始化数据不含有key的时候 2014/9/12
                    val = $.jgrid.randId();
                    ts.p.data[i][idname] = val;
                }
                ts.p._index[val] = i;
            }
        },
        constructTr: function (id, hide, altClass, rd, cur, selected) {
            var ts = this;
            var tabindex = '-1', restAttr = '', attrName, style = hide ? 'display:none;' : '',
                classes = 'jqgrow' + (altClass ? ' ' + altClass : '') + (selected ? ' ui-state-highlight' : ''),
                rowAttrObj = ts._trigger("rowAttr", [rd, cur, id]);
            if (typeof rowAttrObj !== "object") {
                rowAttrObj = $.isFunction(ts.p.rowattr) ? ts.p.rowattr.call(ts, rd, cur, id) : {};
            }
            if (!$.isEmptyObject(rowAttrObj)) {
                if (rowAttrObj.hasOwnProperty("id")) {
                    id = rowAttrObj.id;
                    delete rowAttrObj.id;
                }
                if (rowAttrObj.hasOwnProperty("tabindex")) {
                    tabindex = rowAttrObj.tabindex;
                    delete rowAttrObj.tabindex;
                }
                if (rowAttrObj.hasOwnProperty("style")) {
                    style += rowAttrObj.style;
                    delete rowAttrObj.style;
                }
                if (rowAttrObj.hasOwnProperty("class")) {
                    classes += ' ' + rowAttrObj['class'];
                    delete rowAttrObj['class'];
                }
                // dot't allow to change role attribute
                try {
                    delete rowAttrObj.role;
                } catch (ra) {
                }
                for (attrName in rowAttrObj) {
                    if (rowAttrObj.hasOwnProperty(attrName)) {
                        restAttr += ' ' + attrName + '=' + rowAttrObj[attrName];
                    }
                }
            }
            return '<tr role="row" id="' + id + '" tabindex="' + tabindex + '" class="' + classes + '"' +
                (style === '' ? '' : ' style="' + style + '"') + restAttr + '>';
        },
        addJSONData: function (data, t, rcnt, more, adjust) { //rcnt 在scroll中用,more指page>1
            var ts = this;
            var startReq = new Date();
            if (data) {
                if (ts.p.treeANode === -1 ) {//&& !ts.p.scroll
                    ts.emptyRows(false, true);
                    rcnt = 1;
                } else {
                    rcnt = rcnt > 1 ? rcnt : 1;
                }
            } else {
                return;
            }

            var dReader, frd, keyName = ts.p.keyName;

            if (ts.p.datatype === "json") {//json数据需重新装填
                ts.p.data = [];
                ts.p._index = {};
                dReader = ts.p.jsonReader;
                frd = 'json';
            } else {
                dReader = ts.p.localReader;
                frd = 'local';
            }
            ts.p.reccount = 0;

            var ir = 0, v, i, j, f = [], cur, gi = ts.p.multiselect ? 1 : 0, si = 0, ni = ts.p.rownumbers === true ? 1 : 0, arrayReader = ts.orderedCols(gi + ni), objectReader = ts.reader(frd), rowReader, len, drows, idn, rd = {}, fpos, idr, rowData = [], cn = (ts.p.altRows === true) ? ts.p.altclass : "", cn1;
            ts.p.page = ts.intNum($.jgrid.getAccessor(data, dReader.page), ts.p.page);
            ts.p.lastpage = ts.intNum($.jgrid.getAccessor(data, dReader.total), 1);
            ts.p.records = ts.intNum($.jgrid.getAccessor(data, dReader.records));
            ts.p.userData = $.jgrid.getAccessor(data, dReader.userdata) || {};
            idn = ts.p.keyName; //定死了
            if (!dReader.repeatitems) { //repeatitems json是true,local是false
                f = objectReader;
                if (f.length > 0 && !isNaN(idn)) {
                    idn = ts.p.keyName;
                }
            }
            drows = $.jgrid.getAccessor(data, dReader.root);
            //if (drows == null && $.isArray(data)) {
            //    drows = data;
            //}
            if (!drows) {
                drows = [];
            }
            len = drows.length;
            i = 0;
            if (len > 0 && ts.p.page <= 0) {
                ts.p.page = 1;
            }
            var rn = parseInt(ts.p.rowNum, 10),
            // br=ts.p.scroll?$.jgrid.randId():1,
                altr, selected = false, selr;
            if (adjust) {
                rn *= adjust + 1;
            }
            if (ts.p.datatype === "local" && !ts.p.deselectAfterSort) {
                selected = true;
            }
            var grpdata = [], hiderow = false;

            while (i < len) {
                cur = drows[i];
                idr = $.jgrid.getAccessor(cur, idn);
                if (idr === undefined) {
                    idr = $.jgrid.randId();
                }
                idr = ts.p.idPrefix + idr;
                altr = rcnt === 1 ? 0 : rcnt;
                cn1 = (altr + i) % 2 === 1 ? cn : '';
                if (selected) {
                    if (ts.p.multiselect) {
                        selr = ($.inArray(idr, ts.p.selarrrow) !== -1);
                    } else {
                        selr = (idr === ts.p.selrow);
                    }
                }
                var iStartTrTag = rowData.length;
                rowData.push("");
                if (ni) {
                    rowData.push(ts.addRowNum(0, i, ts.p.page, ts.p.rowNum));
                }
                if (gi) {
                    rowData.push(ts.addMulti(idr, ni, i, selr));
                }
                rowReader = objectReader;
                if (dReader.repeatitems) {
                    if (dReader.cell) {
                        cur = $.jgrid.getAccessor(cur, dReader.cell) || cur;
                    }
                    if ($.isArray(cur)) {
                        rowReader = arrayReader;
                    }
                }
                for (j = 0; j < rowReader.length; j++) {
                    v = $.jgrid.getAccessor(cur, rowReader[j]);
                    rd[ts.p.colModel[j + gi + ni].name] = v;
                    rowData.push(ts.addCell(idr, v, j + gi + ni, i + rcnt, cur, rd));
                }
                rowData[iStartTrTag] = ts.constructTr(idr, hiderow, cn1, rd, cur, selr);
                rowData.push("</tr>");

                if (ts.p.datatype === "json") {//填充JSON格式数据
                    rd[keyName] = $.jgrid.stripPref(ts.p.idPrefix, idr);
                    ts.p.data.push(rd);
                    ts.p._index[rd[keyName]] = ts.p.data.length - 1;
                }
                if (ts.p.gridview === false) {
                    $("#" + ts.p.id + " tbody:first").append(rowData.join(''));
                    ts._trigger("afterInsertRow", [idr, rd, cur]);
                    rowData = [];//ari=0;
                }
                rd = {};
                ir++;
                i++;
                if (ir === rn) {
                    break;
                }
            }
            if (ts.p.gridview === true) {
                fpos = ts.p.treeANode > -1 ? ts.p.treeANode : 0;

                if (ts.p.treeGrid === true && fpos > 0) {
                    $(ts.rows[fpos]).after(rowData.join(''));
                } else {
                    $("#" + ts.p.id + " tbody:first").append(rowData.join(''));
                }
            }
            ts.p.totaltime = new Date() - startReq;
            if (ir > 0) {
                if (ts.p.records === 0) {
                    ts.p.records = len;
                }
            }
            rowData = null;
            if (ts.p.treeGrid === true) {
                try {
                    $(ts.element).jqGrid("setTreeNode", fpos + 1, ir + fpos + 1);
                } catch (e) {
                }
            }
            if (!ts.p.treeGrid ) {//&& !ts.p.scroll
                ts.grid.bDiv.scrollTop = 0;
            }
            ts.p.reccount = ir;
            ts.p.treeANode = -1;
            if (ts.p.userDataOnFooter) {
                $(ts.element).jqGrid("footerData", "set", ts.p.userData, true);
            }
            //if (locdata && !ts.p.server) { //服务器端json格式数据不需要设置
            //    ts.p.records = len;
            //    ts.p.lastpage = Math.ceil(len / rn);
            //}
            if (!more) {
                ts.updatepager(false, true);
            }
            if (ts.p.datatype === "json") {
                while (ir < len && drows[ir]) {
                    cur = drows[ir];
                    idr = $.jgrid.getAccessor(cur, idn);
                    if (idr === undefined) {
                        idr = $.jgrid.randId();
                        if (f.length === 0) {
                            if (dReader.cell) {
                                var ccur2 = $.jgrid.getAccessor(cur, dReader.cell) || cur;
                                idr = ccur2 != null && ccur2[idn] !== undefined ? ccur2[idn] : idr;
                                ccur2 = null;
                            }
                        }
                    }
                    if (cur) {
                        idr = ts.p.idPrefix + idr;
                        rowReader = objectReader;
                        if (dReader.repeatitems) {
                            if (dReader.cell) {
                                cur = $.jgrid.getAccessor(cur, dReader.cell) || cur;
                            }
                            if ($.isArray(cur)) {
                                rowReader = arrayReader;
                            }
                        }

                        for (j = 0; j < rowReader.length; j++) {
                            rd[ts.p.colModel[j + gi + ni].name] = $.jgrid.getAccessor(cur, rowReader[j]);
                        }
                        rd[keyName] = $.jgrid.stripPref(ts.p.idPrefix, idr);
                        ts.p.data.push(rd);
                        ts.p._index[rd[keyName]] = ts.p.data.length - 1;
                        rd = {};
                    }
                    ir++;
                }
            }
        },
        addLocalData: function () {
            var ts = this;
            var st = ts.p.multiSort ? [] : "", sto = [], fndsort = false, cmtypes = {}, grtypes = [], grindexes = [], srcformat, sorttype, newformat;
            if (!$.isArray(ts.p.data)) {
                return;
            } else {
                ts.refreshIndex();
            }
            $.each(ts.p.colModel, function () {
                sorttype = this.sorttype || "text";
                if (sorttype === "date" || sorttype === "datetime") {
                    if (this.formatter && typeof this.formatter === 'string' && this.formatter === 'date') {
                        if (this.formatoptions && this.formatoptions.srcformat) {
                            srcformat = this.formatoptions.srcformat;
                        } else {
                            srcformat = $.jgrid.formatter.date.srcformat;
                        }
                        if (this.formatoptions && this.formatoptions.newformat) {
                            newformat = this.formatoptions.newformat;
                        } else {
                            newformat = $.jgrid.formatter.date.newformat;
                        }
                    } else {
                        srcformat = newformat = this.datefmt || "Y-m-d";
                    }
                    cmtypes[this.name] = {"stype": sorttype, "srcfmt": srcformat, "newfmt": newformat};
                } else {
                    cmtypes[this.name] = {"stype": sorttype, "srcfmt": '', "newfmt": ''};
                }
                if (ts.p.multiSort) {
                    if (this.lso) {
                        st.push(this.name);
                        var tmplso = this.lso.split("-");
                        sto.push(tmplso[tmplso.length - 1]);
                    }
                } else {
                    if (!fndsort && (this.index === ts.p.sortname || this.name === ts.p.sortname)) {
                        st = this.name; // ???
                        fndsort = true;
                    }
                }
            });
            var compareFnMap = {
                    'eq': function (queryObj) {
                        return queryObj.equals;
                    },
                    'ne': function (queryObj) {
                        return queryObj.notEquals;
                    },
                    'lt': function (queryObj) {
                        return queryObj.less;
                    },
                    'le': function (queryObj) {
                        return queryObj.lessOrEquals;
                    },
                    'gt': function (queryObj) {
                        return queryObj.greater;
                    },
                    'ge': function (queryObj) {
                        return queryObj.greaterOrEquals;
                    },
                    'cn': function (queryObj) {
                        return queryObj.contains;
                    },
                    'nc': function (queryObj, op) {
                        return op === "OR" ? queryObj.orNot().contains : queryObj.andNot().contains;
                    },
                    'bw': function (queryObj) {
                        return queryObj.startsWith;
                    },
                    'bn': function (queryObj, op) {
                        return op === "OR" ? queryObj.orNot().startsWith : queryObj.andNot().startsWith;
                    },
                    'en': function (queryObj, op) {
                        return op === "OR" ? queryObj.orNot().endsWith : queryObj.andNot().endsWith;
                    },
                    'ew': function (queryObj) {
                        return queryObj.endsWith;
                    },
                    'ni': function (queryObj, op) {
                        return op === "OR" ? queryObj.orNot().equals : queryObj.andNot().equals;
                    },
                    'in': function (queryObj) {
                        return queryObj.equals;
                    },
                    'nu': function (queryObj) {
                        return queryObj.isNull;
                    },
                    'nn': function (queryObj, op) {
                        return op === "OR" ? queryObj.orNot().isNull : queryObj.andNot().isNull;
                    }

                },
                query = $.jgrid.from(ts.p.data);
            if (ts.p.ignoreCase) {
                query = query.ignoreCase();
            }
            function tojLinq(group) {
                var s = 0, index, gor, ror, opr, rule;
                if (group.groups != null) {
                    gor = group.groups.length && group.groupOp.toString().toUpperCase() === "OR";
                    if (gor) {
                        query.orBegin();
                    }
                    for (index = 0; index < group.groups.length; index++) {
                        if (s > 0 && gor) {
                            query.or();
                        }
                        try {
                            tojLinq(group.groups[index]);
                        } catch (e) {
                            alert(e);
                        }
                        s++;
                    }
                    if (gor) {
                        query.orEnd();
                    }
                }
                if (group.rules != null) {
                    //if(s>0) {
                    //	var result = query.select();
                    //	query = $.jgrid.from( result);
                    //	if (ts.p.ignoreCase) { query = query.ignoreCase(); }
                    //}
                    try {
                        ror = group.rules.length && group.groupOp.toString().toUpperCase() === "OR";
                        if (ror) {
                            query.orBegin();
                        }
                        for (index = 0; index < group.rules.length; index++) {
                            rule = group.rules[index];
                            opr = group.groupOp.toString().toUpperCase();
                            if (compareFnMap[rule.op] && rule.field) {
                                if (s > 0 && opr && opr === "OR") {
                                    query = query.or();
                                }
                                query = compareFnMap[rule.op](query, opr)(rule.field, rule.data, cmtypes[rule.field]);
                            }
                            s++;
                        }
                        if (ror) {
                            query.orEnd();
                        }
                    } catch (g) {
                        alert(g);
                    }
                }
            }

            if (ts.p.search === true) {
                var srules = ts.p.postData.filters;
                if (srules) {
                    if (typeof srules === "string") {
                        srules = $.jgrid.parse(srules);
                    }
                    tojLinq(srules);
                } else {
                    try {
                        query = compareFnMap[ts.p.postData.searchOper](query)(ts.p.postData.searchField, ts.p.postData.searchString, cmtypes[ts.p.postData.searchField]);
                    } catch (se) {
                    }
                }
            }
            if (ts.p.multiSort) {
                $.each(st, function (i) {
                    query.orderBy(this, sto[i], cmtypes[this].stype, cmtypes[this].srcfmt);
                });
            } else {
                if (st && ts.p.sortorder && fndsort) {
                    if (ts.p.sortorder.toUpperCase() === "DESC") {
                        query.orderBy(ts.p.sortname, "d", cmtypes[st].stype, cmtypes[st].srcfmt);
                    } else {
                        query.orderBy(ts.p.sortname, "a", cmtypes[st].stype, cmtypes[st].srcfmt);
                    }
                }
            }
            var queryResults = query.select(),
                recordsperpage = parseInt(ts.p.rowNum, 10),
                total = queryResults.length,
                page = parseInt(ts.p.page, 10),
                totalpages = Math.ceil(total / recordsperpage),
                retresult = {};
            queryResults = queryResults.slice((page - 1) * recordsperpage, page * recordsperpage);
            query = null;
            cmtypes = null;
            retresult[ts.p.localReader.total] = totalpages;
            retresult[ts.p.localReader.page] = page;
            retresult[ts.p.localReader.records] = total;
            retresult[ts.p.localReader.root] = queryResults;
            retresult[ts.p.localReader.userdata] = ts.p.userData;
            queryResults = null;
            return retresult;
        },
        updatepager: function (rn, dnd) {
            var ts = this;
            var cp, last, base, from, to, tot, fmt, pgboxes = "", sppg,
                tspg = ts.p.pager ? "_" + ts.p.pager.substr(1) : "",
                tspg_t = ts.p.toppager ? "_" + ts.p.toppager.substr(1) : "";
            base = parseInt(ts.p.page, 10) - 1;
            if (base < 0) {
                base = 0;
            }
            base = base * parseInt(ts.p.rowNum, 10);
            to = base + ts.p.reccount;
            pgboxes = ts.p.pager || "";
            pgboxes += ts.p.toppager ? (pgboxes ? "," + ts.p.toppager : ts.p.toppager) : "";
            if (pgboxes) {
                fmt = $.jgrid.formatter.integer || {};
                cp = ts.intNum(ts.p.page);
                last = ts.intNum(ts.p.lastpage);
                // if(ts.p.reccount > 0 && last === 0) last = ts.p.lastpage = 1;
                $(".selbox", pgboxes)[this.p.useProp ? 'prop' : 'attr']("disabled", false);
                if (ts.p.pginput === true) {
                    $('.ui-pg-input', pgboxes).val(ts.p.page);
                    sppg = ts.p.toppager ? '#sp_1' + tspg + ",#sp_1" + tspg_t : '#sp_1' + tspg;
                    $(sppg).html($.fmatter ? $.fmatter.util.NumberFormat(ts.p.lastpage, fmt) : ts.p.lastpage);
                }
                if (ts.p.viewrecords) {
                    if (ts.p.reccount === 0) {
                        $(".ui-paging-info", pgboxes).html(ts.p.emptyrecords);
                    } else {
                        from = base + 1;
                        tot = ts.p.records;
                        if ($.fmatter) {
                            from = $.fmatter.util.NumberFormat(from, fmt);
                            to = $.fmatter.util.NumberFormat(to, fmt);
                            tot = $.fmatter.util.NumberFormat(tot, fmt);
                        }
                        $(".ui-paging-info", pgboxes).html($.jgrid.format(ts.p.recordtext, from, to, tot));
                    }
                }
                if (ts.p.pgbuttons === true) {
                    if (cp <= 0) {
                        cp = last = 0;
                    }
                    if (cp === 1 || cp === 0) {
                        $("#first" + tspg + ", #prev" + tspg).addClass('ui-state-disabled').removeClass('ui-state-hover');
                        if (ts.p.toppager) {
                            $("#first_t" + tspg_t + ", #prev_t" + tspg_t).addClass('ui-state-disabled').removeClass('ui-state-hover');
                        }
                    } else {
                        $("#first" + tspg + ", #prev" + tspg).removeClass('ui-state-disabled');
                        if (ts.p.toppager) {
                            $("#first_t" + tspg_t + ", #prev_t" + tspg_t).removeClass('ui-state-disabled');
                        }
                    }
                    if (cp === last || cp === 0) {
                        $("#next" + tspg + ", #last" + tspg).addClass('ui-state-disabled').removeClass('ui-state-hover');
                        if (ts.p.toppager) {
                            $("#next_t" + tspg_t + ", #last_t" + tspg_t).addClass('ui-state-disabled').removeClass('ui-state-hover');
                        }
                    } else {
                        $("#next" + tspg + ", #last" + tspg).removeClass('ui-state-disabled');
                        if (ts.p.toppager) {
                            $("#next_t" + tspg_t + ", #last_t" + tspg_t).removeClass('ui-state-disabled');
                        }
                    }
                } else {
                    $(".ui-pg-table", pgboxes).hide();
                }
            }
            if (rn === true && ts.p.rownumbers === true) {
                $(">td.jqgrid-rownum", ts.rows).each(function (i) {
                    $(this).html(base + 1 + i);
                });
            }
            if (dnd && ts.p.jqgdnd) {
                $(ts.element).jqGrid('gridDnD', 'updateDnD');
            }
            ts._trigger("gridComplete");
        },
        //内部加载表格数据用
        populate: function (npage) {
            var ts = this;
            if(this.p.showMask && $.blockUI){
                $(this.element).blockUI();
                _.delay(function(){
                    ts._populate(npage);
                    $(ts.element).unblockUI();
                }, 0)
            }else{
                ts._populate(npage);
            }

        },
        //内部加载表格数据用
        _populate: function (npage) {
            var ts = this;
            var dt, dstr;
            if (ts.p.page <= 0) {
                ts.p.page = Math.min(1, ts.p.lastpage);
            }
            var adjust = 0;
            dt = ts.p.datatype.toLowerCase();
            switch (dt) {
                case "json":
                    //服务器端数据,p.data在服务器端,index?
                    //if (typeof ts.p.data === 'string') {
                    //    dstr = $.jgrid.parse(ts.p.data);
                    //}
                    //else {
                        dstr = ts.p.data;
                    //}
                    ts.addJSONData(dstr, ts.grid.bDiv);
                    ts._trigger("afterGridComplete");
                    //ts.p.datatype = "local";
                    break;
                case "local":
                    //本地数据,p.data在客户端,需刷新index,分页排序
                    //ts.p.datatype = "local";
                    var req = ts.addLocalData();
                    ts.addJSONData(req, ts.grid.bDiv);
                    ts._trigger("afterGridComplete");
                    break;
            }
        },
        setHeadCheckBox: function (checked) {
            var ts = this;
            $('#cb_' + ts.p.id, ts.grid.hDiv)[ts.p.useProp ? 'prop' : 'attr']("checked", checked);
            var fid = ts.p.frozenColumns ? ts.p.id + "_frozen" : "";
            if (fid) {
                $('#cb_' + ts.p.id, ts.grid.fhDiv)[ts.p.useProp ? 'prop' : 'attr']("checked", checked);
            }
        },
        //特殊处理服务器分页的情况,分页、排序需要重取服务端数据
        populatePage: function () {
            var ts = this;
            if (ts.p.datatype === "json") {
                var ret = [];
                if ($.isFunction(ts.p.pageData)) {
                    ts.p.data = ts.p.pageData.call(ts, ts.p.page, ts.p.sortname, ts.p.sortorder);
                } else {//基本不会走到
                    alert("please support pageData function to fetch per page data!");
                    return false;
                }
                //ts.addJSONData(ret, ts.grid.bDiv);
                //return false;
            }
            ts.populate();
        },
        setPager: function (pgid, tp) {
            // TBD - consider escaping pgid with pgid = $.jgrid.jqID(pgid);
            var ts = this;
            var str = "", pgcnt, twd, tdw, i,
                clearVals = function (onpaging) {
                    var ret;
                    ret = ts._trigger('onPaging', [onpaging]);
                    if (ret === false) {
                        return false;
                    }
                    ts.p.selrow = null;
                    if (ts.p.multiselect) {
                        ts.p.selarrrow = [];
                        ts.setHeadCheckBox(false);
                    }
                    ts.p.savedRow = [];
                    return true;
                };

            //左移右移4个按钮不支持
            pgid = pgid.substr(1);
            tp += "_" + pgid; //toppager 暂不支持
            pgcnt = "pg_" + pgid;

            if (ts.p.pginput === true) {
                $(".ui-pg-input", "#" + pgcnt).replaceWith($.jgrid.format(ts.p.pgtext || "", "<input class='ui-pg-input' type='text' size='2' maxlength='7' value='0' role='textbox'/>", "<span id='sp_1_" + pgid + "'></span>"));
            }
            tdw = $(".ui-jqgrid").css("font-size") || "11px";
            $(document.body).append("<div id='testpg' class='ui-jqgrid' style='font-size:" + tdw + ";visibility:hidden;' ></div>");
            twd = $("td#" + pgid + "_" + ts.p.pagerpos + ">:first-child").clone().appendTo("#testpg").width();
            $("#testpg").remove();
            if (twd > 0) {
                if ($("#sp_1_" + pgid).length > 0) {
                    twd += 50;
                }
                // if(pginp !== "") { twd += 50; } //should be param
                $("td#" + pgid + "_" + ts.p.pagerpos, "#" + pgcnt).width(twd);
            }
            ts.p._nvtd = [];
            ts.p._nvtd[0] = twd ? Math.floor((ts.p.width - twd) / 2) : Math.floor(ts.p.width / 3);
            ts.p._nvtd[1] = 0;

            if (ts.p.pgbuttons === true) {
                $(".ui-pg-button", "#" + pgcnt).hover(function () {
                    if ($(this).hasClass('ui-state-disabled')) {
                        this.style.cursor = 'default';
                    } else {
                        $(this).addClass('ui-state-hover');
                        this.style.cursor = 'pointer';
                    }
                }, function () {
                    if (!$(this).hasClass('ui-state-disabled')) {
                        $(this).removeClass('ui-state-hover');
                        this.style.cursor = "default";
                    }
                });
                $("#first" + tp + ", #prev" + tp + ", #next" + tp + ", #last" + tp).click(function () {
                    var cp = ts.intNum(ts.p.page, 1),
                        last = ts.intNum(ts.p.lastpage, 1), selclick = false,
                        fp = true, pp = true, np = true, lp = true;
                    if (last === 0 || last === 1) {
                        fp = false;
                        pp = false;
                        np = false;
                        lp = false;
                    }
                    else if (last > 1 && cp >= 1) {
                        if (cp === 1) {
                            fp = false;
                            pp = false;
                        }
                        //else if( cp>1 && cp <last){ }
                        else if (cp === last) {
                            np = false;
                            lp = false;
                        }
                    } else if (last > 1 && cp === 0) {
                        np = false;
                        lp = false;
                        cp = last - 1;
                    }
                    var opt = this.id.substring(0, this.id.length - tp.length);
                    if (!clearVals(opt)) {
                        return false;
                    }
                    if (this.id === 'first' + tp && fp) {
                        ts.p.page = 1;
                        selclick = true;
                    }
                    if (this.id === 'prev' + tp && pp) {
                        ts.p.page = (cp - 1);
                        selclick = true;
                    }
                    if (this.id === 'next' + tp && np) {
                        ts.p.page = (cp + 1);
                        selclick = true;
                    }
                    if (this.id === 'last' + tp && lp) {
                        ts.p.page = last;
                        selclick = true;
                    }
                    if (selclick) {
                        ts.populatePage()
                    }
                    return false;
                });
            }
            if (ts.p.pginput === true) { //TODO 输出的值不在范围内的情况
                $('input.ui-pg-input', "#" + pgcnt).keypress(function (e) {
                    var key = e.charCode || e.keyCode || 0;
                    if (key === 13) {
                        if (!clearVals('user')) {
                            return false;
                        }
                        $(this).val(ts.intNum($(this).val(), 1));
                        ts.p.page = ($(this).val() > 0) ? $(this).val() : ts.p.page;
                        ts.populatePage()
                        return false;
                    }
                    return this;
                });
            }
        },
        multiSort: function (iCol, obj) {
            var ts = this;
            var splas, sort = "", cm = ts.p.colModel, fs = false, ls,
                selTh = ts.p.frozenColumns ? obj : ts.grid.headers[iCol].el, so = "";
            $("span.ui-grid-ico-sort", selTh).addClass('ui-state-disabled');
            $(selTh).attr("aria-selected", "false");

            if (cm[iCol].lso) {
                if (cm[iCol].lso === "asc") {
                    cm[iCol].lso += "-desc";
                    so = "desc";
                } else if (cm[iCol].lso === "desc") {
                    cm[iCol].lso += "-asc";
                    so = "asc";
                } else if (cm[iCol].lso === "asc-desc" || cm[iCol].lso === "desc-asc") {
                    cm[iCol].lso = "";
                }
            } else {
                cm[iCol].lso = so = cm[iCol].firstsortorder || 'asc';
            }
            if (so) {
                $("span.s-ico", selTh).show();
                $("span.ui-icon-" + so, selTh).removeClass('ui-state-disabled');
                $(selTh).attr("aria-selected", "true");
            } else {
                $("span.s-ico", selTh).hide();
            }
            ts.p.sortorder = "";
            $.each(cm, function (i) {
                if (this.lso) {
                    if (i > 0 && fs) {
                        sort += ", ";
                    }
                    splas = this.lso.split("-");
                    sort += cm[i].index || cm[i].name;
                    sort += " " + splas[splas.length - 1];
                    fs = true;
                    ts.p.sortorder = splas[splas.length - 1];
                }
            });
            ls = sort.lastIndexOf(ts.p.sortorder);
            sort = sort.substring(0, ls);
            ts.p.sortname = sort;
        },
        sortData: function (index, idxcol, reload, sor, obj) {
            var ts = this;
            if (!ts.p.colModel[idxcol].sortable) {
                return;
            }
            if (ts.p.savedRow.length > 0) {
                return;
            }
            if (!reload) {
                if (ts.p.lastsort === idxcol) {
                    if (ts.p.sortorder === 'asc') {
                        ts.p.sortorder = 'desc';
                    } else if (ts.p.sortorder === 'desc') {
                        ts.p.sortorder = 'asc';
                    }
                } else {
                    ts.p.sortorder = ts.p.colModel[idxcol].firstsortorder || 'asc';
                }
                ts.p.page = 1;
            }
            if (ts.p.multiSort) {
                ts.multiSort(idxcol, obj);
            } else {
                if (sor) {
                    if (ts.p.lastsort === idxcol && ts.p.sortorder === sor && !reload) {
                        return;
                    }
                    ts.p.sortorder = sor;
                }
                var previousSelectedTh = ts.grid.headers[ts.p.lastsort].el, newSelectedTh = ts.p.frozenColumns ? obj : ts.grid.headers[idxcol].el;

                $("span.ui-grid-ico-sort", previousSelectedTh).addClass('ui-state-disabled');
                $(previousSelectedTh).attr("aria-selected", "false");
                if (ts.p.frozenColumns) {
                    ts.grid.fhDiv.find("span.ui-grid-ico-sort").addClass('ui-state-disabled');
                    ts.grid.fhDiv.find("th").attr("aria-selected", "false");
                }
                $("span.ui-icon-" + ts.p.sortorder, newSelectedTh).removeClass('ui-state-disabled');
                $(newSelectedTh).attr("aria-selected", "true");
                if (ts.p.lastsort !== idxcol) {
                    if (ts.p.frozenColumns) {
                        ts.grid.fhDiv.find("span.s-ico").hide();
                    }
                    $("span.s-ico", previousSelectedTh).hide();
                    $("span.s-ico", newSelectedTh).show();
                }
                index = index.substring(5 + ts.p.id.length + 1); // bad to be changed!?!
                ts.p.sortname = ts.p.colModel[idxcol].index || index;
            }
            if (ts._trigger("onSortCol", [ts.p.sortname, idxcol, ts.p.sortorder]) === false) {
                ts.p.lastsort = idxcol;
                return;
            }
            if (ts.p.datatype === "local") {
                if (ts.p.deselectAfterSort) {
                    $(ts.element).jqGrid("resetSelection");
                }
            } else {
                ts.p.selrow = null;
                if (ts.p.multiselect) {
                    ts.setHeadCheckBox(false);
                }
                ts.p.selarrrow = [];
                ts.p.savedRow = [];
            }
            ts.populatePage();
            ts.p.lastsort = idxcol;
            if (ts.p.sortname !== index && idxcol) {
                ts.p.lastsort = idxcol;
            }
        },
        setColWidth: function () {
            var ts = this, grid = ts.grid;
            var initwidth = 0, brd = $.jgrid.cell_width ? 0 : ts.intNum(ts.p.cellLayout, 0), vc = 0, lvc, scw = ts.intNum(ts.p.scrollOffset, 0), cw, hs = false, aw, gw = 0, cr;
            $.each(ts.p.colModel, function () {
                if (this.hidden === undefined) {
                    this.hidden = false;
                }
                this.widthOrg = cw = ts.intNum(this.width, 0);
                if (this.hidden === false) {
                    initwidth += cw + brd;
                    if (this.fixed) {
                        gw += cw + brd;
                    } else {
                        vc++;
                    }
                }
            });
            if (isNaN(ts.p.width)) {
                ts.p.width = initwidth + ((ts.p.shrinkToFit === false && !isNaN(ts.p.height)) ? scw : 0);
            }
            grid.width = ts.p.width;
            ts.p.tblwidth = initwidth;
            if (ts.p.shrinkToFit === false && ts.p.forceFit === true) {
                ts.p.forceFit = false;
            }
            if (ts.p.shrinkToFit === true && vc > 0) {
                aw = grid.width - brd * vc - gw;
                if (!isNaN(ts.p.height)) {
                    aw -= scw;
                    hs = true;
                }
                aw -= 1;
                initwidth = 0;
                $.each(ts.p.colModel, function (i) {
                    if (this.hidden === false && !this.fixed) {
                        cw = Math.round(aw * this.width / (ts.p.tblwidth - brd * vc - gw));
                        this.width = cw;
                        initwidth += cw;
                        lvc = i;
                    }
                });
                cr = 0;
                if (hs) {
                    if (grid.width - gw - (initwidth + brd * vc) !== scw) {
                        cr = grid.width - gw - (initwidth + brd * vc) - scw;
                    }
                } else if (!hs && Math.abs(grid.width - gw - (initwidth + brd * vc)) !== 1) {
                    cr = grid.width - gw - (initwidth + brd * vc);
                }
                ts.p.colModel[lvc].width += (cr - 1);
                ts.p.tblwidth = initwidth + (cr - 1) + brd * vc + gw;
                if (ts.p.tblwidth > ts.p.width) {
                    ts.p.colModel[lvc].width -= (ts.p.tblwidth - parseInt(ts.p.width, 10));
                    ts.p.tblwidth = ts.p.width;
                }
            }
        },
        nextVisible: function (iCol) {
            var ts = this;
            var ret = iCol, j = iCol, i;
            for (i = iCol + 1; i < ts.p.colModel.length; i++) {
                if (ts.p.colModel[i].hidden !== true) {
                    j = i;
                    break;
                }
            }
            return j - ret;
        },
        getOffset: function (iCol) {
            var ts = this;
            var $th = $(ts.grid.headers[iCol].el), ret = [$th.position().left + $th.outerWidth()];
            ret[0] -= ts.grid.bDiv.scrollLeft;
            ret.push($(ts.grid.hDiv).position().top);
            ret.push($(ts.grid.bDiv).offset().top - $(ts.grid.hDiv).offset().top + $(ts.grid.bDiv).height());
            return ret;
        },
        getColumnHeaderIndex: function (th) {
            var ts = this;
            var i, headers = ts.grid.headers, ci = $.jgrid.getCellIndex(th);
            for (i = 0; i < headers.length; i++) {
                if (th === headers[i].el) {
                    ci = i;
                    break;
                }
            }
            return ci;
        },

        /**
         * 获取参数数据.
         * 此方法非常有用，可以获取很多需要的东西,如page当前页,rowNum每页记录数,records记录总数等等
         * <pre>
         *        var dataLength = $("#gridBase").jqGrid("getGridParam","records记录总数等等");
         * </pre>
         * @param  {string} pName 参数的key值
         * @return {Object}       返回参数key值对应的值value
         */
        getGridParam: function (pName) {
            var ts = this;
            if (!ts || !ts.grid) {
                return;
            }
            if (!pName) {
                return ts.p;
            }
            return ts.p[pName] !== undefined ? ts.p[pName] : null;
        },
        /**
         * 设置参数数据，此方法非常有用，可以动态的改变表格行为，如重载表格数据等等
         * @param {Object} newParams 新的键值对，会覆盖原有的参数数据
         */
        setGridParam: function (newParams) {
            if (this.grid && typeof newParams === 'object') {
                $.extend(true, this.p, newParams);
            }
        },
        /**
         * 获取界面的行元素
         * @param  {string} rowid 行标识
         * @return {Object}    返回行标识对应的dom节点
         */
        getGridRowById: function (rowid) {
            var row;
            try {
                row = this.rows.namedItem(rowid);
            } catch (e) {
                row = $(this.grid.bDiv).find("#" + rowid);
            }
            return row;
        },
        /**
         * 获取所有行唯一标识
         * @return {Array} 返回rowid的集合
         */
        getDataIDs: function () {
            var ids = [], i = 0, len, j = 0;
            len = this.rows.length;
            if (len && len > 0) {
                while (i < len) {
                    if ($(this.rows[i]).hasClass('jqgrow')) {
                        ids[j] = this.rows[i].id;
                        j++;
                    }
                    i++;
                }
            }
            return ids;
        },
        /**
         * 获取多选模式下选中的记录
         * @return {Array} 打勾的记录
         */
        getCheckRows: function () {
            var rows = [];
            var ts = this, index;
            var selarrrow = ts.p.selarrrow;
            for (var i = 0; i < selarrrow.length; i++) {
                rows.push(ts.p.data[ts.p._index[selarrrow[i]]]);
            }
            return rows;
        },
        /**
         * 禁用,启用多个复选框
         * @param {Array} selarrrow 目标行的标识集合;也可以是行序列号,从0开始
         * @param {Boolean} flag true表示禁用,false表示取消禁用
         */
        setCheckDisabled: function (selarrrow, flag) {
            var ts = this, rowid, $row;
            if ($.isArray(selarrrow)) {
                for (var i = 0; i < selarrrow.length; i++) {
                    rowid = selarrrow[i];
                    $row = $("#" + rowid, ts.element);
                    if (!$row[0] && typeof rowid === 'number') { //如果id找不到,则当做行数序号来取
                        $row = $($(ts.element).find("tr.jqgrow")[rowid]);
                    }
                    $row.find("input[type='checkbox']").attr("disabled", flag);
                    flag ? $row.addClass('ui-state-disabled') : $row.removeClass('ui-state-disabled');
                }
            } else {
                rowid = selarrrow;
                $row = $("#" + rowid, ts.element);
                if (!$row[0] && typeof rowid === 'number') { //如果id找不到,则当做行数序号来取
                    $row = $($(ts.element).find("tr.jqgrow")[rowid]);
                }
                $row.find("input[type='checkbox']").attr("disabled", flag);
                flag ? $row.addClass('ui-state-disabled') : $row.removeClass('ui-state-disabled');
            }
        },
        /**
         * 禁用,启用全部复选框
         * @param {Boolean} flag true表示禁用复选框功能，false表示取消禁用复选框功能
         */
        setAllCheckDisabled: function (flag) {
            $("#gview_" + this.p.id).find("input[type='checkbox']").attr("disabled", flag);
            flag ? $("#gview_" + this.p.id).find(".jqgrow").addClass('ui-state-disabled') : $("#gview_" + this.p.id).find(".jqgrow").removeClass('ui-state-disabled');
        },
        /**
         * 实现多选模式下表格的全选,清空,反选功能
         * @param {Boolean} [flag] 为空默认反选,true表示全选,false表示清空
         */
        setAllCheckRows: function (flag) {
            var ts = this;
            if (flag !== false && flag !== true) {
                flag = !$("#cb_" + ts.p.id).attr("checked");
            }
            $("#cb_" + ts.p.id).attr("checked", flag).trigger("click").attr("checked", flag);
            return this;
        },

        /**
         * 设置，取消，反选多选记录
         * @param {Array} selarrrow 目标行的标识集合;也可以是行序列号,从0开始
         * @param {Boolean} [flag] 为空默认反选,true表示全选,false表示清空
         */
        setCheckRows: function (selarrrow, flag) {
            var ts = this, _flag, rowid, ia;
            for (var i = 0; i < selarrrow.length; i++) {
                rowid = selarrrow[i];
                //如果id找不到,则当做行数序号来取
                if (!$("#" + rowid, ts)[0] && typeof rowid === 'number') {
                    rowid = $(ts.element).find("tr.jqgrow")[rowid].id;
                }
                ia = $.inArray(rowid, ts.p.selarrrow); //原为(非)选中状态
                if (flag === true || flag === false) { //如果不定义flag参数，则进行反选操作
                    _flag = flag;
                } else {
                    _flag = ia === -1 ? true : false;
                }
                if (_flag === false && ia !== -1) {//原为选中状态且现要求取消选中
                    $(ts.element).jqGrid("setSelection", rowid);
                } else if (_flag === true && ia === -1) { //原为非选中状态且现要求选中
                    $(ts.element).jqGrid("setSelection", rowid);
                }
            }
        },
        /**
         * 获取选中行记录
         * @return {Object} 返回选中行的记录
         */
        getSelection: function () {
            var row = {};
            var ts = this;
            row = $(ts.element).jqGrid("getRowData", ts.p.selrow);
            return row;
        },
        /**
         * 设置行选中
         * @param {string} rowid 行标识;也可以是行号,从0开始;也可以是行数据对象
         * @param {boolean} onsr 是否触发行选中的事件onSelectRow
         */
        setSelection: function (selection, onsr, e) {
            var ts = this, stat, pt, ner, ia, tpsr, fid;
            if (selection === undefined) {
                return;
            }
            if ($.type(selection) === 'object') {
                selection = selection [ts.p.keyName];
            }
            onsr = onsr === false ? false : true;
            pt = $(ts.element).jqGrid('getGridRowById', selection);
            if (!pt && typeof selection === 'number') { //如果id找不到,则当做行数序号来取
                pt = $(ts.element).find("tr.jqgrow")[selection];
                selection = pt.id;
            }
            if (!pt || !pt.className || pt.className.indexOf('ui-state-disabled') > -1) {
                return;
            }
            function scrGrid(iR) {
                var ch = $(ts.grid.bDiv)[0].clientHeight,
                    st = $(ts.grid.bDiv)[0].scrollTop,
                    rpos = $(ts.rows[iR]).position().top,
                    rh = ts.rows[iR].clientHeight;
                if (rpos + rh >= ch + st) {
                    $(ts.grid.bDiv)[0].scrollTop = rpos - (ch + st) + rh + st;
                }
                else if (rpos < ch + st) {
                    if (rpos < st) {
                        $(ts.grid.bDiv)[0].scrollTop = rpos;
                    }
                }
            }


            function childrenNodeChecked(node) {
                var checkflag = false;
                var result = $(ts).jqGrid("getFullTreeNode", node);
                result.splice(0, 1);
                $(result).each(function (i) {
                    ia = $.inArray(result[i][ts.p.keyName] + "", ts.p.selarrrow);
                    if (ia !== -1) {
                        checkflag = true;
                        return false;
                    }
                });
                return checkflag;
            }

            function cascadeChecked(stat) {
                var pos = ts.p._index[ts.p.selrow];
                var rowData = ts.p.data[pos];
                var rowid, result;
                if (ts.p.checkChildren) {
                    result = $(ts.element).jqGrid("getFullTreeNode", rowData);
                    result.splice(0, 1);
                    $(result).each(function (i) {
                        rowid = result[i][ts.p.keyName] + "";
                        ia = $.inArray(rowid, ts.p.selarrrow);
                        if (ia === -1 && stat) {
                            $($(ts.element).jqGrid('getGridRowById', rowid)).addClass("ui-state-highlight").attr("aria-selected", "true");
                            ts.p.selarrrow.push(rowid);
                        } else if (ia !== -1 && !stat) {
                            $($(ts.element).jqGrid('getGridRowById', rowid)).removeClass("ui-state-highlight").attr({"aria-selected": "false"});
                            ts.p.selarrrow.splice(ia, 1);
                        }
                        $("#jqg_" + ts.p.id + "_" + rowid).attr("checked", stat);

                    });
                }
                if (ts.p.checkParent) {
                    result = $(ts.element).jqGrid("getNodeAncestors", rowData);
                    $(result).each(function (i) {
                        if (!stat && childrenNodeChecked(result[i])) return false;//首先判断result[i]有没有子节点选中,有则跳出
                        rowid = result[i][ts.p.keyName] + "";
                        ia = $.inArray(rowid, ts.p.selarrrow);
                        if (ia === -1 && stat) {
                            $("#jqg_" + ts.p.id + "_" + rowid).attr("checked", stat);
                            ts.p.selarrrow.push(rowid);
                        }
                        if (ia !== -1 && !stat) {
                            $("#jqg_" + ts.p.id + "_" + rowid).attr("checked", stat);
                            ts.p.selarrrow.splice(ia, 1);
                        }
                    });
                }
            }


            if (ts.p.scrollrows === true) {
                ner = $(ts.element).jqGrid('getGridRowById', selection).rowIndex;
                if (ner >= 0) {
                    scrGrid(ner);
                }
            }
            if (ts.p.frozenColumns === true) {
                fid = ts.p.id + "_frozen";
            }
            if (!ts.p.multiselect) {
                if (ts.p.selrow !== pt.id) {
                    $($(ts.element).jqGrid('getGridRowById', ts.p.selrow)).removeClass("ui-state-highlight").attr({
                        "aria-selected": "false",
                        "tabindex": "-1"
                    });
                    $(pt).addClass("ui-state-highlight").attr({"aria-selected": "true", "tabindex": "0"});//.focus();
                    if (fid) {
                        $("#" + ts.p.selrow, "#" + fid).removeClass("ui-state-highlight");
                        $("#" + selection, "#" + fid).addClass("ui-state-highlight");
                    }
                    stat = true;
                } else {
                    stat = false;
                }
                ts.p.selrow = pt.id;
                if (onsr) {
                    ts._trigger("onSelectRow", [pt.id, stat, e]);
                    // 提供changerow事件,方便使用者不需要通过stat判断是不是选中的同一行
                    if (stat) {
                        ts._trigger("onChangeRow", [pt.id, e]);
                    }
                }
            } else {
                //unselect selectall checkbox when deselecting a specific row
                ts.setHeadCheckBox(false);
                ts.p.selrow = pt.id;
                ia = $.inArray(ts.p.selrow, ts.p.selarrrow);
                if (ia === -1) {
                    $(pt).addClass("ui-state-highlight").attr("aria-selected", "true");
                    stat = true;
                    ts.p.selarrrow.push(ts.p.selrow);
                    if (ts.p.treeGrid) cascadeChecked(stat);
                } else {
                    $(pt).removeClass("ui-state-highlight").attr("aria-selected", "false");
                    stat = false;
                    ts.p.selarrrow.splice(ia, 1);
                    if (ts.p.treeGrid) cascadeChecked(stat);
                    if (ts.p.selarrrow.length > 0) {
                        ts.p.selrow = ts.p.selarrrow[ts.p.selarrrow.length - 1];//保留上一次点击记录
                    }
                    tpsr = ts.p.selarrrow[0];
                    ts.p.selrow = (tpsr === undefined) ? null : tpsr;
                }
                $("#jqg_" + ts.p.id + "_" + pt.id)[ts.p.useProp ? 'prop' : 'attr']("checked", stat);
                if (fid) {
                    if (ia === -1) {
                        $("#" + selection, "#" + fid).addClass("ui-state-highlight");
                    } else {
                        $("#" + selection, "#" + fid).removeClass("ui-state-highlight");
                    }
                    $("#jqg_" + ts.p.id + "_" + selection, "#" + fid)[ts.p.useProp ? 'prop' : 'attr']("checked", stat);
                }
                if (onsr) {
                    ts._trigger("onSelectRow", [pt.id, stat, e]);
                }
            }
        },
        /**
         * 取消行选中，如果没有行标识参数则可以取消所有行的选中状态
         * @param  {string} rowid (optional) 行标识
         */
        resetSelection: function (rowid) {
            var ts = this, sr, fid;
            if (ts.p.frozenColumns === true) {
                fid = ts.p.id + "_frozen";
            }
            if (rowid !== undefined) {
                sr = rowid === ts.p.selrow ? ts.p.selrow : rowid;
                $("#" + ts.p.id + " tbody:first tr#" + sr).removeClass("ui-state-highlight").attr("aria-selected", "false");
                if (fid) {
                    $("#" + sr, "#" + fid).removeClass("ui-state-highlight");
                }
                if (ts.p.multiselect) {
                    $("#jqg_" + ts.p.id + "_" + sr, "#" + ts.p.id)[ts.p.useProp ? 'prop' : 'attr']("checked", false);
                    if (fid) {
                        $("#jqg_" + ts.p.id + "_" + sr, "#" + fid)[ts.p.useProp ? 'prop' : 'attr']("checked", false);
                    }
                    ts.setHeadCheckBox(false);
                }
                sr = null;
            } else if (!ts.p.multiselect) {
                if (ts.p.selrow) {
                    $("#" + ts.p.id + " tbody:first tr#" + ts.p.selrow).removeClass("ui-state-highlight").attr("aria-selected", "false");
                    if (fid) {
                        $("#" + ts.p.selrow, "#" + fid).removeClass("ui-state-highlight");
                    }
                    ts.p.selrow = null;
                }
            } else {
                $(ts.p.selarrrow).each(function (i, n) {
                    $($(ts.element).jqGrid('getGridRowById', n)).removeClass("ui-state-highlight").attr("aria-selected", "false");
                    $("#jqg_" + ts.p.id + "_" + n)[ts.p.useProp ? 'prop' : 'attr']("checked", false);
                    if (fid) {
                        $("#" + n, "#" + fid).removeClass("ui-state-highlight");
                        $("#jqg_" + ts.p.id + "_" + n, "#" + fid)[ts.p.useProp ? 'prop' : 'attr']("checked", false);
                    }
                });
                ts.setHeadCheckBox(false);
                ts.p.selarrrow = [];
            }
            if (ts.p.cellEdit === true) {
                if (parseInt(ts.p.iCol, 10) >= 0 && parseInt(ts.p.iRow, 10) >= 0) {
                    $("td:eq(" + ts.p.iCol + ")", ts.rows[ts.p.iRow]).removeClass("edit-cell ui-state-highlight");
                    $(ts.rows[ts.p.iRow]).removeClass("selected-row ui-state-hover");
                }
            }
            ts.p.savedRow = [];
        },
        /**
         * 通过数据对象获取行标识rowid
         * @param  {Object} data 行数据对象
         * @return {String} 如果配置了列的key属性,则此值返回data[key对应的列名];否则返回由表格自动生成的标识
         */
        getRowid: function (data) {
            var res;
            if (data === undefined) {
                return res;
            }
            var ts = this;
            res = data[ts.p.keyName];
            return res;
        },
        /**
         * 获取表格对象的行标识名称
         * @return {String} 如果配置了列的key属性,则返回此列列名,否则返回表格默认的key值名称.
         * 默认取值"_id_".可以通过设置初始化对象localReader.id改变默认的key值名字.
         */
        getKeyName: function () {
            var keyName;
            var ts = this;
            keyName = ts.p.keyName;
            return keyName;
        },
        /**
         * 获取表格单个或者全部数据 TODO 此方法需要修改,可接受rowid数组
         * @param  {string} rowid (optional) 表格行记录的唯一标识，可为空
         * @return {Object} 如果参数rowid为空，返回整个记录数组，否则只返回rowid对应的那条记录数据
         */
        getRowData: function (rowid) {
            var ts = this;
            if (rowid === undefined) {
                return ts.p.data;
            } else {
                var index = ts.p._index[rowid];
                return isNaN(index)?{}:ts.p.data[ts.p._index[rowid]];
            }
        },
        /**
         * 删除行记录
         * @param  {string} rowid 行标识,也可以是行对象
         * @return {boolean}       是否删除成功
         */
        delRowData: function (rowid) {
            var success = false, rowInd, ia;
            var ts = this;
            //如果rowid是对象,则说明参数没有rowid
            if ($.type(rowid) === 'object') {
                rowid = rowid[ts.p.keyName];
            }
            rowInd = $(ts.element).jqGrid('getGridRowById', rowid);
            if (!rowInd) {
                return false;
            }
            $(rowInd).remove();
            ts.p.records--;
            ts.p.reccount--;
            ts.updatepager(true, false);
            success = true;
            if (ts.p.multiselect) {
                ia = $.inArray(rowid, ts.p.selarrrow);
                if (ia !== -1) {
                    ts.p.selarrrow.splice(ia, 1);
                }
            }
            if (ts.p.multiselect && ts.p.selarrrow.length > 0) {
                ts.p.selrow = ts.p.selarrrow[ts.p.selarrrow.length - 1];
            } else {
                ts.p.selrow = null;
            }
            if (ts.p.datatype === 'local') {
                var id = $.jgrid.stripPref(ts.p.idPrefix, rowid),
                    pos = ts.p._index[id];
                if (pos !== undefined) {
                    ts.p.data.splice(pos, 1);
                    ts.refreshIndex();
                }
            }
            if (ts.p.altRows === true && success) {
                var cn = ts.p.altclass;
                $(ts.rows).each(function (i) {
                    if (i % 2 === 1) {
                        $(this).addClass(cn);
                    }
                    else {
                        $(this).removeClass(cn);
                    }
                });
            }
            return success;
        },
        /**
         * 修改行数据,目前不接受rowid值的修改
         * @param {string} rowid 行标识,此参数也可以是行数据,会自动取数据的key值作为rowid
         * @param {Object} [data]  修改后的内容,对象会进行深拷贝替换掉原来的值
         * @param {string} [cssp]  修改后的行样式，可以是class，也可以是css对象
         * @return {boolean} 是否修改成功
         */
        setRowData: function (rowid, data, cssp) {
            var nm, success = true, title;
            if (!this.grid) {
                return false;
            }
            var ts = this, vl, ind, cp = typeof cssp, lcdata = {};
            //如果rowid是对象,则说明参数没有rowid
            if (typeof rowid === 'object') {
                cssp = data;
                data = rowid;
                rowid = data[ts.p.keyName];
            }
            ind = $(ts.element).jqGrid('getGridRowById', rowid);
            if (!ind) {
                return false;
            }
            if (data) {
                try {
                    $(ts.p.colModel).each(function (i) {
                        nm = this.name;
                        var dval = $.jgrid.getAccessor(data, nm);
                        if (dval !== undefined) {
                            lcdata[nm] = this.formatter && typeof this.formatter === 'string' && this.formatter === 'date' ? $.unformat.date.call(ts, dval, this) : dval;
                            vl = ts.formatter(rowid, dval, i, data, 'edit');
                            title = this.title ? {"title": $.jgrid.stripHtml(vl)} : {};
                            if (ts.p.treeGrid === true && nm === ts.p.ExpandColumn) {
                                $("td[role='gridcell']:eq(" + i + ") > span:first", ind).html(vl).attr(title);
                            } else {
                                $("td[role='gridcell']:eq(" + i + ")", ind).html(vl).attr(title);
                            }
                        }
                    });
                    if (ts.p.datatype === 'local') {
                        var id = $.jgrid.stripPref(ts.p.idPrefix, rowid),
                            pos = ts.p._index[id], key;
                        if (ts.p.treeGrid) {
                            for (key in ts.p.treeReader) {
                                if (ts.p.treeReader.hasOwnProperty(key)) {
                                    delete lcdata[ts.p.treeReader[key]];
                                }
                            }
                        }
                        if (pos !== undefined) {
                            ts.p.data[pos] = $.extend(false, ts.p.data[pos], data);//lcdata
                        }
                        lcdata = null;
                    }
                } catch (e) {
                    success = false;
                }
            }
            if (success) {
                if (cp === 'string') {
                    $(ind).addClass(cssp);
                } else if (cp === 'object') {
                    $(ind).css(cssp);
                }
                ts._trigger("afterGridComplete");
            }
            return success;
        },
        /**
         * 新增数据，可以指定新增的位置
         * @param {string} rowid 行标识,此参数也可以是行数据,会自动取数据的key值作为rowid;
         * @param {Object} [rdata] 行数据,也可以是数据数组
         * @param {string} [pos]   数据新增的位置，默认是last，可选值有first、last，after和before则需要参考src参数
         * @param {string} [src]   新增位置的参考标识
         * @return {boolean} 是否新增成功
         */
        addRowData: function (rowid, rdata, pos, src) {
            var ts = this;
            //如果rowid是对象,则说明参数没有rowid
            if (typeof rowid === 'object') {
                src = pos;
                pos = rdata;
                rdata = rowid;
                rowid = undefined;
            }
            if (!pos) {
                pos = "last";
            }
            var success = false, nm, row, gi, ni, sind, i, v, prp = "", aradd, cnm, cn, data, cm, id;
            if (rdata) {
                if ($.isArray(rdata)) {
                    aradd = true;
                    // pos = "last";
                    cnm = rowid || ts.p.keyName;
                } else {
                    rdata = [rdata];
                    aradd = false;
                }
                var datalen = rdata.length;
                ni = ts.p.rownumbers === true ? 1 : 0;
                gi = ts.p.multiselect === true ? 1 : 0;
                if (!aradd) {
                    if (rowid !== undefined) {
                        rowid = String(rowid);
                    } else {
                        rowid = $.jgrid.randId();
                        cnm = ts.p.keyName;
                        if (rdata[0][cnm] !== undefined) {
                            rowid = rdata[0][cnm];
                        }
                        //如果
                        else rdata[0][cnm] = rowid;
                        // if(t.p.keyIndex !== false) {
                        // 	cnm = t.p.colModel[t.p.keyIndex+gi+ni].name; //实际上就是t.p.keyName
                        // 	if(rdata[0][cnm] !== undefined) { rowid = rdata[0][cnm]; }
                        // }
                    }
                }
                cn = ts.p.altclass;
                var k = 0, cna = "", lcdata = {};
                // air = $.isFunction(t.p.afterInsertRow) ? true : false;
                while (k < datalen) {
                    data = rdata[k];
                    row = [];
                    if (aradd) {
                        try {
                            rowid = data[cnm];
                            if (rowid === undefined) {
                                rowid = $.jgrid.randId();
                                data[cnm] = rowid;
                            }
                        }
                        catch (e) {
                            rowid = $.jgrid.randId();
                        }
                        cna = ts.p.altRows === true ? (t.rows.length - 1) % 2 === 0 ? cn : "" : "";
                    }
                    id = rowid;
                    rowid = ts.p.idPrefix + rowid;
                    if (ni) {
                        prp = ts.formatCol(0, 1, '', null, rowid, true);
                        row[row.length] = "<td role=\"gridcell\" class=\"jqgrid-rownum\" " + prp + ">0</td>";
                    }
                    if (gi) {
                        v = "<input role=\"checkbox\" type=\"checkbox\"" + " id=\"jqg_" + ts.p.id + "_" + rowid + "\" class=\"cbox\"/>";
                        prp = ts.formatCol(ni, 1, '', null, rowid, true);
                        row[row.length] = "<td role=\"gridcell\" " + prp + ">" + v + "</td>";
                    }
                    for (i = gi + ni; i < ts.p.colModel.length; i++) {
                        cm = ts.p.colModel[i];
                        nm = cm.name;
                        lcdata[nm] = data[nm];
                        v = ts.formatter(rowid, $.jgrid.getAccessor(data, nm), i, data);
                        prp = ts.formatCol(i, 1, v, data, rowid, lcdata);
                        row[row.length] = "<td role=\"gridcell\" " + prp + ">" + v + "</td>";
                    }
                    row.unshift(ts.constructTr(rowid, false, cna, lcdata, data, false));
                    row[row.length] = "</tr>";
                    if (ts.rows.length === 0) {
                        $("table:first", ts.grid.bDiv).append(row.join(''));
                    } else {
                        switch (pos) {
                            case 'last':
                                $(ts.rows[ts.rows.length - 1]).after(row.join(''));
                                sind = ts.rows.length - 1;
                                break;
                            case 'first':
                                $(ts.rows[0]).after(row.join(''));
                                sind = 1;
                                break;
                            case 'after':
                                sind = $(ts.element).jqGrid('getGridRowById', src);
                                if (sind) {
                                    $(sind).after(row.join(''));
                                    sind = sind.rowIndex + 1;
                                }
                                break;
                            case 'before':
                                sind = $(ts.element).jqGrid('getGridRowById', src);
                                if (sind) {
                                    $(sind).before(row.join(''));
                                    sind = sind.rowIndex - 1;
                                }
                                break;
                        }
                    }
                    ts.p.records++;
                    ts.p.reccount++;
                    ts._trigger("afterInsertRow", [rowid, data, data]);
                    // if(air) { ts.p.afterInsertRow.call(t,rowid,data,data); }
                    k++;
                    if (ts.p.datatype === 'local') {
                        lcdata[ts.p.keyName] = id;
                        ts.p._index[id] = ts.p.data.length;
                        //ts.p.data.push(lcdata);
                        if (pos && src) {//2012-5-22 新增节点的数据插入到对应的节点处,以免刷新的时候会换位置
                            var parentindex = ts.p._index[src];
                            var newdata = [];
                            for (var i = 0; i < ts.p.data.length; i++) {
                                if (pos == 'before') {
                                    if (parentindex == i) newdata.push(data);//lcdata
                                }
                                newdata.push(ts.p.data[i]);
                                if (pos == 'after') {
                                    if (parentindex == i) newdata.push(data);//lcdata
                                }
                            }
                            ts.p.data = newdata;
                            ts.refreshIndex();
                        } else {
                            ts.p.data.push(data);//lcdata
                        }
                        lcdata = {};
                    }
                    if (pos == 'after') { //修复批量新增子节点顺序的问题
                        src = id;
                    }
                }
                if (ts.p.altRows === true && !aradd) {
                    if (pos === "last") {
                        if ((ts.rows.length - 1) % 2 === 1) {
                            $(ts.rows[ts.rows.length - 1]).addClass(cn);
                        }
                    } else {
                        $(t.rows).each(function (i) {
                            if (i % 2 === 1) {
                                $(this).addClass(cn);
                            }
                            else {
                                $(this).removeClass(cn);
                            }
                        });
                    }
                }
                ts.updatepager(true, true);
                success = true;
            }
            return success;
        },
        /**
         * 在含有footerrow的场景下，可以获取或设置底部的值
         * @param  {String} action set or get
         * @param  {Object} data   如果是set方式,则此参数就是设置进去的值
         */
        footerData: function (action, data, format) {
            var nm, success = false, res = {}, title;

            function isEmpty(obj) {
                var i;
                for (i in obj) {
                    if (obj.hasOwnProperty(i)) {
                        return false;
                    }
                }
                return true;
            }

            if (action === undefined) {
                action = "get";
            }
            if (typeof format !== "boolean") {
                format = true;
            }
            action = action.toLowerCase();
            var ts = this, vl;
            if (!ts.grid || !ts.p.footerrow) {
                return false;
            }
            if (action === "set") {
                if (isEmpty(data)) {
                    return false;
                }
            }
            success = true;
            $(this.p.colModel).each(function (i) {
                nm = this.name;
                if (action === "set") {
                    if (data[nm] !== undefined) {
                        vl = format ? ts.formatter("", data[nm], i, data, 'edit') : data[nm];
                        title = this.title ? {"title": $.jgrid.stripHtml(vl)} : {};
                        $("tr.footrow td:eq(" + i + ")", ts.grid.sDiv).html(vl).attr(title);
                        success = true;
                    }
                } else if (action === "get") {
                    res[nm] = $("tr.footrow td:eq(" + i + ")", ts.grid.sDiv).html();
                }
            });
            return action === "get" ? res : success;
        },
        showHideCol: function (colname, show) {
            var ts = this, fndh = false, brd = $.jgrid.cell_width ? 0 : ts.p.cellLayout, cw;
            if (!ts.grid) {
                return;
            }
            if (typeof colname === 'string') {
                colname = [colname];
            }
            show = show !== "none" ? "" : "none";
            var sw = show === "" ? true : false,
                gh = ts.p.groupHeader && (typeof ts.p.groupHeader === 'object' || $.isFunction(ts.p.groupHeader) );
            if (gh) {
                $(ts.element).jqGrid('destroyGroupHeader', false);
            }
            $(this.p.colModel).each(function (i) {
                if ($.inArray(this.name, colname) !== -1 && this.hidden === sw) {
                    if (ts.p.frozenColumns === true && this.frozen === true) {
                        return true;
                    }
                    $("tr[role=rowheader]", ts.grid.hDiv).each(function () {
                        $(this.cells[i]).css("display", show);
                    });
                    $(ts.rows).each(function () {
                        if (!$(this).hasClass("jqgroup")) {
                            $(this.cells[i]).css("display", show);
                        }
                    });
                    if (ts.p.footerrow) {
                        $("tr.footrow td:eq(" + i + ")", ts.grid.sDiv).css("display", show);
                    }
                    cw = parseInt(this.width, 10);
                    if (show === "none") {
                        ts.p.tblwidth -= cw + brd;
                    } else {
                        ts.p.tblwidth += cw + brd;
                    }
                    this.hidden = !sw;
                    fndh = true;
                    ts._trigger("showHideCol", [sw, this.name, i]);
                }
            });
            if (fndh === true && ts.p.fixWidth) {
                if (ts.p.shrinkToFit === true && !isNaN(ts.p.height)) {
                    ts.p.tblwidth += parseInt(ts.p.scrollOffset, 10);
                }
                $(ts.element).jqGrid("setGridWidth", ts.p.shrinkToFit === true ? ts.p.tblwidth : ts.p.width);
            }
            if (gh) {
                $(ts.element).jqGrid('setGroupHeaders', ts.p.groupHeader);
            }
        },
        /**
         * 隐藏(多)列
         * @param  {Array} colname 要隐藏的列名称的集合
         */
        hideCol: function (colname) {
            return $(this.element).jqGrid("showHideCol", colname, "none");
        },
        /**
         * 显示(多)列
         * @param  {Array} colname 要显示的列名称的集合
         */
        showCol: function (colname) {
            return $(this.element).jqGrid("showHideCol", colname, "");
        },
        remapColumns: function (permutation, updateCells, keepHeader) {
            function resortArray(a) {
                var ac;
                if (a.length) {
                    ac = $.makeArray(a);
                } else {
                    ac = $.extend({}, a);
                }
                $.each(permutation, function (i) {
                    a[i] = ac[this];
                });
            }

            var ts = this;

            function resortRows(parent, clobj) {
                $(">tr" + (clobj || ""), parent).each(function () {
                    var row = this;
                    var elems = $.makeArray(row.cells);
                    $.each(permutation, function () {
                        var e = elems[this];
                        if (e) {
                            row.appendChild(e);
                        }
                    });
                });
            }

            resortArray(ts.p.colModel);
            // resortArray(ts.p.colNames);
            resortArray(ts.grid.headers);
            resortRows($("thead:first", ts.grid.hDiv), keepHeader && ":not(.ui-jqgrid-labels)");
            if (updateCells) {
                resortRows($("#" + ts.p.id + " tbody:first"), ".jqgfirstrow, tr.jqgrow, tr.jqfoot");
            }
            if (ts.p.footerrow) {
                resortRows($("tbody:first", ts.grid.sDiv));
            }
            if (ts.p.remapColumns) {
                if (!ts.p.remapColumns.length) {
                    ts.p.remapColumns = $.makeArray(permutation);
                } else {
                    resortArray(ts.p.remapColumns);
                }
            }
            ts.p.lastsort = $.inArray(ts.p.lastsort, permutation);
            if (ts.p.treeGrid) {
                ts.p.expColInd = $.inArray(ts.p.expColInd, permutation);
            }
            ts._trigger("remapColumns", [permutation, updateCells, keepHeader]);
        },
        /**
         * 修改表格宽度
         * @param {number} newWidth 新的宽度，不带单位，默认px
         * @param {boolean} shrink 默认取初始化参数shrinkToFit的值，值为false的话，列宽不按比例缩小
         */
        setGridWidth: function (nwidth, shrink) {
            if (!this.grid) {
                return;
            }
            var ts = this, cw,
                initwidth = 0, brd = $.jgrid.cell_width ? 0 : ts.p.cellLayout, lvc, vc = 0, hs = false, scw = ts.p.scrollOffset, aw, gw = 0, cr;
            if (typeof shrink !== 'boolean') {
                shrink = ts.p.shrinkToFit;
            }
            if (isNaN(nwidth)) {
                return;
            }
            nwidth = parseInt(nwidth, 10);
            ts.grid.width = ts.p.width = nwidth;
            $(ts.element).css("width", nwidth + "px");
            //$("#gbox_"+ts.p.id).css("width",nwidth+"px");
            $("#gview_" + ts.p.id).css("width", nwidth + "px");
            $(ts.grid.bDiv).css("width", nwidth + "px");
            $(ts.grid.hDiv).css("width", nwidth + "px");
            if (ts.p.pager) {
                $(ts.p.pager).css("width", nwidth + "px");
            }
            if (ts.p.toppager) {
                $(ts.p.toppager).css("width", nwidth + "px");
            }
            if (ts.p.toolbar[0] === true) {
                $("#t_" + ts.id).css("width", nwidth + "px");
                if (ts.p.toolbar[1] === "both") {
                    $("#tb_" + ts.id).css("width", nwidth + "px");
                }
            }
            if (ts.p.footerrow) {
                $(ts.grid.sDiv).css("width", nwidth + "px");
            }
            if (shrink === false && ts.p.forceFit === true) {
                ts.p.forceFit = false;
            }
            if (shrink === true) {
                $.each(ts.p.colModel, function () {
                    if (this.hidden === false) {
                        cw = this.widthOrg;
                        initwidth += cw + brd;
                        if (this.fixed) {
                            gw += cw + brd;
                        } else {
                            vc++;
                        }
                    }
                });
                if (vc === 0) {
                    return;
                }
                ts.p.tblwidth = initwidth;
                aw = nwidth - brd * vc - gw;
                if (!isNaN(ts.p.height)) {
                    if ($(ts.grid.bDiv)[0].clientHeight < $(ts.grid.bDiv)[0].scrollHeight || ts.rows.length === 1) {
                        hs = true;
                        aw -= scw;
                    }
                }
                initwidth = 0;
                var cle = ts.grid.cols.length > 0;
                $.each(ts.p.colModel, function (i) {
                    if (this.hidden === false && !this.fixed) {
                        cw = this.widthOrg;
                        cw = Math.round(aw * cw / (ts.p.tblwidth - brd * vc - gw));
                        if (cw < 0) {
                            return;
                        }
                        this.width = cw;
                        initwidth += cw;
                        ts.grid.headers[i].width = cw;
                        ts.grid.headers[i].el.style.width = cw + "px";
                        if (ts.p.footerrow) {
                            ts.grid.footers[i].style.width = cw + "px";
                        }
                        if (cle) {
                            ts.grid.cols[i].style.width = cw + "px";
                        }
                        lvc = i;
                    }
                });

                if (!lvc) {
                    return;
                }

                cr = 0;
                if (hs) {
                    if (nwidth - gw - (initwidth + brd * vc) !== scw) {
                        cr = nwidth - gw - (initwidth + brd * vc) - scw;
                    }
                } else if (Math.abs(nwidth - gw - (initwidth + brd * vc)) !== 1) {
                    cr = nwidth - gw - (initwidth + brd * vc);
                }
                ts.p.colModel[lvc].width += (cr - 1);
                ts.p.tblwidth = initwidth + (cr - 1) + brd * vc + gw;
                if (ts.p.tblwidth > nwidth) {
                    var delta = ts.p.tblwidth - parseInt(nwidth, 10);
                    ts.p.tblwidth = nwidth;
                    cw = ts.p.colModel[lvc].width = ts.p.colModel[lvc].width - delta;
                } else {
                    cw = ts.p.colModel[lvc].width;
                }
                ts.grid.headers[lvc].width = cw;
                ts.grid.headers[lvc].el.style.width = cw + "px";
                if (cle) {
                    ts.grid.cols[lvc].style.width = cw + "px";
                }
                if (ts.p.footerrow) {
                    ts.grid.footers[lvc].style.width = cw + "px";
                }
            }
            if (ts.p.tblwidth) {
                $('table:first', ts.grid.bDiv).css("width", ts.p.tblwidth + "px");
                $('table:first', ts.grid.hDiv).css("width", ts.p.tblwidth + "px");
                ts.grid.hDiv.scrollLeft = ts.grid.bDiv.scrollLeft;
                if (ts.p.footerrow) {
                    $('table:first', ts.grid.sDiv).css("width", ts.p.tblwidth + "px");
                }
            }
        },
        /**
         * 修改表格高度
         * @param {number} newHeight 表格新的高度，可以带单位
         */
        setGridHeight: function (nh) {
            var ts = this;
            if (!ts.grid) {
                return;
            }
            var $el = $(ts.element);
            nh = nh - ($el.outerHeight() - ts.p.height);
            var bDiv = $(ts.grid.bDiv);
            bDiv.css({height: nh + (isNaN(nh) ? "" : "px")});
            if (ts.p.frozenColumns === true) {
                //follow the original set height to use 16, better scrollbar width detection
                $('#' + ts.p.id + "_frozen").parent().height(bDiv.height() - 16);
            }
            ts.p.height = nh;
            //if (ts.p.scroll) {
            //    ts.grid.populateVisible();
            //}
        },
        setCaption: function (newcap) {
            this.p.caption = newcap;
            $("span.ui-jqgrid-title", this.grid.cDiv).html(newcap);
            $(this.grid.cDiv).show();
        },
        /**
         * 修改列头内容及样式
         * @param {string} colname 列名
         * @param {string} newData   单元格修改后的值
         * @param {string} [prop]  修改后的单元格样式，可以是class也可以是css对象
         * @param {Object} [attrp] 修改后的单元格的附加属性，譬如可以修改title属性
         */
        setLabel: function (colname, nData, prop, attrp) {
            var ts = this, pos = -1;
            if (!ts.grid) {
                return;
            }
            if (colname !== undefined) {
                $(ts.p.colModel).each(function (i) {
                    if (this.name === colname) {
                        pos = i;
                        return false;
                    }
                });
            } else {
                return;
            }
            if (pos >= 0) {
                var thecol = $("tr.ui-jqgrid-labels th:eq(" + pos + ")", ts.grid.hDiv);
                if (nData) {
                    var ico = $(".s-ico", thecol);
                    $("[id^=jqgh_]", thecol).empty().html(nData).append(ico);
                    // ts.p.colNames[pos] = nData;
                    ts.p.colModel[pos].label = nData
                }
                if (prop) {
                    if (typeof prop === 'string') {
                        $(thecol).addClass(prop);
                    } else {
                        $(thecol).css(prop);
                    }
                }
                if (typeof attrp === 'object') {
                    $(thecol).attr(attrp);
                }
            }
        },
        /**
         * 修改单元格内容及样式
         * @param {string} rowid   行标识
         * @param {string} colname 列名
         * @param {string} newData   单元格修改后的值
         * @param {string} [prop]  修改后的单元格样式，可以是class也可以是css对象
         * @param {Object} [attrp] 修改后的单元格的附加属性，譬如可以修改title属性
         * @param {boolean} [forceupd] 强制刷新标识，如果单元格要修改成空值的，需要设置此参数为true;此参数主要用来区别只修改单元格样式功能用的
         */
        setCell: function (rowid, colname, nData, cssp, attrp, forceupd) {
            var ts = this, pos = -1, v, title;
            if (!ts.grid) {
                return;
            }
            if (isNaN(colname)) {
                $(ts.p.colModel).each(function (i) {
                    if (this.name === colname) {
                        pos = i;
                        return false;
                    }
                });
            } else {
                pos = parseInt(colname, 10);
            }
            if (pos >= 0) {
                var ind = $(ts.element).jqGrid('getGridRowById', rowid);
                if (ind) {
                    var tcell = $("td:eq(" + pos + ")", ind);
                    if (nData !== "" || forceupd === true) {
                        v = ts.formatter(rowid, nData, pos, ind, 'edit');
                        title = ts.p.colModel[pos].title ? {"title": $.jgrid.stripHtml(v)} : {};
                        if (ts.p.treeGrid && $(".tree-wrap", $(tcell)).length > 0) {
                            $("span", $(tcell)).html(v).attr(title);
                        } else {
                            $(tcell).html(v).attr(title);
                        }
                        if (ts.p.datatype === "local") {
                            var cm = ts.p.colModel[pos], index;
                            nData = cm.formatter && typeof cm.formatter === 'string' && cm.formatter === 'date' ? $.unformat.date.call(ts, nData, cm) : nData;
                            index = ts.p._index[$.jgrid.stripPref(ts.p.idPrefix, rowid)];
                            if (index !== undefined) {
                                ts.p.data[index][cm.name] = nData;
                            }
                        }
                    }
                    if (typeof cssp === 'string') {
                        $(tcell).addClass(cssp);
                    } else if (cssp) {
                        $(tcell).css(cssp);
                    }
                    if (typeof attrp === 'object') {
                        $(tcell).attr(attrp);
                    }
                }
            }
        },
        getCell: function (rowid, col) {
            var ret = false;
            var ts = this, pos = -1;
            if (!ts.grid) {
                return;
            }
            if (isNaN(col)) {
                $(ts.p.colModel).each(function (i) {
                    if (this.name === col) {
                        pos = i;
                        return false;
                    }
                });
            } else {
                pos = parseInt(col, 10);
            }
            if (pos >= 0) {
                var ind = $(ts.element).jqGrid('getGridRowById', rowid);
                if (ind) {
                    try {
                        ret = $.unformat.call(ts, $("td:eq(" + pos + ")", ind), {
                            rowId: ind.id,
                            colModel: ts.p.colModel[pos]
                        }, pos, true);
                    } catch (e) {
                        ret = $.jgrid.htmlDecode($("td:eq(" + pos + ")", ind).html());
                    }
                }
            }
            return ret;
        },
        getCol: function (col, obj, mathopr) {
            var ret = [], val, sum = 0, min, max, v;
            obj = typeof obj !== 'boolean' ? false : obj;
            if (mathopr === undefined) {
                mathopr = false;
            }
            var ts = this, pos = -1;
            if (!ts.grid) {
                return;
            }
            if (isNaN(col)) {
                $(ts.p.colModel).each(function (i) {
                    if (this.name === col) {
                        pos = i;
                        return false;
                    }
                });
            } else {
                pos = parseInt(col, 10);
            }
            if (pos >= 0) {
                var ln = ts.rows.length, i = 0, dlen = 0;
                if (ln && ln > 0) {
                    while (i < ln) {
                        if ($(ts.rows[i]).hasClass('jqgrow')) {
                            try {
                                val = $.unformat.call(ts, $(ts.rows[i].cells[pos]), {
                                    rowId: ts.rows[i].id,
                                    colModel: ts.p.colModel[pos]
                                }, pos, true);
                            } catch (e) {
                                val = $.jgrid.htmlDecode(ts.rows[i].cells[pos].innerHTML);
                            }
                            if (mathopr) {
                                v = parseFloat(val);
                                if (!isNaN(v)) {
                                    sum += v;
                                    if (max === undefined) {
                                        max = min = v;
                                    }
                                    min = Math.min(min, v);
                                    max = Math.max(max, v);
                                    dlen++;
                                }
                            }
                            else if (obj) {
                                ret.push({id: ts.rows[i].id, value: val});
                            }
                            else {
                                ret.push(val);
                            }
                        }
                        i++;
                    }
                    if (mathopr) {
                        switch (mathopr.toLowerCase()) {
                            case 'sum':
                                ret = sum;
                                break;
                            case 'avg':
                                ret = sum / dlen;
                                break;
                            case 'count':
                                ret = (ln - 1);
                                break;
                            case 'min':
                                ret = min;
                                break;
                            case 'max':
                                ret = max;
                                break;
                        }
                    }
                }
            }
            return ret;
        },
        /**
         * @method
         * 重新加载数据
         */
        reloadData:function(newData){
            $(this.element).jqGrid("clearGridData");
            $(this.element).jqGrid("setGridParam", {"data":newData}).trigger("reloadGrid");
        },
        /**
         * 清空数据
         */
        clearGridData: function (clearfooter) {
            var ts = this;
            if (!ts.grid) {
                return;
            }
            if (typeof clearfooter !== 'boolean') {
                clearfooter = false;
            }
            if (ts.p.deepempty) {
                $("#" + ts.p.id + " tbody:first tr:gt(0)").remove();
            }
            else {
                var trf = $("#" + ts.p.id + " tbody:first tr:first")[0];
                $("#" + ts.p.id + " tbody:first").empty().append(trf);
            }
            if (ts.p.footerrow && clearfooter) {
                $(".ui-jqgrid-ftable td", ts.grid.sDiv).html("&#160;");
            }
            ts.p.selrow = null;
            ts.p.selarrrow = [];
            ts.p.savedRow = [];
            ts.p.records = 0;
            ts.p.page = 1;
            ts.p.lastpage = 0;
            ts.p.reccount = 0;
            ts.p.data = [];
            ts.p._index = {};
            ts.updatepager(true, false);
        },
        getInd: function (rowid, rc) {
            var ret = false, rw;
            rw = $(this.element).jqGrid('getGridRowById', rowid);
            if (rw) {
                ret = rc === true ? rw : rw.rowIndex;
            }
            return ret;
        },
        bindKeys: function (settings) {
            var o = $.extend({
                scrollingRows: true
            }, settings || {});

            var ts = this;
            if (!$('body').is('[role]')) {
                $('body').attr('role', 'application');
            }
            ts.p.scrollrows = o.scrollingRows;
            $(ts.$tb).keydown(function (event) {
                var target = $(this).find('tr[tabindex=0]')[0], id, r, mind,
                    expanded = ts.p.treeReader.expanded_field;
                //check for arrow keys
                if (target) {
                    mind = ts.p._index[$.jgrid.stripPref(ts.p.idPrefix, target.id)];
                    if (event.keyCode === 37 || event.keyCode === 38 || event.keyCode === 39 || event.keyCode === 40) {
                        // up key
                        if (event.keyCode === 38) {
                            r = target.previousSibling;
                            id = "";
                            if (r) {
                                if ($(r).is(":hidden")) {
                                    while (r) {
                                        r = r.previousSibling;
                                        if (!$(r).is(":hidden") && $(r).hasClass('jqgrow')) {
                                            id = r.id;
                                            break;
                                        }
                                    }
                                } else {
                                    id = r.id;
                                }
                            }
                            $(ts.element).jqGrid('setSelection', id, true, event);
                            event.preventDefault();
                        }
                        //if key is down arrow
                        if (event.keyCode === 40) {
                            r = target.nextSibling;
                            id = "";
                            if (r) {
                                if ($(r).is(":hidden")) {
                                    while (r) {
                                        r = r.nextSibling;
                                        if (!$(r).is(":hidden") && $(r).hasClass('jqgrow')) {
                                            id = r.id;
                                            break;
                                        }
                                    }
                                } else {
                                    id = r.id;
                                }
                            }
                            $(ts.element).jqGrid('setSelection', id, true, event);
                            event.preventDefault();
                        }
                        // left
                        if (event.keyCode === 37) {
                            if (ts.p.treeGrid && ts.p.data[mind][expanded]) {
                                $(target).find("div.treeclick").trigger('click');
                            }
                            ts._trigger("onLeftKey", [ts.p.selrow]);
                        }
                        // right
                        if (event.keyCode === 39) {
                            if (ts.p.treeGrid && !ts.p.data[mind][expanded]) {
                                $(target).find("div.treeclick").trigger('click');
                            }
                            ts._trigger("onRightKey", [ts.p.selrow]);
                        }
                    }
                    //check if enter was pressed on a grid or treegrid node
                    else if (event.keyCode === 13) {
                        ts._trigger("onEnter", [ts.p.selrow]);
                    } else if (event.keyCode === 32) {
                        ts._trigger("onSpace", [ts.p.selrow]);
                    }
                }
            });
        },
        unbindKeys: function () {
            $(this.$tb).unbind('keydown');
        },
        getLocalRow: function (rowid) {
            var ret = false, ind;
            if (rowid !== undefined) {
                ind = this.p._index[$.jgrid.stripPref(this.p.idPrefix, rowid)];
                if (ind >= 0) {
                    ret = this.p.data[ind];
                }
            }
            return ret;
        }


    });

    $.fn.jqGrid = $.fn.grid;//历史原因,增加别名

});




/**
     * 表格初始化完成的事件
     * @event onInitGrid
     */
    /**
     * 表格事件操作完成的事件,可绑定gridGridComplete事件
     * @event gridComplete
     */
    /**
     * 加载每一条数据触发的事件,可修改每一行的展示,需要设置参数gridview为false,可绑定gridAfterInsertRow事件
     * @event afterInsertRow
     * @param  {String} rowid 行标识
     * @param  {Object} data 行数据对象
     */
    /**
     * 单击其他行之后的事件,可绑定gridChangeRow事件,与选中行事件的区别在于点击已选中的记录不再会触发事件
     * @event onChangeRow
     * @param  {String} rowid 行标识
     * @param  {Object} e event对象
     */
    /**
     * 单击选中行之后的事件,可绑定gridSelectRow事件
     * @event onSelectRow
     * @param  {String} rowid 行标识
     * @param  {Boolean} state 是否选中，一般用于多选
     * @param  {Object} e event对象
     */
    /**
     * 选中单元格的事件,可绑定gridCellSelect事件
     * @event onCellSelect
     * @param  {String} rowid 行标识
     * @param  {Number} iCol  列索引
     * @param  {String} cellcontent 单元格内容
     * @param  {Object} e event对象
     */
    /**
     * 双击选中行事件,可绑定gridDblClickRow事件
     * @event onDblClickRow
     * @param  {String} rowid 行标识
     * @param  {Number} iRow  行索引
     * @param  {Number} iCol  列索引
     * @param  {Object} e event对象
     */
    /**
     * 右击选中行事件,可绑定gridRightClickRow事件
     * @event onRightClickRow
     * @param  {String} rowid 行标识
     * @param  {Number} iRow  行索引
     * @param  {Number} iCol  列索引
     * @param  {Object} e event对象
     */
    /**
     * 单击选中行开始的事件,可绑定gridBeforeSelectRow事件
     * @event beforeSelectRow
     * @param  {String} rowid 行标识
     * @param  {Object} e event对象
     * @return {Boolean} 返回值，返回false或者"stop"则中断选中行操作
     */
    /**
     * 点击排序开始的事件,可绑定gridSortCol事件
     * @event onSortCol
     * @param  {String} sortname 排序列名称
     * @param  {Number} iCol  列索引
     * @param  {String} sortorder 排序方式,升序还是降序
     * @return {String} 返回值，返回"stop"中断排序操作
     */
    /**
     * 列头拖拽的开始事件,可绑定gridResizeStart事件
     * @event resizeStart
     * @param  {Object} e event对象
     * @return {number} idx 列索引
     */
    /**
     * 列头拖拽的结束事件,可绑定gridResizeStop事件
     * @event resizeStop
     * @param  {number} nw  新的列宽
     * @return {number} idx 列索引
     */
    /**
     * 点击表头缩放按钮触发的事件,可绑定gridHeaderClick事件
     * @event onHeaderClick
     * @param  {String} gridstate  表格状态,visible或者hidden
     * @param  {Object} e event对象
     */
    /**
     * 按回车键触发事件,可绑定gridKeyEnter事件,需调用bindKeys方法
     * @event onEnter
     * @param  {String} rowid 行标识
     */
    /**
     * 按空格键触发事件,可绑定gridKeyEnter事件,需调用bindKeys方法
     * @event onSpace
     * @param  {String} rowid 行标识
     */
    /**
     * 按左移键触发事件,可绑定gridKeyLeft事件,需调用bindKeys方法;如果是tree则收缩节点
     * @event onLeftKey
     * @param  {String} rowid 行标识
     */
    /**
     * 按右移键触发事件,可绑定gridKeyRight事件,需调用bindKeys方法;如果是tree则展开节点
     * @event onRightKey
     * @param  {String} rowid 行标识
     */
    /**
     * 重载表格数据的事件,通过grid对象的trigger方法调用.
     * @event reloadGrid
     * @param  {Object} [opt] 重载参数,一般为{page:n}格式,表示加载的页数
     */
    /**
     * 点击分页按钮触发的事件
     * @event onPaging
     * @param  {String} onpaging 点击的按钮位置,对应first,prev,next,last;如果是直接输入页码,则此值为user
     * @return {String} 返回值，返回"stop"中断翻页操作
     */
    /**
     * 点击列头全选按钮触发的事件,可绑定gridSelectAll事件
     * @event onSelectAll
     * @param  {Array} aRowids  选中状态的行标识集合
     * @param  {Boolean} status 表格状态,true表示选中,false表示没有选中
     */
    /**
     * 编辑行绑定的事件,也可在editRow方法参数传入oneditfunc函数
     * @event inlineEditRow
     * @param  {String} rowid  行标识
     */
    /**
     * 保存行数据前绑定的事件;返回空值或者返回第一个参数为false的数组，则中断保存行操作
     * @event beforeSaveRow
     * @param  {String} rowid  行标识
     * @param  {Object} data   修改过的行数据
     */
    /**
     * 保存行数据后绑定的事件,也可在editRow/saveRow方法参数传入aftersavefunc函数
     * @event inlineAfterSaveRow
     * @param  {String} rowid  行标识
     * @param  {Object} data   修改过的行数据
     */
    /**
     * 取消行数据编辑后绑定的事件,也可在editRow/saveRow方法参数传入afterrestorefunc函数
     * @event inlineAfterRestoreRow
     * @param  {String} rowid  行标识
     */
    /**
     * 编辑单元格前绑定的事件
     * @event beforeEditCell
     * @param  {String} rowid  行标识
     * @param  {String} colName  列名
     * @param  {String} cellcontext  单元格值
     * @param  {number} iRow  行索引
     * @param  {number} iCol  列索引
     */
    /**
     * 编辑单元格后绑定的事件
     * @event afterEditCell
     * @param  {String} rowid  行标识
     * @param  {String} colName  列名
     * @param  {String} cellcontext  单元格值
     * @param  {number} iRow  行索引
     * @param  {number} iCol  列索引
     */
    /**
     * 保存单元格数据前绑定的事件,返回空值或者返回第一个参数为false的数组，则中断保存单元格操作
     * @event beforeSaveCell
     * @param  {String} rowid  行标识
     * @param  {String} colName  列名
     * @param  {String} cellcontext  单元格值
     * @param  {number} iRow  行索引
     * @param  {number} iCol  列索引
     */
    /**
     * 保存单元格数据后绑定的事件
     * @event afterSaveCell
     * @param  {String} rowid  行标识
     * @param  {String} colName  列名
     * @param  {String} cellcontext  单元格值
     * @param  {number} iRow  行索引
     * @param  {number} iCol  列索引
     */
    /**
     * 取消单元格编辑后绑定的事件
     * @event afterRestoreCell
     * @param  {String} rowid  行标识
     * @param  {String} colName  列名
     * @param  {String} cellcontext  单元格值
     * @param  {number} iRow  行索引
     * @param  {number} iCol  列索引
     */
    /**
     * tree节点的展开事件,可绑定gridOnRowExpand事件
     * @event onRowExpand
     * @param  {Object} row 需展开的节点对象
     */
    /**
     * tree节点的收缩事件,可绑定gridOnRowCollapse事件
     * @event onRowCollapse
     * @param  {Object} row 需收缩的节点对象
     */




    /** @cfg {Object} height='100%|150' 表格高度,默认取父容器的高度,可以设置具体数值,也可以带单位.
     *  <pre>
     *      取值逻辑:
     *      先取控件初始化参数中的height属性,如果没有设置
     *      再取元素自身的height,如果没有设置
     *      再取元素父容器的height,如果高度为0
     *      则取150的默认值
     *      注意点:
     *      如果页面表格控件已经初始化计算出宽度,此时动态操作dom使页面出现垂直滚动条(垂直滚动条的出现会使屏幕变窄),此时宽度需要重新设置
     *  </pre>
     */
    /** @cfg {Number} page=1 初始化页码.
     */
    /** @cfg {Number} rowNum=20 初始化一页显示的记录条数,默认无限大,分页的场景下，默认20条每页.
     */
    /** @cfg {Number} records=0 记录总数.一般被用于取值
     */
    /** @cfg {Number} reccount 当前页的记录总数.一般被用于取值
     */
    /** @cfg {Boolean} pager 分页标识.设置为true会在grid底部构造id为gridid+pager的分页栏
     */
    /** @cfg {Boolean} pgbuttons=true 是否显示分页前后可点击按钮
     */
    /** @cfg {Boolean} pginput=true 是否显示分页的文本输入框，按回车可以跳转到指定的页
     */
    /** @cfg {Object} colModel 列的定义，需详细说明
     */
    /** @cfg {String} sortorder="asc" 排序方式，默认升序
     */
    /** @cfg {String} sortname 排序的列标识
     */
    /** @cfg {String} datatype="local" 数据类型，一般分为local数组和json格式,分别对应本地数据和服务器端数据
     */
    /** @cfg {String} selrow 单选条件下的选中的记录.一般被用于取值
     */
    /** @cfg {Boolean} shrinkToFit=true 表格列宽是否按比例缩放，默认true
     */
    /** @cfg {Object} jsonReader json格式的定义
     */
    /** @cfg {String} lastpage 分页情况下的总页数，一般被用于取值
     */
    /** @cfg {String} lastsort 记录上一次排序的情况，一般被用于取值
     */
    /** @cfg {String} selarrrow 复选条件下的选中的记录.一般被用于获取打勾的记录
     */
    /** @cfg {Boolean} viewrecords=true 有分页栏的情况下显示详细的记录数，默认true，tree的场景下此参数无效
     */
    /** @cfg {Boolean} multiselect=false 开启表格多选功能
     */
    /** @cfg {String} multikey=false 表格多选功能的辅助快捷键，如配置ctrl则只有按住ctrl键才能多选行
     */
    /** @cfg {String} caption  表头显示的标题，只有配置此参数才会出现表格的缩放按钮
     */
    /** @cfg {Boolean} hidegrid=false 当含有表头时，是否出现表格缩放按钮
     */
    /** @cfg {Boolean} hiddengrid=false 初始化是否隐藏表格
     */
    /** @cfg {Object} userData 表格数据额外的值，也可以存在于json格式数据中，可用于toolbar或者footerrow
     */
    /** @cfg {Boolean} forceFit=false 修改某列宽度的时候其他列是否自适应填充
     */
    /** @cfg {String} gridstate="visible" 表格状态，一般用于取值，判断表格是否隐藏
     */
    /** @cfg {Boolean} cellEdit=false 是否开启单元格编辑模式
     */
    /** @cfg {Boolean} multiboxonly=false 多选状态下，是否只有点击列checkbox才能多选
     */
    /** @cfg {Boolean} scrollrows=true 当设置某条记录选中时，如果此记录未在可见范围，滚动条会自动滚动，默认值true
     */
    /** @cfg {Boolean} autowidth=false 表格宽度是否自适应，取决于父节点宽度，默认为false，否则可以设置width来指定表格宽度
     */
    /** @cfg {Boolean} width="100%" 表格宽度是否自适应，取决于父节点宽度，同autowidth=true场景，否则可以设置width来指定表格宽度
     */
    /** @cfg {Number} scrollOffset=18 滚动条宽度
     */
    /** @cfg {Number} cellLayout=5 单元格间距
     */
    /** @cfg {Number} multiselectWidth=20 多选框列宽
     */
    /** @cfg {Number} rownumWidth=25 rownumbers序号列开启时的列宽
     */
    /** @cfg {Boolean} gridview=true 是否开启快速加载模式，如果定义了afterInsertRow事件，此参数则要求设置为false
     */
    /** @cfg {Boolean} rownumbers=false 是否开启序号列
     */
    /** @cfg {Boolean} footerrow=false 是否在表格底部新增一行，一般用于统计
     */
    /** @cfg {Boolean} userDataOnFooter=false 是否将userdata数据自动同步到footerrow那一行上
     */
    /** @cfg {String} pagerpos='center' 表格分页栏位置
     */
    /** @cfg {String} recordpos='right' 表格记录栏位置
     */
    /** @cfg {Boolean} hoverrows=true 鼠标移动到行，当前行是否高亮
     */
    /** @cfg {Boolean} showMask=false 加载表格数据的时候是否出现loading遮罩,依赖blockui控件;此属性开启会采用延迟加载数据的方式,因此加载完数据对数据进行操作的步骤,需要放到数据加载完成事件(gridComplete)里完成
     */
    /** @cfg {Boolean} fixWidth=false 隐藏列的时候是否改变表格外层宽度
     */
    /** @cfg {Array} data 表格的数据列表，可用于传值重新加载也可以取值
     */
    /** @cfg {Object} cmTemplate 表格列的通用属性
     */
    /** @cfg {Boolean} multiSort 表格是否支持多列排序，默认false
     */
    /** @cfg {Boolean} cellAutoSave 单元格编辑，切换单元格后，原值是否保存，默认true,可选"","false"分别表示切换时不处理和不保存值
     */
    /** @cfg {Boolean} treeGrid 表格是否启用tree形式
     */
    /** @cfg {Object} treeReader tree格式的定义
     */
    /** @cfg {String} expandColumn tree格式展开的列定义
     */
    /** @cfg {String} expandColClick=false 点击可展开列内容而不需要点击图标就支持节点缩放
     */
    /** @cfg {Boolean} leafChange treeGrid场景下，节点类型是否支持转变，譬如没有子节点的父节点点击会图标变成子节点，子节点新增数据后图标变成父节点，默认false
     */
    /** @cfg {Boolean} checkParent=false treeGrid的多选场景下，点击某个节点，是否自动选中它的所有父节点
     */
    /** @cfg {Boolean} checkChildren=false treeGrid的多选场景下，点击某个节点，是否自动选中它的所有子节点
     */
    /** @cfg {Function} pageData 服务器端数据接口函数，此函数的返回值为包含分页信息的json数据，用户可以在此方法里面跟服务器作交互,此方法提供参数有目标页码，排序列及排序方式。参数datatype为json时生效。
     */
    /**
     * @cfg {String} treeDataFormat="child" treeGrid数据格式化方式,默认child表示父子关系;可配置成line,则表示线性关系;配置成none则表示无需格式化,用户可以自行选择$.jgrid.treeDataFormat/childrenDataFormat进行数据格式化  
     * <pre>
        chlid:
        [
            {id:"2",invdate:"2010-05-25",name:"test2",note:"懒加载示例",tax:"20.00",total:"320.00"},
            {id:"3",invdate:"2007-09-01",name:"test3",note:"懒加载示例",tax:"30.00",total:"430.00",children:[],
            {id:"4",invdate:"2007-10-04",name:"test",note:"note",tax:"10.00",total:"210.00",
                children:[
                    {id:"5",invdate:"2007-10-05",name:"test2",note:"note2",tax:"20.00",total:"320.00"},
                    {id:"6",invdate:"2007-09-06",name:"test3",note:"note3",tax:"30.00",total:"430.00"}
                ]
            },
            {id:"7",invdate:"2007-10-04",name:"test",note:"懒加载示例",tax:"10.00",total:"210.00",loaded:false,children:[]},
            {id:"8",invdate:"2007-10-03",name:"test2",note:"note2",amount:"300.00",tax:"21.00",total:"320.00",
                children:[
                    {id:"9",invdate:"2007-09-01",name:"test3",note:"note3",amount:"400.00",tax:"30.00",total:"430.00"},
                    {id:"11",invdate:"2007-10-01",name:"test",note:"note",amount:"200.00",tax:"10.00",total:"210.00"}
                ]
            }
        ]
        line:
        [
            {id:"1",level:1} ,
            {id:"2",parent:"1",level:2},
            {id:"3",parent:"1",level:2},
            {id:"4",parent:"1",level:2},
            {id:"5",parent:"4",level:3},
            {id:"6",parent:"4",level:3},
            {id:"7",parent:"1",level:2},
            {id:"8",parent:"1",level:2},
            {id:"9",parent:"8",level:3},
            {id:"11",parent:"8",level:3}
        ]
     * </pre>
     */
/*
 * Created by tanyl on 2014/12/22.
 */
!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.grid.advance', factory);
    } else {
        factory();
    }
}(function () {

    'use strict';

    $.extend($.ui.grid.prototype , {
    //$.widget("ui.grid", $.ui.grid, {
        getColProp : function(colname){
            var ret ={}, ts = this[0];
            if ( !ts.grid ) { return false; }
            var cM = ts.p.colModel, i;
            for ( i=0;i<cM.length;i++ ) {
                if ( cM[i].name === colname ) {
                    ret = cM[i];
                    break;
                }
            }
            return ret;
        },
        setColProp : function(colname, obj){
            //do not set width will not work
            //return this.each(function(){
                if ( this.grid ) {
                    if ( obj ) {
                        var cM = this.p.colModel, i;
                        for ( i=0;i<cM.length;i++ ) {
                            if ( cM[i].name === colname ) {
                                $.extend(true, this.p.colModel[i],obj);
                                break;
                            }
                        }
                    }
                }
            //});
        },
        //可以通过设置排序参数,重载数据来实现,此方法可以不用
        sortGrid : function(colname,reload, sor){
                var ts=this,idx=-1,i, sobj=false;
                if ( !ts.grid ) { return;}
                if ( !colname ) { colname = ts.p.sortname; }
                for ( i=0;i<ts.p.colModel.length;i++ ) {
                    if ( ts.p.colModel[i].index === colname || ts.p.colModel[i].name === colname ) {
                        idx = i;
                        if(ts.p.frozenColumns === true && ts.p.colModel[i].frozen === true) {
                            sobj = ts.grid.fhDiv.find("#" + ts.p.id + "_" + colname);
                        }
                        break;
                    }
                }
                if ( idx !== -1 ){
                    var sort = ts.p.colModel[idx].sortable;
                    if ( typeof sort !== 'boolean' ) { sort =  true; }
                    if ( typeof reload !=='boolean' ) { reload = false; }
                    if ( sort ) { ts.sortData("jqgh_"+ts.p.id+"_" + colname, idx, reload, sor, sobj); }
                }
        },

        setGridState : function(state) {
                if ( !this.grid ) {return;}
                var ts = this;
                if(state === 'hidden'){
                    $(".ui-jqgrid-bdiv, .ui-jqgrid-hdiv","#gview_"+ts.p.id).slideUp("fast");
                    if(ts.p.pager) {$(ts.p.pager).slideUp("fast");}
                    if(ts.p.toppager) {$(ts.p.toppager).slideUp("fast");}
                    if(ts.p.toolbar[0]===true) {
                        if( ts.p.toolbar[1] === 'both') {
                            $(ts.grid.ubDiv).slideUp("fast");
                        }
                        $(ts.grid.uDiv).slideUp("fast");
                    }
                    if(ts.p.footerrow) { $(".ui-jqgrid-sdiv","#gbox_"+ts.p.id).slideUp("fast"); }
                    $(".ui-jqgrid-titlebar-close span",ts.grid.cDiv).removeClass("ui-icon-circle-triangle-n").addClass("ui-icon-circle-triangle-s");
                    ts.p.gridstate = 'hidden';
                } else if(state === 'visible') {
                    $(".ui-jqgrid-hdiv, .ui-jqgrid-bdiv","#gview_"+ts.p.id).slideDown("fast");
                    if(ts.p.pager) {$(ts.p.pager).slideDown("fast");}
                    if(ts.p.toppager) {$(ts.p.toppager).slideDown("fast");}
                    if(ts.p.toolbar[0]===true) {
                        if( ts.p.toolbar[1] === 'both') {
                            $(ts.grid.ubDiv).slideDown("fast");
                        }
                        $(ts.grid.uDiv).slideDown("fast");
                    }
                    if(ts.p.footerrow) { $(".ui-jqgrid-sdiv","#gbox_"+ts.p.id).slideDown("fast"); }
                    $(".ui-jqgrid-titlebar-close span",ts.grid.cDiv).removeClass("ui-icon-circle-triangle-s").addClass("ui-icon-circle-triangle-n");
                    ts.p.gridstate = 'visible';
                }
        },

        destroyGroupHeader : function(nullHeader)
        {
            if(nullHeader === undefined) {
                nullHeader = true;
            }
                var ts = this, $tr, i, l, headers, $th, $resizing, grid = ts.grid,
                    thead = $("table.ui-jqgrid-htable thead", grid.hDiv), cm = ts.p.colModel, hc;
                if(!grid) { return; }
                $(ts.element).unbind('.setGroupHeaders');
                $tr = $("<tr>", {role: "rowheader"}).addClass("ui-jqgrid-labels");
                ts._gridHeight = $(ts.element).outerHeight();
                headers = grid.headers;
                for (i = 0, l = headers.length; i < l; i++) {
                    hc = cm[i].hidden ? "none" : "";
                    $th = $(headers[i].el)
                        .width(headers[i].width)
                        .css('display',hc);
                    try {
                        $th.removeAttr("rowSpan");
                    } catch (rs) {
                        //IE 6/7
                        $th.attr("rowSpan",1);
                    }
                    $tr.append($th);
                    $resizing = $th.children("span.ui-jqgrid-resize");
                    if ($resizing.length>0) {// resizable column
                        $resizing[0].style.height = "";
                    }
                    $th.children("div")[0].style.top = "";
                }
                $(thead).children('tr.ui-jqgrid-labels').remove();
                $(thead).prepend($tr);

                if(nullHeader === true) {
                    $(ts.element).jqGrid('setGridParam',{ 'groupHeader': null});
                }
        },
        /**
         * 设置复杂表头
         * @param {Object} o 复杂表头的参数.
         * 参数内useColSpanStyle表示列头是否纵向合并单元格;
         * 参数内groupHeaders表示列头属性,内部startColumnName表示开始的列,numberOfColumns表示从开始列的数量,titleText表示合并后的列头显示值
         * <pre>
         * $("#gridAdvanced").jqGrid("setGroupHeaders", {
         *    useColSpanStyle: true,
         *    groupHeaders:[{startColumnName: "amount", numberOfColumns: 3, titleText: "<em>Price</em>"}]
         * });
         * </pre>
         */
        setGroupHeaders : function ( o ) { //TODO 含有组合标题并且是冻结列的场景下,隐藏多列或者拖动存在像素差
            o = $.extend({
                useColSpanStyle :  false,
                groupHeaders: []
            },o  || {});
                this.p.groupHeader = o;
                var ts = this,
                    i, cmi, skip = 0, $tr, $colHeader, th, $th, thStyle,
                    iCol,
                    cghi,
                //startColumnName,
                    numberOfColumns,
                    titleText,
                    cVisibleColumns,
                    colModel = ts.p.colModel,
                    cml = colModel.length,
                    ths = ts.grid.headers,
                    $htable = $("table.ui-jqgrid-htable", ts.grid.hDiv),
                    $trLabels = $htable.children("thead").children("tr.ui-jqgrid-labels:last").addClass("jqg-second-row-header"),
                    $thead = $htable.children("thead"),
                    $theadInTable,
                    $firstHeaderRow = $htable.find(".jqg-first-row-header");
                if($firstHeaderRow[0] === undefined) {
                    $firstHeaderRow = $('<tr>', {role: "row", "aria-hidden": "true"}).addClass("jqg-first-row-header").css("height", "auto");
                } else {
                    $firstHeaderRow.empty();
                }
                var $firstRow,
                    inColumnHeader = function (text, columnHeaders) {
                        var length = columnHeaders.length, i;
                        for (i = 0; i < length; i++) {
                            if (columnHeaders[i].startColumnName === text) {
                                return i;
                            }
                        }
                        return -1;
                    };
                //
                $(ts.$tb).prepend($thead);
                $tr = $('<tr>', {role: "rowheader"}).addClass("ui-jqgrid-labels jqg-third-row-header");
                for (i = 0; i < cml; i++) {
                    th = ths[i].el;
                    $th = $(th);
                    cmi = colModel[i];
                    // build the next cell for the first header row
                    thStyle = { height: '0px', width: ths[i].width + 'px', display: (cmi.hidden ? 'none' : '')};
                    $("<th>", {role: 'gridcell'}).css(thStyle).appendTo($firstHeaderRow);

                    th.style.width = ""; // remove unneeded style
                    iCol = inColumnHeader(cmi.name, o.groupHeaders);
                    if (iCol >= 0) {
                        cghi = o.groupHeaders[iCol];
                        numberOfColumns = cghi.numberOfColumns;
                        titleText = cghi.titleText;

                        // caclulate the number of visible columns from the next numberOfColumns columns
                        for (cVisibleColumns = 0, iCol = 0; iCol < numberOfColumns && (i + iCol < cml); iCol++) {
                            if (!colModel[i + iCol].hidden) {
                                cVisibleColumns++;
                            }
                        }

                        // The next numberOfColumns headers will be moved in the next row
                        // in the current row will be placed the new column header with the titleText.
                        // The text will be over the cVisibleColumns columns
                        $colHeader = $('<th>').attr({role: "columnheader"})
                            .addClass("ui-th-column-header")
                            .css({'border-top': '0px none'})//'height':'22px',
                            .html(titleText);
                        if(cVisibleColumns > 0) {
                            $colHeader.attr("colspan", String(cVisibleColumns));
                        }
                        if (ts.p.headertitles) {
                            $colHeader.attr("title", $colHeader.text());
                        }
                        // hide if not a visible cols
                        if( cVisibleColumns === 0) {
                            $colHeader.hide();
                        }

                        $th.before($colHeader); // insert new column header before the current
                        $tr.append(th);         // move the current header in the next row

                        // set the coumter of headers which will be moved in the next row
                        skip = numberOfColumns - 1;
                    } else {
                        if (skip === 0) {
                            if (o.useColSpanStyle) {
                                // expand the header height to two rows
                                $th.attr("rowspan", "2");
                            } else {
                                $('<th>', {role: "columnheader"})
                                    .addClass("ui-th-column-header")
                                    .css({"display": cmi.hidden ? 'none' : '', 'border-top': '0px none'})
                                    .insertBefore($th);
                                $tr.append(th);
                            }
                        } else {
                            // move the header to the next row
                            //$th.css({"padding-top": "2px", height: "19px"});
                            $tr.append(th);
                            skip--;
                        }
                    }
                }
                $theadInTable = $(ts.$tb).children("thead");
                $theadInTable.prepend($firstHeaderRow);
                $tr.insertAfter($trLabels);
                $htable.append($theadInTable);

                if (o.useColSpanStyle) {
                    // Increase the height of resizing span of visible headers
                    $htable.find("span.ui-jqgrid-resize").each(function () {
                        var $parent = $(this).parent();
                        if ($parent.is(":visible")) {
                            this.style.cssText = 'height: ' + $parent.height() + 'px !important; cursor: col-resize;';
                        }
                    });



                    // Set position of the sortable div (the main lable)
                    // with the column header text to the middle of the cell.
                    // One should not do this for hidden headers.
                    $htable.find("div.ui-jqgrid-sortable").each(function () {
                        var $ts = $(this), $parent = $ts.parent();
                        if ($parent.is(":visible") && $parent.is(":has(span.ui-jqgrid-resize)")) {
                            $ts.css('top', ($parent.height() - $ts.outerHeight()) / 2 + 'px');
                        }
                    });
                }

                $firstRow = $theadInTable.find("tr.jqg-first-row-header");
                ts._bind('resizeStop.setGroupHeaders', function (e, nw, idx) {
                    $firstRow.find('th').eq(idx).width(nw-4); //解决复杂列头拖动是列宽计算错误问题
                });

                //复groupheader多出来的24px//隐藏列的时候会触发setGroupHeaders操作,此时就不需要处理多出来24px
                //组合表头只支持2级并且第一次初始化的时候就
                if(!ts._initGroupHeaders){
                    $(ts.element).jqGrid('setGridHeight',$(ts.element).outerHeight()-$tr.height());
                    ts._initGroupHeaders = true;
                }
        },
        /**
         * 设置列的冻结效果,在有水平滚动条的情况下,移动水平滚动条,此列位置不变.列的冻结从最左侧开始算起,可支持多列
         * @param {number} colnum 冻结列的数量
         */
        setFrozenColumns : function (colnum) {
                if ( !this.grid ) {return;}
                var ts = this, cm = ts.p.colModel,i=0, len = cm.length, maxfrozen = -1, frozen= false;
                // TODO treeGrid and grouping  Support
                if(ts.p.treeGrid === true || ts.p.cellEdit === true || ts.p.sortable || ts.p.scroll || ts.p.grouping )
                {
                    return;
                }
                if(ts.p.rownumbers) { i++; }
                if(ts.p.multiselect) { i++; }

                if(colnum && colnum < len) {
                    frozen = true;
                    maxfrozen = colnum - 1;
                    while(i<colnum)
                    {
                        cm[i].frozen = true;
                        i++;
                    }
                }else{
                    // get the max index of frozen col
                    while(i<len)
                    {
                        // from left, no breaking frozen
                        if(cm[i].frozen === true)
                        {
                            frozen = true;
                            maxfrozen = i;
                        } else {
                            break;
                        }
                        i++;
                    }
                }
                if( maxfrozen>=0 && frozen) {
                    var top = ts.p.caption ? $(ts.grid.cDiv).outerHeight() : 0,
                        hth = $(".ui-jqgrid-htable","#gview_"+ts.p.id).height();
                    if(ts.p.toolbar[0] === true) {
                        if(ts.p.toolbar[1] !== "bottom") {
                            top = top + $(ts.grid.uDiv).outerHeight();
                        }
                    }
                    ts.grid.fhDiv = $('<div style="position:absolute;left:0px;top:'+top+'px;height:'+hth+'px;border-bottom-width: 0px;" class="frozen-div ui-jqgrid-hdiv"></div>');
                    ts.grid.fbDiv = $('<div style="position:absolute;left:0px;top:'+(parseInt(top,10)+parseInt(hth,10) + 1)+'px;overflow-y:hidden" class="frozen-bdiv ui-jqgrid-bdiv"></div>');
                    $("#gview_"+ts.p.id).append(ts.grid.fhDiv);
                    // ts.grid.fhDiv.innerWidth(250);
                    var htbl = $(".ui-jqgrid-htable","#gview_"+ts.p.id).clone(true);
                    // groupheader support - only if useColSpanstyle is false
                    if(ts.p.groupHeader) {
                        $("tr.jqg-first-row-header, tr.jqg-third-row-header", htbl).each(function(){
                            $("th:gt("+maxfrozen+")",this).remove();
                            var offval = 5;
                            if(maxfrozen==0) offval+=4;
                            //取外层的值,如果有组合列头的话,只需要加5,没有的话则需要加9
                            $("th",this).each(function(index, val) {
                                $(this).width($(this).width()+offval);
                            });
                        });
                        var swapfroz = -1, fdel = -1, cs, rs;
                        $("tr.jqg-second-row-header th", htbl).each(function(){
                            cs= parseInt($(this).attr("colspan"),10);
                            rs= parseInt($(this).attr("rowspan"),10);
                            if(rs) {
                                swapfroz++;
                                fdel++;
                            }
                            if(cs) {
                                swapfroz = swapfroz+cs;
                                fdel++;
                            }
                            if(swapfroz === maxfrozen) {
                                return false;
                            }
                        });
                        if(swapfroz !== maxfrozen) {
                            fdel = maxfrozen;
                        }
                        $("tr.jqg-second-row-header", htbl).each(function(){
                            $("th:gt("+fdel+")",this).remove();
                        });
                    } else {
                        $("tr",htbl).each(function(){
                            $("th:gt("+maxfrozen+")",this).remove();
                            $("th",this).each(function(index, val) {
                                $(this).width($(this).width()+9);
                            });
                        });
                    }
                    $(htbl).width(1);
                    // resizing stuff
                    $(ts.grid.fhDiv).append(htbl)
                        .mousemove(function (e) {
                            if(ts.grid.resizing){ ts.grid.dragMove(e);return false; }
                        });
                    ts._bind('resizeStop.setFrozenColumns', function (e, w, index) {
                        var th_width = $("th:eq("+index+")",ts.grid.hDiv).outerWidth();
                        // console.log("width:"+th_width + ":another:"+w);
                        var rhth = $(".ui-jqgrid-htable",ts.grid.fhDiv);
                        $("th:eq("+index+")",rhth).outerWidth(th_width);
                        var btd = $(".ui-jqgrid-btable",ts.grid.fbDiv);
                        $("td:eq("+index+")",btd).outerWidth( th_width);
                        //
                    });
                    // sorting stuff
                    ts._bind('onSortCol.setFrozenColumns', function (e, index, idxcol) {
                        var previousSelectedTh = $("tr.ui-jqgrid-labels:last th:eq("+ts.p.lastsort+")",ts.grid.fhDiv), newSelectedTh = $("tr.ui-jqgrid-labels:last th:eq("+idxcol+")",ts.grid.fhDiv);
                        $("span.ui-grid-ico-sort",previousSelectedTh).addClass('ui-state-disabled');
                        $(previousSelectedTh).attr("aria-selected","false");
                        $("span.ui-icon-"+ts.p.sortorder,newSelectedTh).removeClass('ui-state-disabled');
                        $(newSelectedTh).attr("aria-selected","true");
                        if(ts.p.lastsort !== idxcol) {
                            $("span.s-ico",previousSelectedTh).hide();
                            $("span.s-ico",newSelectedTh).show();
                        };
                        // var th_width = $("th:eq("+index+")",ts.grid.hDiv).width();
                        // var rhth = $(".ui-jqgrid-htable",ts.grid.fhDiv);
                        // $("th:eq("+index+")",rhth).width(th_width);
                        // var btd = $(".ui-jqgrid-btable",ts.grid.fbDiv);
                        // $("tr td:eq("+index+")",btd).width( th_width);
                    });

                    // data stuff
                    //TODO support for setRowData
                    $("#gview_"+ts.p.id).append(ts.grid.fbDiv);
                    //


                    $(ts.grid.bDiv).scroll(function () {
                        $(ts.grid.fbDiv).scrollTop($(this).scrollTop());
                    });
                    if(ts.p.hoverrows === true) {
                        $("#"+ts.p.id).unbind('mouseover').unbind('mouseout');
                    }
                    ts._bind('afterGridComplete.setFrozenColumns', function () {
                        //+9
                        $("#"+ts.p.id+"_frozen").remove();
                        $(ts.grid.fbDiv).height($(ts.grid.bDiv).height()-17);
                        var btbl = $(ts.$tb).clone(true);
                        $("tr[role=row]",btbl).each(function(){
                            $("td[role=gridcell]:gt("+maxfrozen+")",this).remove();
                        });
                        // 与header一致 2014/8/25
                        var rhths = $(".ui-jqgrid-htable",ts.grid.fhDiv).find('.jqg-first-row-header th');
                        $("tr[role=row]:first",btbl).each(function(){
                            $("td",this).each(function(index, val) {
                                if($.browser.msie){
                                    $(this).width($(rhths[index]).outerWidth());
                                }else{
                                    $(this).outerWidth($(rhths[index]).outerWidth());
                                }
                            });
                        });

                        $(btbl).width(1).attr("id",ts.p.id+"_frozen");
                        $(ts.grid.fbDiv).append(btbl);

                        if(ts.p.hoverrows === true) {
                            $("tr.jqgrow", btbl).hover(
                                function(){ $(this).addClass("ui-state-hover"); $("#"+$.jgrid.jqID(this.id), "#"+ts.p.id).addClass("ui-state-hover"); },
                                function(){ $(this).removeClass("ui-state-hover"); $("#"+$.jgrid.jqID(this.id), "#"+ts.p.id).removeClass("ui-state-hover"); }
                            );
                            $("tr.jqgrow", ts.$tb).hover(
                                function(){ $(this).addClass("ui-state-hover"); $("#"+$.jgrid.jqID(this.id), "#"+ts.p.id+"_frozen").addClass("ui-state-hover");},
                                function(){ $(this).removeClass("ui-state-hover"); $("#"+$.jgrid.jqID(this.id), "#"+ts.p.id+"_frozen").removeClass("ui-state-hover"); }
                            );
                        }
                        btbl=null;
                    });
                    if(!ts.grid.hDiv.loading) {
                        ts._trigger("afterGridComplete");
                    }
                    ts.p.frozenColumns = true;
                }
        },
        destroyFrozenColumns :  function() {
                if ( !this.grid ) {return;}
                if(this.p.frozenColumns === true) {
                    var ts = this;
                    $(ts.grid.fhDiv).remove();
                    $(ts.grid.fbDiv).remove();
                    ts.grid.fhDiv = null; ts.grid.fbDiv=null;
                    $(this.element).unbind('.setFrozenColumns');
                    if(ts.p.hoverrows === true) {
                        var ptr;
                        $(ts.$tb).bind('mouseover',function(e) {
                            ptr = $(e.target).closest("tr.jqgrow");
                            $(ptr).addClass("ui-state-hover");
                        }).bind('mouseout',function(e) {
                            ptr = $(e.target).closest("tr.jqgrow");
                            $(ptr).removeClass("ui-state-hover");
                        });
                    }
                    this.p.frozenColumns = false;
                }
        },
        sortableColumns : function (tblrow){
            var ts = this, tid= ts.p.id;
            function start() {ts.p.disableClick = true;}
            var sortable_opts = {
                "tolerance" : "pointer",
                "axis" : "x",
                "scrollSensitivity": "1",
                "items": '>th:not(:has(#jqgh_'+tid+'_cb'+',#jqgh_'+tid+'_rn),:hidden)',
                "placeholder": {
                    element: function(item) {
                        var el = $(document.createElement(item[0].nodeName))
                            .addClass(item[0].className+" ui-sortable-placeholder ui-state-highlight")
                            .removeClass("ui-sortable-helper")[0];
                        return el;
                    },
                    update: function(self, p) {
                        p.height(self.currentItem.innerHeight() - parseInt(self.currentItem.css('paddingTop')||0, 10) - parseInt(self.currentItem.css('paddingBottom')||0, 10));
                        p.width(self.currentItem.innerWidth() - parseInt(self.currentItem.css('paddingLeft')||0, 10) - parseInt(self.currentItem.css('paddingRight')||0, 10));
                    }
                },
                "update": function(event, ui) {
                    var p = $(ui.item).parent(),
                        th = $(">th", p),
                        colModel = ts.p.colModel,
                        cmMap = {}, tid= ts.p.id+"_";
                    $.each(colModel, function(i) { cmMap[this.name]=i; });
                    var permutation = [];
                    th.each(function() {
                        var id = $(">div", this).get(0).id.replace(/^jqgh_/, "").replace(tid,"");
                        if (cmMap.hasOwnProperty(id)) {
                            permutation.push(cmMap[id]);
                        }
                    });

                    $(ts.element).jqGrid("remapColumns",permutation, true, true);
                    if ($.isFunction(ts.p.sortable.update)) {
                        ts.p.sortable.update(permutation);
                    }
                    setTimeout(function(){ts.p.disableClick=false;}, 50);
                }
            };
            if (ts.p.sortable.options) {
                $.extend(sortable_opts, ts.p.sortable.options);
            } else if ($.isFunction(ts.p.sortable)) {
                ts.p.sortable = { "update" : ts.p.sortable };
            }
            if (sortable_opts.start) {
                var s = sortable_opts.start;
                sortable_opts.start = function(e,ui) {
                    start();
                    s.call(this,e,ui);
                };
            } else {
                sortable_opts.start = start;
            }
            if (ts.p.sortable.exclude) {
                sortable_opts.items += ":not("+ts.p.sortable.exclude+")";
            }
            tblrow.sortable(sortable_opts).data("sortable").floating = true;
        },
        /**
         * 可以在表格内拖动行数据移动位置,依赖jqueryui的拖拽事件,不支持tree操作
         * @param  {Object} [opts] 可定义start和update事件，会在拖拽开始和结束的时候执行
         */
        sortableRows : function (opts) {
            // Can accept all sortable options and events
            var ts = this;
            if(!ts.grid) { return; }
            // Currently we disable a treeGrid sortable
            if(ts.p.treeGrid) { return; }
            if($.fn.sortable) {
                opts = $.extend({
                        "cursor":"move",
                        "axis" : "y",
                        "items": ".jqgrow"
                    },
                    opts || {});
                if(opts.start && $.isFunction(opts.start)) {
                    opts._start_ = opts.start;
                    delete opts.start;
                } else {opts._start_=false;}
                if(opts.update && $.isFunction(opts.update)) {
                    opts._update_ = opts.update;
                    delete opts.update;
                } else {opts._update_ = false;}
                opts.start = function(ev,ui) {
                    $(ui.item).css("border-width","0px");
                    $("td",ui.item).each(function(i){
                        this.style.width = ts.grid.cols[i].style.width;
                    });
                    if(opts._start_) {
                        opts._start_.apply(this,[ev,ui]);
                    }
                };
                opts.update = function (ev,ui) {
                    $(ui.item).css("border-width","");
                    if(ts.p.rownumbers === true) {
                        $("td.jqgrid-rownum",ts.rows).each(function( i ){
                            $(this).html( i+1+(parseInt(ts.p.page,10)-1)*parseInt(ts.p.rowNum,10) );
                        });
                    }
                    if(opts._update_) {
                        opts._update_.apply(this,[ev,ui]);
                    }
                };
                $("tbody:first",ts.elememt).sortable(opts);
                $("tbody:first",ts.elememt).disableSelection();
            }
        },
        /**
         * 可在表格间拖拽数据,依赖jqueryui的拖拽事件,不支持tree操作
         * @param  {Object} opts 可定义onstart、onstop事件，会在拖拽开始、结束的时候执行等等,
         * opts.connectWith 此值不为空,表示拖拽的目标对象.如示例中gridDrag2的行数据能拖进gridDrag中
         * <pre>
         * 	$("#gridDrag2").jqGrid("gridDnD",{connectWith:"#gridDrag"})
         * </pre>
         */
        gridDnD : function(opts) {
            var ts = this, i, cn;
            if(!ts.grid) { return; }
            // Currently we disable a treeGrid drag and drop
            if(ts.p.treeGrid) { return; }
            if(!$.fn.draggable || !$.fn.droppable) { return; }
            function updateDnD ()
            {
                var datadnd = $.data(ts.element[0],"dnd");
                $("tr.jqgrow:not(.ui-draggable)",ts.element).draggable($.isFunction(datadnd.drag) ? datadnd.drag.call(ts.element[0],datadnd) : datadnd.drag);
            }
            var appender = "<table id='jqgrid_dnd' class='ui-jqgrid-dnd'></table>";
            if($("#jqgrid_dnd")[0] === undefined) {
                $('body').append(appender);
            }

            if(typeof opts === 'string' && opts === 'updateDnD' && ts.p.jqgdnd===true) {
                updateDnD();
                return;
            }
            opts = $.extend({
                "drag" : function (opts) {
                    return $.extend({
                        start : function (ev, ui) {
                            var i, subgid;
                            // hack
                            // drag and drop does not insert tr in table, when the table has no rows
                            // we try to insert new empty row on the target(s)
                            var datadnd = $.data(ts.element[0],"dnd");
                            for (i=0;i<datadnd.connectWith.length;i++){
                                if($(datadnd.connectWith[i]).jqGrid('getGridParam','reccount') === 0 ){
                                    $(datadnd.connectWith[i]).jqGrid('addRowData','jqg_empty_row',{});
                                }
                            }
                            ui.helper.addClass("ui-state-highlight");
                            $("td",ui.helper).each(function(i) {
                                this.style.width = ts.grid.headers[i].width+"px";
                            });
                            if(opts.onstart && $.isFunction(opts.onstart) ) { opts.onstart.call(ts.element[0],ev,ui); }
                        },
                        stop :function(ev,ui) {
                            var i, ids;
                            if(ui.helper.dropped && !opts.dragcopy) {
                                ids = $(ui.helper).attr("id");
                                if(ids === undefined) { ids = $(this).attr("id"); }
                                $(ts.element).jqGrid('delRowData',ids );
                            }
                            var datadnd = $.data(ts.element[0],"dnd");
                            // if we have a empty row inserted from start event try to delete it
                            for (i=0;i<datadnd.connectWith.length;i++){
                                $(datadnd.connectWith[i]).jqGrid('delRowData','jqg_empty_row');
                            }
                            if(opts.onstop && $.isFunction(opts.onstop) ) { opts.onstop.call(ts.element[0],ev,ui); }
                        }
                    },opts.drag_opts || {});
                },
                "drop" : function (opts) {
                    return $.extend({
                        accept: function(d) {
                            if (!$(d).hasClass('jqgrow')) { return d;}
                            var tid = $(d).closest(".ui-jqgrid");//找到目标table
                            if(tid.length > 0 && $.data(tid[0],"dnd") !== undefined) {
                                var cn = $.data(tid[0],"dnd").connectWith;
                                return $.inArray('#'+this.id,cn) !== -1 ? true : false;
                            }
                            return false;
                        },
                        drop: function(ev, ui) {
                            if (!$(ui.draggable).hasClass('jqgrow')) { return; }
                            var accept = $(ui.draggable).attr("id");
                            var getdata = ui.draggable.closest(".ui-jqgrid").jqGrid('getRowData',accept);
                            if(!opts.dropbyname) {
                                var j =0, tmpdata = {}, nm, key;
                                var dropmodel = $("#"+this.id).jqGrid('getGridParam','colModel');
                                try {
                                    for (key in getdata) {
                                        if (getdata.hasOwnProperty(key)) {
                                            if(key === ts.p.localReader.id) continue;
                                            nm = dropmodel[j].name;
                                            if( !(nm === 'cb' || nm === 'rn')) {
                                                if(getdata.hasOwnProperty(key) && dropmodel[j]) {
                                                    tmpdata[nm] = getdata[key];
                                                }
                                            }
                                            j++;
                                        }
                                    }
                                    getdata = tmpdata;
                                } catch (e) {
                                    console.log(e);
                                }
                            }
                            ui.helper.dropped = true;
                            if(opts.beforedrop && $.isFunction(opts.beforedrop) ) {
                                //parameters to this callback - event, element, data to be inserted, sender, reciever
                                // should return object which will be inserted into the reciever
                                var datatoinsert = opts.beforedrop.call(this,ev,ui,getdata,ts.p.id,$(this));
                                if (datatoinsert !== undefined && datatoinsert !== null && typeof datatoinsert === "object") { getdata = datatoinsert; }
                            }
                            if(ui.helper.dropped) {
                                var growid;
                                if(opts.autoid) {
                                    if($.isFunction(opts.autoid)) {
                                        growid = opts.autoid.call(this,getdata);
                                    } else {
                                        growid = opts.autoidprefix + $.jgrid.randId();
                                    }
                                }
                                // NULL is interpreted as undefined while null as object
                                $("#"+this.id).jqGrid('addRowData',growid,getdata,opts.droppos);
                            }
                            if(opts.ondrop && $.isFunction(opts.ondrop) ) { opts.ondrop.call(this,ev,ui, getdata); }
                        }}, opts.drop_opts || {});
                },
                "onstart" : null,
                "onstop" : null,
                "beforedrop": null,
                "ondrop" : null,
                "drop_opts" : {
                    "activeClass": "ui-state-active",
                    "hoverClass": "ui-state-hover"
                },
                "drag_opts" : {
                    "revert": "invalid",
                    "helper": "clone",
                    "cursor": "move",
                    "appendTo" : "#jqgrid_dnd",
                    "zIndex": 5000
                },
                "dragcopy": false,
                "dropbyname" : false,
                "droppos" : "first",
                "autoid" : true,
                "autoidprefix" : "dnd_"
            }, opts || {});

            if(!opts.connectWith) { return; }
            opts.connectWith = opts.connectWith.split(",");
            opts.connectWith = $.map(opts.connectWith,function(n){return $.trim(n);});
            $.data(ts.element[0],"dnd",opts);

            if(ts.p.reccount !== 0 && !ts.p.jqgdnd) {
                updateDnD();
            }
            ts.p.jqgdnd = true;
            for (i=0;i<opts.connectWith.length;i++){
                cn =opts.connectWith[i];
                $(cn).droppable($.isFunction(opts.drop) ? opts.drop.call(ts.element[0],opts) : opts.drop);
            }
        },
        gridResize : function(opts) {
            var ts = this, gID = ts.p.id;
            if(!ts.grid || !$.fn.resizable) { return; }
            opts = $.extend({}, opts || {});
            if(opts.alsoResize ) {
                opts._alsoResize_ = opts.alsoResize;
                delete opts.alsoResize;
            } else {
                opts._alsoResize_ = false;
            }
            if(opts.stop && $.isFunction(opts.stop)) {
                opts._stop_ = opts.stop;
                delete opts.stop;
            } else {
                opts._stop_ = false;
            }
            opts.stop = function (ev, ui) {
                $(ts.element).jqGrid('setGridParam',{height:$("#gview_"+gID+" .ui-jqgrid-bdiv").height()});
                $(ts.element).jqGrid('setGridWidth',ui.size.width,opts.shrinkToFit);
                if(opts._stop_) { opts._stop_.call(ts.element[0],ev,ui); }
            };
            if(opts._alsoResize_) {
                var optstest = "{\'#gview_"+gID+" .ui-jqgrid-bdiv\':true,'" +opts._alsoResize_+"':true}";
                opts.alsoResize = eval('('+optstest+')'); // the only way that I found to do this
            } else {
                opts.alsoResize =  $(".ui-jqgrid-bdiv","#gview_"+gID);
            }
            delete opts._alsoResize_;
            $(ts.element).resizable(opts);
        }
    })

});
/*
 * Created by tanyl on 2014/12/30.
 */
!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.grid.tree', factory);
    } else {
        factory();
    }
}(function () {

    'use strict';

    $.extend($.ui.grid.prototype , {
        setTreeNode : function(i, len){
            //return this.each(function(){
                var ts = this;
                if( !ts.grid || !ts.p.treeGrid ) {return;}
                var expCol = ts.p.expColInd,
                    expanded = ts.p.treeReader.expanded_field,
                    isLeaf = ts.p.treeReader.leaf_field,
                    level = ts.p.treeReader.level_field,
                    icon = ts.p.treeReader.icon_field,
                    loaded = ts.p.treeReader.loaded, curLevel, ident,lftpos, twrap,
                    ldat, lf;

                //fix keyName
                // ts.p.localReader.id = ts.p.keyName?ts.p.keyName:ts.p.localReader.id;
                while(i<len) {
                    var ind = $.jgrid.stripPref(ts.p.idPrefix, ts.rows[i].id), dind = ts.p._index[ind], expan;
                    ldat = ts.p.data[dind];
                    curLevel = parseInt(ldat[level],10);
                    if(ts.p.tree_root_level === 0) {
                        ident = curLevel+1;
                        lftpos = curLevel;
                    } else {
                        ident = curLevel;
                        lftpos = curLevel -1;
                    }
                    twrap = "<div class='tree-wrap' style='width:"+(ident*18)+"px;'>";
                    twrap += "<div style='left:"+(lftpos*18)+"px;' class='ui-icon ";


                    if(ldat[loaded] !== undefined) {
                        if(ldat[loaded]==="true" || ldat[loaded]===true) {
                            ldat[loaded] = true;
                        } else {
                            ldat[loaded] = false;
                        }
                    }
                    if(ldat[isLeaf] === "true" || ldat[isLeaf] === true) {
                        twrap += ((ldat[icon] !== undefined && ldat[icon] !== "") ? ldat[icon] : ts.p.treeIcons.leaf)+" tree-leaf treeclick";
                        ldat[isLeaf] = true;
                        lf="leaf";
                    } else {
                        ldat[isLeaf] = false;
                        lf="";
                    }
                    ldat[expanded] = ((ldat[expanded] === "true" || ldat[expanded] === true) ? true : false) && (ldat[loaded] || ldat[loaded] === undefined);
                    if(ldat[expanded] === false) {
                        twrap += ((ldat[isLeaf] === true) ? "'" : ts.p.treeIcons.plus+" tree-plus treeclick'");
                    } else {
                        twrap += ((ldat[isLeaf] === true) ? "'" : ts.p.treeIcons.minus+" tree-minus treeclick'");
                    }

                    twrap += "></div></div>";
                    $(ts.rows[i].cells[expCol]).wrapInner("<span class='cell-wrapper"+lf+"'></span>").prepend(twrap);

                    if(curLevel !== parseInt(ts.p.tree_root_level,10)) {
                        var pn = $(ts.element).jqGrid('getNodeParent',ldat);
                        expan = pn && pn.hasOwnProperty(expanded) ? pn[expanded] : true;
                        if( !expan ){
                            $(ts.rows[i]).css("display","none");
                        }
                    }
                    $(ts.rows[i].cells[expCol])
                        .find("div.treeclick")
                        .bind("click",function(e){

                            var target = e.target || e.srcElement,
                                ind2 =$.jgrid.stripPref(ts.p.idPrefix,$(target,ts.rows).closest("tr.jqgrow")[0].id),
                                pos = ts.p._index[ind2];


                            //add 2014/5/22
                            var cSel = ts._trigger("beforeSelectRow", [ind2, e]);
                            if(cSel === false) return false;

                            if(!ts.p.data[pos][isLeaf]){
                                if(ts.p.data[pos][expanded]){
                                    // $(ts.element).jqGrid("collapseRow",ts.p.data[pos]);
                                    $(ts.element).jqGrid("collapseNode",ts.p.data[pos]);
                                    ts._trigger("onRowCollapse", [ts.p.data[pos]]);
                                } else {
                                    // $(ts.element).jqGrid("expandRow",ts.p.data[pos]);
                                    $(ts.element).jqGrid("expandNode",ts.p.data[pos]);
                                    //add 2014/5/22
                                    ts._trigger("onRowExpand", [ts.p.data[pos]]);
                                    if(!ts.p.leafChange) return false;
                                    var parent = ts.p.data[pos];
                                    var children = $(ts.element).jqGrid("getNodeChildren",parent);
                                    if(children.length==0){//没有子节点则自动更新图标及状态
                                        parent[isLeaf]=true;//更新父节点状态
                                        parent[expanded] = false;
                                        $(ts.element).jqGrid("setTreeRow",parent[ts.p.keyName],parent);
                                        var prow = $(ts.element).jqGrid('getInd', parent[ts.p.keyName]);
                                        $(ts.rows[prow])
                                            .find("span.cell-wrapper").removeClass("cell-wrapper").addClass("cell-wrapperleaf")
                                            .end()
                                            .find("div.tree-minus").removeClass(ts.p.treeIcons.minus+" tree-minus").addClass(ts.p.treeIcons.leaf+" tree-leaf");
                                    }

                                }
                            }
                            return false;
                        });
                    if(ts.p.ExpandColClick === true) {
                        $(ts.rows[i].cells[expCol])
                            .find("span.cell-wrapper")
                            .css("cursor","pointer")
                            .bind("click",function(e) {
                                var target = e.target || e.srcElement,
                                    ind2 =$.jgrid.stripPref(ts.p.idPrefix,$(target,ts.rows).closest("tr.jqgrow")[0].id),
                                    pos = ts.p._index[ind2];
                                if(!ts.p.data[pos][isLeaf]){
                                    if(ts.p.data[pos][expanded]){
                                        // $(ts.element).jqGrid("collapseRow",ts.p.data[pos]);
                                        $(ts.element).jqGrid("collapseNode",ts.p.data[pos]);
                                    } else {
                                        // $(ts.element).jqGrid("expandRow",ts.p.data[pos]);
                                        $(ts.element).jqGrid("expandNode",ts.p.data[pos]);
                                    }
                                }
                                $(ts.element).jqGrid("setSelection",ind2);
                                return false;
                            });
                    }
                    i++;
                }

            //});
        },
        setTreeGrid : function() {
            //return this.each(function (){
                var ts = this, i=0, pico, ecol = false, nm, key, tkey, dupcols=[];
                if(!ts.p.treeGrid) {return;}
                // if(!ts.p.treedatatype ) {$.extend(ts.p,{treedatatype: ts.p.datatype});}
                ts.p.altRows =false;
                ts.p.viewrecords = false;
                // ts.p.pgbuttons = false;ts.p.pginput = false;
                // ts.p.gridview =  true;
                // if(ts.p.rowTotal === null ) { ts.p.rowNum = 10000; }
                // ts.p.multiselect = false;
                //ts.p.rowList = [];
                ts.p.expColInd = 0;
                pico = 'ui-icon-triangle-1-' + (ts.p.direction==="rtl" ? 'w' : 'e');
                ts.p.treeIcons = $.extend({plus:pico,minus:'ui-icon-triangle-1-s',leaf:'ui-icon-radio-off'},ts.p.treeIcons || {});
                ts.p.treeReader = $.extend({
                    level_field: "level",
                    parent_id_field: "parent",
                    leaf_field: "isLeaf",
                    expanded_field: "expanded",
                    loaded: "loaded",
                    icon_field: "icon"
                },ts.p.treeReader );
                for ( key in ts.p.colModel){
                    if(ts.p.colModel.hasOwnProperty(key)) {
                        nm = ts.p.colModel[key].name;
                        if( nm === ts.p.ExpandColumn && !ecol ) {
                            ecol = true;
                            ts.p.expColInd = i;
                        }
                        i++;
                        //
                        for(tkey in ts.p.treeReader) {
                            if(ts.p.treeReader.hasOwnProperty(tkey) && ts.p.treeReader[tkey] === nm) {
                                dupcols.push(nm);
                            }
                        }
                    }
                }
                $.each(ts.p.treeReader,function(j,n){
                    if(n && $.inArray(n, dupcols) === -1){
                        if(j==='leaf_field') { ts.p._treeleafpos= i; }
                        i++;
                        // ts.p.colNames.push(n);
                        ts.p.colModel.push({label:n,name:n,width:1,hidden:true,sortable:false,resizable:false,hidedlg:true,editable:true,search:false});
                    }
                });
            //});
        },
        /**
         * 界面上展开节点行
         * @param  {Object} rowData 要展开的行数据
         */
        expandRow: function (record){
            //this.each(function(){
                var ts = this;
                if(!ts.grid || !ts.p.treeGrid) {return;}
                var childern = $(ts.element).jqGrid("getNodeChildren",record),
                //if ($(ts.element).jqGrid("isVisibleNode",record)) {
                    expanded = ts.p.treeReader.expanded_field;
                $(childern).each(function(){
                    var id  = ts.p.idPrefix + $.jgrid.getAccessor(this,ts.p.keyName);
                    $($(ts.element).jqGrid('getGridRowById', id)).css("display","");
                    if(this[expanded]) {
                        $(ts.element).jqGrid("expandRow",this);
                    }
                });
                //}
            //});
        },
        /**
         * 界面上收缩节点行
         * @param  {Object} rowData 要收缩的行数据
         */
        collapseRow : function (record) {
            //this.each(function(){
                var ts = this;
                if(!ts.grid || !ts.p.treeGrid) {return;}
                var childern = $(ts.element).jqGrid("getNodeChildren",record),
                    expanded = ts.p.treeReader.expanded_field;
                $(childern).each(function(){
                    var id  = ts.p.idPrefix + $.jgrid.getAccessor(this,ts.p.keyName);
                    $($(ts.element).jqGrid('getGridRowById', id)).css("display","none");
                    if(this[expanded]){
                        $(ts.element).jqGrid("collapseRow",this);
                    }
                });
            //});
        },
        /**
         * 获取跟节点数据
         * @return {Array} 根节点数据集合
         */
        getRootNodes : function() {
            var result = [];
            //this.each(function(){
                var ts = this;
                if(!ts.grid || !ts.p.treeGrid) {return;}
                var parent_id = ts.p.treeReader.parent_id_field;
                $(ts.p.data).each(function(){
                    if(this[parent_id] === null || String(this[parent_id]).toLowerCase() === "null" || this[parent_id] === undefined || this[parent_id] === "undefined" ||  this[parent_id] === "" ) {
                        result.push(this);
                    }
                });
            //});
            return result;
        },
        /**
         * 获取某节点的级别，即相对于根节点的level
         * @param  {Object} rowData 节点数据
         * @return {Object} 所在tree里面的级别
         */
        getNodeDepth : function(rc) {
            var ret = null;
            //this.each(function(){
                if(!this.grid || !this.p.treeGrid) {return;}
                var ts = this;
                ret = $(ts.element).jqGrid("getNodeAncestors",rc).length;
            //});
            return ret;
        },
        /**
         * 获取某节点的父节点数据
         * @param  {Object} rowData 节点数据
         * @return {Object} 父节点数据
         */
        getNodeParent : function(rc) {
            var result = null;
            //this.each(function(){
                var ts = this;
                if(!ts.grid || !ts.p.treeGrid) {return;}
                var parent_id = ts.p.treeReader.parent_id_field,
                    dtid = ts.p.keyName;
                $(this.p.data).each(function(){
                    if(this[dtid] === $.jgrid.stripPref(ts.p.idPrefix, rc[parent_id]) ) {
                        result = this;
                        return false;
                    }
                });
            //});
            return result;
        },
        /**
         * 获取某节点的子节点数据
         * @param  {Object} rowData 节点数据
         * @return {Array} 下一级子节点数据集合
         */
        getNodeChildren : function(rc) {
            var result = [];
            //this.each(function(){
                var ts = this;
                if(!ts.grid || !ts.p.treeGrid) {return;}
                var parent_id = ts.p.treeReader.parent_id_field,
                    dtid = ts.p.keyName;
                $(this.p.data).each(function(){
                    if(this[parent_id] == $.jgrid.stripPref(ts.p.idPrefix, rc[dtid])) {
                        result.push(this);
                    }
                });
            //});
            return result;
        },
        /**
         * 获取某节点下的全部节点数据，含自身数据
         * @param  {Object} rowData 节点数据
         * @return {Array}  节点下全部的数据集合
         */
        getFullTreeNode : function(rc) {
            var result = [];
            //this.each(function(){
                var ts = this, len;
                if(!ts.grid || !ts.p.treeGrid) {return;}
                if(rc) {
                    result.push(rc);
                    var parent_id = ts.p.treeReader.parent_id_field,
                        dtid = ts.p.keyName;
                    $(this.p.data).each(function(i){
                        len = result.length;
                        for (i = 0; i < len; i++) {
                            if ($.jgrid.stripPref(ts.p.idPrefix, result[i][dtid]) === this[parent_id]) {
                                result.push(this);
                                break;
                            }
                        }
                    });
                }
            //});
            return result;
        },
        /**
         * 获取某节点的父节点以上的数据，从下往上的数据集合，不包含自身
         * @param  {Object} rowData 节点数据
         * @return {Object} 父节点递归数据集合
         */
        getNodeAncestors : function(rc) {
            var ancestors = [];
            var ts = this;
            //this.each(function(){
                if(!this.grid || !this.p.treeGrid) {return;}
                var parent = $(ts.element).jqGrid("getNodeParent",rc);
                while (parent) {
                    ancestors.push(parent);
                    parent = $(ts.element).jqGrid("getNodeParent",parent);
                }
            //});
            return ancestors;
        },
        /**
         * 节点是否可见，可用于定位某个节点用
         * @param  {Object} rowData 节点数据
         * @return {Boolean}    节点是否可见，所有的父节点都是展开状态节点才是可见状态
         */
        isVisibleNode : function(rc) {
            var result = true;
            //this.each(function(){
                var ts = this;
                if(!ts.grid || !ts.p.treeGrid) {return;}
                var ancestors = $(ts.element).jqGrid("getNodeAncestors",rc),
                    expanded = ts.p.treeReader.expanded_field;
                $(ancestors).each(function(){
                    result = result && this[expanded];
                    if(!result) {return false;}
                });
            //});
            return result;
        },
        /**
         * 展开节点数据，往往配合展开行expandRow方法一起使用
         * @param  {Object} rowData 节点数据
         */
        expandNode : function(rc) {
            //return this.each(function(){
                var ts = this;
                if(!ts.grid || !ts.p.treeGrid) {return;}
                var expanded = ts.p.treeReader.expanded_field;
                if(!rc[expanded] || rc[expanded] === "false") {
                    rc[expanded] = true;
                    var id = $.jgrid.getAccessor(rc,ts.p.keyName);
                    var rc1 = $("#" + ts.p.idPrefix + id,ts.grid.bDiv)[0];
                    $("div.treeclick",rc1).removeClass(ts.p.treeIcons.plus+" tree-plus").addClass(ts.p.treeIcons.minus+" tree-minus");
                }
                $(ts.element).jqGrid("expandRow",rc);
            //});
        },
        /**
         * 收缩节点数据，往往配合收缩行collapseRow方法一起使用
         * @param  {Object} rowData 节点数据
         */
        collapseNode : function(rc) {
            //return this.each(function(){
                var ts = this;
                if(!ts.grid || !ts.p.treeGrid) {return;}
                var expanded = ts.p.treeReader.expanded_field;
                if(rc[expanded] || rc[expanded] === "true") {
                    rc[expanded] = false;
                    var id = $.jgrid.getAccessor(rc,ts.p.keyName);
                    var rc1 = $("#" + ts.p.idPrefix + $.jgrid.jqID(id),ts.grid.bDiv)[0];
                    $("div.treeclick",rc1).removeClass(ts.p.treeIcons.minus+" tree-minus").addClass(ts.p.treeIcons.plus+" tree-plus");
                }
                $(ts.element).jqGrid("collapseRow",rc);
            //});
        },
        SortTree : function( sortname, newDir, st, datefmt) {
            //return this.each(function(){
                if(!this.grid || !this.p.treeGrid) {return;}
                var i, len,
                    rec, records = [], ts = this, query, roots,
                    rt = $(this).jqGrid("getRootNodes");
                // Sorting roots
                query = $.jgrid.from(rt);
                query.orderBy(sortname,newDir,st, datefmt);
                roots = query.select();

                // Sorting children
                for (i = 0, len = roots.length; i < len; i++) {
                    rec = roots[i];
                    records.push(rec);
                    $(ts.element).jqGrid("collectChildrenSortTree",records, rec, sortname, newDir,st, datefmt);
                }
                $.each(records, function(index) {
                    var id  = $.jgrid.getAccessor(this,ts.p.keyName);
                    $('#'+$.jgrid.jqID(ts.p.id)+ ' tbody tr:eq('+index+')').after($('tr#'+$.jgrid.jqID(id),ts.grid.bDiv));
                });
                query = null;roots=null;records=null;
            //});
        },
        collectChildrenSortTree : function(records, rec, sortname, newDir,st, datefmt) {
            //return this.each(function(){
            var ts = this;
                if(!ts.grid || !ts.p.treeGrid) {return;}
                var i, len,
                    child, ch, query, children;
                ch = $(ts.element).jqGrid("getNodeChildren",rec);
                query = $.jgrid.from(ch);
                query.orderBy(sortname, newDir, st, datefmt);
                children = query.select();
                for (i = 0, len = children.length; i < len; i++) {
                    child = children[i];
                    records.push(child);
                    $(ts.element).jqGrid("collectChildrenSortTree",records, child, sortname, newDir, st, datefmt);
                }
            //});
        },
        setTreeRow : function(rowid, data) {
            return this.jqGrid("modTreeNode",rowid, data);
        },
        /**
         * 修改节点数据
         * @method modTreeNode
         * @param {String} rowid 行标识,也可以直接传入行数据rowData
         * @param {Object} [rowData]  行数据,行标识的值目前不支持修改
         */
        modTreeNode:function(rowid, data) {
            var success=false;
            //this.each(function(){
                var ts = this;
                if(!ts.grid || !ts.p.treeGrid) {return;}
                success = $(ts.element).jqGrid("setRowData",rowid,data);
            //});
            return success;
        },
        /**
         * 删除tree节点
         * @param  {String} nodeid 行标识,也可以是行数据rowData
         */
        delTreeNode : function (rowid) {
            var ts = this,rid = ts.p.keyName;
            if($.type(rowid)==='object'){
                rowid = rowid[rid];
            }
            //return this.each(function () {
                if(!ts.grid || !ts.p.treeGrid) {return;}
                var rc = ts.p._index[rowid];
                if (rc !== undefined) {
                    var dr = $(ts.element).jqGrid("getFullTreeNode",ts.p.data[rc]);
                    if(dr.length>0){
                        for (var i=0;i<dr.length;i++){
                            $(ts.element).jqGrid("delRowData",dr[i][rid]);
                        }
                    }
                }
            //});
        },
        /**
         * 新增tree节点
         * @param {String} nodeid     行标识,也可以是行数据rowData
         * @param {String} parent     父节点标识,也可以是父节点数据,可为空,为空表示新增的是跟节点
         * @param {Object} [rowData]       新增的节点数据,如果第一个参数是行标识的话,此值需要传
         * @param {Boolean} [expandData] 如果新增的数据所在的父节点未展开且此值设置为true，则触发展开操作
         */
        addChildNode : function( nodeid, parentid, data, expandData ) {
            //return this.each(function(){
            var ts = this;
            if($.type(nodeid)==='object'){
                expandData = data;
                data = nodeid;
                nodeid = data[ts.p.keyName];
            }
            if($.type(parentid)==='object'){
                parentid = parentid[ts.p.keyName];
            }
            if(data) {
                // we suppose tha the id is autoincremet and
                var expanded = ts.p.treeReader.expanded_field,
                    isLeaf = ts.p.treeReader.leaf_field,
                    level = ts.p.treeReader.level_field,
                //icon = ts.p.treeReader.icon_field,
                    parent = ts.p.treeReader.parent_id_field,
                // left = ts.p.treeReader.left_field,
                // right = ts.p.treeReader.right_field,
                    loaded = ts.p.treeReader.loaded,
                    method, parentindex, parentdata, parentlevel, i, len, max=0, rowind = parentid, leaf, maxright;
                if(expandData===undefined) {expandData = false;}
                if ( nodeid === undefined || nodeid === null ) {
                    i = ts.p.data.length-1;
                    if(	i>= 0 ) {
                        while(i>=0){max = Math.max(max, parseInt(ts.p.data[i][ts.p.keyName],10)); i--;}
                    }
                    nodeid = max+1;
                }
                var prow = $(ts.element).jqGrid('getInd', parentid);
                leaf = false;
                // if not a parent we assume root
                if ( parentid === undefined  || parentid === null || parentid==="") {
                    parentid = null;
                    rowind = null;
                    method = 'last';
                    parentlevel = ts.p.tree_root_level;
                    i = ts.p.data.length+1;
                } else {
                    method = 'after';
                    parentindex = ts.p._index[parentid];
                    parentdata = ts.p.data[parentindex];
                    parentid = parentdata[ts.p.keyName];
                    parentlevel = parseInt(parentdata[level],10)+1;
                    var childs = $(ts.element).jqGrid('getFullTreeNode', parentdata);
                    // if there are child nodes get the last index of it
                    if(childs.length) {
                        i = childs[childs.length-1][ts.p.keyName];
                        rowind = i;
                        i = $(ts.element).jqGrid('getInd',rowind)+1;
                    } else {
                        i = $(ts.element).jqGrid('getInd', parentid)+1;
                    }
                    // if the node is leaf
                    if(parentdata[isLeaf]) {
                        leaf = true;
                        parentdata[expanded] = true;
                        //var prow = $(ts.element).jqGrid('getInd', parentid);
                        $(ts.rows[prow])
                            .find("span.cell-wrapperleaf").removeClass("cell-wrapperleaf").addClass("cell-wrapper")
                            .end()
                            .find("div.tree-leaf").removeClass(ts.p.treeIcons.leaf+" tree-leaf").addClass(ts.p.treeIcons.minus+" tree-minus");
                        ts.p.data[parentindex][isLeaf] = false;
                        parentdata[loaded] = true;
                    }
                }
                len = i+1;

                if( data[expanded]===undefined)  {data[expanded]= false;}
                if( data[loaded]===undefined )  { data[loaded] = false;}
                data[level] = parentlevel;
                if( data[isLeaf]===undefined) {data[isLeaf]= true;}
                // if( ts.p.treeGridModel === "adjacency") {
                data[parent] = parentid;
                // }
                // if( parentid === null || leaf ) {
                $(ts.element).jqGrid('addRowData', nodeid, data, method, rowind);
                $(ts.element).jqGrid('setTreeNode', i, len);
                // }
                if(parentdata && !parentdata[expanded] && expandData) {
                    $(ts.rows[prow])
                        .find("div.treeclick")
                        .click();
                }
            }
            //});
        },
        /**
         * 新增多个tree节点
         * @param {Array} dataArr  多个tree节点
         * @param {Object} [parent]  父节点行数据,也可以是父节点rowid,为空则表示数据加在根节点上
         * @param {Boolean} [expandData] 如果新增的数据所在的父节点未展开且此值设置为true，则触发展开操作
         */
        addChildNodes : function(  dataArr, parentid, expandData ) {
            //return this.each(function(){
            var ts = this,parentdata,parentid,rowind;
            if($.type(parentid)==='object'){
                parentdata = parentid;
                parentid = parentdata[ts.p.keyName];
            }
            if(dataArr) {
                if(!$.isArray(dataArr)){
                    dataArr = [dataArr];
                }
                if (ts.p.treeDataFormat === "child") {//数据需要重组
                    dataArr = $.jgrid.childrenDataFormat(dataArr, ts.p.keyName);
                } else if (ts.p.treeDataFormat === "line") {
                    dataArr = $.jgrid.treeDataFormat(dataArr);
                }
                rowind = parentid;
                // we suppose tha the id is autoincremet and
                var expanded = ts.p.treeReader.expanded_field,
                    isLeaf = ts.p.treeReader.leaf_field,
                    level = ts.p.treeReader.level_field,
                //icon = ts.p.treeReader.icon_field,
                    parent = ts.p.treeReader.parent_id_field,
                // left = ts.p.treeReader.left_field,
                // right = ts.p.treeReader.right_field,
                    loaded = ts.p.treeReader.loaded,
                    method, parentindex, parentlevel, i, len, max=0, leaf, maxright,rowind;
                if(expandData===undefined) {expandData = false;}
                var prow = $(ts.element).jqGrid('getInd', parentid);
                leaf = false;
                // if not a parent we assume root
                if ( parentid === undefined  || parentid === null || parentid==="") {
                    parentid = null;
                    rowind = null;
                    method = 'last';
                    parentlevel = ts.p.tree_root_level;
                    i = ts.p.data.length+1;
                } else {
                    method = 'after';
                    parentindex = ts.p._index[parentid];
                    // parentdata = ts.p.data[parentindex];
                    parentid = parentdata[ts.p.keyName];
                    parentlevel = parseInt(parentdata[level],10)+1;
                    var childs = $(ts.element).jqGrid('getFullTreeNode', parentdata);
                    // if there are child nodes get the last index of it
                    if(childs.length) {
                        i = childs[childs.length-1][ts.p.keyName];
                        rowind = i;
                        i = $(ts.element).jqGrid('getInd',rowind)+1;
                    } else {
                        i = $(ts.element).jqGrid('getInd', parentid)+1;
                    }
                    // if the node is leaf
                    if(parentdata[isLeaf]) {
                        leaf = true;
                        parentdata[expanded] = true;
                        //var prow = $(ts.element).jqGrid('getInd', parentid);
                        $(ts.rows[prow])
                            .find("span.cell-wrapperleaf").removeClass("cell-wrapperleaf").addClass("cell-wrapper")
                            .end()
                            .find("div.tree-leaf").removeClass(ts.p.treeIcons.leaf+" tree-leaf").addClass(ts.p.treeIcons.minus+" tree-minus");
                        ts.p.data[parentindex][isLeaf] = false;
                        parentdata[loaded] = true;
                    }
                }
                len = i+dataArr.length;
                for(var j=0;j<dataArr.length;j++){
                    if( dataArr[j][expanded]===undefined)  {dataArr[j][expanded]= false;}
                    dataArr[j][loaded] = true ;
                    dataArr[j][level] +=parentlevel;
                    if( dataArr[j][isLeaf]===undefined) {dataArr[j][isLeaf]= true;}
                    if( dataArr[j][parent]===undefined || dataArr[j][parent] === null ) {dataArr[j][parent] = parentid;}
                }
                // if( parentid === null || leaf ) {
                $(ts.element).jqGrid('addRowData', ts.p.keyName, dataArr, method, rowind);
                $(ts.element).jqGrid('setTreeNode', i, len);
                // }
                if(parentdata && !parentdata[expanded] && expandData) {
                    $(ts.rows[prow])
                        .find("div.treeclick")
                        .click();
                }
            }
            //});
        }
    });

    $.jgrid.treeDataFormat = function(items,expandedAll){
        for (var i = 0; i < items.length; i++) {
            if (items[i].isLeaf == null) {
                items[i].isLeaf = (i==(items.length-1) || items[i+1].level<=items[i].level) ? true : false ; //判断是否为叶子节点
            }
            items[i].level = items[i].level -1 ;//level减一;parent,isLeaf自己控制;
            if (expandedAll) {
                items[i].expanded = true; //全局展开
            } else if (items[i].expanded == null) {
                items[i].expanded = false; //默认不展开
                //特殊处理,跟节点默认展开
                //if(items[i].level === 0) items[i].expanded = true;
            }
            items[i].loaded = true; //数据已加载
        }
        return items;
    }

    $.jgrid.childrenDataFormat = function(items,keyName,expandedAll){
        var treeData = [],
            index = 0,
            treeLevel = 0;

        dealWithChildren(items, treeLevel, null);

        function dealWithChildren(retVal, treeLevel, parentId) {
            for (var i = 0; i < retVal.length; i++) {
                var temp = retVal[i];
                var tempData = temp;
                tempData.level = treeLevel;
                tempData.parent = parentId;
                if (tempData.isLeaf == null) {
                    tempData.isLeaf = tempData.hasOwnProperty("children") ? false : true; //根据节点是否有children属性,判断是否为叶子节点
                }
                if (expandedAll) {
                    tempData.expanded = true; //默认不展开
                } else if (tempData.expanded == null) {
                    tempData.expanded = false; //默认不展开
                }
                tempData.loaded = true;
                treeData[index++] = tempData;
                if (tempData.children != null) {
                    if (tempData.children.length > 0) {
                        dealWithChildren(tempData.children, treeLevel + 1, tempData[keyName]);
                    }
                    tempData.children = null; //不会将数据保存为全局变量吧
                }
            }
        }
        return treeData;
    }

});
/*
 * Created by tanyl on 2015/1/2.
 */
!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.grid.edithelp', factory);
    } else {
        factory();
    }
}(function () {

    'use strict';

    $.extend($.jgrid,{
        //Helper functions
        findPos : function(obj) {
            var curleft = 0, curtop = 0;
            if (obj.offsetParent) {
                do {
                    curleft += obj.offsetLeft;
                    curtop += obj.offsetTop;
                } while (obj = obj.offsetParent);
                //do not change obj == obj.offsetParent
            }
            return [curleft,curtop];
        },
        info_dialog : function(caption, content,c_b, modalopt) {
            alert(content);
            // console.log("caption:"+caption +"-->content:"+content+"-->c_b:"+c_b+"-->modalopt:"+modalopt);
            // var mopt = {
            // 	width:290,
            // 	height:'auto',
            // 	dataheight: 'auto',
            // 	drag: true,
            // 	resize: false,
            // 	left:250,
            // 	top:170,
            // 	zIndex : 1000,
            // 	jqModal : true,
            // 	modal : false,
            // 	closeOnEscape : true,
            // 	align: 'center',
            // 	buttonalign : 'center',
            // 	buttons : []
            // // {text:'textbutt', id:"buttid", onClick : function(){...}}
            // // if the id is not provided we set it like info_button_+ the index in the array - i.e info_button_0,info_button_1...
            // };
            // $.extend(true, mopt, $.jgrid.jqModal || {}, {caption:"<b>"+caption+"</b>"}, modalopt || {});
            // var jm = mopt.jqModal, self = this;
            // if($.fn.jqm && !jm) { jm = false; }
            // // in case there is no jqModal
            // var buttstr ="", i;
            // if(mopt.buttons.length > 0) {
            // 	for(i=0;i<mopt.buttons.length;i++) {
            // 		if(mopt.buttons[i].id === undefined) { mopt.buttons[i].id = "info_button_"+i; }
            // 		buttstr += "<a id='"+mopt.buttons[i].id+"' class='fm-button ui-state-default ui-corner-all'>"+mopt.buttons[i].text+"</a>";
            // 	}
            // }
            // var dh = isNaN(mopt.dataheight) ? mopt.dataheight : mopt.dataheight+"px",
            // cn = "text-align:"+mopt.align+";";
            // var cnt = "<div id='info_id'>";
            // cnt += "<div id='infocnt' style='margin:0px;padding-bottom:1em;width:100%;overflow:auto;position:relative;height:"+dh+";"+cn+"'>"+content+"</div>";
            // cnt += c_b ? "<div class='ui-widget-content ui-helper-clearfix' style='text-align:"+mopt.buttonalign+";padding-bottom:0.8em;padding-top:0.5em;background-image: none;border-width: 1px 0 0 0;'><a id='closedialog' class='fm-button ui-state-default ui-corner-all'>"+c_b+"</a>"+buttstr+"</div>" :
            // 	buttstr !== ""  ? "<div class='ui-widget-content ui-helper-clearfix' style='text-align:"+mopt.buttonalign+";padding-bottom:0.8em;padding-top:0.5em;background-image: none;border-width: 1px 0 0 0;'>"+buttstr+"</div>" : "";
            // cnt += "</div>";

            // try {
            // 	if($("#info_dialog").attr("aria-hidden") === "false") {
            // 		$.jgrid.hideModal("#info_dialog",{jqm:jm});
            // 	}
            // 	$("#info_dialog").remove();
            // } catch (e){}
            // $.jgrid.createModal({
            // 	themodal:'info_dialog',
            // 	modalhead:'info_head',
            // 	modalcontent:'info_content',
            // 	scrollelm: 'infocnt'},
            // 	cnt,
            // 	mopt,
            // 	'','',true
            // );
            // // attach onclick after inserting into the dom
            // if(buttstr) {
            // 	$.each(mopt.buttons,function(i){
            // 		$("#"+$.jgrid.jqID(this.id),"#info_id").bind('click',function(){mopt.buttons[i].onClick.call($("#info_dialog")); return false;});
            // 	});
            // }
            // $("#closedialog", "#info_id").click(function(){
            // 	self.hideModal("#info_dialog",{
            // 		jqm:jm,
            // 		onClose: $("#info_dialog").data("onClose") || mopt.onClose,
            // 		gb: $("#info_dialog").data("gbox") || mopt.gbox
            // 	});
            // 	return false;
            // });
            // $(".fm-button","#info_dialog").hover(
            // 	function(){$(this).addClass('ui-state-hover');},
            // 	function(){$(this).removeClass('ui-state-hover');}
            // );
            // if($.isFunction(mopt.beforeOpen) ) { mopt.beforeOpen(); }
            // $.jgrid.viewModal("#info_dialog",{
            // 	onHide: function(h) {
            // 		h.w.hide().remove();
            // 		if(h.o) { h.o.remove(); }
            // 	},
            // 	modal :mopt.modal,
            // 	jqm:jm
            // });
            // if($.isFunction(mopt.afterOpen) ) { mopt.afterOpen(); }
            // try{ $("#info_dialog").focus();} catch (m){}
        },
        bindEv: function  (el, opt) {
            var $t = this;
            if($.isFunction(opt.dataInit)) {
                opt.dataInit.call($t,el,opt);
            }
            if(opt.dataEvents) {
                $.each(opt.dataEvents, function() {
                    if (this.data !== undefined) {
                        $(el).bind(this.type, this.data, this.fn);
                    } else {
                        $(el).bind(this.type, this.fn);
                    }
                });
            }
        },
        // Form Functions
        createEl : function(eltype,options,vl,autowidth, ajaxso) {
            var elem = "", $t = this;
            function setAttributes(elm, atr, exl ) {
                var exclude = ['dataInit','dataEvents','dataUrl', 'buildSelect','sopt', 'searchhidden', 'defaultValue', 'attr', 'custom_element', 'custom_value'];
                if(exl !== undefined && $.isArray(exl)) {
                    $.merge(exclude, exl);
                }
                $.each(atr, function(key, value){
                    if($.inArray(key, exclude) === -1) {
                        $(elm).attr(key,value);
                    }
                });
                if(!atr.hasOwnProperty('id')) {
                    $(elm).attr('id', $.jgrid.randId());
                }
            }
            switch (eltype)
            {
                case "textarea" :
                    elem = document.createElement("textarea");
                    if(autowidth) {
                        if(!options.cols) { $(elem).css({width:"98%"});}
                    } else if (!options.cols) { options.cols = 20; }
                    if(!options.rows) { options.rows = 2; }
                    if(vl==='&nbsp;' || vl==='&#160;' || (vl.length===1 && vl.charCodeAt(0)===160)) {vl="";}
                    elem.value = vl;
                    setAttributes(elem, options);
                    $(elem).attr({"role":"textbox","multiline":"true"});
                    break;
                case "checkbox" : //what code for simple checkbox
                    elem = document.createElement("input");
                    elem.type = "checkbox";
                    if( !options.value ) {
                        var vl1 = (vl+"").toLowerCase();
                        if(vl1.search(/(false|f|0|no|n|off|undefined)/i)<0 && vl1!=="") {
                            elem.checked=true;
                            elem.defaultChecked=true;
                            elem.value = vl;
                        } else {
                            elem.value = "on";
                        }
                        $(elem).attr("offval","off");
                    } else {
                        var cbval = options.value.split(":");
                        if(vl === cbval[0]) {
                            elem.checked=true;
                            elem.defaultChecked=true;
                        }
                        elem.value = cbval[0];
                        $(elem).attr("offval",cbval[1]);
                    }
                    setAttributes(elem, options, ['value']);
                    $(elem).attr("role","checkbox");
                    break;
                case "select" :
                    elem = document.createElement("select");
                    elem.setAttribute("role","select");
                    var msl, ovm = [];
                    if(options.multiple===true) {
                        msl = true;
                        elem.multiple="multiple";
                        $(elem).attr("aria-multiselectable","true");
                    } else { msl = false; }
                    if(options.dataUrl !== undefined) {
                        var rowid = options.name ? String(options.id).substring(0, String(options.id).length - String(options.name).length - 1) : String(options.id),
                            postData = options.postData || ajaxso.postData;

                        if ($t.p && $t.p.idPrefix) {
                            rowid = $.jgrid.stripPref($t.p.idPrefix, rowid);
                        }
                        $.ajax($.extend({
                            url: $.isFunction(options.dataUrl) ? options.dataUrl.call($t, rowid, vl, String(options.name)) : options.dataUrl,
                            type : "GET",
                            dataType: "html",
                            data: $.isFunction(postData) ? postData.call($t, rowid, vl, String(options.name)) : postData,
                            context: {elem:elem, options:options, vl:vl},
                            success: function(data){
                                var ovm = [], elem = this.elem, vl = this.vl,
                                    options = $.extend({},this.options),
                                    msl = options.multiple===true,
                                    a = $.isFunction(options.buildSelect) ? options.buildSelect.call($t,data) : data;
                                if(typeof a === 'string') {
                                    a = $( $.trim( a ) ).html();
                                }
                                if(a) {
                                    $(elem).append(a);
                                    setAttributes(elem, options, postData ? ['postData'] : undefined );
                                    if(options.size === undefined) { options.size =  msl ? 3 : 1;}
                                    if(msl) {
                                        ovm = vl.split(",");
                                        ovm = $.map(ovm,function(n){return $.trim(n);});
                                    } else {
                                        ovm[0] = $.trim(vl);
                                    }
                                    //$(elem).attr(options);
                                    setTimeout(function(){
                                        $("option",elem).each(function(i){
                                            //if(i===0) { this.selected = ""; }
                                            // fix IE8/IE7 problem with selecting of the first item on multiple=true
                                            if (i === 0 && elem.multiple) { this.selected = false; }
                                            $(this).attr("role","option");
                                            if($.inArray($.trim($(this).text()),ovm) > -1 || $.inArray($.trim($(this).val()),ovm) > -1 ) {
                                                this.selected= "selected";
                                            }
                                        });
                                    },0);
                                }
                            }
                        },ajaxso || {}));
                    } else if(options.value) {
                        var i;
                        if(options.size === undefined) {
                            options.size = msl ? 3 : 1;
                        }
                        if(msl) {
                            ovm = vl.split(",");
                            ovm = $.map(ovm,function(n){return $.trim(n);});
                        }
                        if(typeof options.value === 'function') { options.value = options.value(); }
                        var so,sv, ov,
                            sep = options.separator === undefined ? ":" : options.separator,
                            delim = options.delimiter === undefined ? ";" : options.delimiter;
                        if(typeof options.value === 'string') {
                            so = options.value.split(delim);
                            for(i=0; i<so.length;i++){
                                sv = so[i].split(sep);
                                if(sv.length > 2 ) {
                                    sv[1] = $.map(sv,function(n,ii){if(ii>0) { return n;} }).join(sep);
                                }
                                ov = document.createElement("option");
                                ov.setAttribute("role","option");
                                ov.value = sv[0]; ov.innerHTML = sv[1];
                                elem.appendChild(ov);
                                if (!msl &&  ($.trim(sv[0]) === $.trim(vl) || $.trim(sv[1]) === $.trim(vl))) { ov.selected ="selected"; }
                                if (msl && ($.inArray($.trim(sv[1]), ovm)>-1 || $.inArray($.trim(sv[0]), ovm)>-1)) {ov.selected ="selected";}
                            }
                        } else if (typeof options.value === 'object') {
                            var oSv = options.value, key;
                            for (key in oSv) {
                                if (oSv.hasOwnProperty(key ) ){
                                    ov = document.createElement("option");
                                    ov.setAttribute("role","option");
                                    ov.value = key; ov.innerHTML = oSv[key];
                                    elem.appendChild(ov);
                                    if (!msl &&  ( $.trim(key) === $.trim(vl) || $.trim(oSv[key]) === $.trim(vl)) ) { ov.selected ="selected"; }
                                    if (msl && ($.inArray($.trim(oSv[key]),ovm)>-1 || $.inArray($.trim(key),ovm)>-1)) { ov.selected ="selected"; }
                                }
                            }
                        }
                        setAttributes(elem, options, ['value']);
                    }
                    break;
                case "text" :
                case "password" :
                case "button" :
                    var role;
                    if(eltype==="button") { role = "button"; }
                    else { role = "textbox"; }
                    elem = document.createElement("input");
                    elem.type = eltype;
                    elem.value = vl;
                    setAttributes(elem, options);
                    if(eltype !== "button"){
                        if(autowidth) {
                            if(!options.size) { $(elem).css({width:"98%"}); }
                        } else if (!options.size) { options.size = 20; }
                    }
                    $(elem).attr("role",role);
                    break;
                case "image" :
                case "file" :
                    elem = document.createElement("input");
                    elem.type = eltype;
                    setAttributes(elem, options);
                    break;
                case "custom" :
                    elem = document.createElement("span");
                    try {
                        if($.isFunction(options.custom_element)) {
                            var celm = options.custom_element.call($t,vl,options);
                            if(celm) {
                                celm = $(celm).addClass("customelement").attr({id:options.id,name:options.name});
                                $(elem).empty().append(celm);
                            } else {
                                throw "e2";
                            }
                        } else {
                            throw "e1";
                        }
                    } catch (e) {
                        if (e==="e1") { $.jgrid.info_dialog($.jgrid.errors.errcap,"function 'custom_element' "+$.jgrid.edit.msg.nodefined, $.jgrid.edit.bClose);}
                        if (e==="e2") { $.jgrid.info_dialog($.jgrid.errors.errcap,"function 'custom_element' "+$.jgrid.edit.msg.novalue,$.jgrid.edit.bClose);}
                        else { $.jgrid.info_dialog($.jgrid.errors.errcap,typeof e==="string"?e:e.message,$.jgrid.edit.bClose); }
                    }
                    break;
            }
            return elem;
        },
        // Date Validation Javascript
        checkDate : function (format, date) {
            var daysInFebruary = function(year){
                    // February has 29 days in any year evenly divisible by four,
                    // EXCEPT for centurial years which are not also divisible by 400.
                    return (((year % 4 === 0) && ( year % 100 !== 0 || (year % 400 === 0))) ? 29 : 28 );
                },
                tsp = {}, sep;
            format = format.toLowerCase();
            //we search for /,-,. for the date separator
            if(format.indexOf("/") !== -1) {
                sep = "/";
            } else if(format.indexOf("-") !== -1) {
                sep = "-";
            } else if(format.indexOf(".") !== -1) {
                sep = ".";
            } else {
                sep = "/";
            }
            format = format.split(sep);
            date = date.split(sep);
            if (date.length !== 3) { return false; }
            var j=-1,yln, dln=-1, mln=-1, i;
            for(i=0;i<format.length;i++){
                var dv =  isNaN(date[i]) ? 0 : parseInt(date[i],10);
                tsp[format[i]] = dv;
                yln = format[i];
                if(yln.indexOf("y") !== -1) { j=i; }
                if(yln.indexOf("m") !== -1) { mln=i; }
                if(yln.indexOf("d") !== -1) { dln=i; }
            }
            if (format[j] === "y" || format[j] === "yyyy") {
                yln=4;
            } else if(format[j] ==="yy"){
                yln = 2;
            } else {
                yln = -1;
            }
            var daysInMonth = [0,31,29,31,30,31,30,31,31,30,31,30,31],
                strDate;
            if (j === -1) {
                return false;
            }
            strDate = tsp[format[j]].toString();
            if(yln === 2 && strDate.length === 1) {yln = 1;}
            if (strDate.length !== yln || (tsp[format[j]]===0 && date[j]!=="00")){
                return false;
            }
            if(mln === -1) {
                return false;
            }
            strDate = tsp[format[mln]].toString();
            if (strDate.length<1 || tsp[format[mln]]<1 || tsp[format[mln]]>12){
                return false;
            }
            if(dln === -1) {
                return false;
            }
            strDate = tsp[format[dln]].toString();
            if (strDate.length<1 || tsp[format[dln]]<1 || tsp[format[dln]]>31 || (tsp[format[mln]]===2 && tsp[format[dln]]>daysInFebruary(tsp[format[j]])) || tsp[format[dln]] > daysInMonth[tsp[format[mln]]]){
                return false;
            }
            return true;
        },
        isEmpty : function(val)
        {
            if (val.match(/^\s+$/) || val === "")	{
                return true;
            }
            return false;
        },
        checkTime : function(time){
            // checks only hh:ss (and optional am/pm)
            var re = /^(\d{1,2}):(\d{2})([apAP][Mm])?$/,regs;
            if(!$.jgrid.isEmpty(time))
            {
                regs = time.match(re);
                if(regs) {
                    if(regs[3]) {
                        if(regs[1] < 1 || regs[1] > 12) { return false; }
                    } else {
                        if(regs[1] > 23) { return false; }
                    }
                    if(regs[2] > 59) {
                        return false;
                    }
                } else {
                    return false;
                }
            }
            return true;
        },
        checkValues : function(val, valref, customobject, nam) {
            var edtrul,i, nm, dft, len, g = this, cm = g.p.colModel;
            if(customobject === undefined) {
                if(typeof valref==='string'){
                    for( i =0, len=cm.length;i<len; i++){
                        if(cm[i].name===valref) {
                            edtrul = cm[i].editrules;
                            valref = i;
                            if(cm[i].formoptions != null) { nm = cm[i].formoptions.label; }
                            break;
                        }
                    }
                } else if(valref >=0) {
                    edtrul = cm[valref].editrules;
                }
            } else {
                edtrul = customobject;
                nm = nam===undefined ? "_" : nam;
            }
            if(edtrul) {
                // if(!nm) { nm = g.p.colNames != null ? g.p.colNames[valref] : cm[valref].label; }
                if(!nm) { nm = g.p.colModel != null ? g.p.colModel[valref].label : cm[valref].label; }
                if(edtrul.required === true) {
                    if( $.jgrid.isEmpty(val) )  { return [false,nm+": "+$.jgrid.edit.msg.required,""]; }
                }
                // force required
                var rqfield = edtrul.required === false ? false : true;
                if(edtrul.number === true) {
                    if( !(rqfield === false && $.jgrid.isEmpty(val)) ) {
                        if(isNaN(val)) { return [false,nm+": "+$.jgrid.edit.msg.number,""]; }
                    }
                }
                if(edtrul.minValue !== undefined && !isNaN(edtrul.minValue)) {
                    if (parseFloat(val) < parseFloat(edtrul.minValue) ) { return [false,nm+": "+$.jgrid.edit.msg.minValue+" "+edtrul.minValue,""];}
                }
                if(edtrul.maxValue !== undefined && !isNaN(edtrul.maxValue)) {
                    if (parseFloat(val) > parseFloat(edtrul.maxValue) ) { return [false,nm+": "+$.jgrid.edit.msg.maxValue+" "+edtrul.maxValue,""];}
                }
                var filter;
                if(edtrul.email === true) {
                    if( !(rqfield === false && $.jgrid.isEmpty(val)) ) {
                        // taken from $ Validate plugin
                        filter = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i;
                        if(!filter.test(val)) {return [false,nm+": "+$.jgrid.edit.msg.email,""];}
                    }
                }
                if(edtrul.integer === true) {
                    if( !(rqfield === false && $.jgrid.isEmpty(val)) ) {
                        if(isNaN(val)) { return [false,nm+": "+$.jgrid.edit.msg.integer,""]; }
                        if ((val % 1 !== 0) || (val.indexOf('.') !== -1)) { return [false,nm+": "+$.jgrid.edit.msg.integer,""];}
                    }
                }
                if(edtrul.date === true) {
                    if( !(rqfield === false && $.jgrid.isEmpty(val)) ) {
                        if(cm[valref].formatoptions && cm[valref].formatoptions.newformat) {
                            dft = cm[valref].formatoptions.newformat;
                            if( $.jgrid.formatter.date.masks.hasOwnProperty(dft) ) {
                                dft = $.jgrid.formatter.date.masks[dft];
                            }
                        } else {
                            dft = cm[valref].datefmt || "Y-m-d";
                        }
                        if(!$.jgrid.checkDate (dft, val)) { return [false,nm+": "+$.jgrid.edit.msg.date+" - "+dft,""]; }
                    }
                }
                if(edtrul.time === true) {
                    if( !(rqfield === false && $.jgrid.isEmpty(val)) ) {
                        if(!$.jgrid.checkTime (val)) { return [false,nm+": "+$.jgrid.edit.msg.date+" - hh:mm (am/pm)",""]; }
                    }
                }
                if(edtrul.url === true) {
                    if( !(rqfield === false && $.jgrid.isEmpty(val)) ) {
                        filter = /^(((https?)|(ftp)):\/\/([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*\/?)/i;
                        if(!filter.test(val)) {return [false,nm+": "+$.jgrid.edit.msg.url,""];}
                    }
                }
                if(edtrul.custom === true) {
                    if( !(rqfield === false && $.jgrid.isEmpty(val)) ) {
                        if($.isFunction(edtrul.custom_func)) {
                            var ret = edtrul.custom_func.call(g,val,nm,valref);
                            return $.isArray(ret) ? ret : [false,$.jgrid.edit.msg.customarray,""];
                        }
                        return [false,$.jgrid.edit.msg.customfcheck,""];
                    }
                }
            }
            return [true,"",""];
        }
    })

});
/*
 * Created by tanyl on 2015/1/2.
 */
!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.grid.inline', factory);
    } else {
        factory();
    }
}(function () {

    'use strict';

    $.extend($.ui.grid.prototype , {
        /**
         * 编辑单元格
         * @param  {number} iRow 行索引
         * @param  {number} iCol 列索引
         * @param  {Boolean} [ed]   已在编辑状态的单元格是否不再触发编辑操作
         */
        editCell : function (iRow,iCol, ed){
            //return this.each(function (){
                var ts = this, nm, tmp,cc, cm;
                if (!ts.grid || ts.p.cellEdit !== true) {return;}
                iCol = parseInt(iCol,10);
                // select the row that can be used for other methods
                ts.p.selrow = ts.rows[iRow].id;
                // if (!ts.p.knv) {$(ts.element).jqGrid("GridNav");}
                // check to see if we have already edited cell
                if (ts.p.savedRow.length>0) {
                    // prevent second click on that field and enable selects
                    if (ed===true ) {
                        if(iRow == ts.p.iRow && iCol == ts.p.iCol){
                            return;
                        }
                    }
                    if(ts.p.cellAutoSave === true || ts.p.cellAutoSave === "true"){
                        $(ts.element).jqGrid("saveCell",ts.p.savedRow[0].id,ts.p.savedRow[0].ic);
                    }else if(ts.p.cellAutoSave === false || ts.p.cellAutoSave === "false"){
                        $(ts.element).jqGrid("restoreCell",ts.p.savedRow[0].id,ts.p.savedRow[0].ic);
                    }
                    // save the cell
                    // } else {
                    // 	window.setTimeout(function () { $("#"+$.jgrid.jqID(ts.p.knv)).attr("tabindex","-1").focus();},0);
                }
                cm = ts.p.colModel[iCol];
                nm = cm.name;
                if (nm==='cb' || nm==='rn') {return;}
                cc = $("td:eq("+iCol+")",ts.rows[iRow]);
                if (cm.editable===true && ed===true && !cc.hasClass("not-editable-cell")) {
                    if(parseInt(ts.p.iCol,10)>=0  && parseInt(ts.p.iRow,10)>=0) {
                        $("td:eq("+ts.p.iCol+")",ts.rows[ts.p.iRow]).removeClass("edit-cell ui-state-highlight");
                        $(ts.rows[ts.p.iRow]).removeClass("selected-row ui-state-hover");
                    }
                    $(cc).addClass("edit-cell ui-state-highlight");
                    $(ts.rows[iRow]).addClass("selected-row ui-state-hover");
                    try {
                        tmp =  $.unformat.call(ts,cc,{rowId: ts.rows[iRow].id, colModel:cm},iCol,true);
                    } catch (_) {
                        tmp = ( cm.edittype && cm.edittype === 'textarea' ) ? $(cc).text() : $(cc).html();
                    }
                    if(ts.p.autoencode) { tmp = $.jgrid.htmlDecode(tmp); }
                    if (!cm.edittype) {cm.edittype = "text";}
                    ts.p.savedRow.push({id:iRow,ic:iCol,name:nm,v:tmp});
                    if(tmp === "&nbsp;" || tmp === "&#160;" || (tmp.length===1 && tmp.charCodeAt(0)===160) ) {tmp='';}
                    if($.isFunction(ts.p.formatCell)) {
                        var tmp2 = ts.p.formatCell.call(ts, ts.rows[iRow].id,nm,tmp,iRow,iCol);
                        if(tmp2 !== undefined ) {tmp = tmp2;}
                    }
                    ts._trigger("beforeEditCell", [ts.rows[iRow].id, nm, tmp, iRow, iCol]);
                    var opt = $.extend({}, cm.editoptions || {} ,{id:iRow+"_"+nm,name:nm});
                    var elc = $.jgrid.createEl.call(ts,cm.edittype,opt,tmp,true,$.extend({},$.jgrid.ajaxOptions,ts.p.ajaxSelectOptions || {}));
                    $(cc).html("").append(elc).attr("tabindex","0");
                    $.jgrid.bindEv.call(ts, elc, opt);
                    window.setTimeout(function () { $(elc).focus();},0);
                    $("input, select, textarea",cc).bind("keydown",function(e) {
                        if (e.keyCode === 27) {
                            // if($("input.hasDatepicker",cc).length >0) {
                            // 	if( $(".ui-datepicker").is(":hidden") )  { $(ts.element).jqGrid("restoreCell",iRow,iCol); }
                            // 	else { $("input.hasDatepicker",cc).datepicker('hide'); }
                            // } else {
                            $(ts.element).jqGrid("restoreCell",iRow,iCol);
                            // }
                        } //ESC
                        if (e.keyCode === 13) {
                            $(ts.element).jqGrid("saveCell",iRow,iCol);
                            // Prevent default action
                            return false;
                        } //Enter 暂时屏蔽 TODO 2014/6/5
                        if (e.keyCode === 9)  {
                            if(!ts.grid.hDiv.loading ) {
                                if (e.shiftKey) {$(ts.element).jqGrid("prevCell",iRow,iCol);} //Shift TAb
                                else {$(ts.element).jqGrid("nextCell",iRow,iCol);} //Tab
                            } else {
                                return false;
                            }
                        }
                        e.stopPropagation();
                    });
                    ts._trigger("afterEditCell", [ts.rows[iRow].id, nm, tmp, iRow, iCol]);
                } else {
                    if (parseInt(ts.p.iCol,10)>=0  && parseInt(ts.p.iRow,10)>=0) {
                        $("td:eq("+ts.p.iCol+")",ts.rows[ts.p.iRow]).removeClass("edit-cell ui-state-highlight");
                        $(ts.rows[ts.p.iRow]).removeClass("selected-row ui-state-hover");
                    }
                    cc.addClass("edit-cell ui-state-highlight");
                    $(ts.rows[iRow]).addClass("selected-row ui-state-hover");
                    tmp = cc.html().replace(/\&#160\;/ig,'');
                    ts._trigger("selectCell", [ts.rows[iRow].id, nm, tmp, iRow, iCol]);
                    if ($.isFunction(ts.p.onSelectCell)) {
                        ts.p.onSelectCell.call(ts, ts.rows[iRow].id,nm,tmp,iRow,iCol);
                    }
                }
                ts.p.iCol = iCol; ts.p.iRow = iRow;
            //});
        },
        /**
         * 保存单元格
         * @param  {number} iRow 行索引
         * @param  {number} iCol 列索引
         */
        saveCell : function (iRow, iCol){
            //return this.each(function(){
                var ts= this, fr;
                if (!ts.grid || ts.p.cellEdit !== true) {return;}
                if ( ts.p.savedRow.length >= 1) {fr = 0;} else {fr=null;}
                if(fr !== null) {
                    var cc = $("td:eq("+iCol+")",ts.rows[iRow]),v,v2,
                        cm = ts.p.colModel[iCol], nm = cm.name, nmjq = $.jgrid.jqID(nm) ;
                    switch (cm.edittype) {
                        case "select":
                            // if(!cm.editoptions.multiple) { //自己使用下拉多选控件
                            v = $("#"+iRow+"_"+nmjq+" option:selected",ts.rows[iRow]).val();
                            v2 = $("#"+iRow+"_"+nmjq+" option:selected",ts.rows[iRow]).text();
                            // } else {
                            // 	var sel = $("#"+iRow+"_"+nmjq,ts.rows[iRow]), selectedText = [];
                            // 	v = $(sel).val();
                            // 	if(v) { v.join(",");} else { v=""; }
                            // 	$("option:selected",sel).each(
                            // 		function(i,selected){
                            // 			selectedText[i] = $(selected).text();
                            // 		}
                            // 	);
                            // 	v2 = selectedText.join(",");
                            // }
                            if(cm.formatter) { v2 = v; }
                            break;
                        case "checkbox":
                            var cbv  = ["Yes","No"];
                            if(cm.editoptions){
                                cbv = cm.editoptions.value.split(":");
                            }
                            v = $("#"+iRow+"_"+nmjq,ts.rows[iRow]).is(":checked") ? cbv[0] : cbv[1];
                            v2=v;
                            break;
                        case "password":
                        case "text":
                        case "textarea":
                        case "button" :
                            v = $("#"+iRow+"_"+nmjq,ts.rows[iRow]).val();
                            v2=v;
                            break;
                        case 'custom' :
                            try {
                                if(cm.editoptions && $.isFunction(cm.editoptions.custom_value)) {
                                    v = cm.editoptions.custom_value.call(ts, $(".customelement",cc),'get');
                                    if (v===undefined) { throw "e2";} else { v2=v; }
                                } else { throw "e1"; }
                            } catch (e) {
                                if (e==="e1") { $.jgrid.info_dialog($.jgrid.errors.errcap,"function 'custom_value' "+$.jgrid.edit.msg.nodefined,$.jgrid.edit.bClose); }
                                if (e==="e2") { $.jgrid.info_dialog($.jgrid.errors.errcap,"function 'custom_value' "+$.jgrid.edit.msg.novalue,$.jgrid.edit.bClose); }
                                else {$.jgrid.info_dialog($.jgrid.errors.errcap,e.message,$.jgrid.edit.bClose); }
                            }
                            break;
                    }
                    // The common approach is if nothing changed do not do anything
                    if (v2 !== ts.p.savedRow[fr].v){

                        var vvv = ts._trigger("beforeSaveCell", [ts.rows[iRow].id, nm, v, iRow, iCol]);
                        if(vvv && typeof vvv==="object"&&vvv.push){
                            if(vvv.length>1 && vvv[0]===false){
                                try {
                                    window.setTimeout(function(){$.jgrid.info_dialog($.jgrid.errors.errcap,v+" "+vvv[1],$.jgrid.edit.bClose);},100);
                                    $(ts.element).jqGrid("restoreCell",iRow,iCol);
                                } catch (e) {}
                                return false;
                            }
                        }
                        // if (vvv) {v = vvv; v2=vvv;}
                        // if ($.isFunction(ts.p.beforeSaveCell)) {
                        // 	var vv = ts.p.beforeSaveCell.call(ts, ts.rows[iRow].id,nm, v, iRow,iCol);
                        // 	if (vv) {v = vv; v2=vv;}
                        // }
                        // //2014/5/21
                        // if(v === false){
                        // 	try {
                        // 		window.setTimeout(function(){$.jgrid.info_dialog($.jgrid.errors.errcap,v+" "+v2,$.jgrid.edit.bClose);},100);
                        // 		$(ts.element).jqGrid("restoreCell",iRow,iCol);
                        // 	} catch (e) {}
                        // 	return false;
                        // }
                        //
                        var cv = $.jgrid.checkValues.call(ts,v,iCol);
                        if(cv[0] === true) {
                            var addpost = ts._trigger("beforeSubmitCell", [ts.rows[iRow].id, nm, v, iRow, iCol]) || {};
                            if ($.isFunction(ts.p.beforeSubmitCell)) {
                                addpost = ts.p.beforeSubmitCell.call(ts, ts.rows[iRow].id,nm, v, iRow,iCol);
                                if (!addpost) {addpost={};}
                            }
                            // if( $("input.hasDatepicker",cc).length >0) { $("input.hasDatepicker",cc).datepicker('hide'); }
                            $(cc).empty();
                            $(ts.element).jqGrid("setCell",ts.rows[iRow].id,iCol, v2, false, false, true);
                            var leftpos =$(cc).position().left;
                            $(cc).addClass("dirty-cell").prepend('<span class="span-dirty" style="left:'+leftpos+'px"></span>');
                            $(ts.rows[iRow]).addClass("edited");
                            ts._trigger("afterSaveCell", [ts.rows[iRow].id, nm, v, iRow, iCol]);
                            ts.p.savedRow.splice(0,1);
                        } else {
                            try {
                                window.setTimeout(function(){$.jgrid.info_dialog($.jgrid.errors.errcap,v+" "+cv[1],$.jgrid.edit.bClose);},100);
                                $(ts.element).jqGrid("restoreCell",iRow,iCol);
                            } catch (e) {}
                        }
                    } else {
                        $(ts.element).jqGrid("restoreCell",iRow,iCol);
                    }
                }
                // window.setTimeout(function () { $("#"+$.jgrid.jqID(ts.p.knv)).attr("tabindex","-1").focus();},0);
            //});
        },
        /**
         * 取消单元格编辑
         * @param  {number} iRow 行索引
         * @param  {number} iCol 列索引
         */
        restoreCell : function(iRow, iCol) {
            //return this.each(function(){
                var ts= this, fr;
                if (!ts.grid || ts.p.cellEdit !== true ) {return;}
                if ( ts.p.savedRow.length >= 1) {fr = 0;} else {fr=null;}
                if(fr !== null) {
                    var cc = $("td:eq("+iCol+")",ts.rows[iRow]);
                    // datepicker fix
                    // if($.isFunction($.fn.datepicker)) {
                    // 	try {
                    // 		$("input.hasDatepicker",cc).datepicker('hide');
                    // 	} catch (e) {}
                    // }
                    $(cc).empty().attr("tabindex","-1");
                    $(ts.element).jqGrid("setCell",ts.rows[iRow].id, iCol, ts.p.savedRow[fr].v, false, false, true);
                    ts._trigger("afterRestoreCell", [ts.rows[iRow].id, ts.p.savedRow[fr].v, iRow, iCol]);
                    ts.p.savedRow.splice(0,1);
                }
                // window.setTimeout(function () { $("#"+ts.p.knv).attr("tabindex","-1").focus();},0);
            //});
        },
        nextCell : function (iRow,iCol) {
            //return this.each(function (){
                var ts = this, nCol=false, i;
                if (!ts.grid || ts.p.cellEdit !== true) {return;}
                while(iRow<=ts.p.reccount){
                    for (i=iCol+1; i<ts.p.colModel.length; i++) {
                        if ( ts.p.colModel[i].editable ===true) {
                            nCol = i; break;
                        }
                    }
                    if(nCol === false && iRow < ts.p.reccount ) {
                        iRow ++;iCol = 0;
                    } else {
                        break;
                    }
                }
                if(nCol !== false) {
                    $(ts.element).jqGrid("editCell",iRow,nCol,true);
                } else {
                    if (ts.p.savedRow.length >0) {
                        $(ts.element).jqGrid("saveCell",iRow,iCol);
                    }
                }
            //});
        },
        prevCell : function (iRow,iCol) {
            //return this.each(function (){
                var ts = this, nCol=false, i;
                if (!ts.grid || ts.p.cellEdit !== true) {return;}
                // try to find next editable cell
                while(iRow>0){
                    for (i=iCol-1; i>=0; i--) {
                        if ( ts.p.colModel[i].editable ===true) {
                            nCol = i; break;
                        }
                    }
                    if(nCol === false && iRow > 1 ) {
                        iRow --;iCol = ts.p.colModel.length-1;
                    } else {
                        break;
                    }
                }

                if(nCol !== false) {
                    $(ts.element).jqGrid("editCell",iRow,nCol,true);
                } else {
                    if (ts.p.savedRow.length >0) {
                        $(ts.element).jqGrid("saveCell",iRow,iCol);
                    }
                }
            //});
        },
        // GridNav : function() {
        // 	return this.each(function () {
        // 		var  ts = this;
        // 		if (!ts.grid || ts.p.cellEdit !== true ) {return;}
        // 		// trick to process keydown on non input elements
        // 		ts.p.knv = ts.p.id + "_kn";
        // 		var selection = $("<div style='position:fixed;top:0px;width:1px;height:1px;' tabindex='0'><div tabindex='-1' style='width:1px;height:1px;' id='"+ts.p.knv+"'></div></div>"),
        // 		i, kdir;
        // 		function scrollGrid(iR, iC, tp){
        // 			if (tp.substr(0,1)==='v') {
        // 				var ch = $(ts.grid.bDiv)[0].clientHeight,
        // 				st = $(ts.grid.bDiv)[0].scrollTop,
        // 				nROT = ts.rows[iR].offsetTop+ts.rows[iR].clientHeight,
        // 				pROT = ts.rows[iR].offsetTop;
        // 				if(tp === 'vd') {
        // 					if(nROT >= ch) {
        // 						$(ts.grid.bDiv)[0].scrollTop = $(ts.grid.bDiv)[0].scrollTop + ts.rows[iR].clientHeight;
        // 					}
        // 				}
        // 				if(tp === 'vu'){
        // 					if (pROT < st ) {
        // 						$(ts.grid.bDiv)[0].scrollTop = $(ts.grid.bDiv)[0].scrollTop - ts.rows[iR].clientHeight;
        // 					}
        // 				}
        // 			}
        // 			if(tp==='h') {
        // 				var cw = $(ts.grid.bDiv)[0].clientWidth,
        // 				sl = $(ts.grid.bDiv)[0].scrollLeft,
        // 				nCOL = ts.rows[iR].cells[iC].offsetLeft+ts.rows[iR].cells[iC].clientWidth,
        // 				pCOL = ts.rows[iR].cells[iC].offsetLeft;
        // 				if(nCOL >= cw+parseInt(sl,10)) {
        // 					$(ts.grid.bDiv)[0].scrollLeft = $(ts.grid.bDiv)[0].scrollLeft + ts.rows[iR].cells[iC].clientWidth;
        // 				} else if (pCOL < sl) {
        // 					$(ts.grid.bDiv)[0].scrollLeft = $(ts.grid.bDiv)[0].scrollLeft - ts.rows[iR].cells[iC].clientWidth;
        // 				}
        // 			}
        // 		}
        // 		function findNextVisible(iC,act){
        // 			var ind, i;
        // 			if(act === 'lft') {
        // 				ind = iC+1;
        // 				for (i=iC;i>=0;i--){
        // 					if (ts.p.colModel[i].hidden !== true) {
        // 						ind = i;
        // 						break;
        // 					}
        // 				}
        // 			}
        // 			if(act === 'rgt') {
        // 				ind = iC-1;
        // 				for (i=iC; i<ts.p.colModel.length;i++){
        // 					if (ts.p.colModel[i].hidden !== true) {
        // 						ind = i;
        // 						break;
        // 					}
        // 				}
        // 			}
        // 			return ind;
        // 		}

        // 		$(selection).insertBefore(ts.grid.cDiv);
        // 		$("#"+ts.p.knv)
        // 		.focus()
        // 		.keydown(function (e){
        // 			kdir = e.keyCode;
        // 			if(ts.p.direction === "rtl") {
        // 				if(kdir===37) { kdir = 39;}
        // 				else if (kdir===39) { kdir = 37; }
        // 			}
        // 			switch (kdir) {
        // 				case 38:
        // 					if (ts.p.iRow-1 >0 ) {
        // 						scrollGrid(ts.p.iRow-1,ts.p.iCol,'vu');
        // 						$(ts.element).jqGrid("editCell",ts.p.iRow-1,ts.p.iCol,false);
        // 					}
        // 				break;
        // 				case 40 :
        // 					if (ts.p.iRow+1 <=  ts.rows.length-1) {
        // 						scrollGrid(ts.p.iRow+1,ts.p.iCol,'vd');
        // 						$(ts.element).jqGrid("editCell",ts.p.iRow+1,ts.p.iCol,false);
        // 					}
        // 				break;
        // 				case 37 :
        // 					if (ts.p.iCol -1 >=  0) {
        // 						i = findNextVisible(ts.p.iCol-1,'lft');
        // 						scrollGrid(ts.p.iRow, i,'h');
        // 						$(ts.element).jqGrid("editCell",ts.p.iRow, i,false);
        // 					}
        // 				break;
        // 				case 39 :
        // 					if (ts.p.iCol +1 <=  ts.p.colModel.length-1) {
        // 						i = findNextVisible(ts.p.iCol+1,'rgt');
        // 						scrollGrid(ts.p.iRow,i,'h');
        // 						$(ts.element).jqGrid("editCell",ts.p.iRow,i,false);
        // 					}
        // 				break;
        // 				case 13:
        // 					if (parseInt(ts.p.iCol,10)>=0 && parseInt(ts.p.iRow,10)>=0) {
        // 						$(ts.element).jqGrid("editCell",ts.p.iRow,ts.p.iCol,true);
        // 					}
        // 				break;
        // 				default :
        // 					return true;
        // 			}
        // 			return false;
        // 		});
        // 	});
        // },
        /**
         * 获取修改过的单元格记录,可用于一次性提交
         * @param  {String} [mthd] 可设置为值dirty，设置的话则返回修改过的单元格记录,为空则返回修改过的行记录
         */
        getChangedCells : function (mthd) {
            var ret=[];
            if (!mthd) {mthd='all';}
            //this.each(function(){
                var ts= this,nm;
                if (!ts.grid || ts.p.cellEdit !== true ) {return;}
                $(ts.rows).each(function(j){
                    var res = {};
                    if ($(this).hasClass("edited")) {
                        $('td',this).each( function(i) {
                            nm = ts.p.colModel[i].name;
                            if ( nm !== 'cb' ) {
                                if (mthd==='dirty') {
                                    if ($(this).hasClass('dirty-cell')) {
                                        try {
                                            res[nm] = $.unformat.call(ts,this,{rowId:ts.rows[j].id, colModel:ts.p.colModel[i]},i,true);
                                        } catch (e){
                                            res[nm] = $.jgrid.htmlDecode($(this).html());
                                        }
                                    }
                                } else {
                                    try {
                                        res[nm] = $.unformat.call(ts,this,{rowId:ts.rows[j].id,colModel:ts.p.colModel[i]},i,true);
                                    } catch (e) {
                                        res[nm] = $.jgrid.htmlDecode($(this).html());
                                    }
                                }
                            }
                        });
                        res.id = this.id;
                        ret.push(res);
                    }
                });
            //});
            return ret;
        }
        /// end  cell editing
    });




});
/*
 * Created by tanyl on 2015/1/2.
 */
!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.grid.inline', factory);
    } else {
        factory();
    }
}(function () {

    'use strict';

    $.jgrid.inlineEdit = $.jgrid.inlineEdit || {};

    $.extend($.ui.grid.prototype , {
        /**
         * 编辑某行记录
         * @param  {String} rowid              行标识		 *
         * @param  {Object} [option]           编辑行的参数对象
         * option.keys 是否支持键盘事件,esc取消enter保存
         * option.beforeEditRow 编辑前触发的函数,返回false则中断行编辑操作
         * option.oneditfunc 编辑时触发的函数
         * option.extraparam 编辑传入的额外参数
         * option.aftersavefunc 数据保存成功后触发的函数
         * option.errorfunc 数据保存失败后触发的函数
         * option.afterrestorefunc 数据还原后触发的函数
         */
        editRow : function(rowid,o) {
            // Compatible mode old versions
            //var o={}, args = $.makeArray(arguments).slice(1);
            //
            //if( $.type(args[0]) === "object" ) {
            //    o = args[0];
            //} else {
            //    if (keys !== undefined) { o.keys = keys; }
            //    if ($.isFunction(oneditfunc)) { o.oneditfunc = oneditfunc; }
            //    if ($.isFunction(successfunc)) { o.successfunc = successfunc; }
            //    // if (url !== undefined) { o.url = url; }
            //    if (extraparam !== undefined) { o.extraparam = extraparam; }
            //    if ($.isFunction(aftersavefunc)) { o.aftersavefunc = aftersavefunc; }
            //    if ($.isFunction(errorfunc)) { o.errorfunc = errorfunc; }
            //    if ($.isFunction(afterrestorefunc)) { o.afterrestorefunc = afterrestorefunc; }
            //    // last two not as param, but as object (sorry)
            //    //if (restoreAfterError !== undefined) { o.restoreAfterError = restoreAfterError; }
            //}
            o = $.extend(true, {
                keys : false,
                oneditfunc: null,
                successfunc: null,
                url: null,
                extraparam: {},
                aftersavefunc: null,
                errorfunc: null,
                afterrestorefunc: null,
                restoreAfterError: true
            }, $.jgrid.inlineEdit, o );

            // End compatible
            //return this.each(function(){
                var ts = this, nm, tmp, editable, cnt=0, focus=null, svr={}, ind,cm, bfer;
                if (!ts.grid ) { return; }
                ind = $(ts.element).jqGrid("getInd",rowid,true);
                if( ind === false ) {return;}
                bfer = $.isFunction( o.beforeEditRow ) ? o.beforeEditRow.call(ts,o, rowid) :  undefined;
                if( bfer === undefined ) {
                    bfer = true;
                }
                if(!bfer) { return; }
                editable = $(ind).attr("editable") || "0";
                if (editable === "0" && !$(ind).hasClass("not-editable-row")) {
                    cm = ts.p.colModel;
                    $('td[role="gridcell"]',ind).each( function(i) {
                        nm = cm[i].name;
                        var treeg = ts.p.treeGrid===true && nm === ts.p.ExpandColumn;
                        if(treeg) { tmp = $("span:first",this).html();}
                        else {
                            try {
                                tmp = $.unformat.call(ts,this,{rowId:rowid, colModel:cm[i]},i,true);
                            } catch (_) {
                                tmp =  ( cm[i].edittype && cm[i].edittype === 'textarea' ) ? $(this).text() : $(this).html();
                            }
                        }
                        if ( nm !== 'cb' && nm !== 'rn') {
                            if(ts.p.autoencode) { tmp = $.jgrid.htmlDecode(tmp); }
                            svr[nm]=tmp;
                            if(cm[i].editable===true) {
                                if(focus===null) { focus = i; }
                                if (treeg) { $("span:first",this).html(""); }
                                else { $(this).html(""); }
                                var opt = $.extend({},cm[i].editoptions || {},{id:rowid+"_"+nm,name:nm});
                                if(!cm[i].edittype) { cm[i].edittype = "text"; }
                                if(tmp === "&nbsp;" || tmp === "&#160;" || (tmp.length===1 && tmp.charCodeAt(0)===160) ) {tmp='';}
                                var elc = $.jgrid.createEl.call(ts,cm[i].edittype,opt,tmp,true,$.extend({},$.jgrid.ajaxOptions,ts.p.ajaxSelectOptions || {}));
                                $(elc).addClass("editable");
                                if(treeg) { $("span:first",this).append(elc); }
                                else { $(this).append(elc); }
                                $.jgrid.bindEv.call(ts, elc, opt);
                                //Again IE
                                if(cm[i].edittype === "select" && cm[i].editoptions!==undefined && cm[i].editoptions.multiple===true  && cm[i].editoptions.dataUrl===undefined && $.browser.msie) {
                                    $(elc).width($(elc).width());
                                }
                                cnt++;
                            }
                        }
                    });
                    if(cnt > 0) {
                        svr.id = rowid; ts.p.savedRow.push(svr);
                        $(ind).attr("editable","1");
                        $("td:eq("+focus+") input",ind).focus();
                        if(o.keys===true) {
                            $(ind).bind("keydown",function(e) {
                                if (e.keyCode === 27) {
                                    $(ts.element).jqGrid("restoreRow",rowid, o.afterrestorefunc);
                                    // if(ts.p._inlinenav) {
                                    // 	try {
                                    // 		$(ts.element).jqGrid('showAddEditButtons');
                                    // 	} catch (eer1) {}
                                    // }
                                    return false;
                                }
                                if (e.keyCode === 13) {
                                    var ta = e.target;
                                    if(ta.tagName === 'TEXTAREA') { return true; }
                                    if( $(ts.element).jqGrid("saveRow", rowid, o ) ) {
                                        // if(ts.p._inlinenav) {
                                        // 	try {
                                        // 		$(ts.element).jqGrid('showAddEditButtons');
                                        // 	} catch (eer2) {}
                                        // }
                                    }
                                    return false;
                                }
                            });
                        }
                        ts._trigger("inlineEditRow", [rowid, o]);
                        if( $.isFunction(o.oneditfunc)) { o.oneditfunc.call(ts, rowid); }
                    }
                }
            //});
        },
        /**
         * 保存某行记录
         * @param  {String} rowid              行标识
         * @param  {Object} [option]             保存行的参数对象
         * option.extraparam 保存传入的额外参数
         * option.aftersavefunc 数据保存成功后触发的函数
         * option.errorfunc 数据保存失败后触发的函数
         * option.afterrestorefunc 数据还原后触发的函数
         */
        saveRow : function(rowid, o) {
            // Compatible mode old versions
            //var args = $.makeArray(arguments).slice(1), o = {};
            //
            //if( $.type(args[0]) === "object" ) {
            //    o = args[0];
            //} else {
            //    // if ($.isFunction(successfunc)) { o.successfunc = successfunc; }
            //    // if (url !== undefined) { o.url = url; }
            //    if (extraparam !== undefined) { o.extraparam = extraparam; }
            //    if ($.isFunction(aftersavefunc)) { o.aftersavefunc = aftersavefunc; }
            //    if ($.isFunction(errorfunc)) { o.errorfunc = errorfunc; }
            //    if ($.isFunction(afterrestorefunc)) { o.afterrestorefunc = afterrestorefunc; }
            //}
            o = $.extend(true, {
                // successfunc: null,
                // url: null,
                extraparam: {},
                aftersavefunc: null,
                errorfunc: null,
                afterrestorefunc: null,
                restoreAfterError: true
            }, $.jgrid.inlineEdit, o );
            // End compatible
            var success = false;
            var ts = this, nm, tmp={}, tmp2={}, tmp3= {}, editable, fr, cv, ind;
            if (!ts.grid ) { return success; }
            ind = $(ts.element).jqGrid("getInd",rowid,true);
            if(ind === false) {return success;}

            // var bfsr = $.isFunction( o.beforeSaveRow ) ?	o.beforeSaveRow.call(ts,o, rowid) :  undefined;
            // if( bfsr === undefined ) {
            // 	bfsr = true;
            // }
            // if(!bfsr) { return; }

            editable = $(ind).attr("editable");
            // o.url = o.url || ts.p.editurl;
            if (editable==="1") {
                var cm;
                $('td[role="gridcell"]',ind).each(function(i) {
                    cm = ts.p.colModel[i];
                    nm = cm.name;
                    if ( nm !== 'cb' && cm.editable===true && nm !== 'rn' && !$(this).hasClass('not-editable-cell')) {
                        switch (cm.edittype) {
                            case "checkbox":
                                var cbv = ["Yes","No"];
                                if(cm.editoptions ) {
                                    cbv = cm.editoptions.value.split(":");
                                }
                                tmp[nm]=  $("input",this).is(":checked") ? cbv[0] : cbv[1];
                                break;
                            case 'text':
                            case 'password':
                            case 'textarea':
                            case "button" :
                                tmp[nm]=$("input, textarea",this).val();
                                break;
                            case 'select':
                                // if(!cm.editoptions.multiple) {
                                tmp[nm] = $("select option:selected",this).val();
                                tmp2[nm] = $("select option:selected", this).text();
                                // } else {
                                // 	var sel = $("select",this), selectedText = [];
                                // 	tmp[nm] = $(sel).val();
                                // 	if(tmp[nm]) { tmp[nm]= tmp[nm].join(","); } else { tmp[nm] =""; }
                                // 	$("select option:selected",this).each(
                                // 		function(i,selected){
                                // 			selectedText[i] = $(selected).text();
                                // 		}
                                // 	);
                                // 	tmp2[nm] = selectedText.join(",");
                                // }
                                if(cm.formatter && cm.formatter === 'select') { tmp2={}; }
                                break;
                            case 'custom' :
                                try {
                                    if(cm.editoptions && $.isFunction(cm.editoptions.custom_value)) {
                                        tmp[nm] = cm.editoptions.custom_value.call(ts, $(".customelement",this),'get');
                                        if (tmp[nm] === undefined) { throw "e2"; }
                                    } else { throw "e1"; }
                                } catch (e) {
                                    if (e==="e1") { $.jgrid.info_dialog($.jgrid.errors.errcap,"function 'custom_value' "+$.jgrid.edit.msg.nodefined,$.jgrid.edit.bClose); }
                                    if (e==="e2") { $.jgrid.info_dialog($.jgrid.errors.errcap,"function 'custom_value' "+$.jgrid.edit.msg.novalue,$.jgrid.edit.bClose); }
                                    else { $.jgrid.info_dialog($.jgrid.errors.errcap,e.message,$.jgrid.edit.bClose); }
                                }
                                break;
                        }
                        cv = $.jgrid.checkValues.call(ts,tmp[nm],i);
                        if(cv[0] === false) {
                            return false;
                        }
                        if(ts.p.autoencode) { tmp[nm] = $.jgrid.htmlEncode(tmp[nm]); }
                        // if(o.url !== 'clientArray' && cm.editoptions && cm.editoptions.NullIfEmpty === true) {
                        // 	if(tmp[nm] === "") {
                        // 		tmp3[nm] = 'null';
                        // 	}
                        // }
                    }
                });
                //
                var bfsr = ts._trigger("beforeSaveRow", [rowid,tmp,o]);
                if(bfsr && typeof bfsr==="object"&&bfsr.push){
                    if(bfsr.length>1 && bfsr[0]===false){
                        try {
                            var tr = $(ts.element).jqGrid('getGridRowById', rowid), positions = $.jgrid.findPos(tr);
                            $.jgrid.info_dialog($.jgrid.errors.errcap,bfsr[1],$.jgrid.edit.bClose,{left:positions[0],top:positions[1]+$(tr).outerHeight()});
                        } catch (e) {}
                        return success;

                    }
                }

                if (cv[0] === false){
                    try {
                        var tr = $(ts.element).jqGrid('getGridRowById', rowid), positions = $.jgrid.findPos(tr);
                        $.jgrid.info_dialog($.jgrid.errors.errcap,cv[1],$.jgrid.edit.bClose,{left:positions[0],top:positions[1]+$(tr).outerHeight()});
                    } catch (e) {
                        alert(cv[1]);
                    }
                    return success;
                }
                var idname, opers = ts.p.prmNames, oldRowId = rowid;
                idname = ts.p.keyName;
                // if (ts.p.keyIndex === false) {
                // 	idname = opers.id;
                // } else {
                // 	idname = ts.p.colModel[ts.p.keyIndex +
                // 		(ts.p.rownumbers === true ? 1 : 0) +
                // 		(ts.p.multiselect === true ? 1 : 0) ].name;
                // }
                if(tmp) {
                    tmp[opers.oper] = opers.editoper;
                    if (tmp[idname] === undefined || tmp[idname]==="") {
                        tmp[idname] = rowid;
                    } else if (ind.id !== ts.p.idPrefix + tmp[idname]) {
                        // rename rowid
                        var oldid = $.jgrid.stripPref(ts.p.idPrefix, rowid);
                        if (ts.p._index[oldid] !== undefined) {
                            ts.p._index[tmp[idname]] = ts.p._index[oldid];
                            delete ts.p._index[oldid];
                        }
                        rowid = ts.p.idPrefix + tmp[idname];
                        $(ind).attr("id", rowid);
                        if (ts.p.selrow === oldRowId) {
                            ts.p.selrow = rowid;
                        }
                        if ($.isArray(ts.p.selarrrow)) {
                            var i = $.inArray(oldRowId, ts.p.selarrrow);
                            if (i>=0) {
                                ts.p.selarrrow[i] = rowid;
                            }
                        }
                        if (ts.p.multiselect) {
                            var newCboxId = "jqg_" + ts.p.id + "_" + rowid;
                            $("input.cbox",ind)
                                .attr("id", newCboxId)
                                .attr("name", newCboxId);
                        }
                        // TODO: to test the case of frozen columns
                    }
                    if(ts.p.inlineData === undefined) { ts.p.inlineData ={}; }
                    tmp = $.extend({},tmp,ts.p.inlineData,o.extraparam);
                }
                tmp = $.extend({},tmp, tmp2);
                if(ts.p.autoencode) {
                    $.each(tmp,function(n,v){
                        tmp[n] = $.jgrid.htmlDecode(v);
                    });
                }
                var k, resp = $(ts.element).jqGrid("setRowData",rowid,tmp);
                $(ind).attr("editable","0");
                for(k=0;k<ts.p.savedRow.length;k++) {
                    if( String(ts.p.savedRow[k].id) === String(oldRowId)) {fr = k; break;}
                }
                if(fr >= 0) { ts.p.savedRow.splice(fr,1); }
                ts._trigger("inlineAfterSaveRow", [rowid, tmp, o]);
                if( $.isFunction(o.aftersavefunc) ) { o.aftersavefunc.call(ts, rowid,resp, o); }
                success = true;
                $(ind).removeClass("jqgrid-new-row").unbind("keydown");
            }
            return success;
        },
        /**
         * 取消行编辑
         * @param  {String} rowid            行标识
         * @param  {Function} afterrestorefunc 取消行编辑触发的事件
         */
        restoreRow : function(rowid, afterrestorefunc) {
            // Compatible mode old versions
            var args = $.makeArray(arguments).slice(1), o={};

            if( $.type(args[0]) === "object" ) {
                o = args[0];
            } else {
                if ($.isFunction(afterrestorefunc)) { o.afterrestorefunc = afterrestorefunc; }
            }
            o = $.extend(true, {}, $.jgrid.inlineEdit, o );

            // End compatible

            //return this.each(function(){
                var ts= this, fr, ind, ares={}, k;
                if (!ts.grid ) { return; }
                ind = $(ts.element).jqGrid("getInd",rowid,true);
                if(ind === false) {return;}
                var bfcr = $.isFunction( o.beforeCancelRow ) ?	o.beforeCancelRow.call(ts,cancelPrm, sr) :  undefined;
                if( bfcr === undefined ) {
                    bfcr = true;
                }
                if(!bfcr) { return; }
                for(k=0;k<ts.p.savedRow.length;k++) {
                    if( String(ts.p.savedRow[k].id) === String(rowid)) {fr = k; break;}
                }
                if(fr >= 0) {
                    // if($.isFunction($.fn.datepicker)) {
                    // 	try {
                    // 		$("input.hasDatepicker","#"+$.jgrid.jqID(ind.id)).datepicker('hide');
                    // 	} catch (e) {}
                    // }
                    $.each(ts.p.colModel, function(){
                        if(this.editable === true && ts.p.savedRow[fr].hasOwnProperty(this.name)) {
                            ares[this.name] = ts.p.savedRow[fr][this.name];
                        }
                    });
                    $(ts.element).jqGrid("setRowData",rowid,ares);
                    $(ind).attr("editable","0").unbind("keydown");
                    ts.p.savedRow.splice(fr,1);
                    if($("#"+rowid, ts.$tb).hasClass("jqgrid-new-row")){
                        setTimeout(function(){
                            $(ts.element).jqGrid("delRowData",rowid);
                            // $(ts.element).jqGrid('showAddEditButtons');
                        },0);
                    }
                }
                ts._trigger("inlineAfterRestoreRow", [rowid]);
                if ($.isFunction(o.afterrestorefunc))
                {
                    o.afterrestorefunc.call(ts, rowid);
                }
            //});
        },
        /**
         * 新增一行记录
         * @param  {Object} [option]             新增行的参数对象
         * option.rowID 行标识
         * option.initdata 新增的初始化值
         * option.position 新增的行记录位置，默认first
         */
        addRow : function ( p ) {
            p = $.extend(true, {
                rowID : null,
                initdata : {},
                position :"first",
                useDefValues : true,
                useFormatter : false,
                addRowParams : {extraparam:{}}
            },p  || {});
            //return this.each(function(){
                if (!this.grid ) { return; }
                var ts = this;
                var bfar = $.isFunction( p.beforeAddRow ) ?	p.beforeAddRow.call(ts,p.addRowParams) :  undefined;
                if( bfar === undefined ) {
                    bfar = true;
                }
                if(!bfar) { return; }
                var idname = ts.p.keyName;
                // if (ts.p.keyIndex === false) {
                // 	idname = opers.id;
                // } else {
                // 	idname = ts.p.colModel[ts.p.keyIndex +
                // 		(ts.p.rownumbers === true ? 1 : 0) +
                // 		(ts.p.multiselect === true ? 1 : 0)].name;
                // }
                p.rowID = $.isFunction(p.rowID) ? p.rowID.call(ts, p) : ( (p.rowID != null) ? p.rowID : (p.initdata[idname])?(p.initdata[idname]): $.jgrid.randId());
                if(p.useDefValues === true) {
                    $(ts.p.colModel).each(function(){
                        if( this.editoptions && this.editoptions.defaultValue ) {
                            var opt = this.editoptions.defaultValue,
                                tmp = $.isFunction(opt) ? opt.call(ts) : opt;
                            p.initdata[this.name] = tmp;
                        }
                    });
                }
                $(ts.element).jqGrid('addRowData', p.rowID, p.initdata, p.position);
                p.rowID = ts.p.idPrefix + p.rowID;
                $("#"+$.jgrid.jqID(p.rowID), "#"+$.jgrid.jqID(ts.p.id)).addClass("jqgrid-new-row");
                if(p.useFormatter) {
                    $("#"+$.jgrid.jqID(p.rowID)+" .ui-inline-edit", "#"+$.jgrid.jqID(ts.p.id)).click();
                } else {
                    var opers = ts.p.prmNames,
                        oper = opers.oper;
                    p.addRowParams.extraparam[oper] = opers.addoper;
                    $(ts.element).jqGrid('editRow', p.rowID, p.addRowParams);
                    $(ts.element).jqGrid('setSelection', p.rowID);
                }
         }//,
        // inlineNav : function (elem, o) {
        // 	o = $.extend(true,{
        // 		edit: true,
        // 		editicon: "ui-icon-pencil",
        // 		add: true,
        // 		addicon:"ui-icon-plus",
        // 		save: true,
        // 		saveicon:"ui-icon-disk",
        // 		cancel: true,
        // 		cancelicon:"ui-icon-cancel",
        // 		addParams : {addRowParams: {extraparam: {}}},
        // 		editParams : {},
        // 		restoreAfterSelect : true
        // 	}, $.jgrid.nav, o ||{});
        // 	return this.each(function(){
        // 		if (!this.grid ) { return; }
        // 		var ts = this, onSelect, gID = $.jgrid.jqID(ts.p.id);
        // 		ts.p._inlinenav = true;
        // 		// detect the formatactions column
        // 		if(o.addParams.useFormatter === true) {
        // 			var cm = ts.p.colModel,i;
        // 			for (i = 0; i<cm.length; i++) {
        // 				if(cm[i].formatter && cm[i].formatter === "actions" ) {
        // 					if(cm[i].formatoptions) {
        // 						var defaults =  {
        // 							keys:false,
        // 							onEdit : null,
        // 							onSuccess: null,
        // 							afterSave:null,
        // 							onError: null,
        // 							afterRestore: null,
        // 							extraparam: {},
        // 							url: null
        // 						},
        // 						ap = $.extend( defaults, cm[i].formatoptions );
        // 						o.addParams.addRowParams = {
        // 							"keys" : ap.keys,
        // 							"oneditfunc" : ap.onEdit,
        // 							"successfunc" : ap.onSuccess,
        // 							"url" : ap.url,
        // 							"extraparam" : ap.extraparam,
        // 							"aftersavefunc" : ap.afterSave,
        // 							"errorfunc": ap.onError,
        // 							"afterrestorefunc" : ap.afterRestore
        // 						};
        // 					}
        // 					break;
        // 				}
        // 			}
        // 		}
        // 		if(o.add) {
        // 			$(ts.element).jqGrid('navButtonAdd', elem,{
        // 				caption : o.addtext,
        // 				title : o.addtitle,
        // 				buttonicon : o.addicon,
        // 				id : ts.p.id+"_iladd",
        // 				onClickButton : function () {
        // 					$(ts.element).jqGrid('addRow', o.addParams);
        // 					if(!o.addParams.useFormatter) {
        // 						$("#"+gID+"_ilsave").removeClass('ui-state-disabled');
        // 						$("#"+gID+"_ilcancel").removeClass('ui-state-disabled');
        // 						$("#"+gID+"_iladd").addClass('ui-state-disabled');
        // 						$("#"+gID+"_iledit").addClass('ui-state-disabled');
        // 					}
        // 				}
        // 			});
        // 		}
        // 		if(o.edit) {
        // 			$(ts.element).jqGrid('navButtonAdd', elem,{
        // 				caption : o.edittext,
        // 				title : o.edittitle,
        // 				buttonicon : o.editicon,
        // 				id : ts.p.id+"_iledit",
        // 				onClickButton : function () {
        // 					var sr = $(ts.element).jqGrid('getGridParam','selrow');
        // 					if(sr) {
        // 						$(ts.element).jqGrid('editRow', sr, o.editParams);
        // 						$("#"+gID+"_ilsave").removeClass('ui-state-disabled');
        // 						$("#"+gID+"_ilcancel").removeClass('ui-state-disabled');
        // 						$("#"+gID+"_iladd").addClass('ui-state-disabled');
        // 						$("#"+gID+"_iledit").addClass('ui-state-disabled');
        // 					} else {
        // 						$.jgrid.viewModal("#alertmod",{gbox:"#gbox_"+gID,jqm:true});$("#jqg_alrt").focus();
        // 					}
        // 				}
        // 			});
        // 		}
        // 		if(o.save) {
        // 			$(ts.element).jqGrid('navButtonAdd', elem,{
        // 				caption : o.savetext || '',
        // 				title : o.savetitle || 'Save row',
        // 				buttonicon : o.saveicon,
        // 				id : ts.p.id+"_ilsave",
        // 				onClickButton : function () {
        // 					var sr = ts.p.savedRow[0].id;
        // 					if(sr) {
        // 						var opers = ts.p.prmNames,
        // 						oper = opers.oper, tmpParams = {};
        // 						if($("#"+$.jgrid.jqID(sr), "#"+gID ).hasClass("jqgrid-new-row")) {
        // 							o.addParams.addRowParams.extraparam[oper] = opers.addoper;
        // 							tmpParams = o.addParams.addRowParams;
        // 						} else {
        // 							if(!o.editParams.extraparam) {
        // 								o.editParams.extraparam = {};
        // 							}
        // 							o.editParams.extraparam[oper] = opers.editoper;
        // 							tmpParams = o.editParams;
        // 						}
        // 						if( $(ts.element).jqGrid('saveRow', sr, tmpParams) ) {
        // 							// $(ts.element).jqGrid('showAddEditButtons');
        // 						}
        // 					} else {
        // 						$.jgrid.viewModal("#alertmod",{gbox:"#gbox_"+gID,jqm:true});$("#jqg_alrt").focus();
        // 					}
        // 				}
        // 			});
        // 			$("#"+gID+"_ilsave").addClass('ui-state-disabled');
        // 		}
        // 		if(o.cancel) {
        // 			$(ts.element).jqGrid('navButtonAdd', elem,{
        // 				caption : o.canceltext || '',
        // 				title : o.canceltitle || 'Cancel row editing',
        // 				buttonicon : o.cancelicon,
        // 				id : ts.p.id+"_ilcancel",
        // 				onClickButton : function () {
        // 					var sr = ts.p.savedRow[0].id, cancelPrm = {};
        // 					if(sr) {
        // 						if($("#"+$.jgrid.jqID(sr), "#"+gID ).hasClass("jqgrid-new-row")) {
        // 							cancelPrm = o.addParams.addRowParams;
        // 						} else {
        // 							cancelPrm = o.editParams;
        // 						}
        // 						$(ts.element).jqGrid('restoreRow', sr, cancelPrm);
        // 						// $(ts.element).jqGrid('showAddEditButtons');
        // 					} else {
        // 						$.jgrid.viewModal("#alertmod",{gbox:"#gbox_"+gID,jqm:true});$("#jqg_alrt").focus();
        // 					}
        // 				}
        // 			});
        // 			$("#"+gID+"_ilcancel").addClass('ui-state-disabled');
        // 		}
        // 		if(o.restoreAfterSelect === true) {
        // 			if($.isFunction(ts.p.beforeSelectRow)) {
        // 				onSelect = ts.p.beforeSelectRow;
        // 			} else {
        // 				onSelect =  false;
        // 			}
        // 			ts.p.beforeSelectRow = function(id, stat) {
        // 				var ret = true;
        // 				// if(ts.p.savedRow.length > 0 && ts.p._inlinenav===true && ( id !== ts.p.selrow && ts.p.selrow !==null) ) {
        // 				// 	if(ts.p.selrow === o.addParams.rowID ) {
        // 				// 		$(ts.element).jqGrid('delRowData', ts.p.selrow);
        // 				// 	} else {
        // 				// 		$(ts.element).jqGrid('restoreRow', ts.p.selrow, o.editParams);
        // 				// 	}
        // 				// 	$(ts.element).jqGrid('showAddEditButtons');
        // 				// }
        // 				if(onSelect) {
        // 					ret = onSelect.call(ts, id, stat);
        // 				}
        // 				return ret;
        // 			};
        // 		}

        // 	});
        // },
        // showAddEditButtons : function()  {
        // 	return this.each(function(){
        // 		if (!this.grid ) { return; }
        // 		var gID = $.jgrid.jqID(this.p.id);
        // 		$("#"+gID+"_ilsave").addClass('ui-state-disabled');
        // 		$("#"+gID+"_ilcancel").addClass('ui-state-disabled');
        // 		$("#"+gID+"_iladd").removeClass('ui-state-disabled');
        // 		$("#"+gID+"_iledit").removeClass('ui-state-disabled');
        // 	});
        // }
        //end inline edit

        //navButtonAdd : function (elem, p) {
        //    p = $.extend({
        //        caption : "",
        //        title: '',
        //        buttonicon : 'ui-icon-newwin',
        //        onClickButton: null,
        //        position : "last",
        //        cursor : 'pointer'
        //    }, p ||{});
        //    return this.each(function() {
        //        if( !this.grid)  {return;}
        //        if( typeof elem === "string" && elem.indexOf("#") !== 0) {elem = "#"+$.jgrid.jqID(elem);}
        //        var findnav = $(elem)[0], ts = this;
        //        if (findnav) {
        //            if( p.id && $("#"+$.jgrid.jqID(p.id), findnav)[0] !== undefined )  {return;}
        //            var tbd = $("<div style='float:left;cursor:pointer;margin-left:5px;'></div>");
        //            if(p.buttonicon.toString().toUpperCase() === "NONE") {
        //                $(tbd).addClass('ui-pg-button ui-corner-all').append("<div class='ui-pg-div'>"+p.caption+"</div>");
        //            } else	{
        //                $(tbd).addClass('ui-pg-button ui-corner-all').append("<div class='ui-pg-div'><span class='ui-icon "+p.buttonicon+"'></span>"+p.caption+"</div>");
        //            }
        //            if(p.id) {$(tbd).attr("id",p.id);}
        //            if(p.position==='first'){
        //                // if(findnav.rows[0].cells.length ===0 ) {
        //                // 	$(findnav).append(tbd);
        //                // } else {
        //                $(findnav).prepend(tbd);
        //                // }
        //            } else {
        //                $(findnav).append(tbd);
        //            }
        //            $(tbd,findnav)
        //                .attr("title",p.title  || "")
        //                .click(function(e){
        //                    if (!$(this).hasClass('ui-state-disabled')) {
        //                        if ($.isFunction(p.onClickButton) ) {p.onClickButton.call(ts,e);}
        //                    }
        //                    return false;
        //                })
        //                .hover(
        //                function () {
        //                    if (!$(this).hasClass('ui-state-disabled')) {
        //                        $(this).addClass('ui-state-hover');
        //                    }
        //                },
        //                function () {$(this).removeClass("ui-state-hover");}
        //            );
        //        }
        //    });
        //}
    });

});
/**
 * Created by huangxinghui on 2014/12/4.
 */
/*!
 * iCheck v1.0.2, http://git.io/arlzeA
 * ===================================
 * Powerful jQuery and Zepto plugin for checkboxes and radio buttons customization
 *
 * (c) 2013 Damir Sultanov, http://fronteed.com
 * MIT Licensed
 */

!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.icheck', factory);
    } else {
        factory();
    }
}(function () {
    'use strict';
    $.widget("ui.icheck", {
        _create: function () {
            var type = this.element.attr('type');
            var className = type === 'checkbox' ? 'icheckbox' : 'iradio';
            this.$parent = this.element.wrap('<div class="' + className + '"></div>').parent();
            this.$helper = $('<ins class="icheck-helper"/>');
            this.$helper.appendTo(this.$parent);
            this._update();
            this._delegateEvent();
        },
        _delegateEvent: function () {
            this._on(this.element, {
                'change': '_onChange'
            });

            this.$helper.on('click', $.proxy(this._onHelperClick, this));
        },

        _setOption: function (key, value) {
            this._super(key, value);

            if (key === 'disabled') {
                this.element.attr(key, value);
                this.$parent.toggleClass('disabled', value);
            }
        },

        _destroy: function () {
            this.$helper.remove();
            this.element.unwrap();
        },

        _update : function () {
            this.$parent[this.element.prop('checked')?'addClass':'removeClass']('checked');
        },

        _onChange: function () {
            var type = this.element.attr('type'),
                checked;

            if (type === 'radio') {
                this._offOtherCheck();
                checked = true;
            } else {
                checked = this.element.prop('checked');
                this.$parent.removeClass('indeterminate');
            }
            this.$parent.toggleClass('checked', checked);
        },

        _onHelperClick: function () {
            if (!this.options.disabled) {
                this._onChange();
            }
        },

        _offOtherCheck: function () {
            var that = this,
                $form,
                inputs;

            $form = this.element.closest('form');
            inputs = 'input[name="' + this.element.attr('name') + '"]';
            inputs = $form.length ? $form.find(inputs) : $(inputs);
            inputs.each(function() {
                if (this != that.element[0] && $(this).data('icheck')) {
                    $(this).icheck('uncheck');
                }
            });
        },

        check: function () {
            var checked = this.element.prop('checked'),
                type = this.element.attr('type'),
                name = this.element.attr('name');

            if (!checked) {
                if (type === 'radio' && name) {
                    this._offOtherCheck();
                } else {
                    this.element.prop('indeterminate', false);
                }
                this.element.prop('checked', true);
            }

            this.$parent.removeClass('indeterminate').addClass('checked');
        },

        uncheck: function () {
            var checked = this.element.prop('checked');

            if (checked) {
                this.element.prop('checked', false);
            }

            this.$parent.removeClass('checked');
        },

        indeterminate: function () {
            var indeterminate = this.element.prop('indeterminate');

            if (!indeterminate) {
                this.element.prop('indeterminate', true);
                this.element.prop('checked', false);
            }

            this.$parent.removeClass('checked').addClass('indeterminate');
        },

        determinate: function () {
            var indeterminate = this.element.prop('indeterminate');

            if (indeterminate) {
                this.element.prop('indeterminate', false);
            }

            this.$parent.removeClass('indeterminate');
        }
    });
})
/**
 * 页面初次引导<br>
 * @class fish.desktop.widget.Intro
 * @extends fish.desktop.widget
 *
 * 用法:<br/>
 *      <pre>$(document.body).intro().intro('start');</pre>
 */
!function (factory) {
  if (typeof define === 'function' && define.amd) {
    define('fish.intro', factory);
  } else {
    factory();
  }
}(function () {

  $.widget('ui.intro', {
    options: {
      /**
       * @cfg {String} NextLabel='Next &rara;' next button label in tooltip box
       */
      nextLabel: 'Next &rarr;',
      /**
       * @cfg {String} prevLabel='&larr; Back' previous button label in tooltip box
       */
      prevLabel: '&larr; Back',
      /**
       * @cfg {String} skipLabel='Skip' skip button label in tooltip box
       */
      skipLabel: 'Skip',
      /**
       * @cfg {String} doneLabel='done' done button label in tooltip box
       */
      doneLabel: 'Done',
      /**
       * @cfg {String} toolTipPosition='bottom' default tooltip box position
       */
      toolTipPosition: 'bottom',
      /**
       * @cfg {String} toolTipClass='' next css class for tooltip boxes
       */
      toolTipClass: '',
      /**
       * @cfg {Boolean} exitOnEsc=true close introduction when pressing escape button?
       */
      exitOnEsc: true,
      /**
       * @cfg {Boolean} exitOnOverlayClick=true close introduction when clicking on overlay layer?
       */
      exitOnOverlayClick: true,
      /**
       * @cfg {Boolean} showStepNumbers=true show step numbers in introduction?
       */
      showStepNumbers: true,
      /**
       * @cfg {Boolean} keyboardNavigation=true let user use keyboard to navigate the tour?
       */
      keyboardNavigation: true,
      /**
       * @cfg {Boolean} showButtons=true show tour control buttons?
       */
      showButtons: true,
      /**
       * @cfg {Boolean} showBullets=true show tour bullets?
       */
      showBullets: true,
      /**
       * @cfg {Boolean} scrollToElement=true  scroll to highlighted element?
       */
      scrollToElement: true,
      /**
       * @cfg {Number} overlayOpacity=0.8 set the overlay opacity
       */
      overlayOpacity: 0.8,
      /**
       * @cfg {boolean} rtl=fasle Set the text from right to left,default false(LTR)
       */
      rtl: false,

      //event callback
      /**
       * before change function of intro
       * @event beforeChange
       * @param {Event} event Event Object
       * @param {Object} ui intro Object
       */
      beforeChange: $.noop,
      /**
       * change function of intro
       * @event change
       * @param {Event} event Event Object
       * @param {Object} ui intro Object
       */
      change: $.noop,
      /**
       * after change function of intro
       * @event afterChange
       * @param {Event} event Event Object
       * @param {Object} ui intro Object
       */
      afterChange: $.noop,
      /**
       * complete function of intro
       * @event complete
       * @param {Event} event Event Object
       * @param {Object} ui intro Object
       */
      complete: $.noop,
      /**
       * exit function of intro
       * @event exit
       * @param {Event} event Event Object
       * @param {Object} ui intro Object
       */
      exit: $.noop
    },
    _create: function () {
      var $el = this.element;

      this.options = $.extend({}, this.options, {
        nextLabel: $el.data('next-label'),
        prevLabel: $el.data('prev-label'),
        skipLabel: $el.data('skip-label'),
        doneLabel: $el.data('done-label'),
        toolTipPosition: $el.data('tooltip-position'),
        toolTipClass: $el.data('tooltip-class'),
        exitOnEsc: $el.data('exit-on-esc'),
        exitOnOverlayClick: $el.data('exit-on-overlay-click'),
        showStepNumbers: $el.data('show-step-numbers'),
        keyboardNavigation: $el.data('keyboard-navigation'),
        showButtons: $el.data('show-buttons'),
        showBullets: $el.data('show-bulltets')
      });

    },
    _init: function () {
    },
    _destroy: function () {
    },

    _start: function () {
      var introItems = [], self = this, $el = this.element;

      if (this.options.steps) {
        var allIntroSteps = [];
        for (var i = 0, stepsLength = this.options.steps.length; i < stepsLength; i++) {
          var currentItem = $.extend(true, {}, this.options.steps[i]);
          //set the step
          currentItem.step = introItems.length + 1;
          //use querySelector function only when developer used css selector
          if (typeof(currentItem.element) === 'string') {
            currentItem.element = $(currentItem.element);
          }

          if (currentItem.element != null) {
            introItems.push(currentItem);
          }
        }

      } else {
        //use steps from data-* annotations
        var allIntroSteps = $el.find('*[data-intro]');
        //if there's no element to intro
        if (allIntroSteps.length < 1) {
          return false;
        }

        //first add intro items with data-step
        for (var i = 0, elmsLength = allIntroSteps.length; i < elmsLength; i++) {
          var $currentelement = $(allIntroSteps[i]);
          var step = parseInt($currentelement.data('step'), 10);

          introItems[step - 1] = {
            element: $currentelement,
            intro: $currentelement.data('intro'),
            step: step,
            tooltipClass: $currentelement.data('tooltipClass'),
            position: $currentelement.data('position') || this.options.tooltipposition
          };
        }

      }

      //ok, sort all items with given steps
      introItems.sort(function (a, b) {
        return a.step - b.step;
      });

      //set it to the ui-intro object
      this.introItems = introItems;

      //add overlay layer to the page
      this._addOverlayLayer();

      //then, start the show
      this._nextStep();

      // handle events
      this._handleEvent();
    },
    /**
     * 绑定键盘事件
     * @private
     */
    _handleEvent: function () {
      var self = this, timer;

      if (this.options.keyboardNavigation === true) {
        function keydownEvent(e) {
          if (e.keyCode === $.ui.keyCode.ESCAPE && self.options.exitOnEsc === true) {//escape key pressed, exit the intro
            self._trigger('exit', null, self.introItems[self.currentStep]);
            self._exitIntro();
          } else if (e.keyCode === $.ui.keyCode.LEFT) {//left arrow
            self._previousStep();
          } else if (e.keyCode === $.ui.keyCode.RIGHT || e.keyCode === $.ui.keyCode.ENTER) {  //right arrow or enter
            self._nextStep();
            //prevent default behaviour on hitting enter, to prevent steps being skipped in some browsers
            if (e.preventDefault) {
              e.preventDefault();
            } else {
              e.returnValue = false;
            }
          }
        }

        if (document.addEventListener) {
          $(window).on('keydown.intro', keydownEvent);
        } else {
          $(document).on('keydown.intro', keydownEvent);
        }
      }

      $(window).on("resize.intro", function (e) {
        clearTimeout(timer);
        timer = setTimeout(function () {
          self._setHelperLayer(self.element.find('.ui-intro-helper-layer'));
        }, 150);
      });
    },

    /**
     * 给目标添加遮罩层
     * @returns {boolean}
     * @private
     */
    _addOverlayLayer: function () {
      var $overlay = $('<div class="ui-intro-overlay"></div>'),
          styletext = '',
          that = this, $el = this.element;

      //check if the target element is body, we should calculate the size of overlay layer in a better way
      if ($el.is(document) || $el.is(document.body)) {
        styletext += 'top: 0;bottom: 0; left: 0;right: 0;position: fixed;';
        $overlay.attr('style', styletext);
      } else {
        //set overlay layer position
        var offset = $el.offset();
        styletext += 'width:' + $el.outerwidth() + 'px';
        styletext += ',height:' + $el.outerheight() + 'px';
        styletext += ',top:' + offset.top + 'px';
        styletext += ',left:' + offset.left + 'px';
        $overlay.attr('style', styletext);
      }

      $el.append($overlay);
      $overlay.on('click', function (e) {
        if (that.options.exitOnOverlayClick === true) {
          $overlay.off('click');
          that._trigger('exit', null, that.introItems[that.currentStep]);
          that._exitIntro();
        }
      });

      setTimeout(function () {
        styletext += 'opacity: ' + that.options.overlayOpacity + ';';
        $overlay.attr('style', styletext);
      }, 10);

      return true;
    },
    /**
     * 设置填出层
     * @param $helperlayer
     * @private
     */
    _setHelperLayer: function ($helperlayer) {
      if ($helperlayer && $helperlayer.length != 0) {
        var currentelement = this.introItems[this.currentStep];
        //prevent error when `this.currentStep` in undefined
        if (!currentelement) return;

        var elPosition = this._getOffset(currentelement.element), //currentElement.element is $el
            widthheightpadding = 10;

        if (currentelement.position == 'floating') {
          widthheightpadding = 0;
        }

        //set new position to helper layer
        $helperlayer.attr('style', 'width: ' + (elPosition.width + widthheightpadding) + 'px; ' +
          'height:' + (elPosition.height + widthheightpadding) + 'px; ' +
          'top:' + (elPosition.top - 5) + 'px;' +
          'left: ' + (elPosition.left - 5) + 'px;');
      }
    },

    /**
     * 最终实现弹出引导界面的
     * @param target
     * @private
     */
    _showIntro: function (target) {
      this._trigger('change', null, target);

      var self = this,
          oldhelperlayer = document.querySelector('.ui-intro-helper-layer'),
          elementposition = this._getOffset(target.element);

      if (oldhelperlayer != null) { //已经存在引导提示框
        var $oldHelperLayer = $(oldhelperlayer),
            oldhelpernumberlayer = oldhelperlayer.querySelector('.ui-intro-helper-number-layer'),
            oldtooltiplayer = oldhelperlayer.querySelector('.ui-intro-tooltiptext'),
            oldarrowlayer = oldhelperlayer.querySelector('.ui-intro-arrow'),
            oldtooltipcontainer = oldhelperlayer.querySelector('.ui-intro-tooltip'),
            $skipBtn = $oldHelperLayer.find('.ui-intro-skipbutton'),// 没有作用域限制
            $prevBtn = $oldHelperLayer.find('.ui-intro-prevbutton'),
            $nextBtn = $oldHelperLayer.find('.ui-intro-nextbutton');

        //hide the tooltip
        oldtooltipcontainer.style.opacity = 0;

        if (oldhelpernumberlayer != null) {
          var lastIntroItem = this.introItems[(target.step - 2 >= 0 ? target.step - 2 : 0)];

          if (lastIntroItem != null && (this._direction == 'forward' && lastIntroItem.position == 'floating')
            || (this._direction == 'backward' && target.position == 'floating')) {
            oldhelpernumberlayer.style.opacity = 0;
          }
        }

        //set new position to helper layer
        this._setHelperLayer($(oldhelperlayer));

        //remove `ui-intro-fix-parent` class from the elements
        $('.ui-intro-fix-parent').removeClass('ui-intro-fix-parent');

        //remove old classes
        var oldshowelement = document.querySelector('.ui-intro-show-element');
        oldshowelement.className = oldshowelement.className.replace(/ui-intro-[a-za-z]+/g, '').replace(/^\s+|\s+$/g, '');

        //we should wait until the css3 transition is competed (it's 0.3 sec) to prevent incorrect `height` and `width` calculation
        if (self._lastshowelementtimer) {
          clearTimeout(self._lastshowelementtimer);
        }
        self._lastshowelementtimer = setTimeout(function () {
          //set current step to the label
          if (oldhelpernumberlayer != null) {
            oldhelpernumberlayer.innerHTML = target.step;
          }
          //set current tooltip text
          oldtooltiplayer.innerHTML = target.intro;
          //set the tooltip position
          self._placeToolTip(target.element, oldtooltipcontainer, oldarrowlayer, oldhelpernumberlayer);

          //change active bullet
          $oldHelperLayer.find('.ui-intro-bullets li > a.active').removeClass();
          $oldHelperLayer.find('.ui-intro-bullets li > a').each(function () {
            var $this = $(this);
            if ($this.data('step-number') == target.step) {
              $this.addClass('active');
              return false;
            }
          });

          //show the tooltip
          oldtooltipcontainer.style.opacity = 1;
          if (oldhelpernumberlayer) oldhelpernumberlayer.style.opacity = 1;
        }, 350);

      } else {
        var $helperlayer = $('<div class="ui-intro-helper-layer"></div>'),
            $arrowlayer = $('<div class="ui-intro-arrow"></div>'),
            $toolTipLayer = $('<div class="ui-intro-tooltip"></div>'),
            $toolTipTextLayer = $('<div class="ui-intro-tooltiptext"></div>').html(target.intro),
            $bulletsLayer = $('<div class="ui-intro-bullets"></div>'),
            $buttonsLayer = $('<div class="ui-intro-tooltipbuttons"></div>');

        if (this.options.rtl === true) {
          $buttonsLayer.addClass('rtl');
          $toolTipLayer.addClass('rtl');
        }

        //set new position to helper layer
        this._setHelperLayer($helperlayer);

        //add helper layer to target element
        this.element.append($helperlayer);

        if (this.options.showBullets === false) {
          $bulletsLayer.css('display', 'none');
        }

        var $ulContainer = $('<ul>');

        for (var i = 0, stepLength = this.introItems.length; i < stepLength; i++) {
          var $innerli = $('<li>'), $anchorlink = $('<a href="javascript:void(0)">&nbsp;</a>');

          $anchorlink.on('click', function () {
            var step = $(this).data('step-number');
            $ulContainer.find('li a.active').data('step-number') !== step && self.goToStep(step);
          });

          if (i === (target.step - 1)) {
            $anchorlink.removeClass().addClass('active');
          }

          $anchorlink.data('step-number', this.introItems[i].step);
          $innerli.append($anchorlink);
          $ulContainer.append($innerli);
        }

        $bulletsLayer.append($ulContainer);

        (this.options.showButtons === false) && $buttonsLayer.css('display', 'none');

        $toolTipLayer.append($toolTipTextLayer).append($bulletsLayer);

        //add helper layer number
        if (this.options.showStepNumbers === true) {
          var $helperNumberLayer = $('<span class="ui-intro-helper-number-layer">' + target.step + '</span>');
          $helperlayer.append($helperNumberLayer);
        }
        $helperlayer.append($toolTipLayer.append($arrowlayer));

        //next button
        var $nextBtn = $('<a href="javascript:void(0)" class="ui-intro-button ui-intro-nextbutton">' + this.options.nextLabel + '</a>');
        $nextBtn.on('click', function () {
          if (self.introItems.length - 1 != self.currentStep) {
            self._nextStep();
          }
        });

        //previous button
        var $prevBtn = $('<a href="javascript:void(0)" class="ui-intro-button ui-intro-prevbutton">' + this.options.prevLabel + '</a>');
        $prevBtn.on('click', function () {
          if (self.currentStep != 0) {
            self._previousStep();
          }
        });

        //skip button
        var $skipBtn = $('<a href="javascript:void(0)" class="ui-intro-button ui-intro-skipbutton">' + this.options.skiplabel + '</a>');
        $skipBtn.on('click', function () {
          if (self.introItems.length - 1 == self.currentStep) {
            self._trigger('complete');
          }
          if (self.introItems.length - 1 != self.currentStep) {
            self._trigger('exit', null, self.introItems[self.currentStep]);
          }

          self._exitIntro();
        });

        if (this.options.rtl === true) {
          $skipBtn.addClass('rtl');
        }

        $buttonsLayer.append($skipBtn);

        //in order to prevent displaying next/previous button always
        (this.introItems.length > 1) && $buttonsLayer.append($prevBtn).append($nextBtn);

        $toolTipLayer.append($buttonsLayer);

        //set proper position
        this._placeToolTip(target.element, $toolTipLayer[0], $arrowlayer[0], $helperNumberLayer[0]);
      }

      if (this.currentStep == 0 && this.introItems.length > 1) { //第一个提示
        $prevBtn.addClass('ui-intro-disabled');
        $nextBtn.removeClass('ui-intro-disabled');
        $skipBtn.html(this.options.skipLabel);
      } else if (this.introItems.length - 1 == this.currentStep || this.introItems.length == 1) {
        //最后一个，或者只有一个
        $prevBtn.removeClass('ui-intro-disabled');
        $nextBtn.addClass('ui-intro-disabled');
        $skipBtn.html(this.options.doneLabel);
      } else {//中间状态
        $prevBtn.removeClass('ui-intro-disabled');
        $nextBtn.removeClass('ui-intro-disabled');
        $skipBtn.html(this.options.skipLabel);
      }

      //set focus on "next" button, so that hitting enter always moves you onto the next step
      $nextBtn.focus();

      //add target element position style
      target.element.addClass('ui-intro-show-element');

      var currentElementPosition = target.element.css('position');
      if (currentElementPosition !== 'absolute' && currentElementPosition !== 'relative') {
        //change to new intro item
        target.element.addClass('ui-intro-relative-position');
      }

      var $parent = target.element.parent();
      while ($parent != null && $parent.length != 0) {
        var node = $parent[0];
        if (node.tagName.toLowerCase() === 'body') break;

        //fix the stacking contenxt problem.
        //more detail: https://developer.mozilla.org/en-us/docs/web/guide/css/understanding_z_index/the_stacking_context
        var zindex = $parent.css('z-index');
        var opacity = parseFloat($parent.css('opacity'));
        var transform = $parent.css('transform') || $parent.css('-webkit-transform') || $parent.css('-moz-transform') || $parent.css('-ms-transform') || $parent.css('-o-transform');
        if (/[0-9]+/.test(zindex) || opacity < 1 || transform !== 'none') {
          $parent.addClass('ui-intro-fix-parent');
        }

        $parent = $parent.parent();
      }

      if (!this._isInViewPort(target.element[0]) && this.options.scrollToElement === true) {
        var currentEl = target.element[0],
            rect = currentEl.getBoundingClientRect(),
            winHeight = $(window).outerHeight(),
            top = rect.bottom - (rect.bottom - rect.top),
            bottom = rect.bottom - winHeight;

        if (top < 0 || currentEl.clientHeight > winHeight) {//scroll up
          window.scrollBy(0, top - 30); // 30px padding from edge to look nice

        } else {//scroll down
          window.scrollBy(0, bottom + 100); // 70px + 30px padding from edge to look nice
        }
      }

      this._trigger('afterChange', null, target);
    },

    /**
     * 计算ToolTip位置
     * @param targetElement 目标元素（tooltip相对的元素）
     * @param tooltipLayer
     * @param arrowLayer
     * @param helperNumberLayer
     * @private
     */
    _placeToolTip: function (targetElement, tooltipLayer, arrowLayer, helperNumberLayer) {
      var tooltipCssClass = '', currentStepObj, tooltipOffset, targetElementOffset;

      //reset the old style
      tooltipLayer.style.top = null;
      tooltipLayer.style.right = null;
      tooltipLayer.style.bottom = null;
      tooltipLayer.style.left = null;
      tooltipLayer.style.marginLeft = null;
      tooltipLayer.style.marginTop = null;

      arrowLayer.style.display = 'inherit';

      if (typeof(helperNumberLayer) != 'undefined' && helperNumberLayer != null) {
        helperNumberLayer.style.top = null;
        helperNumberLayer.style.left = null;
      }

      //prevent error when `this.currentStep` is undefined
      if (!this.introItems[this.currentStep]) return;

      //if we have a custom css class for each step
      currentStepObj = this.introItems[this.currentStep];
      if (typeof (currentStepObj.tooltipClass) === 'string') {
        tooltipCssClass = currentStepObj.tooltipClass || '';
      } else {
        tooltipCssClass = this.options.tooltipClass || '';
      }

      tooltipLayer.className = (tooltipLayer.className + tooltipCssClass).replace(/^\s+|\s+$/g, '');

      //custom css class for tooltip boxes
      var tooltipCssClass = this.options.tooltipClass,
          currentTooltipPosition = this.introItems[this.currentStep].position;
      //TODO 优化成jQuery对象
      switch (currentTooltipPosition) {
        case 'top':
          tooltipLayer.style.left = '15px';
          tooltipLayer.style.top = '-' + (this._getOffset($(tooltipLayer)).height + 10) + 'px';
          arrowLayer.className = 'ui-intro-arrow bottom';
          break;
        case 'right':
          tooltipLayer.style.left = (this._getOffset($(targetElement)).width + 20) + 'px';
          arrowLayer.className = 'ui-intro-arrow left';
          break;
        case 'left':
          if (this.options.showStepNumbers == true) {
            tooltipLayer.style.top = '15px';
          }
          tooltipLayer.style.right = (this._getOffset($(targetElement)).width + 20) + 'px';
          arrowLayer.className = 'ui-intro-arrow right';
          break;
        case 'floating':
          arrowLayer.style.display = 'none';

          //we have to adjust the top and left of layer manually for intro items without element
          tooltipOffset = this._getOffset($(tooltipLayer));

          tooltipLayer.style.left = '50%';
          tooltipLayer.style.top = '50%';
          tooltipLayer.style.marginLeft = '-' + (tooltipOffset.width / 2) + 'px';
          tooltipLayer.style.marginTop = '-' + (tooltipOffset.height / 2) + 'px';

          if (typeof(helperNumberLayer) != 'undefined' && helperNumberLayer != null) {
            helperNumberLayer.style.left = '-' + ((tooltipOffset.width / 2) + 18) + 'px';
            helperNumberLayer.style.top = '-' + ((tooltipOffset.height / 2) + 18) + 'px';
          }

          break;
        case 'bottom-right-aligned':
          arrowLayer.className = 'ui-intro-arrow top-right';
          tooltipLayer.style.right = '0px';
          tooltipLayer.style.bottom = '-' + (this._getOffset($(tooltipLayer)).height + 10) + 'px';
          break;
        case 'bottom-middle-aligned':
          targetElementOffset = this._getOffset(targetElement);
          tooltipOffset = this._getOffset(tooltipLayer);

          arrowLayer.className = 'ui-intro-arrow top-middle';
          tooltipLayer.style.left = (targetElementOffset.width / 2 - tooltipOffset.width / 2) + 'px';
          tooltipLayer.style.bottom = '-' + (tooltipOffset.height + 10) + 'px';
          break;
        case 'bottom-left-aligned':
        // Bottom-left-aligned is the same as the default bottom
        case 'bottom':
        // Bottom going to follow the default behavior
        default:
          tooltipLayer.style.bottom = '-' + (this._getOffset($(tooltipLayer)).height + 10) + 'px';
          arrowLayer.className = 'ui-intro-arrow top';
          break;
      }
    },
    /**
     * 获取元素的位置
     * @param $el
     * @returns {*}
     * @private
     */
    _getOffset: function ($el) {
      var pos = $el.offset();
      return $.extend({}, pos, {width: $el.outerWidth(), height: $el.outerHeight()});
    },
    /**
     * 判断元素是否在视野（window）内
     * @param el
     * @returns {boolean}
     * @private
     */
    _isInViewPort: function (el) {
      var rect = el.getBoundingClientRect();

      return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        (rect.bottom + 80) <= window.innerHeight && // add 80 to get the text right
        rect.right <= window.innerWidth
        );
    },
    /**
     * 下一步
     * @private
     */
    _nextStep: function () {
      this.direction = 'forward';

      if (typeof (this.currentStep) === 'undefined') {
        this.currentStep = 0;
      } else {
        ++this.currentStep;
      }

      if ((this.introItems.length) <= this.currentStep) {
        this._trigger('complete');
        this._exitIntro();
        return;
      }

      var nextStep = this.introItems[this.currentStep];

      this._trigger('beforeChange', null, nextStep);
      this._showIntro(nextStep);
    },

    /**
     * 上一步
     * @returns {boolean}
     * @private
     */
    _previousStep: function () {
      this.direction = 'backward';

      if (this.currentStep === 0) {
        return false;
      }

      var nextStep = this.introItems[--this.currentStep];
      this._trigger('beforeChange', null, nextStep);
      this._showIntro(nextStep);
    },

    /**
     * 跳转到指定引导页
     * @param step 页码
     * @private
     */
    _goToStep: function (step) {
      this.currentStep = step - 2; //nextStep中会+1，所有这里要减2
      if (typeof (this.introItems) !== 'undefined') {
        this._nextStep();
      }
    },

    _exitIntro: function () {
      //remove overlay layer from the page
      var $el = this.element;
      var $overlay = $el.find('.ui-intro-overlay');

      //return if intro already completed or skipped
      if ($overlay == null || $overlay.length === 0) {
        return;
      }

      //for fade-out animation
      $overlay.css('opacity', 0);
      setTimeout(function () {
        $overlay.remove();
      }, 500);

      //remove all helper
      $el.find('.ui-intro-helper-layer').remove();

      //remove intro floating element
      $el.find('.ui-intro-floating-element').remove();

      //remove `ui-intro-showElement` class from the element
      var showElement = document.querySelector('.ui-intro-show-element');
      if (showElement) {
        showElement.className = showElement.className.replace(/ui-intro-[a-zA-Z]+/g, '').replace(/^\s+|\s+$/g, ''); // This is a manual trim.
      }

      //remove `ui-intro-fixParent` class from the elements
      var fixParents = document.querySelectorAll('.ui-intro-fix-parent');
      if (fixParents && fixParents.length > 0) {
        for (var i = fixParents.length - 1; i >= 0; i--) {
          fixParents[i].className = fixParents[i].className.replace(/ui-intro-fix-parent/g, '').replace(/^\s+|\s+$/g, '');
        }
      }

      //clean listeners
      if (document.addEventListener) {
        $(window).off('keydown.intro');
      } else {
        $(document).off('resize.intro');
      }

      //set the step to zero
      this.currentStep = undefined;
    },

    /**
     * 启动引导对话框
     * @method
     * @chainable
     * @return {Object} jQuery Object
     */
    start: function () {
      this._start();
      return this;
    },
    /**
     * 跳转到指定页码
     * @method
     * @param {Number} step 转到指定步骤
     * @chainable
     * @return {Object} jQuery Object
     */
    goToStep: function (step) {
      this._goToStep(step);
      return this;
    },
    /**
     * 下一步
     * @method
     * @chainable
     * @return {Object} jQuery Object
     */
    nextStep: function () {
      this._nextStep();
      return this;
    },
    /**
     * 上一步
     * @method
     * @chainable
     * @return {Object} jQuery Object
     */
    previousStep: function () {
      this._previousStep();
      return this;
    },

    /**
     * 退出引导
     * @chainable
     * @return {Object} jQuery Object
     */
    exit: function () {
      this._exitIntro();
      return this;
    }
  });

});
/**
 * @class fish.desktop.util.MD5
 * md5加密工具
 * <pre>
 *   fish.MD5(string, key)
 * </pre>
 */

! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.md5', factory)
    } else {
        factory();
    }
}(function() {
    'use strict';

    /*
     * Add integers, wrapping at 2^32. This uses 16-bit operations internally
     * to work around bugs in some JS interpreters.
     */
    function safe_add(x, y) {
        var lsw = (x & 0xFFFF) + (y & 0xFFFF),
            msw = (x >> 16) + (y >> 16) + (lsw >> 16);
        return (msw << 16) | (lsw & 0xFFFF);
    }

    /*
     * Bitwise rotate a 32-bit number to the left.
     */
    function bit_rol(num, cnt) {
        return (num << cnt) | (num >>> (32 - cnt));
    }

    /*
     * These functions implement the four basic operations the algorithm uses.
     */
    function md5_cmn(q, a, b, x, s, t) {
        return safe_add(bit_rol(safe_add(safe_add(a, q), safe_add(x, t)), s), b);
    }

    function md5_ff(a, b, c, d, x, s, t) {
        return md5_cmn((b & c) | ((~b) & d), a, b, x, s, t);
    }

    function md5_gg(a, b, c, d, x, s, t) {
        return md5_cmn((b & d) | (c & (~d)), a, b, x, s, t);
    }

    function md5_hh(a, b, c, d, x, s, t) {
        return md5_cmn(b ^ c ^ d, a, b, x, s, t);
    }

    function md5_ii(a, b, c, d, x, s, t) {
        return md5_cmn(c ^ (b | (~d)), a, b, x, s, t);
    }

    /*
     * Calculate the MD5 of an array of little-endian words, and a bit length.
     */
    function binl_md5(x, len) {
        /* append padding */
        x[len >> 5] |= 0x80 << (len % 32);
        x[(((len + 64) >>> 9) << 4) + 14] = len;

        var i, olda, oldb, oldc, oldd,
            a = 1732584193,
            b = -271733879,
            c = -1732584194,
            d = 271733878;

        for (i = 0; i < x.length; i += 16) {
            olda = a;
            oldb = b;
            oldc = c;
            oldd = d;

            a = md5_ff(a, b, c, d, x[i], 7, -680876936);
            d = md5_ff(d, a, b, c, x[i + 1], 12, -389564586);
            c = md5_ff(c, d, a, b, x[i + 2], 17, 606105819);
            b = md5_ff(b, c, d, a, x[i + 3], 22, -1044525330);
            a = md5_ff(a, b, c, d, x[i + 4], 7, -176418897);
            d = md5_ff(d, a, b, c, x[i + 5], 12, 1200080426);
            c = md5_ff(c, d, a, b, x[i + 6], 17, -1473231341);
            b = md5_ff(b, c, d, a, x[i + 7], 22, -45705983);
            a = md5_ff(a, b, c, d, x[i + 8], 7, 1770035416);
            d = md5_ff(d, a, b, c, x[i + 9], 12, -1958414417);
            c = md5_ff(c, d, a, b, x[i + 10], 17, -42063);
            b = md5_ff(b, c, d, a, x[i + 11], 22, -1990404162);
            a = md5_ff(a, b, c, d, x[i + 12], 7, 1804603682);
            d = md5_ff(d, a, b, c, x[i + 13], 12, -40341101);
            c = md5_ff(c, d, a, b, x[i + 14], 17, -1502002290);
            b = md5_ff(b, c, d, a, x[i + 15], 22, 1236535329);

            a = md5_gg(a, b, c, d, x[i + 1], 5, -165796510);
            d = md5_gg(d, a, b, c, x[i + 6], 9, -1069501632);
            c = md5_gg(c, d, a, b, x[i + 11], 14, 643717713);
            b = md5_gg(b, c, d, a, x[i], 20, -373897302);
            a = md5_gg(a, b, c, d, x[i + 5], 5, -701558691);
            d = md5_gg(d, a, b, c, x[i + 10], 9, 38016083);
            c = md5_gg(c, d, a, b, x[i + 15], 14, -660478335);
            b = md5_gg(b, c, d, a, x[i + 4], 20, -405537848);
            a = md5_gg(a, b, c, d, x[i + 9], 5, 568446438);
            d = md5_gg(d, a, b, c, x[i + 14], 9, -1019803690);
            c = md5_gg(c, d, a, b, x[i + 3], 14, -187363961);
            b = md5_gg(b, c, d, a, x[i + 8], 20, 1163531501);
            a = md5_gg(a, b, c, d, x[i + 13], 5, -1444681467);
            d = md5_gg(d, a, b, c, x[i + 2], 9, -51403784);
            c = md5_gg(c, d, a, b, x[i + 7], 14, 1735328473);
            b = md5_gg(b, c, d, a, x[i + 12], 20, -1926607734);

            a = md5_hh(a, b, c, d, x[i + 5], 4, -378558);
            d = md5_hh(d, a, b, c, x[i + 8], 11, -2022574463);
            c = md5_hh(c, d, a, b, x[i + 11], 16, 1839030562);
            b = md5_hh(b, c, d, a, x[i + 14], 23, -35309556);
            a = md5_hh(a, b, c, d, x[i + 1], 4, -1530992060);
            d = md5_hh(d, a, b, c, x[i + 4], 11, 1272893353);
            c = md5_hh(c, d, a, b, x[i + 7], 16, -155497632);
            b = md5_hh(b, c, d, a, x[i + 10], 23, -1094730640);
            a = md5_hh(a, b, c, d, x[i + 13], 4, 681279174);
            d = md5_hh(d, a, b, c, x[i], 11, -358537222);
            c = md5_hh(c, d, a, b, x[i + 3], 16, -722521979);
            b = md5_hh(b, c, d, a, x[i + 6], 23, 76029189);
            a = md5_hh(a, b, c, d, x[i + 9], 4, -640364487);
            d = md5_hh(d, a, b, c, x[i + 12], 11, -421815835);
            c = md5_hh(c, d, a, b, x[i + 15], 16, 530742520);
            b = md5_hh(b, c, d, a, x[i + 2], 23, -995338651);

            a = md5_ii(a, b, c, d, x[i], 6, -198630844);
            d = md5_ii(d, a, b, c, x[i + 7], 10, 1126891415);
            c = md5_ii(c, d, a, b, x[i + 14], 15, -1416354905);
            b = md5_ii(b, c, d, a, x[i + 5], 21, -57434055);
            a = md5_ii(a, b, c, d, x[i + 12], 6, 1700485571);
            d = md5_ii(d, a, b, c, x[i + 3], 10, -1894986606);
            c = md5_ii(c, d, a, b, x[i + 10], 15, -1051523);
            b = md5_ii(b, c, d, a, x[i + 1], 21, -2054922799);
            a = md5_ii(a, b, c, d, x[i + 8], 6, 1873313359);
            d = md5_ii(d, a, b, c, x[i + 15], 10, -30611744);
            c = md5_ii(c, d, a, b, x[i + 6], 15, -1560198380);
            b = md5_ii(b, c, d, a, x[i + 13], 21, 1309151649);
            a = md5_ii(a, b, c, d, x[i + 4], 6, -145523070);
            d = md5_ii(d, a, b, c, x[i + 11], 10, -1120210379);
            c = md5_ii(c, d, a, b, x[i + 2], 15, 718787259);
            b = md5_ii(b, c, d, a, x[i + 9], 21, -343485551);

            a = safe_add(a, olda);
            b = safe_add(b, oldb);
            c = safe_add(c, oldc);
            d = safe_add(d, oldd);
        }
        return [a, b, c, d];
    }

    /*
     * Convert an array of little-endian words to a string
     */
    function binl2rstr(input) {
        var i,
            output = '';
        for (i = 0; i < input.length * 32; i += 8) {
            output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xFF);
        }
        return output;
    }

    /*
     * Convert a raw string to an array of little-endian words
     * Characters >255 have their high-byte silently ignored.
     */
    function rstr2binl(input) {
        var i,
            output = [];
        output[(input.length >> 2) - 1] = undefined;
        for (i = 0; i < output.length; i += 1) {
            output[i] = 0;
        }
        for (i = 0; i < input.length * 8; i += 8) {
            output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << (i % 32);
        }
        return output;
    }

    /*
     * Calculate the MD5 of a raw string
     */
    function rstr_md5(s) {
        return binl2rstr(binl_md5(rstr2binl(s), s.length * 8));
    }

    /*
     * Calculate the HMAC-MD5, of a key and some data (raw strings)
     */
    function rstr_hmac_md5(key, data) {
        var i,
            bkey = rstr2binl(key),
            ipad = [],
            opad = [],
            hash;
        ipad[15] = opad[15] = undefined;
        if (bkey.length > 16) {
            bkey = binl_md5(bkey, key.length * 8);
        }
        for (i = 0; i < 16; i += 1) {
            ipad[i] = bkey[i] ^ 0x36363636;
            opad[i] = bkey[i] ^ 0x5C5C5C5C;
        }
        hash = binl_md5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
        return binl2rstr(binl_md5(opad.concat(hash), 512 + 128));
    }

    /*
     * Convert a raw string to a hex string
     */
    function rstr2hex(input) {
        var hex_tab = '0123456789abcdef',
            output = '',
            x,
            i;
        for (i = 0; i < input.length; i += 1) {
            x = input.charCodeAt(i);
            output += hex_tab.charAt((x >>> 4) & 0x0F) +
                hex_tab.charAt(x & 0x0F);
        }
        return output;
    }

    /*
     * Encode a string as utf-8
     */
    function str2rstr_utf8(input) {
        return unescape(encodeURIComponent(input));
    }

    /*
     * Take string arguments and return either raw or hex encoded strings
     */
    function raw_md5(s) {
        return rstr_md5(str2rstr_utf8(s));
    }

    function hex_md5(s) {
        return rstr2hex(raw_md5(s));
    }

    function raw_hmac_md5(k, d) {
        return rstr_hmac_md5(str2rstr_utf8(k), str2rstr_utf8(d));
    }

    function hex_hmac_md5(k, d) {
        return rstr2hex(raw_hmac_md5(k, d));
    }

    /**
     * @method MD5
     * MD5是输入不定長度信息，輸出固定長度128-bits的演算法。经过程序流程，生成四个32位数据，最后联合起来成为一个128-bits散列。基本方式为，求余、取余、调整长度、与链接变量进行循环运算。得出结果。一般128位的MD5散列被表示为32位十六进制数字
     *   fish.MD5提供了两种形式的结果返回，一个是16进制形式，一种未经转换的128位散列值
     * @param {String} string 输入的信息
     * @param {String} key    密钥
     * @param {Boolean} [raw=false]    是否返回128bit的散列摘要
     * @return {String} 如果raw传入true，则返回128bit的散列摘要；否则返回32位16进制数字摘要
     */
    fish.MD5 = function(string, key, raw) {
        if (!key) {
            if (!raw) {
                return hex_md5(string);
            }
            return raw_md5(string);
        }
        if (!raw) {
            return hex_hmac_md5(key, string);
        }
        return raw_hmac_md5(key, string);
    }
});

/**
 * @class fish.desktop.widget.Menu
 * @extends fish.desktop.widget
 * menu组件
 */
!function (factory) {
  if (typeof define === 'function' && define.amd) {
    define('fish.menu', factory);
  } else {
    factory();
  }
}(function () {

  var mouseHandled = false;
  $.widget("ui.menu", {
    defaultElement: "<ul>",
    delay: 300,
    options: {
      /**
       * @cfg {Object} icons Icons to use for submenus, matching an icon defined by the fish css .
       * @cfg {String} icons.submenu  
       * @cfg {String} icons.firstmenu 
       */
      icons: {
        submenu: "arrow-left",
        firstmenu: "arrow-down"
      },
      /**
       * @cfg {String} menus Selector for the elements that serve as the menu container, including sub-menus.default is "ul"
       */
      menus: "ul",
      position: {
        my: "left top",
        at: "right top",
        collision: "flipfit"
      },
      firstposition: {
        my: "left top",
        at: "left bottom+2",
        collision: "flipfit"
      },
      role: "menu",
      /**
       * @cfg {Boolean} disabled 
       * Disables the menu if set to true.
       */
      disabled:false,

      // callbacks
      blur: null,
      focus: null,
      select: null
    },

    _create: function () {
      this.activeMenu = this.element;
      this.element
          .uniqueId()
          .addClass("ui-menu ")
          .toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length)
          .attr({
            role: this.options.role,
            tabIndex: 0
          })
        // need to catch all clicks on disabled menu
        // not possible through _on
          .bind("click" + this.eventNamespace, $.proxy(function (event) {
            if (this.options.disabled) {
              event.preventDefault();
            }
          }, this));

      if (this.options.disabled) {
        this.element
            .addClass("ui-state-disabled")
            .attr("aria-disabled", "true");
      }

      //
      // if(this.element.hasClass('navbar-nav')){
      // 	this.element.removeClass('ui-widget ui-widget-content ui-corner-all');
      // }

      this._on({
        // Prevent focus from sticking to links inside menu after clicking
        // them (focus should always stay on UL during navigation).
        "mousedown .ui-menu-item > a": function (event) {
          event.preventDefault();
        },
        "click .ui-state-disabled > a": function (event) {
          event.preventDefault();
        },
        "click .ui-menu-item:has(a)": function (event) {
          var target = $(event.target).closest(".ui-menu-item");
          if (!mouseHandled && target.not(".ui-state-disabled").length) {
            mouseHandled = true;

            this.select(event);
            // Open submenu on click
            if (target.has(".ui-menu").length) {
              this.expand(event);
            } else if (!this.element.is(":focus")) {
              // Redirect focus to the menu
              this.element.trigger("focus", [ true ]);

              // If the active item is on the top level, let it stay active.
              // Otherwise, blur the active item since it is no longer visible.
              if (this.active && this.active.parents(".ui-menu").length === 1) {
                clearTimeout(this.timer);
              }
            }
          }
        },
        "mouseenter .ui-menu-item": function (event) {
          var target = $(event.currentTarget);
          // Remove ui-state-active class from siblings of the newly focused menu item
          // to avoid a jump caused by adjacent elements both having a class with a border
          target.siblings().children(".ui-state-active").removeClass("ui-state-active");
          this.focus(event, target);
        },
        mouseleave: "collapseAll",
        "mouseleave .ui-menu": "collapseAll",
        focus: function (event, keepActiveItem) {
          // If there's already an active item, keep it active
          // If not, activate the first item
          var item = this.active || this.element.children(".ui-menu-item").eq(0);

          if (!keepActiveItem) {
            this.focus(event, item);
          }
        },
        blur: function (event) {
          this._delay(function () {
            if (!$.contains(this.element[0], this.document[0].activeElement)) {
              this.collapseAll(event);
            }
          });
        },
        keydown: "_keydown"
      });

      this.refresh();

      // Clicks outside of a menu collapse any open menus
      this._on(this.document, {
        click: function (event) {
          if (!$(event.target).closest(".ui-menu").length) {
            this.collapseAll(event);
          }

          // Reset the mouseHandled flag
          mouseHandled = false;
        }
      });
    },

    _destroy: function () {
      // Destroy (sub)menus
      this.element
          .removeAttr("aria-activedescendant")
          .find(".ui-menu").andSelf()
          .removeClass("ui-menu ui-menu-icons") // ui-widget ui-widget-content ui-corner-all
          .removeAttr("role")
          .removeAttr("tabIndex")
          .removeAttr("aria-labelledby")
          .removeAttr("aria-expanded")
          .removeAttr("aria-hidden")
          .removeAttr("aria-disabled")
          .removeUniqueId()
          .show();

      // Destroy menu items
      this.element.find(".ui-menu-item")
          .removeClass("ui-menu-item")
          .removeAttr("role")
          .removeAttr("aria-disabled")
          .children("a")
          .removeUniqueId()
        // .removeClass( "ui-corner-all ui-state-hover" )
          .removeAttr("tabIndex")
          .removeAttr("role")
          .removeAttr("aria-haspopup")
          .children().each(function () {
            var elem = $(this);
            if (elem.data("ui-menu-submenu-carat")) {
              elem.remove();
            }
          });

      // Destroy menu dividers
      this.element.find(".ui-menu-divider").removeClass("ui-menu-divider");// ui-widget-content
    },

    _keydown: function (event) {
      var match, prev, character, skip, regex,
          preventDefault = true;

      function escape(value) {
        return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
      }

      switch (event.keyCode) {
        case $.ui.keyCode.PAGE_UP:
          this.previousPage(event);
          break;
        case $.ui.keyCode.PAGE_DOWN:
          this.nextPage(event);
          break;
        case $.ui.keyCode.HOME:
          this._move("first", "first", event);
          break;
        case $.ui.keyCode.END:
          this._move("last", "last", event);
          break;
        case $.ui.keyCode.UP:
          this.previous(event);
          break;
        case $.ui.keyCode.DOWN:
          this.next(event);
          break;
        case $.ui.keyCode.LEFT:
          this.collapse(event);
          break;
        case $.ui.keyCode.RIGHT:
          if (this.active && !this.active.is(".ui-state-disabled")) {
            this.expand(event);
          }
          break;
        case $.ui.keyCode.ENTER:
        case $.ui.keyCode.SPACE:
          this._activate(event);
          break;
        case $.ui.keyCode.ESCAPE:
          this.collapse(event);
          break;
        default:
          preventDefault = false;
          prev = this.previousFilter || "";
          character = String.fromCharCode(event.keyCode);
          skip = false;

          clearTimeout(this.filterTimer);

          if (character === prev) {
            skip = true;
          } else {
            character = prev + character;
          }

          regex = new RegExp("^" + escape(character), "i");
          match = this.activeMenu.children(".ui-menu-item").filter(function () {
            return regex.test($(this).children("a").text());
          });
          match = skip && match.index(this.active.next()) !== -1 ?
              this.active.nextAll(".ui-menu-item") :
              match;

          // If no matches on the current filter, reset to the last character pressed
          // to move down the menu to the first item that starts with that character
          if (!match.length) {
            character = String.fromCharCode(event.keyCode);
            regex = new RegExp("^" + escape(character), "i");
            match = this.activeMenu.children(".ui-menu-item").filter(function () {
              return regex.test($(this).children("a").text());
            });
          }

          if (match.length) {
            this.focus(event, match);
            if (match.length > 1) {
              this.previousFilter = character;
              this.filterTimer = this._delay(function () {
                delete this.previousFilter;
              }, 1000);
            } else {
              delete this.previousFilter;
            }
          } else {
            delete this.previousFilter;
          }
      }

      if (preventDefault) {
        event.preventDefault();
      }
    },

    _activate: function (event) {
      if (!this.active.is(".ui-state-disabled")) {
        if (this.active.children("a[aria-haspopup='true']").length) {
          this.expand(event);
        } else {
          this.select(event);
        }
      }
    },

    /**
     * @method refresh
     * Initializes sub-menus and menu items that have not already been initialized. New menu items, including sub-menus can be added to the menu or all of the contents of the menu can be replaced and then initialized with the refresh() method.
     */
    refresh: function () {
      var menus, that = this,
          icons = this.options.icons,
          submenus = this.element.find(this.options.menus);
      // Initialize nested menus
      submenus.filter(":not(.ui-menu)")
          .addClass("ui-menu")// ui-widget ui-widget-content ui-corner-all
          .hide()
          .attr({
            role: this.options.role,
            "aria-hidden": "true",
            "aria-expanded": "false"
          })
          .each(function () {
            var menu = $(this),
                item = menu.prev("a"),
                isFirst = that.element.hasClass('ui-menu-horizontal') && (that.element[0] == menu.parent().parent()[0]),
                submenuCarat = $("<span>")
                    .addClass("ui-menu-icon " + (isFirst ? icons.firstmenu : icons.submenu))
                    .data("ui-menu-submenu-carat", true);

            item
                .attr("aria-haspopup", "true")
                .prepend(submenuCarat);
            menu.attr("aria-labelledby", item.attr("id"));
          });
      menus = submenus.add(this.element);
      // Don't refresh list items that are already adapted
      menus.children(":not(.ui-menu-item):has(a)")
          .addClass("ui-menu-item")
          .attr("role", "presentation")
          .children("a")
          .uniqueId()
        // .addClass( "ui-corner-all" )
          .attr({
            tabIndex: -1,
            role: this._itemRole()
          });

      // Initialize unlinked menu-items containing spaces and/or dashes only as dividers
      menus.children(":not(.ui-menu-item)").each(function () {
        var item = $(this);
        // hyphen, em dash, en dash
        if (!/[^\-—–\s]/.test(item.text())) {
          item.addClass("ui-menu-divider");
        }
      });

      // Add aria-disabled attribute to any disabled menu item
      menus.children(".ui-state-disabled").attr("aria-disabled", "true");

      // If the active item has been removed, blur the menu
      if (this.active && !$.contains(this.element[ 0 ], this.active[ 0 ])) {
        this.blur();
      }
    },

    _itemRole: function () {
      return {
        menu: "menuitem",
        listbox: "option"
      }[ this.options.role ];
    },

    /**
     * @method focus
     * Activates a particular menu item, begins opening any sub-menu if present and triggers the menu's focus event.
     * @param  {Event} event What triggered the menu item to gain focus.
     * @param  {jQuery} item   The menu item to focus/activate.
     * @chainable
     */
    focus: function (event, item) {
      var nested, focused;
      this.blur(event, event && event.type === "focus");

      this._scrollIntoView(item);

      this.active = item.first();
      focused = this.active.children("a").addClass("ui-state-focus");
      // Only update aria-activedescendant if there's a role
      // otherwise we assume focus is managed elsewhere
      if (this.options.role) {
        this.element.attr("aria-activedescendant", focused.attr("id"));
      }

      // Highlight active parent menu item, if any
      this.active
          .parent()
          .closest(".ui-menu-item")
          .children("a:first")
          .addClass("ui-state-active");

      if (event && event.type === "keydown") {
        this._close();
      } else {
        this.timer = this._delay(function () {
          this._close();
        }, this.delay);
      }

      nested = item.children(".ui-menu");
      if (nested.length && ( /^mouse/.test(event.type) )) {
        this._startOpening(nested);
      }
      this.activeMenu = item.parent();

      this._trigger("focus", event, { item: item });
    },

    _scrollIntoView: function (item) {
      var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
      if (this._hasScroll()) {
        borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0;
        paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0;
        offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
        scroll = this.activeMenu.scrollTop();
        elementHeight = this.activeMenu.height();
        itemHeight = item.height();

        if (offset < 0) {
          this.activeMenu.scrollTop(scroll + offset);
        } else if (offset + itemHeight > elementHeight) {
          this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
        }
      }
    },

    /**
     * @method blur 
     * Removes focus from a menu, resets any active element styles and triggers the menu's blur event
     * @param  {Event} [event]     What triggered the menu to blur
     * @chainable
     */
    blur: function (event, fromFocus) {
      if (!fromFocus) {
        clearTimeout(this.timer);
      }

      if (!this.active) {
        return;
      }

      this.active.children("a").removeClass("ui-state-focus");
      this.active = null;

      this._trigger("blur", event, { item: this.active });
    },

    _startOpening: function (submenu) {
      clearTimeout(this.timer);

      // Don't open if already open fixes a Firefox bug that caused a .5 pixel
      // shift in the submenu position when mousing over the carat icon
      if (submenu.attr("aria-hidden") !== "true") {
        return;
      }

      this.timer = this._delay(function () {
        this._close();
        this._open(submenu);
      }, this.delay);
    },

    _open: function (submenu) {

      var isFirst = this.element.hasClass('ui-menu-horizontal') && (this.element[0] == submenu.parent().parent()[0]);

      var position = $.extend({
        of: this.active
      }, isFirst ? this.options.firstposition : this.options.position);

      clearTimeout(this.timer);
      this.element.find(".ui-menu").not(submenu.parents(".ui-menu"))
          .hide()
          .attr("aria-hidden", "true");

      submenu
          .show()
          .removeAttr("aria-hidden")
          .attr("aria-expanded", "true")
          .position(position);
    },
    /**
     * @method collapseAll
     * Closes all open sub-menus
     * @param  {Event} [event] What triggered the menu to collapse.
     * @param  {Boolean} [all]
     * Indicates whether all sub-menus should be closed or only sub-menus below and including the menu that is or contains the target of the triggering event.
     * @chainable
     */
    collapseAll: function (event, all) {
      clearTimeout(this.timer);
      this.timer = this._delay(function () {
        // If we were passed an event, look for the submenu that contains the event
        var currentMenu = all ? this.element :
            $(event && event.target).closest(this.element.find(".ui-menu"));

        // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
        if (!currentMenu.length) {
          currentMenu = this.element;
        }

        this._close(currentMenu);

        this.blur(event);
        this.activeMenu = currentMenu;
      }, this.delay);
    },

    // With no arguments, closes the currently active menu - if nothing is active
    // it closes all menus.  If passed an argument, it will search for menus BELOW
    _close: function (startMenu) {
      if (!startMenu) {
        startMenu = this.active ? this.active.parent() : this.element;
      }

      startMenu
          .find(".ui-menu")
          .hide()
          .attr("aria-hidden", "true")
          .attr("aria-expanded", "false")
          .end()
          .find("a.ui-state-active")
          .removeClass("ui-state-active");
    },

    /**
     * @method collapse
     * Closes the currently active sub-menu
     * @param  {Event} [event] What triggered the menu to collapse.
     * @chainable
     */
    collapse: function (event) {
      var newItem = this.active &&
          this.active.parent().closest(".ui-menu-item", this.element);
      if (newItem && newItem.length) {
        this._close();
        this.focus(event, newItem);
      }
    },

    /**
     * @method expand
     * Opens the sub-menu below the currently active item, if one exists.
     * @param  {Event} event What triggered the menu to expand.
     * @chainable
     */
    expand: function (event) {
      var newItem = this.active &&
          this.active
              .children(".ui-menu ")
              .children(".ui-menu-item")
              .first();

      if (newItem && newItem.length) {
        this._open(newItem.parent());

        // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
        this._delay(function () {
          this.focus(event, newItem);
        });
      }
    },

    /**
     * @method next
     * Moves active state to next menu item.
     * @param  {Event}   event What triggered the focus to move.
     * @chainable
     */
    next: function (event) {
      this._move("next", "first", event);
    },
    /**
     * @method previous
     * Moves active state to previous menu item.
     * @param  {Event} event What triggered the focus to move
     * @chainable
     */
    previous: function (event) {
      this._move("prev", "last", event);
    },
    /**
     * @method isFirstItem
     * Returns a boolean value stating whether or not the currently active item is the first item in the menu
     * @return {Boolean} 
     */
    isFirstItem: function () {
      return this.active && !this.active.prevAll(".ui-menu-item").length;
    },
    /**
     * @method isLastItem
     * Returns a boolean value stating whether or not the currently active item is the last item in the menu.
     * @return {Boolean}
     */
    isLastItem: function () {
      return this.active && !this.active.nextAll(".ui-menu-item").length;
    },

    _move: function (direction, filter, event) {
      var next;
      if (this.active) {
        if (direction === "first" || direction === "last") {
          next = this.active
              [ direction === "first" ? "prevAll" : "nextAll" ](".ui-menu-item")
              .eq(-1);
        } else {
          next = this.active
              [ direction + "All" ](".ui-menu-item")
              .eq(0);
        }
      }
      if (!next || !next.length || !this.active) {
        next = this.activeMenu.children(".ui-menu-item")[ filter ]();
      }

      this.focus(event, next);
    },
    /**
     * @method nextPage
     * Moves active state to first menu item below the bottom of a scrollable menu or the last item if not scrollable.
     * @param  {Event} event What triggered the focus to move.
     * @chainable
     */
    nextPage: function (event) {
      var item, base, height;

      if (!this.active) {
        this.next(event);
        return;
      }
      if (this.isLastItem()) {
        return;
      }
      if (this._hasScroll()) {
        base = this.active.offset().top;
        height = this.element.height();
        this.active.nextAll(".ui-menu-item").each(function () {
          item = $(this);
          return item.offset().top - base - height < 0;
        });

        this.focus(event, item);
      } else {
        this.focus(event, this.activeMenu.children(".ui-menu-item")
            [ !this.active ? "first" : "last" ]());
      }
    },
    /**
     * @method previousPage
     * Moves active state to first menu item above the top of a scrollable menu or the first item if not scrollable.
     * @param  {Event} event What triggered the focus to move.
     * @chainable
     */
    previousPage: function (event) {
      var item, base, height;
      if (!this.active) {
        this.next(event);
        return;
      }
      if (this.isFirstItem()) {
        return;
      }
      if (this._hasScroll()) {
        base = this.active.offset().top;
        height = this.element.height();
        this.active.prevAll(".ui-menu-item").each(function () {
          item = $(this);
          return item.offset().top - base + height > 0;
        });

        this.focus(event, item);
      } else {
        this.focus(event, this.activeMenu.children(".ui-menu-item").first());
      }
    },

    _hasScroll: function () {
      return this.element.outerHeight() < this.element.prop("scrollHeight");
    },

    /**
     * @method select
     * Selects the currently active menu item, collapses all sub-menus and triggers the menu's select event.
     * @param  {Event} event  What triggered the selection.
     * @chainable
     */
    select: function (event) {
      // TODO: It should never be possible to not have an active item at this
      // point, but the tests don't trigger mouseenter before click.
      this.active = this.active || $(event.target).closest(".ui-menu-item");
      var ui = { item: this.active };
      if (!this.active.has(".ui-menu").length) {
        this.collapseAll(event, true);
      }
      this._trigger("select", event, ui);
    }
  });

});

/**
 * @event blur
 * Triggered when the menu loses focus.
 * @param {Event} event
 * @param {Object} ui ui.item--the current active jquery menu item
 * 
 *     @example
 *     $( ".selector" ).menu({
 *       blur: function( event, ui ) {}
 *     });
 */
/**
 * @event focus
 * Triggered when a menu gains focus or when any menu item is activated.
 * @param {Event} event
 * @param {Object} ui ui.item--the current active jquery menu item
 * 
 *     @example
 *     $( ".selector" ).menu({
 *       focus: function( event, ui ) {}
 *     });
 *     或者
 *     $( ".selector" ).on( "menufocus", function( event, ui ) {} );
 */
/**
 * @event select
 * Triggered when a menu item is selected.
 * @param {Event} event
 * @param {Object} ui ui.item--the current active jquery menu item
 * 
 *     @example
 *     $(".selector").menu({
 *       select: function( event, ui ) {}
 *     });
 *     或者
 *     $(".selector").on( "menuselect", function( event, ui ) {} );
 */

/**
 * @class fish.desktop.widget.Multiselect
 * @extends fish.desktop.widget
 * 多选下拉
 */
! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.multiselect', factory)
    } else {
        factory();
    }
}(function() {

    'use strict';

    var SelectParser, _ref;

    //Select 解析器
    SelectParser = (function() {
        function SelectParser() {
            this.options_index = 0;
            this.parsed = [];
        }

        //添加节点,分两类<optgroup>、<option>
        SelectParser.prototype.add_node = function(child) {
            if (child.nodeName.toUpperCase() === "OPTGROUP") {
                return this.add_group(child);
            } else {
                return this.add_option(child);
            }
        };

        SelectParser.prototype.add_group = function(group) {
            var group_position, option, _i, _len, _ref, _results;
            group_position = this.parsed.length;
            this.parsed.push({
                array_index: group_position,
                group: true,
                label: _.escape(group.label),
                children: 0,
                disabled: group.disabled
            });
            _ref = group.childNodes;
            _results = [];
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                option = _ref[_i];
                _results.push(this.add_option(option, group_position, group.disabled));
            }
            return _results;
        };

        SelectParser.prototype.add_option = function(option, group_position, group_disabled) {
            if (option.nodeName.toUpperCase() === "OPTION") {
                if (option.text !== "") {
                    if (group_position != null) {
                        this.parsed[group_position].children += 1;
                    }
                    this.parsed.push({
                        array_index: this.parsed.length,
                        options_index: this.options_index,
                        value: option.value,
                        text: option.text,
                        html: option.innerHTML,
                        selected: option.selected,
                        disabled: group_disabled === true ? group_disabled : option.disabled,
                        group_array_index: group_position,
                        classes: option.className,
                        style: option.style.cssText
                    });
                } else {
                    this.parsed.push({
                        array_index: this.parsed.length,
                        options_index: this.options_index,
                        empty: true
                    });
                }
                return this.options_index += 1;
            }
        };

        return SelectParser;
    })();

    SelectParser.selectToArray = function(select) {
        var child, parser, _i, _len, _ref;
        parser = new SelectParser();
        _ref = select.childNodes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            child = _ref[_i];
            parser.add_node(child);
        }
        return parser.parsed;
    };

    var TEMPLATE = '<div><ul class="ui-multiselect-choices"><li class="search-field"><input type="text" autocomplete="off"/></li></ul><ul class="dropdown-menu ui-multiselect-results"></ul></div>';

    $.widget("ui.multiselect", {
        widgetEventPrefix: '',
        options: {
            dataTextField: "name",
            dataValueField: "value",
            dataSource: [],
            /**
             * 取初始化参数placeholder值作为默认显示,没有则从html标签中取属性值data-placeholder
             * @cfg {String}  [placeholder=""]
             */
            placeholder: "",
            /**
             * @cfg {Boolean} [completeSearch=false]
             * 默认情况下，会从单词的首字母开始搜索；设置为true的时候，完全匹配
             */
            completeSearch: false,
            /**
             * @cfg {Boolean} [containsSearch=false]
             * 默认情况下，会从单词的首字母开始搜索；设置为true的时候，从任意位置匹配
             */
            containsSearch: false,
            /**
             * @cfg {Boolean} [tabKey=true]
             * 支持tab新增不存在的元素
             */
            tabKey:true,
            /**
             * @cfg {Boolean} [deleteKey=true]
             * 支持backspace键删除记录
             */
            deleteKey: true, //支持delete和backspace键
            /**
             * @cfg {Number}  [maxLength=Infinity]
             * 限制使用者可以最多选择几个option，当到达限额的时候，multiselectmaxselected事件会被触发
             */
            maxLength: Infinity, //最大可以选择多少项
            /**
             * @cfg {Boolean}  [inheritClasses=false]
             * 设置为true的时候，会获取原dom元素上的class加到multiselect的div上
             */
            inheritClasses: false, //是否将multiselect的样式加到div容器上
            /**
             * 是否在列表中显示已选中的选项
             * @cfg {Boolean} [displaySelectedOptions=true]
             */
            displaySelectedOptions: true,
            /**
             * 是否在列表中显示失效的选项
             * @cfg {Boolean} [displayDisabledOptions=true]
             */
            displayDisabledOptions: true,
            groupSearch: true
        },
        _create: function() {
            this._setDefaultValues();
            this._setUpHtml();
            this._eventHandler();
        },
        _setDefaultValues: function() {
            this.options.placeholder = this.options.placeholder || this.element.attr('data-placeholder');
            this.currentSelectedIndex = this.element[0].selectedIndex;
            this._active = false; //是否为激活状态
            this._mouseOn = false; //鼠标是否在上面
            this.results_showing = false;
            this.result_highlighted = null;
        },
        //移除原生select，构建div容器
        _setUpHtml: function() {
            var _classes, _props, options = this.options;
            _classes = ["ui-multiselect-container"];
            if (options.inheritClasses && this.element[0].className) {
                _classes.push(this.element[0].className);
            }
            _props = {
                'class': _classes.join(' '),
                'title': this.element[0].title
            };
            if (this.element[0].id) {
                _props.id = this.element[0].id.replace(/[^\w]/g, '_') + "_multi";
            }
            this.container = $(TEMPLATE).attr(_props);
            this.element.hide().after(this.container);
            this.$ul = this.container.find('.ui-multiselect-choices').first();
            this.$li = this.container.find('li.search-field').first();
            this.$input = this.container.find('input').first().val(options.placeholder);
            this.$menu = this.container.find('.ui-multiselect-results').first();

            options.dataSource &&options.dataSource.length && this._setDataSource(options.dataSource);//支持初始化dataSource属性

            this._menuBuild();
            this._setTabIndex();
            this._setLabelBehavior();
        },
        _setOption: function(key, value) {
            this._super(key, value);

            if (key === "dataSource") {
                this._setDataSource(value);
            }

            if (key === 'disabled') {
                this.element.prop("disabled", value);
                this._update();
            }
        },
        _eventHandler: function() {
            var that = this;
            //div 容器
            this.container.on('mousedown.multiselect', function(evt) {
                that._open(evt);
            });
            this.container.on('mouseup.multiselect', function(evt) {
                that._mouseup(evt);
            });
            this.container.on('mouseenter.multiselect', function(evt) {
                that._mouseOn = true;
            });
            this.container.on('mouseleave.multiselect', function(evt) {
                that._mouseOn = false
            });
            // 下拉选项框
            this.$menu.on('mouseup.multiselect', function(evt) {
                that.menuMouseup(evt); //IMPORTANTCE!!!,通过mouseup事件，检测选中li
            });
            this.$menu.on('mouseover.multiselect', function(evt) {
                that.menuMouseover(evt);
            });
            this.$menu.on('mouseout.multiselect', function(evt) {
                that.menuMouseout(evt);
            });
            this.$menu.on('mousewheel.multiselect DOMMouseScroll.multiselect', function(evt) {
                that.menuMousewheel(evt);
            });
            //搜索框事件
            this.$input.on('blur.multiselect', function(evt) {
                that._blur(evt);
            });
            this.$input.on('keyup.multiselect', function(evt) {
                that._keyup(evt);
            });
            this.$input.on('keydown.multiselect', function(evt) {
                that._keydown(evt);
            });
            this.$input.on('focus.multiselect', function(evt) {
                that._focus(evt);
            });
            this.$input.on('cut.multiselect', function(evt) {
                that._clipboard(evt);
            });
            this.$input.on('paste.multiselect', function(evt) {
                that._clipboard(evt);
            });
            this.$ul.on('click.multiselect', function(evt) {
                that._click(evt);
            });

        },

        _validateHandler: function() {
            var $element = this.element,that = this , $warp ;
            $element.on('change.valid', function() {
                if (that._getValidFlag()) {
                    $element.isValid();
                }
            });
            this.$input.on('focus.valid', function(){
                if($element.hasClass('n-invalid')){
                    $element.resetElement();
                }
            })
            // 下拉菜单隐藏的时候校验----TODO why add this?
            // $element.on('multiselecthidingdropdown.valid', function() {
            //   try {$element.isValid();}catch(e){}
            // });
        },


        _focus: function(evt) {
            var that = this;
            if (!this._active) {
                return _.delay(function() {
                    return that._open();
                }, 50);
            }
        },

        _blur: function(evt) {
            var that = this;
            _.delay(function() {
                that.close();
            }, 100);
        },

        _tabHandler: function(evt) {
            var _inputValue = this.$input.val();
            if (_inputValue && this.options.tabKey ){//响应tab键
                evt.preventDefault();
                this.element.append('<option value="' + _inputValue + '" selected="selected">' + _inputValue + '</option>');
                this._update();
                this._close();
            }
        },

        //下拉框构建option字符串内容
        _buildMenuOption: function(options) {
            var content, data, _i, _len, _ref;
            content = '';
            _ref = this.results_data;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                data = _ref[_i];
                if (data.group) {
                    content += this.result_add_group(data);
                } else {
                    content += this.result_add_option(data);
                }
                if (options != null ? options.first : void 0) {
                    if (data.selected) {
                        this._choiceBuild(data);
                    }
                }
            }
            return content;
        },

        //生成<option>节点
        result_add_option: function(option) {
            var classes, option_el;
            if (!option.search_match) {
                return '';
            }
            if (!this._isSelectOrDisabledMenu(option)) {
                return '';
            }
            classes = [];
            if (!option.disabled && !option.selected) {
                classes.push("active-result");
            }
            if (option.disabled && !option.selected) {
                classes.push("disabled-result");
            }
            if (option.selected) {
                classes.push("result-selected");
            }
            if (option.group_array_index != null) {
                classes.push("group-option");
            }
            if (option.classes !== "") {
                classes.push(option.classes);
            }
            option_el = document.createElement("li");
            option_el.className = classes.join(" ");
            option_el.style.cssText = option.style;
            option_el.setAttribute("data-option-array-index", option.array_index);
            option_el.innerHTML = option.search_text;
            return this.outerHTML(option_el);
        },

        //生成group节点
        result_add_group: function(group) {
            var group_el;
            if (!(group.search_match || group.group_match)) {
                return '';
            }
            if (!(group.active_options > 0)) {
                return '';
            }
            group_el = document.createElement("li");
            group_el.className = "group-result";
            group_el.innerHTML = group.search_text;
            return this.outerHTML(group_el);
        },

        _update: function() {
            this._clearHighlightMenu();
            this._menuBuild();
            if (this.results_showing) {
                return this.winnow_results();
            }
        },

        //在下拉数据中进行搜索
        _search: function(evt) {
            if (this.results_showing) {
                return this.winnow_results();
            } else {
                return this.results_show();
            }
        },

        //显示最终的效果（包括在输入框中进行的搜索）
        winnow_results: function() {
            var escapedSearchText, option, regex, regexAnchor, results, results_group, searchText, startpos, text, zregex, _i, _len, _ref;
            results = 0;
            searchText = this._inputValue();
            escapedSearchText = searchText.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
            regexAnchor = this.options.containsSearch ? "" : "^";
            regex = new RegExp(regexAnchor + escapedSearchText, 'i');
            zregex = new RegExp(escapedSearchText, 'i');
            _ref = this.results_data;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                option = _ref[_i];
                option.search_match = false;
                results_group = null;
                if (this._isSelectOrDisabledMenu(option)) {
                    if (option.group) {
                        option.group_match = false;
                        option.active_options = 0;
                    }
                    if ((option.group_array_index != null) && this.results_data[option.group_array_index]) {
                        results_group = this.results_data[option.group_array_index];
                        if (results_group.active_options === 0 && results_group.search_match) {
                            results += 1;
                        }
                        results_group.active_options += 1;
                    }
                    if (!(option.group && !this.options.groupSearch)) {
                        option.search_text = option.group ? option.label : option.html;
                        option.search_match = this._searchMatch(option.search_text, regex);
                        if (option.search_match && !option.group) {
                            results += 1;
                        }
                        if (option.search_match) {
                            if (searchText.length) {
                                startpos = option.search_text.search(zregex);
                                text = option.search_text.substr(0, startpos + searchText.length) + '</em>' + option.search_text.substr(startpos + searchText.length);
                                option.search_text = text.substr(0, startpos) + '<em>' + text.substr(startpos);
                            }
                            if (results_group != null) {
                                results_group.group_match = true;
                            }
                        } else if ((option.group_array_index != null) && this.results_data[option.group_array_index].search_match) {
                            option.search_match = true;
                        }
                    }
                }
            }
            this._clearHighlightMenu();
            if (results < 1 && searchText.length) {
                this._updateMenu("");
                this._trigger("noresult");
            } else {
                this._updateMenu(this._buildMenuOption());
                return this._highlightMenu();
            }
        },

        //搜索是否还有匹配项
        _searchMatch: function(search_string, regex) {
            var part, parts, _i, _len;
            if (regex.test(search_string)) {
                return true;
            } else if (!this.options.completeSearch && (search_string.indexOf(" ") >= 0 || search_string.indexOf("[") === 0)) {
                parts = search_string.replace(/\[|\]/g, "").split(" ");
                if (parts.length) {
                    for (_i = 0, _len = parts.length; _i < _len; _i++) {
                        part = parts[_i];
                        if (regex.test(part)) {
                            return true;
                        }
                    }
                }
            }
        },

        _choicesCount: function() {
            var option, _i, _len, _ref;
            if (this.selected_option_count != null) {
                return this.selected_option_count;
            }
            this.selected_option_count = 0;
            _ref = this.element[0].options;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                option = _ref[_i];
                if (option.selected) {
                    this.selected_option_count += 1;
                }
            }
            return this.selected_option_count;
        },

        _click: function(evt) {
            evt.preventDefault();
            if (!(this.results_showing || this.is_disabled)) {
                return this.results_show();
            }
        },

        _keyup: function(evt) {
            var stroke, _ref;
            stroke = (_ref = evt.which) != null ? _ref : evt.keyCode;
            this._searchFieldScale();
            switch (stroke) {
                case 8: //BACKSPACE
                    if (this.backstroke_length < 1 && this._choicesCount() > 0) {
                        return this.keydown_backstroke();
                    } else if (!this.pending_backstroke) {
                        this._clearHighlightMenu();
                        return this._search();
                    }
                    break;
                case 13: //ENTER
                    evt.preventDefault();
                    if (this.results_showing) {
                        return this._selectMenu(evt);
                    }
                    break;
                case 27: //ESCAPE
                    if (this.results_showing) {
                        this.results_hide();
                    }
                    return true;
                case 9: //TAB
                case 38: //UP
                case 40: //DOWN
                case 16: //Shift_L
                case 91: //Win_L
                case 17: //Control_L
                    break;
                default:
                    return this._search();
            }
        },

        //粘贴|剪切 时间处理 这类时间需要延迟处理，当事件触发时，搜索框内容还未发生改变
        _clipboard: function(evt) {
            var that = this;
            return _.delay(function() {
                return that._search();
            }, 50);
        },

        _isSelectOrDisabledMenu: function(option) {
            if (!this.options.displaySelectedOptions && option.selected) {
                return false;
            }
            if (!this.options.displayDisabledOptions && option.disabled) {
                return false;
            }
            if (option.empty) {
                return false;
            }
            return true;
        },

        outerHTML: function(element) {
            var tmp;
            if (element.outerHTML) {
                return element.outerHTML;
            }
            tmp = document.createElement("div");
            tmp.appendChild(element);
            return tmp.innerHTML;
        },

        destroy: function() {
            $(this.container[0].ownerDocument).unbind("click.multiselect", $.proxy(this.isActive, this));
            if (this.$input[0].tabIndex) {
                this.element[0].tabIndex = this.$input[0].tabIndex;
            }
            this.container.remove();
            this.element.removeData('multiselect');
            return this.element.show();
        },

        search_field_disabled: function() {
            this.is_disabled = this.element[0].disabled;
            if (this.is_disabled) {
                this.container.addClass('ui-multiselect-disabled');
                this.$input[0].disabled = true;
                return this.close();
            } else {
                this.container.removeClass('ui-multiselect-disabled');
                this.$input[0].disabled = false;
            }
        },

        _open: function(evt) {
            if (!this.is_disabled) {
                if (evt && evt.type === "mousedown" && !this.results_showing) {
                    evt.preventDefault();
                }
                if (!((evt != null) && ($(evt.target)).hasClass("search-choice-close"))) {
                    if (!this._active) {
                        this.$input.val("");
                        $(this.container[0].ownerDocument).on('click.multiselect', $.proxy(this.isActive, this)); //document绑定事件
                        this.results_show();
                    }
                    return this.open();
                }
            }
        },

        _mouseup: function(evt) {
            if (evt.target.nodeName === "ABBR" && !this.is_disabled) {
                return this._resetMenu(evt);
            }
        },

        menuMousewheel: function(evt) {
            var delta;
            if (evt.originalEvent) {
                delta = -evt.originalEvent.wheelDelta || evt.originalEvent.detail;
            }
            if (delta != null) {
                evt.preventDefault();
                if (evt.type === 'DOMMouseScroll') {
                    delta = delta * 40;
                }
                return this.$menu.scrollTop(delta + this.$menu.scrollTop());
            }
        },


        _close: function(evt) {
            $(this.container[0].ownerDocument).unbind("click.multiselect", $.proxy(this.isActive, this));
            this.results_hide();
            this.clear_backstroke();
            this._setDefaultInput();
            return this._searchFieldScale();
        },

        /**
         * @method close
         * 关闭下拉框
         */
        close: function() {
            this._active = false;
            this.container.removeClass("ui-multiselect-container-active");
            return this._close();
        },

        /**
         * @method open
         * 打开下拉框
         */
        open: function() {
            this.container.addClass("ui-multiselect-container-active");
            this._active = true;
            this.$input.val(this.$input.val());
            return this.$input.focus();
        },

        //检测激活的点击是否是当前容器，如果不是则关闭显示的下拉框
        isActive: function(evt) {
            var activeContainer = $(evt.target).closest('.ui-multiselect-container');
            if (activeContainer.length && this.container[0] === activeContainer[0]) {
                return this._active = true;
            } else {
                return this.close();
            }
        },
        //构建下拉列表
        _menuBuild: function() {
            this.parsing = true;
            this.selected_option_count = null;
            this.results_data = SelectParser.selectToArray(this.element[0]);

            this.$ul.find("li.search-choice").remove();

            this._updateMenu(this._buildMenuOption({
                first: true
            }));
            this.search_field_disabled();
            this._setDefaultInput();
            this._searchFieldScale();
            return this.parsing = false;
        },

        _doHighlightMenu: function(el) {
            var high_bottom, high_top, maxHeight, visible_bottom, visible_top;

            if (el.length) {
                this._clearHighlightMenu();
                this.result_highlight = el;
                this.result_highlight.addClass("highlighted");
                maxHeight = parseInt(this.$menu.css("maxHeight"), 10);
                visible_top = this.$menu.scrollTop();
                visible_bottom = maxHeight + visible_top;
                high_top = this.result_highlight.position().top + this.$menu.scrollTop();
                high_bottom = high_top + this.result_highlight.outerHeight();

                //滚动到可见的第一个
                if (high_bottom >= visible_bottom) {
                    return this.$menu.scrollTop((high_bottom - maxHeight) > 0 ? high_bottom - maxHeight : 0);
                } else if (high_top < visible_top) {
                    return this.$menu.scrollTop(high_top);
                }
            }

        },

        _clearHighlightMenu: function() {
            if (this.result_highlight) {
                this.result_highlight.removeClass("highlighted");
            }
            return this.result_highlight = null;
        },

        results_show: function() {
            if (this.options.maxLength <= this._choicesCount()) {
                this._trigger("maxselected");
                return false;
            }
            this.container.addClass("open");
            this.results_showing = true;
            this.$input.focus();
            this.$input.val(this.$input.val());
            this.winnow_results();
            this._trigger("showingdropdown");
        },

        _updateMenu: function(content) {
            return this.$menu.html(content);
        },

        results_hide: function() {
            if (this.results_showing) {
                this._clearHighlightMenu();
                this.container.removeClass("open");
                this._trigger("hidingdropdown");
            }
            return this.results_showing = false;
        },

        //改变TAB键聚焦的方式，使原先的<select>无法使用TAB键，新的搜索框<input>可以聚焦
        _setTabIndex: function(el) {
            var ti;
            if (this.element[0].tabIndex) {
                ti = this.element[0].tabIndex;
                this.element[0].tabIndex = -1;
                return this.$input[0].tabIndex = ti;
            }
        },

        //查找父元素的Label标签，当点击父Label时触发下拉事件
        _setLabelBehavior: function() {
            var that = this;
            this.fieldLabel = this.element.parents("label");
            if (!this.fieldLabel.length && this.element[0].id.length) {
                this.fieldLabel = $("label[for='" + this.element[0].id + "']");
            }
            if (this.fieldLabel.length > 0) {
                return this.fieldLabel.on('click.multiselect', function(evt) {
                    return that._open(evt);
                });
            }
        },

        _setDefaultInput: function() {
            if (this._choicesCount() < 1 && !this._active) {
                this.$input.val(this.options.placeholder);
            } else {
                this.$input.val("");
            }
        },

        menuMouseup: function(evt) {
            var target;
            target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
            if (target.length) {
                this.result_highlight = target;
                this._selectMenu(evt);
                return this.$input.focus();
            }
        },

        menuMouseover: function(evt) {
            var target;
            target = $(evt.target).hasClass("active-result") ? $(evt.target) : $(evt.target).parents(".active-result").first();
            if (target) {
                return this._doHighlightMenu(target);
            }
        },

        menuMouseout: function(evt) {
            if ($(evt.target).hasClass("active-result" || $(evt.target).parents('.active-result').first())) {
                return this._clearHighlightMenu();
            }
        },

        _choiceBuild: function(item) {
            var choice, closeBtn, that = this;

            choice = $('<li />', {
                "class": "search-choice"
            }).html("<span>" + item.html + "</span>");
            if (item.disabled) {
                choice.addClass('search-choice-disabled');
            } else {
                closeBtn = $('<button class="search-choice-close"><span>&times;</span></button>');
                closeBtn.data('option-array-index', item.array_index);
                closeBtn.on('click.multiselect', function(evt) {
                    evt.preventDefault();
                    evt.stopPropagation();
                    if (!that.is_disabled) {
                        return that._deleteMenu($(evt.currentTarget));
                    }
                });
                choice.append(closeBtn);
            }
            return this.$li.before(choice);
        },

        _deleteMenu: function(link) {
            if (this._deselectMenu(link.data("option-array-index"))) {
                this._setDefaultInput();
                if (this._choicesCount() > 0 && this.$input.val().length < 1) {
                    this.results_hide();
                }
                link.parents('li').first().remove();
                this._searchFieldScale();
            }
        },

        _resetMenu: function() {
            this.element[0].options[0].selected = true;
            this._setDefaultInput();
            this._cleanupMenu();
            this._trigger("change");
            // this.element.trigger("multiselectchange");
            if (this._active) {
                return this.results_hide();
            }
        },

        _cleanupMenu: function() {
            this.currentSelectedIndex = this.element[0].selectedIndex;
            return this.selected_item.find("abbr").remove();
        },

        //选中当前选中项,同时对<select>进行赋值
        _selectMenu: function(evt) {
            var high, item;
            if (this.result_highlight) {
                high = this.result_highlight;
                this._clearHighlightMenu();
                if (this.options.maxLength <= this._choicesCount()) {
                    this._trigger("maxselected");
                    return false;
                }
                high.removeClass("active-result");

                item = this.results_data[high[0].getAttribute("data-option-array-index")];
                item.selected = true;
                this.element[0].options[item.options_index].selected = true; //对<select>进行赋值
                this.selected_option_count = null;
                this._choiceBuild(item);
                if (!(evt.metaKey || evt.ctrlKey)) {
                    this.results_hide();
                }
                this.$input.val("");
                this._trigger("change", evt, {
                    'selected': this.element[0].options[item.options_index].value
                });
                this.currentSelectedIndex = this.element[0].selectedIndex;
                this._searchFieldScale();
            }
        },

        _deselectMenu: function(pos) {
            var result_data;
            result_data = this.results_data[pos];
            if (!this.element[0].options[result_data.options_index].disabled) {
                result_data.selected = false;
                this.element[0].options[result_data.options_index].selected = false;
                this.selected_option_count = null;
                this._clearHighlightMenu();
                if (this.results_showing) {
                    this.winnow_results();
                }
                this._trigger("change", null, {
                    deselected: this.element[0].options[result_data.options_index].value
                });
                this._searchFieldScale();
                return true;
            } else {
                return false;
            }
        },


        _inputValue: function() {
            if (this.$input.val() === this.options.placeholder) {
                return "";
            } else {
                return $('<div/>').text($.trim(this.$input.val())).html();
            }
        },

        _highlightMenu: function() {
            var do_high, selected_results;
            selected_results = [];
            do_high = selected_results.length ? selected_results.first() : this.$menu.find(".active-result").first();
            if (do_high != null) {
                return this._doHighlightMenu(do_high);
            }
        },

        keydown_arrow: function() {
            var next_sib;
            if (this.results_showing && this.result_highlight) {
                next_sib = this.result_highlight.nextAll("li.active-result").first();
                if (next_sib) {
                    return this._doHighlightMenu(next_sib);
                }
            } else {
                return this.results_show();
            }
        },

        keyup_arrow: function() {
            var prev_sibs;
            if (this.result_highlight) {
                prev_sibs = this.result_highlight.prevAll("li.active-result");
                if (prev_sibs.length) {
                    return this._doHighlightMenu(prev_sibs.first());
                } else {
                    if (this._choicesCount() > 0) {
                        this.results_hide();
                    }
                    return this._clearHighlightMenu();
                }
            }
        },

        keydown_backstroke: function() {
            var next_available_destroy;
            if (this.pending_backstroke) {
                this._deleteMenu(this.pending_backstroke.find("button"));
                return this.clear_backstroke();
            } else {
                next_available_destroy = this.$li.siblings("li.search-choice").last();
                if (next_available_destroy.length && !next_available_destroy.hasClass("search-choice-disabled")) {
                    this.pending_backstroke = next_available_destroy;
                    if (this.options.deleteKey) {
                        return this.keydown_backstroke();
                    } else {
                        return this.pending_backstroke.addClass("search-choice-focus");
                    }
                }
            }
        },

        clear_backstroke: function() {
            if (this.pending_backstroke) {
                this.pending_backstroke.removeClass("search-choice-focus");
            }
            return this.pending_backstroke = null;
        },

        _keydown: function(evt) {
            var stroke, _ref1;
            stroke = (_ref1 = evt.which) != null ? _ref1 : evt.keyCode;
            this._searchFieldScale();
            if (stroke !== 8 && this.pending_backstroke) {
                this.clear_backstroke();
            }
            switch (stroke) {
                case 8: //BACKSPACE
                    this.backstroke_length = this.$input.val().length;
                    break;
                case 9: //TAB
                    this._tabHandler(evt);
                    break;
                case 13: //ENTER
                    evt.preventDefault();
                    break;
                case 38: //UP
                    evt.preventDefault();
                    this.keyup_arrow();
                    break;
                case 40: //DOWN
                    evt.preventDefault();
                    this.keydown_arrow();
                    break;
            }
        },
        //根据input的情况计算出input的宽度?
        _searchFieldScale: function() {
            this.$input.css("width", this.$input.val() ? "100%" : "25px");
        },

        /**
         * @method refresh
         * 刷新控件,常用于select控件数据发生改变时，重新构建multiselect
         */
        refresh: function() {
            this._update();
        },

        /**
         * @method value
         * 取值与设置选中值
         */
        value: function(newVal) {
            switch ($.type(newVal)) {
                case 'undefined':
                    return this.element.val();
                    break;
                default:
                    newVal = (newVal == null || newVal.length == 0) ? [] : [newVal];
                case 'array':
                    this.element.val(newVal);
                    this._update();
                    break;
            }
        },

        /**
         * @method data
         * 设置下拉数据
         * @param data[{id:1,name:'xx'}]
         */
        _setDataSource : function(data, value, name) {
            value = value || this.options.dataValueField;
            name = name || this.options.dataTextField;
            if ($.type(data) === 'array') {
                var opts = '';
                $.each(data, function(index, obj) {
                    opts += '<option value="' + obj[value] + '"' + (obj.disabled ? ' disabled="true" ' : '') + '>' + obj[name] + '</option>'
                });
                this.element.empty().html(opts);
                this._update();
            }
        }
    });
});


/**
 * @event change
 * 当选中项发生改变的时候触发
 * @param {Event} [evt] jquery的事件对象
 * @param {Object} [params] selected--这次选中项的值；deselected--这次取消选中项的值
 *
 *     @example
 *     $('.my_select_box').on('change', function(evt, params) {
 *         do_something(evt, params);
 *     });
 */
/**
 * @event maxselected
 * 设置了max_selected_options，并且超过了限额的时候触发
 */
/**
 * @event showingdropdown
 * 下拉显示的时候触发
 */
/**
 * @event hidingdropdown
 * 下拉隐藏的时候触发
 */
/**
 * @event noresult
 * 没有匹配到任何结果的时候触发
 */

/**
 * @class fish.desktop.widget.Pagesidebar PageSideBar
 * 页面边控制条
 * 依赖'jquery.slimScroll.js'(滚动条)
 * <pre>
 *  $('.pagesidebar').pagesidebar({data:data});
 * </pre>
 */

!function (factory) {
  if (typeof define === 'function' && define.amd) {
    define('fish.pagesidebar', factory);
  } else {
    factory();
  }
}(function () {
  'use strict';

  $.widget('ui.pagesidebar', {
    options: {
      /**
       * @cfg {Array} 数据源
       */
      data: [],
      /**
       * @cfg {Boolean} [openFirst=false] 自动打开第一个菜单，如果第一个为目录则，打开子菜单中第一个;
       * 如果location.hash已经有值则忽略openFirst参数
       */
      openFirst: false,
      /**
       * @cfg {Boolean} [autoScroll=true] 显示时是否滚动到指定的菜单
       */
      autoScroll: true,
      /**
       * @cfg {Boolean} [keepExpand=false] 是否保持菜单一直展开，默认false
       */
      keepExpand: false,
      /**
       * @cfg {Boolean} [fixed=false] 是否固定pagesidebar，默认false
       */
      fixed: false,
      /**
       * @cfg {String} [position=left] 边框位置
       */
      position: 'left', //left or right
      /**
       * @cfg {Number} [zIndex=1000] z-index
       */
      zIndex: 1000,
      /**
       * @cfg {String} [customClass=''] 自定义样式，默认为空
       */
      customClass: '',


      //event
      /**
       * @event expand pagesidebar隐藏与显示
       */
      expand: $.noop,
      /**
       * @event slideUp pagesidebar菜单向上收起事件
       */
      slideUp: $.noop,
      /**
       * @event slideDown pagesidebar菜单向下展开事件
       */
      slideDown: $.noop
    },

    _create: function () {
      this._createUI();
      this._bindEvents();
      this._action();
    },
    /**
     * 创建骨架
     */
    _createUI: function () {
      var data = this.options.data, $el = this.element;

      $el.addClass('ui-sidebar-wrapper ' + this.options.customClass).css('z-index', this.options.zIndex);

      var $sidebar = $('<div class="ui-sidebar"></div>');
      var $menus = $('<ul class="ui-sidebar-menu"></ul>');

      // 1.create toggle button
      $menus.append('<li class="ui-sidebar-toggler-wrapper"><span class="glyphicon glyphicon-align-justify ui-sidebar-toggler"></span></li>');

      //TODO 2.create search
      //if (this.options.showSearch === true) {
      //  var searchTpl = '<li class="ui-sidebar-search-wrapper">'
      //    + '<a href="javascript:;" class="remove">'
      //    + '<i class="icon-close"></i>'
      //    + '</a>'
      //    + '<div class="input-group">'
      //    + '<input type="text" class="form-control" placeholder="Search...">'
      //    + '<span class="input-group-btn">'
      //    + '<a href="javascript:;" class="btn submit"><i class="icon-magnifier"></i></a>'
      //    + '</span>'
      //    + '</div>';
      //  $menus.append(searchTpl);
      //}

      // 3.create menu
      if (data && data.length != 0) {
        $.each(data, function (index, obj) {
          var subMenus = obj.subMenus;
          var $li = $('<li></li>');

          if (index === 0) {
            $li.addClass('start');
          }
          if (index === (data.length - 1)) {
            $li.addClass('last');
          }

          var hash = obj.hash ? (obj.hash.charAt(0) === '#' ? obj.hash : '#' + obj.hash) : 'javascript:;';
          var head = '<a href="' + hash + '">';
          if (obj.icon && obj.icon.length !== 0) {
            head += '<img alt="img" src="' + obj.icon + '">';
          }
          head += '<span class="title">' + (obj.title || '') + '</span>' + '<span class="selected"></span>';
          if (subMenus && subMenus.length !== 0) {
            head += '<span class="arrow"></span>';
          }
          head += '</a>';

          $li.append(head);

          if (subMenus && subMenus.length !== 0) {
            var ul = '<ul class="sub-menu">';
            $.each(subMenus, function (index, obj) {
              var hash = obj.hash ? (obj.hash.charAt(0) === '#' ? obj.hash : '#' + obj.hash) : 'javascript:;';
              ul += '<li><a href="' + hash + '">';
              if (obj.icon && obj.icon.length !== 0) {
                ul += '<img alt="img" src="' + obj.icon + '">';
              }
              ul += obj.title + '</a></li>';
            });
            ul += '</ul>';
            $li.append(ul);
          } //end if

          $menus.append($li);
        });
      }//end if (data && data.length !=0)

      $el.append($sidebar.append($menus));


      this._setFixed();
      this._setPosition();
    },

    /**
     * 绑定事件
     * @private
     */
    _bindEvents: function () {
      var self = this, $el = this.element,
        $toggleBtn = $el.find('.ui-sidebar-toggler'),
        $sidebar = $el.find('.ui-sidebar'),
        $sidebarMenu = $el.find('.ui-sidebar-menu');

      //toggle按钮
      this._on($toggleBtn, {
        'click': function (e) {
          var $body = $('body');
          if ($body.hasClass("ui-sidebar-closed")) {
            $body.removeClass("ui-sidebar-closed");
            $sidebarMenu.removeClass("ui-sidebar-menu-closed");

            self._trigger('expand', null, {expand: true, $el: $el});
          } else {
            $body.addClass("ui-sidebar-closed");
            $sidebarMenu.addClass("ui-sidebar-menu-closed");
            if ($body.hasClass("ui-sidebar-fixed")) {
              $sidebarMenu.trigger("mouseleave");
            }
            self._trigger('expand', null, {expand: false, $el: $el});
          }

        }
      });//end _on

      //一级菜单事件
      this._on($sidebar.find('li > a'), {
        click: function (e) {
          var $target = $(e.target);
          if ($target.is('span') || $target.is('img')) { //转成<a>
            $target = $target.parent();
          }

          if ($target.next().hasClass('sub-menu') === false) { //只有一级菜单，没有二级菜单
            $sidebarMenu.find('li.active').removeClass('active');
            $target.parent().addClass('active');
            return;
          }

          if ($target.next().hasClass('sub-menu always-open')) {
            return;
          }

          var parent = $target.parent().parent();
          var the = $target; //<a>
          var $subMenus = $target.next();

          var autoScroll = this.options.autoScroll,
            slideSpeed = 200,
            keepExpand = this.options.keepExpand;

          if (keepExpand !== true) {
            parent.children('li.open').children('a').children('.arrow').removeClass('open');
            parent.children('li.open').children('.sub-menu:not(.always-open)').slideUp(slideSpeed);
            parent.children('li.open').removeClass('open');
          }

          var slideOffeset = -200;

          if ($subMenus.is(":visible")) {
            $('.arrow', $target).removeClass("open");
            $target.parent().removeClass("open");
            $subMenus.slideUp(slideSpeed, function () {
              if (autoScroll === true) {
                scrollTo(the, slideOffeset);
              }
              self._trigger('slideUp', null, {$el: $el});
            });
          } else {
            $('.arrow', $target).addClass("open");
            $target.parent().addClass("open");

            $subMenus.slideDown(slideSpeed, function () {
              if (autoScroll === true) {
                scrollTo(the, slideOffeset);
              }

              self._trigger('slideDown', null, {$el: $el});
            });
          }

          e.preventDefault();
        }
      });//end

      //二级菜单事件
      this._on($sidebar.find('li > ul > li > a'), {
        click: function (e) {
          var $target = $(e.target);
          if ($target.is('img')) {
            $target = $target.parent(); // <a>
          }

          // 移除选中(一级和二级)
          $sidebarMenu.find('li.active').removeClass('active');

          //激活(一级和二级)
          $target.parent().addClass('active');
          $target.parent().parent().parent().addClass('active');
        }
      });//end 二级菜单

    },
    _action: function () {
      this._openFirst();
      this._detectHash();
    },

    /**
     * 判断是否自动打开第一个菜单，如果第一个菜单为目录，则打开子菜单中的第一个
     * @private
     */
    _openFirst: function () {
      if (this.options.openFirst !== true) {
        return;
      }
      if (this.options.data == null || this.options.data.length == 0) {
        return;
      }
      //已经有hash
      if (location.hash.length > 1) {
        return;
      }

      var $el = this.element, $sidebar = $el.find('.ui-sidebar'), $sidebarMenu = $el.find('.ui-sidebar-menu');
      //查找一级菜单
      var $firstA = $sidebar.find('ul.ui-sidebar-menu>li>a:eq(0)');
      var hash = $firstA[0]['hash'];
      if (hash.charAt(0) === '#') {
        location.hash = hash;
      } else {
        var $secondA = $sidebar.find('ul.ui-sidebar-menu>li>ul.sub-menu>li>a:eq(0)');
        var hash = $secondA[0]['hash'];
        if (hash.charAt(0) === '#') {
          location.hash = hash;
        }
      }

    },

    /**
     * 检测当前的页面的hash
     * @private
     */
    _detectHash: function () {
      var self = this;
      var hash = location.hash;
      if (hash && hash.length > 1) {
        setTimeout(function () {
          self.locate(hash);
        }, 100);
      }
    },

    /**
     * 动态支持属性设置
     * @param key
     * @param value
     * @private
     */
    _setOption: function (key, value) {
      switch (key) {
        case 'position':
          this._super(key, value);
          this._setPosition();
        case 'fixed':
          this._super(key, value);
          this._setFixed();
          break;
      }

    },

    /**
     * 固定控件
     * @private
     */
    _setFixed: function () {
      var self = this, $el = this.element,
        $sidebarMenu = $el.find('.ui-sidebar-menu'),
        $body = $('body');

      if (this.options.fixed === true) {
        $('body').addClass('ui-sidebar-fixed');
        $sidebarMenu.addClass("ui-sidebar-menu-fixed").removeClass("ui-sidebar-menu-default");


        if ($body.hasClass('ui-sidebar-fixed')) {
          this._on($sidebarMenu, {
            mouseenter: function (e) {
              if ($body.hasClass('ui-sidebar-closed')) {
                $sidebarMenu.removeClass('ui-sidebar-menu-closed');
              }
            },
            mouseleave: function (e) {
              if ($body.hasClass('ui-sidebar-closed')) {
                $sidebarMenu.addClass('ui-sidebar-menu-closed');
              }
            }
          });

        }

        this._setScroll();
      } else {
        $("body").removeClass("ui-sidebar-fixed");
        if ($sidebarMenu.data('ui-slim-scroll-init')) {
          $sidebarMenu.slimScroll({destroy: true});
          $sidebarMenu.removeAttr('style');
        }

        $sidebarMenu.addClass("ui-sidebar-menu-default").removeClass("ui-sidebar-menu-fixed")
          .unbind('mouseenter').unbind('mouseleave');
      }
    },
    /**
     * 设置边框位置
     * @private
     */
    _setPosition: function () {
      if (this.options.position === 'right') {
        $('body').removeClass("ui-sidebar-left").addClass('ui-sidebar-right');
      } else {
        $("body").removeClass("ui-sidebar-right").addClass('ui-sidebar-left');
      }
    },


    /**
     * 菜单滚动条显示
     * @private
     */
    _setScroll: function () {
      var self = this,
        $el = this.element,
        $sidebarMenu = $el.find('.ui-sidebar-menu');
      if ($sidebarMenu.data('ui-slim-scroll-init')) {
        //
        $sidebarMenu.slimScroll({destroy: true});
      }
      //var autoHeight = Math.min($sidebarMenu[0].scrollHeight, document.body.scrollHeight);
      var autoHeight = $sidebarMenu[0].scrollHeight;

      $sidebarMenu.slimScroll({
        allowPageScroll: true, // allow page scroll when the element scroll is ended
        size: '7px',
        position: 'right',
        height: autoHeight,
        alwaysVisible: false,
        railVisible: true,
        disableFadeOut: true
      });
      $sidebarMenu.data('ui-slim-scroll-init', true);

    },
    /**
     * 定位右边菜单
     */
    locate: function (hash) {
      var self = this, $el = this.element,
        $toggleBtn = $el.find('.ui-sidebar-toggler'),
        $sidebar = $el.find('.ui-sidebar'),
        $sidebarMenu = $el.find('.ui-sidebar-menu');

      var $a = $sidebarMenu.find('a');
      $a.each(function (index, a) {
        var $a = $(a);
        if (a.hash === $.trim(hash)) {
          var $ul = $a.parent().parent();
          if ($ul.hasClass('sub-menu')) { //二级菜单
            $sidebarMenu.find('li.active').removeClass('active');
            $a.parent().addClass('active');
            $a.parent().parent().parent().addClass('active');
          } else { //一级菜单
            $sidebarMenu.find('li.active').removeClass('active');
            $a.parent().addClass('active');
          }
          return false;
        }
      });


      this._on($sidebar.find('li > ul > li > a'), {
        click: function (e) {
          var $target = $(e.target);
          if ($target.is('img')) {
            $target = $target.parent(); // <a>
          }

          // 移除选中(一级和二级)
          $sidebarMenu.find('li.active').removeClass('active');

          //激活(一级和二级)
          $target.parent().addClass('active');
          $target.parent().parent().parent().addClass('active');
        }
      });//end 二级菜单
    },

    /**
     * 销毁组件，由widget.js destroy方法调用
     * 清空节点和样式
     * @private
     */
    _destroy: function () {
      var self = this, $el = self.element,
        $sidebarMenu = $el.find('.ui-sidebar-menu');
      if ($sidebarMenu.data('ui-slim-scroll-init')) {
        $sidebarMenu.slimScroll({destroy: true});
      }

      $el.removeClass('ui-sidebar-wrapper').removeClass(this.options.customClass).css('z-index', '').empty();
      $('body').removeClass('ui-sidebar-left ui-sidebar-right ui-sidebar-fixed');
    }
  });

  function scrollTo(el, offeset) {
    var pos = (el && el.size() > 0) ? el.offset().top : 0;

    if (el) {
      pos = pos + (offeset ? offeset : -1 * el.height());
    }

    $('html,body').animate({scrollTop: pos}, 'slow');
  }


});
!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.popedit', ['fish.dialog'], factory);
    } else {
        factory();
    }
}(function () {

    'use strict';

    /**
     * 日期时间控件
     * @class fish.desktop.widget.Datetimepicker
     * @extends fish.desktop.widget
     * <pre>
     *   $(element).datetimepicker(option);
     * </pre>
     */

    $.widget("ui.popedit", {
        widgetEventPrefix: '',
        options: {
            url: '',
            /** @cfg {String} buttonIcon='remove new-window' 默认图标;remove表示清除按钮,弹出层可以使用任意的glyphicon图标
             */
            buttonIcon: 'remove new-window',
            dialogOption: null,
            value: null,
            dataTextField: "name",
            dataValueField: "value",
            initialData : null

        },
        //根据图标属性的配置创建图标
        _createIcon: function () {
            var options = this.options,
                $element = $(this.element),
                $icon = "",
                icons = options.buttonIcon.split(" ");

            for (var i = 0; i < icons.length; i++) {
                $icon += ' <span class="input-group-addon"><span class="glyphicon glyphicon-' + icons[i] + '"></span></span>'
            }
            $element.after($icon);

            this.component = $element.nextAll('.input-group-addon').filter(function (index) {
                return !$(this).children('.glyphicon').hasClass('glyphicon-remove');
            });
            this.componentReset = $element.nextAll('.input-group-addon').filter(function (index) {
                return $(this).children('.glyphicon').hasClass('glyphicon-remove');
            });
            this.component = this.component.length ? this.component : false;
            this.componentReset = this.componentReset.length ? this.componentReset : false;
        },
        //初始化参数
        _getCreateOptions: function () {
            var $element = $(this.element);
            return {
                url: $element.data('url'),
            };
        },
        _create: function () {
            var that = this,
                options = this.options,
                element = this.element,
                $element = $(element);
            $element.addClass('ui-widget-input');
            options.buttonIcon && this._createIcon();
            this._attachEvents();
            this.setValue(options.initialData);
        },
        //popedit提交数据的时候,界面值不是实际值,需要重写getValue方法
        _formHandler: function ($form) {//增加对form的支持
            var that = this;
            $form.on('getvalue'+this.uuid+'.form', function(e){
                var value = that.getValue();
                console.log(that.widgetName + " getFormValue:" + JSON.stringify(value));
                return value ? value[that.options.dataValueField] : "";
            });
        },
        _update : function (value) {
            var options = this.options, _temp;
            if(value === undefined){
                this.setValue(options.initialData);// reset
            } else if (value === null) {//clear
                this.value = value;
            } else {//setValue
                if (typeof value === 'string') {
                    _temp = value;
                    value = {};
                    value[options.dataTextField] = $.trim(_temp);
                    value[options.dataValueField] = $.trim(_temp);
                }
                this.value = value;
                this.element.val(value ? value[options.dataTextField] : "");
            }
        },
        _validateHandler: function () {
            var $element = this.element, that = this, $warp;
            $element.on('change.valid', function () {
                if (that._getValidFlag()) {
                    $element.isValid();
                }
            });
        },
        _attachEvents: function () {
            this._on(this.component, {
                click: '_openDialog'
            });

            if (this.componentReset) {
                this._on(this.componentReset, {
                    click: '_clear'
                });
            }
        },
        /**
         * 打开弹出框
         * @method show
         * @param  {Object} e 事件对象
         */
        _openDialog: function (e) {
            var dialog = this.dialog;
            if (dialog) { //已经存在就直接打开;如果改变url,则重新生成~
                dialog.dialog("open");
                this._trigger('open');
            } else {
                var that = this, url = this.options.url;
                if (url.indexOf("#") === 0) {//以#开头
                    this._initDialog($(url));
                } else {
                    $.ajax({
                        url: url,
                        type: 'get',
                        dataType: 'html'
                    }).done(function (responseText) {
                        var $html = $(responseText);
                        $("body").append($html);
                        $html.attr("id")?$html.uniqueId():"";
                        that._initDialog($("#"+$html.attr("id")));
                    })
                }
            }
        },
        _initDialog: function ($el) {
            var that = this;
            $el.dialog(this.options.dialogOption).on({
                "change": function (e, value) {
                    that.setValue(value);
                }
            });
            this._trigger('open');
            this.dialog = $el;
        },
        _setOption: function (key, value) {

            if (key === "url") {
                if (this.dialog && this.options.url !== value) {
                    this.dialog.dialog("destroy");
                    this.dialog = null;
                }
            }
            this._super(key, value);

            if (key === "dialogOption") {
                if (this.dialog) {
                    this.dialog.dialog("option", value);
                }
            }
            if (key === 'disabled') {
                this.element.prop("disabled", value);
            }
        },
        /**
         * 关闭弹出框
         * @method hide
         * @param  {Object} e 事件对象
         */
        _clear: function (e) {
            this.setValue("");
        },
        setValue: function (value) {//通过filed等属性进行操作//form使用时要进行值覆盖
            var options = this.options, _temp;
            if (typeof value === 'string') {
                _temp = value;
                value = {};
                value[options.dataTextField] = $.trim(_temp);
                value[options.dataValueField] = $.trim(_temp);
            }
            this.value = value;
            this.element.val(value ? value[options.dataTextField] : "");//显示label值，form中覆盖value
            this._trigger('change', null, value);
        },
        getValue: function () {
            var options = this.options, _temp, value = this.value;
            if (typeof value === 'string') {
                _temp = value;
                value = {};
                value[options.dataTextField] = $.trim(_temp);
                value[options.dataValueField] = $.trim(_temp);
            }
            return value;
        }
    })

});

/**
 * @class  fish.desktop.widget.Progressbar
 * @extends fish.desktop.widget
 * 进度条组件
 */
!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.progressbar', factory)
    } else {
        factory();
    }
}(function () {
    'use strict';

    $.widget("ui.progressbar", {
        options: {
            /**
             * @cfg {Number} max The maximum value of the progressbar.
             */
            max: 100,
            /**
             * @cfg {Number} value The value of the progressbar.
             */
            value: 0,
            /**
             * @cfg {String} progressbarClass The customer css of the progressbar.
             */
            progressbarClass: '',
            /**
             * @cfg {String} label 文字内容
             */
            label: '',

            //callback
            change: null,
            complete: null
        },

        min: 0, //不属于可配置项

        /*
         * create创建完成后的时间UI
         * @returns {element|*|Function}
         * @private
         */
        _getCreateEventData: function () {
            return {
                progressbar: this.element
            };
        },

        _create: function () {
            // Constrain initial value
            this.oldValue = this.options.value = this._constrainedValue();

            this.element
                .addClass("ui-progressbar" + this.options.progressbarClass)
                .attr({
                    // Only set static values, aria-valuenow and aria-valuemax are
                    // set inside _refreshValue()
                    role: "progressbar",
                    "aria-valuemin": this.min
                });

            this.valueDiv = $("<div class='ui-progressbar-value'></div>") // ui-widget-header ui-corner-left
                .appendTo(this.element);

            this.labelDiv = $('<div class="progress-label"></div>').html(this.options.label).prependTo(this.element);

            this._refreshValue();
        },

        _destroy: function () {
            this.element
                .removeClass("ui-progressbar")
                .removeAttr("role")
                .removeAttr("aria-valuemin")
                .removeAttr("aria-valuemax")
                .removeAttr("aria-valuenow");

            this.valueDiv.remove();
        },
        /**
         * @method value
         * 获取进度条的值或者设置新值
         * @param  {Number} [newValue] 传入这个参数的时候，就是设置新的值，否则返回当前值
         * @return {Number} 当调用方法取值的时候，返回进度条当前值；否则没有返回
         */
        value: function (newValue) {
            if (newValue === undefined) {
                return this.options.value;
            }

            this.options.value = this._constrainedValue(newValue);
            this._refreshValue();
        },
        /**
         * @method label
         * 设置文字内容
         * @param  {String} newLabel 新的内容
         */
        label: function (newLabel) {
            this.labelDiv.html(newLabel);
        },

        _constrainedValue: function (newValue) {
            if (newValue === undefined) {
                newValue = this.options.value;
            }

            // sanitize value
            if (typeof newValue !== "number") {
                newValue = 0;
            }

            return Math.min(this.options.max, Math.max(this.min, newValue));
        },

        _setOptions: function (options) {
            // Ensure "value" option is set after other values (like max)
            var value = options.value;
            delete options.value;

            this._super(options);

            this.options.value = this._constrainedValue(value);
            this._refreshValue();
        },

        _setOption: function (key, value) {
            if (key === "max") {
                // Don't allow a max less than min
                value = Math.max(this.min, value);
            }

            this._super(key, value); //调用父类的方法
        },

        /**
         * 获取百分比
         * @returns {number}
         * @private
         */
        _percentage: function () {
            return 100 * (this.options.value - this.min) / (this.options.max - this.min);
        },

        /**
         * 刷新值
         * @private
         */
        _refreshValue: function () {

            var value = this.options.value,
                percentage = this._percentage();

            this.valueDiv
                .toggle(value > this.min)
                // .toggleClass("ui-corner-right", value === this.options.max)
                .css('width', percentage.toFixed(0) + "%");
            //      .width(percentage.toFixed(0) + "%"); //fix error in bs

            this.element.attr({
                "aria-valuemax": this.options.max,
                "aria-valuenow": value
            });

            if (this.oldValue !== value) {
                this.oldValue = value;
                this._trigger("change", null, {
                    progressbar: this.element
                });
            }
            if (value === this.options.max) {
                this._trigger("complete", null, {
                    progressbar: this.element
                });
            }
        }
    });
}); //end define
/**
 * @event change
 * Triggered when the value of the progressbar changes.
 * @param {Event} event event object
 *
 *     @example
 *     $(".selector").progressbar({
 *       change: function( event, ui ) {}
 *     });
 *
 *     $( ".selector" ).on( "progressbarchange", function( event, ui ) {} );
 */
/**
 * @event complete
 * Triggered when the value of the progressbar reaches the maximum value.
 * @param {Event} event  event object
 *
 *     @example
 *     $( ".selector" ).progressbar({
 *       complete: function( event, ui ) {}
 *     });
 *
 *     $( ".selector" ).on( "progressbarcomplete", function( event, ui ) {} );
 */

/**
 * raterstar Widget
 * @class fish.desktop.widget.Raterstar
 * <pre>
 *   $(element).raterstar(option);
 * </pre>
 */
!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.raterstar', factory);
    } else {
        factory();
    }
}(function () {
    'use strict';

    $.widget('ui.raterstar', {
        options: {
            /**
             * @cfg {Boolean} disabled=false 是否禁用，默认不禁用
             */
            disabled: false,
            /**
             * @cfg {Number} min=1 最小值，默认1
             */
            min: 1,
            /**
             * @cfg {Number} max=5 最大值，默认5
             */
            max: 5,
            /**
             * @cfg {Number} step=1 移动的步长，默认1
             */
            step: 1,
            /**
             * @cfg {Number} value=null，初始值
             */
            value: null,

            /**
             * @cfg {String} image='img/star.gif' 自定义图标
             */
            image: null,
            /**
             * @cfg {Number} width=25 默认图片宽度
             */
            width: 25,
            /**
             * @cfg {Number} height=25 默认图片高度
             */
            height: 25,
            /**
             * @cfg {Function} 自定义提示信息
             * @param value 当前选中的参数值
             */
            titleFormat: null,
            /**
             * @cfg {Number} zIndex=1000 默认z-index
             */
            zIndex: 1000
        },
        _create: function () {
            this._initUI();
            this._initEvent();
        },

        _initUI: function () {
            var opt = this.options;
            // 主容器
            var $container = $('<ul class="ui-rater-star"></ul>');
            $container.css({
                height: opt.height,
                width: (opt.width * opt.step) * (opt.max - opt.min + opt.step) / opt.step
            });
            if (opt.image) {
                $container.css('background-image', 'url(' + opt.image + ')');
            }


            // 当前选中的
            var $item = $('<li class="ui-rater-star-item-current"></li>');
            if (opt.image) {
                $item.css('background-image', 'url(' + opt.image + ')');
            }
            $item.css('height', opt.height);
            $item.css('width', 0);
            $item.css('z-index', opt.zIndex + opt.max / opt.step + 1);
            if (opt.value) {
                $item.css('width', ((opt.value - opt.min) / opt.step + 1) * opt.step * opt.width);
            }

            $container.append($item);

            // 星星
            if (!!!opt.disabled) { // 是否能更改
                for (var value = opt.min; value <= opt.max; value += opt.step) {
                    $item = $('<li class="ui-rater-star-item"></li>');

                    if (typeof opt.titleFormat == 'function') {
                        $item.attr('title', opt.titleFormat(value));
                    }
                    else {
                        $item.attr('title', value);
                    }
                    $item.css('height', opt.height);
                    $item.css('width', (value - opt.min + opt.step) * opt.width);
                    $item.css('z-index', opt.zIndex + (opt.max - value) / opt.step + 1);
                    if (opt.image) {
                        $item.css('background-image', 'url(' + opt.image + ')');
                    }
                    $container.append($item);
                }
            }
            this.element.append($container);
        },

        _initEvent: function () {
            var self = this, $el = self.element, opt = this.options;
            var $container = self.element.find('.ui-rater-star');

            if (!!!opt.disabled) {
                $container.mouseover(function () {
                    if (opt.disabled) {
                        return;
                    }
                    $(this).find('.ui-rater-star-item-current').hide();
                }).mouseout(function () {
                    if (opt.disabled) {
                        return;
                    }
                    $(this).find('.ui-rater-star-item-current').show();
                })
            }

            // 添加鼠标悬停/点击事件
            $container.find('.ui-rater-star-item').mouseover(function () {
                if (opt.disabled) {
                    return;
                }
                $(this).attr('class', 'ui-rater-star-item-hover');
            }).mouseout(function () {
                if (opt.disabled) {
                    return;
                }
                $(this).attr('class', 'ui-rater-star-item');
            }).click(
                function () {
                    if (opt.disabled) {
                        return;
                    }
                    var $this = $(this);
                    $this.prevAll('.ui-rater-star-item-current').css('width', $this.width());

                    var star_count = (opt.max - opt.min) + opt.step;
                    var current_number = $this.prevAll('.ui-rater-star-item').size() + 1;
                    var current_value = opt.min + (current_number - 1) * opt.step;
                    $el.data('ui-value', current_value);
                    var data = {
                        value: current_value,
                        number: current_number,
                        count: star_count,
                        min: opt.min,
                        max: opt.max
                    };

                    // 处理回调事件
                    self._trigger('afterClick', null, data);
                });// end click

        },

        /**
         *@method 启用
         */
        enable: function () {
            this.options.disabled = false;
        },
        /**
         * @method 禁用
         */
        disable: function () {
            this.options.disabled = true;
        },
        /**
         * @method 取/赋值
         * @param value
         * @returns {*}
         */
        value: function (value) {
            var self = this, $el = self.element, opt = this.options;
            var $container = self.element.find('.ui-rater-star');
            if (value == null) {
                //如果直接取ui-rater-star-item-current会有误差
                return $el.data('ui-value');
            }
            $el.data('ui-value', value);
            $container.find('.ui-rater-star-item-current').css('width', ((value - opt.min) / opt.step + 1) * opt.step * opt.width);
        },

        _destroy: function () {
            this.element.find('.ui-rater-star').off();
            this.element.find('.ui-rater-star-item').off();
            this.element.empty();
        }

    });
});
/**
 * @class  fish.desktop.widget.Resize
 * 统一resize事件
 */
! function(factory) {
    if (typeof define === "function" && define.amd) {
        define('fish.resize', factory);
    } else {
        factory();
    }
}(function() {

    "use strict";

    var $event = $.event,
        $debouncedresize,
        resizeTimeout;

    // in jquery.debouncedresize.js,
    // it defines the interval used to determine if two resize events are part of the same debouncedresize event.
    // Defaults to 150 (milliseconds)
    /**
     * 绑定window的resize事件,在resize结束之后(默认150毫秒)触发,一般只触发一次
     * @event debouncedresize
     * <pre>
     * $(window).on("debouncedresize", function () {
     *   //todo
     * });
     * </pre>
     */
    $debouncedresize = $event.special.debouncedresize = {
        setup: function() {
            $(this).on("resize", $debouncedresize.handler);
        },
        teardown: function() {
            $(this).off("resize", $debouncedresize.handler);
        },
        handler: function(event, execAsap) {
            // Save the context
            var context = this,
                args = arguments,
                dispatch = function() {
                    // set correct event type
                    event.type = "debouncedresize";
                    $event.dispatch.apply(context, args);
                };

            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }

            execAsap ?
                dispatch() :
                resizeTimeout = setTimeout(dispatch, $debouncedresize.threshold);
        },
        threshold: 150
    };

    /**
     * 绑定window的resize事件,在resize的过程中触发
     * @event throttledresize
     * <pre>
     * $(window).on("throttledresize", function () {
     *   //todo
     * });
     * </pre>
     */
    var $throttledresize,
        dummy = {
            _: 0
        },
        frame = 0,
        wasResized, animRunning;

    // in jquery.throttledresize.js,
    // it defines the number of animation ticks (or frames) between each throttledresize event.
    // Defaults to 0 (tick), which means that it's going to fire at a maximum of 60fps.

    $throttledresize = $event.special.throttledresize = {
        setup: function() {
            $(this).on("resize", $throttledresize.handler);
        },
        teardown: function() {
            $(this).off("resize", $throttledresize.handler);
        },
        handler: function(event, execAsap) {
            // Save the context
            var context = this,
                args = arguments;

            wasResized = true;

            if (!animRunning) {
                setInterval(function() {
                    frame++;

                    if (frame > $throttledresize.threshold && wasResized || execAsap) {
                        // set correct event type
                        event.type = "throttledresize";
                        $event.dispatch.apply(context, args);
                        wasResized = false;
                        frame = 0;
                    }
                    if (frame > 9) {
                        $(dummy).stop();
                        animRunning = false;
                        frame = 0;
                    }
                }, 30);
                animRunning = true;
            }
        },
        threshold: 0
    };

});

/**
 *	@class fish.desktop.util.Router
 * 路由组件,用于定义router，options对象的routes属性用于定义路由规则，把url映射到对应函数，当URL匹配到某个路由规则的时候，触发相应的回调函数
 */
! function(factory) {
    if (typeof define === "function" && define.amd) {
        define('fish.router', factory);
    } else {
        factory();
    }
}(function() {
    var _ = fish.util;
    // 定义router，options对象的routes属性用于定义路由规则，把url映射到对应函数，当
    // URL匹配到某个路由规则的时候，触发相应的回调函数
    var Router = fish.Router = function(options) {
        options || (options = {});
        if (options.routes) {
            this.routes = options.routes;
        }
        this._bindRoutes();
        this.initialize.apply(this, arguments);
    };

    //用于匹配route的url规则的正则
    var optionalParam = /\((.*?)\)/g;
    var namedParam = /(\(\?)?:\w+/g;
    var splatParam = /\*\w+/g;
    var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;

    // Set up all inheritable **fish.Router** properties and methods.
    _.extend(Router.prototype, {

        // Initialize is an empty function by default. Override it with your own
        // initialization logic.
        initialize: function() {},

        /**
         * @method route
         * 手动添加一个路由规则，比如:
         *     @example
         *     this.route('search/:query/p:num', 'search', function(query, num) {
         *            ...
         *     });
         * @param {String|RegExp} route 路由的url规则
         * @param {String} [name] 路由规则名称
         * @param {Function} [callback] 回调函数,不传入的时候，会调用router[name]作为回调函数
         */
        route: function(route, name, callback) {
            if (!_.isRegExp(route)) route = this._routeToRegExp(route);
            if (_.isFunction(name)) {
                callback = name;
                name = '';
            }
            if (!callback) callback = this[name];
            var router = this;

            fish.history.route(route, function(fragment) {
                var args = router._extractParameters(route, fragment);
                if (router.execute(callback, args, name) !== false) {

                    /*router.trigger.apply(router, ['route:' + name].concat(args));
						router.trigger('route', name, args);
						fish.history.trigger('route', router, name, args);*/
                }
            });
            return this;
        },

        //使用提供的参数执行路由规则的处理函数
        //覆盖这个函数，可以在调用路由规则的处理函数之前或者之后做一些操作，比如
        /*var MyRouter = fish.Router.extend({
			  execute: function(callback, args) {
			    args.push(parseQueryString(args.pop()));
			    if (callback) callback.apply(this, args);
			  }
			});*/
        execute: function(callback, args, name) {
            if (callback) callback.apply(this, args);
        },

        // Simple proxy to `Backbone.history` to save a fragment into the history.
        navigate: function(fragment, options) {
            fish.history.navigate(fragment, options);
            return this;
        },

        //把所有定义的路由规则绑定到fish.history。我们需要翻转路由规则的排列顺序,
        //保证一般化的规则时定义在路由规则表的底部（匹配程度高的规则放在前面）
        _bindRoutes: function() {
            if (!this.routes) return;
            this.routes = _.result(this, 'routes');
            var route, routes = _.keys(this.routes);
            while ((route = routes.pop()) != null) {
                this.route(route, this.routes[route]);
            }
        },

        //把route规则的字符串转换成正则
        _routeToRegExp: function(route) {
            route = route.replace(escapeRegExp, '\\$&')
                .replace(optionalParam, '(?:$1)?')
                .replace(namedParam, function(match, optional) {
                    return optional ? match : '([^/?]+)';
                })
                .replace(splatParam, '([^?]*?)');
            return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
        },

        //根据给定的路由规则正则，匹配URL片段，返回解析出的参数数组
        //空参数或者没有匹配到的参数，返回null
        _extractParameters: function(route, fragment) {
            var params = route.exec(fragment).slice(1);
            return _.map(params, function(param, i) {
                // Don't decode the search params.
                if (i === params.length - 1) {
                    return param || null
                }

                return param ? decodeURIComponent(param) : null;
            });
        }
    });

    /**
     * @class  fish.desktop.widget.History
     * fish的history管理类，使用pushState或者onhashchange，如果浏览器不支持前两者（比如老版本的IE）,则回退到检测url变化的方案
     * fish.history是一个实例化的History，不需要再去实例化History
     */
    //pushState 可以参看http://diveintohtml5.info/history.html
    //onhashChange 可以参看(https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange
    var History = fish.History = function() {
        this.handlers = [];
        _.bindAll(this, 'checkUrl');

        // Ensure that `History` can be used outside of the browser.
        if (typeof window !== 'undefined') {
            this.location = window.location;
            this.history = window.history;
        }
    };

    //匹配开头的#或者斜线，以及结尾的空格
    var routeStripper = /^[#\/]|\s+$/g;

    //匹配开头或者结尾的一个或者多个斜线
    var rootStripper = /^\/+|\/+$/g;

    //匹配hash(#及后面的内容)
    var pathStripper = /#.*$/;

    //标志History是否已经启动过了
    History.started = false;

    _.extend(History.prototype, {

        //循环检测hash发生变化的时间间隔（浏览器不支持pushstate和onhashchange的时候使用）
        //默认是50毫秒检查一次
        interval: 50,

        /**
         * @method atRoot
         * @return {Boolean} 判断当前路径是否在app的根部
         * @private
         */
        atRoot: function() {
            //如果pathname不是以/结尾，则在后面加一个/，否则不做处理，
            //然后把得到的字符串与root比较(root的默认值是/，用户可以自定义，自定义的时候就需要以/结尾)
            var path = this.location.pathname.replace(/[^\/]$/, '$&/');
            return path === this.root && !this.location.search;
        },

        /**
         * @method getHash
         * 得到hash的值，返回的字符串中不包含#
         * @return {String} 当前的hash值
         * @private
         */
        //没有直接使用location.hash是因为在Firefox中location.hash是解码(decodeed)过的
        getHash: function(window) {
            var match = (window || this).location.href.match(/#(.*)$/);
            //正则中没有使用g，则匹配返回的数组第一个元素是匹配文本，后面才是正则子表达式匹配的文本
            return match ? match[1] : '';
        },
        /**
         * @method getPath
         * 返回pathname和search，并且要把root从中剔除,返回的字符串中不包含斜杠(/)
         * @return {String} 当前的path
         * @private
         */
        getPath: function() {
            var path = decodeURI(this.location.pathname + this.location.search);
            var root = this.root.slice(0, -1); //去掉最后一个字符
            if (!path.indexOf(root)) path = path.slice(root.length); //如果path是以root开头，则截掉root部分
            return path.slice(1); //去掉最前面的斜杠(/)
        },

        /**
         * @method getFragment
         * 从path或者hash中返回url片段
         * @param {String} [fragment] 传入的path或者hash，如果没有传入则取当前的path或者hash
         * @return {String} url片段
         * @private
         */
        getFragment: function(fragment) {
            if (fragment == null) {
                if (this._hasPushState || !this._wantsHashChange) {
                    fragment = this.getPath();
                } else {
                    fragment = this.getHash();
                }
            }
            return fragment.replace(routeStripper, '');
        },

        /**
         * @method start
         * 启动hash改变的事件处理，如果当前url符合某个存在的路由规则，返回true；否则返回false
         * fish.history已经是一个默认的History对象，可以直接调用fish.history.start();
         * @return {Boolean}
         */
        start: function(options) {
            if (History.started) throw new Error('Backbone.history has already been started');
            History.started = true;

            //初始化配置项
            this.options = _.extend({
                root: '/'
            }, this.options, options);
            this.root = this.options.root;
            this._wantsHashChange = this.options.hashChange !== false; //默认使用onhashchange
            this._hasHashChange = 'onhashchange' in window;
            this._wantsPushState = !!this.options.pushState;
            this._hasPushState = !!(this.options.pushState && this.history && this.history.pushState);
            this.fragment = this.getFragment();

            // Add a cross-platform `addEventListener` shim for older browsers.
            var addEventListener = window.addEventListener || function(eventName, listener) {
                return attachEvent('on' + eventName, listener);
            };

            //保证root的开头和结尾都有一个(并且仅有一个)斜杠
            this.root = ('/' + this.root + '/').replace(rootStripper, '/');

            //创建一个iframe，支持如下情况
            //这里有个问题，如果用户指定不适用hashchange又不使用pushstate，似乎有个漏洞，但是这样设置是没有意义的
            if (!this._hasHashChange && this._wantsHashChange && (!this._wantsPushState || !this._hasPushState)) {
                var iframe = document.createElement('iframe');
                iframe.src = 'javascript:0';
                iframe.style.display = 'none';
                iframe.tabIndex = -1;
                var body = document.body;
                // Using `appendChild` will throw on IE < 9 if the document is not ready.
                this.iframe = body.insertBefore(iframe, body.firstChild).contentWindow;
                this.navigate(this.fragment);
            }

            //根据不同的条件，使用不同的事件监听url的变化
            if (this._hasPushState) {
                addEventListener('popstate', this.checkUrl, false);
            } else if (this._wantsHashChange && this._hasHashChange && !this.iframe) {
                addEventListener('hashchange', this.checkUrl, false);
            } else if (this._wantsHashChange) {
                this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
            }

            // Transition from hashChange to pushState or vice versa if both are
            // requested.
            // 这里有点奇怪，还没有看懂
            if (this._wantsHashChange && this._wantsPushState) {
                // If we've started off with a route from a `pushState`-enabled
                // browser, but we're currently in a browser that doesn't support it...
                if (!this._hasPushState && !this.atRoot()) {
                    this.location.replace(this.root + '#' + this.getPath());
                    // Return immediately as browser will do redirect to new url
                    return true;

                    // Or if we've started out with a hash-based route, but we're currently
                    // in a browser where it could be `pushState`-based instead...
                } else if (this._hasPushState && this.atRoot()) {
                    this.navigate(this.getHash(), {
                        replace: true
                    });
                }
            }


            if (!this.options.silent) return this.loadUrl();
        },

        /**
         * @method stop
         * 在真正的app中不会用到，在对于Router的单元测试中可能会有用
         * fish.history已经是一个默认的History对象，可以直接调用fish.history.start();
         */
        stop: function() {
            // Add a cross-platform `removeEventListener` shim for older browsers.
            var removeEventListener = window.removeEventListener || function(eventName, listener) {
                return detachEvent('on' + eventName, listener);
            };

            // 移除事件的监听 
            if (this._hasPushState) {
                removeEventListener('popstate', this.checkUrl, false);
            } else if (this._wantsHashChange && this._hasHashChange && !this.iframe) {
                removeEventListener('hashchange', this.checkUrl, false);
            }

            // 如果有iframe，移除iframe
            if (this.iframe) {
                document.body.removeChild(this.iframe.frameElement);
                this.iframe = null;
            }

            // Some environments will throw when clearing an undefined interval.
            if (this._checkUrlInterval) clearInterval(this._checkUrlInterval);
            History.started = false;
        },

        /**
         * @method route
         * 手工增加一条路由规则
         * @param {String} route 路由规则
         * @param {Function} callback 回调函数
         * @private
         */
        route: function(route, callback) {
            this.handlers.unshift({
                route: route,
                callback: callback
            });
        },

        //检查URL是否发生变化，如果变化了调用loadURl
        checkUrl: function(e) {
            var current = this.getFragment();
            if (current === this.fragment && this.iframe) {
                current = this.getHash(this.iframe);
            }
            if (current === this.fragment) return false;
            if (this.iframe) this.navigate(current);
            this.loadUrl();
        },

        //加载当前的URL片段，如果能够成功匹配一个路由规则，则执行执行回调函数，返回true
        //如果在定义的路由规则中没有匹配到则，返回false
        loadUrl: function(fragment) {
            fragment = this.fragment = this.getFragment(fragment);
            return _.any(this.handlers, function(handler) {
                if (handler.route.test(fragment)) {
                    handler.callback(fragment);
                    return true;
                }
            });
        },

        //在history增加一条记录，如果replace参数设置为true，则换掉history当前的记录
        //调用这个方法的时候，用户需要自己对传入的url片段做URL-ecncoding的处理
        //
        //options对象可以包含'trigger:true'，表示触发路由规则中设置的回调函数(默认不触发)
        //也可以包含'replace:true',表示你想修改当前的URL的history记录，而不是新增一条history记录
        //options直接传入true，表示'trigger:true'
        navigate: function(fragment, options) {
            if (!History.started) return false;
            if (!options || options === true) options = {
                trigger: !!options
            };

            var url = this.root + (fragment = this.getFragment(fragment || ''));

            // Strip the hash and decode for matching.
            fragment = decodeURI(fragment.replace(pathStripper, ''));

            if (this.fragment === fragment) return;
            this.fragment = fragment;

            // Don't include a trailing slash on the root.
            if (fragment === '' && url !== '/') url = url.slice(0, -1);

            // If pushState is available, we use it to set the fragment as a real URL.
            // pushState如果是支持的，使用pushState增加一条记录
            if (this._hasPushState) {
                this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

                //如果是使用hashchange，则使用hash值更新history
            } else if (this._wantsHashChange) {
                this._updateHash(this.location, fragment, options.replace);
                if (this.iframe && (fragment !== this.getHash(this.iframe))) {
                    // Opening and closing the iframe tricks IE7 and earlier to push a
                    // history entry on hash-tag change.  When replace is true, we don't
                    // want this.
                    if (!options.replace) this.iframe.document.open().close();
                    this._updateHash(this.iframe.location, fragment, options.replace);
                }

                //既不支持pushstate，又说明不使用hashchange，则退化为页面刷新
            } else {
                return this.location.assign(url);
            }
            if (options.trigger) return this.loadUrl(fragment);
        },

        // 更新hash，根据replace的值，修改当前history的hash或者新增一条history的值
        _updateHash: function(location, fragment, replace) {
            if (replace) {
                var href = location.href.replace(/(javascript:|#).*$/, '');
                location.replace(href + '#' + fragment);
            } else {
                // Some browsers require that `hash` contains a leading #.
                location.hash = '#' + fragment;
            }
        }

    });

    // Create the default Backbone.history.
    fish.history = new History;

    // Helper function to correctly set up the prototype chain, for subclasses.
    // Similar to `goog.inherits`, but uses a hash of prototype properties and
    // class properties to be extended.
    var extend = function(protoProps, staticProps) {
        var parent = this;
        var child;

        // The constructor function for the new subclass is either defined by you
        // (the "constructor" property in your `extend` definition), or defaulted
        // by us to simply call the parent's constructor.
        if (protoProps && _.has(protoProps, 'constructor')) {
            child = protoProps.constructor;
        } else {
            child = function() {
                return parent.apply(this, arguments);
            };
        }

        // Add static properties to the constructor function, if supplied.
        _.extend(child, parent, staticProps);

        // Set the prototype chain to inherit from `parent`, without calling
        // `parent`'s constructor function.
        var Surrogate = function() {
            this.constructor = child;
        };
        Surrogate.prototype = parent.prototype;
        child.prototype = new Surrogate;

        // Add prototype properties (instance properties) to the subclass,
        // if supplied.
        if (protoProps) _.extend(child.prototype, protoProps);

        // Set a convenience property in case the parent's prototype is needed
        // later.
        child.__super__ = parent.prototype;

        return child;
    };

    // Set up inheritance for the router and history.
    Router.extend = History.extend = extend;
    // } (window.jQuery);
});

/* ========================================================================
 * Bootstrap: scrollspy.js v3.2.0
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

/**
 * 滚动监听
 * @class fish.desktop.widget.ScrollSpy
 * <pre>
    //初始化控件
    $(element).scrollspy(option);
    //调用控件上的方法
    $(element).scrollspy(method);
 * </pre>
 */
! function(factory) {
    if (typeof define === "function" && define.amd) {
        define('fish.scrollspy', factory);
    } else {
        factory();
    }
}(function() {

    'use strict';
    /**
     * ScrollSpy Widget
     * @class fish.desktop.widget.ScrollSpy
     * <pre>
     *   $(element).scrollspy(option);
     *   或者
     *   $('body').scrollspy({target: element})
     * </pre>
     */

    $.widget("ui.scrollspy", {
        options: {
            /**
             * Pixels to offset from top when calculating position of scroll.
             * @cfg {Number} offset=10
             */
            offset: 10
        },
        _create: function() {
            this.$body = $('body');
            var element = this.element;
            this.$scrollElement = $(element).is('body') ? $(window) : $(element);
            this.selector = (this.options.target || '') + ' .nav li > a';
            this.offsets = [];
            this.targets = [];
            this.activeTarget = null;
            this.scrollHeight = 0;
            this.$scrollElement.on('scroll', $.proxy(this._process, this));
            this.refresh();
            this._process();
        },
        _getScrollHeight: function() {
            return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
        },
        /**
         * 刷新滚动监听控件,一般用于手动更改dom结构后调用
         * @method refresh
         */
        refresh: function() {
            var offsetMethod = 'offset'
            var offsetBase = 0

            if (!$.isWindow(this.$scrollElement[0])) {
                offsetMethod = 'position'
                offsetBase = this.$scrollElement.scrollTop()
            }

            this.offsets = []
            this.targets = []
            this.scrollHeight = this._getScrollHeight()

            var self = this

            this.$body.find(this.selector)
                .map(function() {
                    var $el = $(this)
                    var href = $el.data('target') || $el.attr('href')
                    var $href = /^#./.test(href) && $(href)

                    return ($href && $href.length && $href.is(':visible') && [
                        [$href[offsetMethod]().top + offsetBase, href]
                    ]) || null
                })
                .sort(function(a, b) {
                    return a[0] - b[0]
                })
                .each(function() {
                    self.offsets.push(this[0])
                    self.targets.push(this[1])
                })
        },
        _process: function() {
            var scrollTop = this.$scrollElement.scrollTop() + this.options.offset
            var scrollHeight = this._getScrollHeight()
            var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height()
            var offsets = this.offsets
            var targets = this.targets
            var activeTarget = this.activeTarget
            var i

            if (this.scrollHeight != scrollHeight) {
                this.refresh()
            }

            if (scrollTop >= maxScroll) {
                return activeTarget != (i = targets[targets.length - 1]) && this._activate(i)
            }

            if (activeTarget && scrollTop <= offsets[0]) {
                return activeTarget != (i = targets[0]) && this._activate(i)
            }

            for (i = offsets.length; i--;) {
                activeTarget != targets[i] && scrollTop >= offsets[i] && (!offsets[i + 1] || scrollTop <= offsets[i + 1]) && this._activate(targets[i])
            }
        },
        _activate: function(target) {
                this.activeTarget = target

                $(this.selector)
                    .parentsUntil(this.options.target, '.active')
                    .removeClass('active')

                var selector = this.selector +
                    '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]'

                var active = $(selector)
                    .parents('li')
                    .addClass('active')

                if (active.parent('.dropdown-menu').length) {
                    active = active.closest('li.dropdown')
                        .addClass('active')
                }

                this._trigger('activate', null, {
                    item: active
                });
            }
            /**
             * @event activate
             * 滚动到目标元素触发的事件,事件回调有参数item可以取到目标元素
             */
    })
});

/**
 * Slider
 * @class  fish.desktop.widget.Slider
 * @extends fish.desktop.widget
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.mouse.js
 *  jquery.ui.widget.js
 */
! function(factory) {
    if (typeof define === "function" && define.amd) {
        define('fish.slider', factory);
    } else {
        factory();
    }
}(function() {
    'use strict';
    // number of pages in a slider
    // (how many times can you page up/down to go through the whole range)
    var numPages = 5;

    $.widget("ui.slider", $.ui.mouse, {
        widgetEventPrefix: "slide",

        /** @cfg {Boolean/String/Number} animate 滑动滑块时的动画速度,false:无动画特效
         */
        /** @cfg {Number} min 设置滑块最小值
         */
        /** @cfg {Number} max 设置滑块最大值
         */
        /** @cfg {String} orientation 设置水平滑动还是垂直滑动  horizontal/vertical
         */
        /** @cfg {Boolean/String} range 设置两个滑块的区域
         */
        /** @cfg {Number} step 设置每滑动一块的步长
         */
        /** @cfg {Number} value 设置初始滑块数值
         */
        /** @cfg {Number} values 设置两个滑块初始值
         */
        options: {
            sliderClass: '', //自定义样式
            animate: false,
            distance: 0,
            max: 100,
            min: 0,
            orientation: "horizontal",
            range: false,
            step: 1,
            ticks: false, //是否显示刻度
            value: 0,
            values: null,
            // callbacks
            /**
             * 滑块值改变触发的事件
             * @event change
             */
            change: null, //改变事件
            /**
             * 滑块滑动时触发的事件,返回false的话,滑动操作不生效
             * @event slide
             */
            slide: null, //滑动事件
            /**
             * 滑块开始滑动时触发的事件
             * @event start
             */
            start: null,
            /**
             * 滑块滑动停止后触发的事件
             * @event stop
             */
            stop: null
        },

        _create: function() {

            this._keySliding = false;
            this._mouseSliding = false;
            this._animateOff = true;
            this._handleIndex = null;
            this._detectOrientation();
            this._mouseInit();

            var classes = "ui-slider ui-slider-" + this.orientation;
            classes += ' ' + this.options.sliderClass;
            this.element.addClass(classes);

            this._refresh();
            this._setOption("disabled", this.options.disabled);

            this._animateOff = false;
        },

        _refresh: function() {
            this._createRange();
            this._createHandles();
            this._createTicks();
            this._setupEvents();
            this._refreshValue();
        },

        _createHandles: function() {

            var i, handleCount,
                options = this.options,
                existingHandles = this.element.find(".ui-slider-handle"), //.addClass("ui-state-default ui-corner-all"),
                handle = "<a class='ui-slider-handle' href='#'></a>",
                handles = [];

            handleCount = (options.values && options.values.length) || 1;

            if (existingHandles.length > handleCount) {
                existingHandles.slice(handleCount).remove();
                existingHandles = existingHandles.slice(0, handleCount);
            }

            for (i = existingHandles.length; i < handleCount; i++) {
                handles.push(handle);
            }

            this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));

            this.handle = this.handles.eq(0);

            this.handles.each(function(i) {
                $(this).data("ui-slider-handle-index", i);
            });
        },

        _createRange: function() {

            var options = this.options,
                classes = "";

            if (options.range) {
                if (options.range === true) {
                    if (!options.values) {
                        options.values = [this._valueMin(), this._valueMin()];
                    } else if (options.values.length && options.values.length !== 2) {
                        options.values = [options.values[0], options.values[0]];
                    } else if ($.isArray(options.values)) {
                        options.values = options.values.slice(0);
                    }
                }

                if (!this.range || !this.range.length) {
                    this.range = $("<div></div>").appendTo(this.element);

                    classes = "ui-slider-range"; // +
                    // note: this isn't the most fittingly semantic framework class for this element,
                    // but worked best visually with a variety of themes
                    // " ui-widget-header ui-corner-all";
                } else {
                    this.range.removeClass("ui-slider-range-min ui-slider-range-max")
                        // Handle range switching from true to min/max
                        .css({
                            "left": "",
                            "bottom": ""
                        });
                }

                this.range.addClass(classes + ((options.range === "min" || options.range === "max") ? " ui-slider-range-" + options.range : ""));
            } else {
                if (this.range) {
                    this.range.remove();
                }
                this.range = null;
            }
        },

        _createTicks: function() {

            //如果步长小于5则不能使用
            if (!this.options.ticks || this.options.step < 5) {
                return;
            }

            this.element.find('.ui-slider-tick').remove();

            var maxValue = this.options.max,
                minValue = this.options.min,
                start = this.options.min + this.options.step,
                background = this.element.css("border-color"),
                varPercent,
                prop = this.orientation === 'horizontal' ? 'left' : 'bottom';

            while (start < maxValue) {
                varPercent = ((start - minValue) / (maxValue - minValue) * 100) + "%";
                var cssObj = {
                    background: background
                };
                cssObj[prop] = varPercent;
                $("<div/>").addClass("ui-slider-tick " + this.orientation).appendTo(this.element).css(cssObj);

                start += this.options.step;
            }
        },

        _setupEvents: function() {

            var elements = this.handles.add(this.range).filter("a");
            this._off(elements);
            this._on(elements, this._handleEvents);
            this._hoverable(elements); //widget.js
            this._focusable(elements); //widget.js
        },

        _destroy: function() {
            this.handles.remove();
            if (this.range) {
                this.range.remove();
            }

            if (this.options.ticks) {
                this.element.find('.ui-slider-tick').remove();
            }

            this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical"); // ui-widget ui-widget-content ui-corner-all

            this._mouseDestroy();
        },

        _mouseCapture: function(event) {

            var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
                that = this,
                o = this.options;

            if (o.disabled) {
                return false;
            }

            this.elementSize = {
                width: this.element.outerWidth(),
                height: this.element.outerHeight()
            };
            this.elementOffset = this.element.offset();

            position = {
                x: event.pageX,
                y: event.pageY
            };
            normValue = this._normValueFromMouse(position);
            distance = this._valueMax() - this._valueMin() + 1;
            this.handles.each(function(i) {
                var thisDistance = Math.abs(normValue - that.values(i));
                if ((distance > thisDistance) || (distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min))) {
                    distance = thisDistance;
                    closestHandle = $(this);
                    index = i;
                }
            });

            allowed = this._start(event, index);
            if (allowed === false) {
                return false;
            }
            this._mouseSliding = true;

            this._handleIndex = index;

            closestHandle.addClass("ui-state-active").focus();

            offset = closestHandle.offset();
            mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
            this._clickOffset = mouseOverHandle ? {
                left: 0,
                top: 0
            } : {
                left: event.pageX - offset.left - (closestHandle.width() / 2),
                top: event.pageY - offset.top - (closestHandle.height() / 2) - (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) - (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) + (parseInt(closestHandle.css("marginTop"), 10) || 0)
            };

            if (!this.handles.hasClass("ui-state-hover")) {
                this._slide(event, index, normValue);
            }
            this._animateOff = true;
            return true;
        },

        _mouseStart: function() {
            return true;
        },

        _mouseDrag: function(event) {
            var position = {
                    x: event.pageX,
                    y: event.pageY
                },
                normValue = this._normValueFromMouse(position);

            this._slide(event, this._handleIndex, normValue);

            return false;
        },

        _mouseStop: function(event) {
            this.handles.removeClass("ui-state-active");
            this._mouseSliding = false;

            this._stop(event, this._handleIndex);
            this._change(event, this._handleIndex);

            this._handleIndex = null;
            this._clickOffset = null;
            this._animateOff = false;

            return false;
        },

        _detectOrientation: function() {
            this.orientation = (this.options.orientation === "vertical") ? "vertical" : "horizontal";
        },

        _normValueFromMouse: function(position) {

            var pixelTotal,
                pixelMouse,
                percentMouse,
                valueTotal,
                valueMouse;

            if (this.orientation === "horizontal") {
                pixelTotal = this.elementSize.width;
                pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
            } else {
                pixelTotal = this.elementSize.height;
                pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
            }

            percentMouse = (pixelMouse / pixelTotal);
            if (percentMouse > 1) {
                percentMouse = 1;
            }
            if (percentMouse < 0) {
                percentMouse = 0;
            }
            if (this.orientation === "vertical") {
                percentMouse = 1 - percentMouse;
            }

            valueTotal = this._valueMax() - this._valueMin();
            valueMouse = this._valueMin() + percentMouse * valueTotal;

            return this._trimAlignValue(valueMouse);
        },

        _start: function(event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            if (this.options.values && this.options.values.length) {
                uiHash.value = this.values(index);
                uiHash.values = this.values();
            }
            return this._trigger("start", event, uiHash);
        },

        _slide: function(event, index, newVal) {
            var otherVal,
                newValues,
                allowed;

            if (this.options.values && this.options.values.length) {
                otherVal = this.values(index ? 0 : 1);

                if ((this.options.values.length === 2 && this.options.range === true) && ((index === 0 && newVal > otherVal) || (index === 1 && newVal < otherVal))) {
                    newVal = otherVal;
                }

                if (newVal !== this.values(index)) {
                    newValues = this.values();
                    newValues[index] = newVal;
                    // A slide can be canceled by returning false from the slide callback
                    allowed = this._trigger("slide", event, {
                        handle: this.handles[index],
                        value: newVal,
                        values: newValues
                    });
                    otherVal = this.values(index ? 0 : 1);
                    if (allowed !== false) {
                        this.values(index, newVal);
                    }
                }
            } else {
                if (newVal !== this.value()) {
                    // A slide can be canceled by returning false from the slide callback
                    allowed = this._trigger("slide", event, {
                        handle: this.handles[index],
                        value: newVal
                    });
                    if (allowed !== false) {
                        this.value(newVal);
                    }
                }
            }
        },

        _stop: function(event, index) {
            var uiHash = {
                handle: this.handles[index],
                value: this.value()
            };
            if (this.options.values && this.options.values.length) {
                uiHash.value = this.values(index);
                uiHash.values = this.values();
            }

            this._trigger("stop", event, uiHash);
        },

        _change: function(event, index) {
            if (!this._keySliding && !this._mouseSliding) {
                var uiHash = {
                    handle: this.handles[index],
                    value: this.value()
                };
                if (this.options.values && this.options.values.length) {
                    uiHash.value = this.values(index);
                    uiHash.values = this.values();
                }

                //store the last changed value index for reference when handles overlap
                this._lastChangedValue = index;

                this._trigger("change", event, uiHash);
            }
        },

        /**
         * 单个滑块取值
         * @param newValue
         * @returns {*}
         */
        value: function(newValue) {
            if (arguments.length) {
                this.options.value = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, 0);
                return;
            }

            return this._value();
        },
        /**
         * 两个滑块的取值方式
         * @param index 下标索引
         * @param newValue 对应下标值
         * @returns {*}
         */
        values: function(index, newValue) {
            var vals,
                newValues,
                i;

            if (arguments.length > 1) {
                this.options.values[index] = this._trimAlignValue(newValue);
                this._refreshValue();
                this._change(null, index);
                return;
            }

            if (arguments.length) {
                if ($.isArray(arguments[0])) {
                    vals = this.options.values;
                    newValues = arguments[0];
                    for (i = 0; i < vals.length; i += 1) {
                        vals[i] = this._trimAlignValue(newValues[i]);
                        this._change(null, i);
                    }
                    this._refreshValue();
                } else {
                    if (this.options.values && this.options.values.length) {
                        return this._values(index);
                    } else {
                        return this.value();
                    }
                }
            } else {
                return this._values();
            }
        },

        _setOption: function(key, value) {
            var i,
                valsLength = 0;

            if (key === "range" && this.options.range === true) {
                if (value === "min") {
                    this.options.value = this._values(0);
                    this.options.values = null;
                } else if (value === "max") {
                    this.options.value = this._values(this.options.values.length - 1);
                    this.options.values = null;
                }
            }

            if ($.isArray(this.options.values)) {
                valsLength = this.options.values.length;
            }

            $.Widget.prototype._setOption.apply(this, arguments);

            switch (key) {
                case "orientation":
                    this._detectOrientation();
                    this.element.removeClass("ui-slider-horizontal ui-slider-vertical")
                        .addClass("ui-slider-" + this.orientation);
                    this._refreshValue();
                    this._refreshTick();
                    break;
                case "value":
                    this._animateOff = true;
                    this._refreshValue();
                    this._change(null, 0);
                    this._animateOff = false;
                    break;
                case "values":
                    this._animateOff = true;
                    this._refreshValue();
                    for (i = 0; i < valsLength; i += 1) {
                        this._change(null, i);
                    }
                    this._animateOff = false;
                    break;
                case "min":
                case "max":
                    this._animateOff = true;
                    this._refreshValue();
                    this._refreshTick();
                    this._animateOff = false;
                    break;
                case "range":
                    this._animateOff = true;
                    this._refresh();
                    this._animateOff = false;
                    break;
            }
        },

        //internal value getter
        // _value() returns value trimmed by min and max, aligned by step
        _value: function() {
            var val = this.options.value;
            val = this._trimAlignValue(val);

            return val;
        },

        //internal values getter
        // _values() returns array of values trimmed by min and max, aligned by step
        // _values( index ) returns single value trimmed by min and max, aligned by step
        _values: function(index) {
            var val,
                vals,
                i;

            if (arguments.length) {
                val = this.options.values[index];
                val = this._trimAlignValue(val);

                return val;
            } else if (this.options.values && this.options.values.length) {
                // .slice() creates a copy of the array
                // this copy gets trimmed by min and max and then returned
                vals = this.options.values.slice();
                for (i = 0; i < vals.length; i += 1) {
                    vals[i] = this._trimAlignValue(vals[i]);
                }

                return vals;
            } else {
                return [];
            }
        },

        // returns the step-aligned value that val is closest to, between (inclusive) min and max
        _trimAlignValue: function(val) {
            if (val <= this._valueMin()) {
                return this._valueMin();
            }
            if (val >= this._valueMax()) {
                return this._valueMax();
            }
            var step = (this.options.step > 0) ? this.options.step : 1,
                valModStep = (val - this._valueMin()) % step,
                alignValue = val - valModStep;

            if (Math.abs(valModStep) * 2 >= step) { //如果不小于步长的一半，则加上一个步长
                alignValue += (valModStep > 0) ? step : (-step);
            }

            // Since JavaScript has problems with large floats, round
            // the final value to 5 digits after the decimal point (see #4124)
            return parseFloat(alignValue.toFixed(5));
        },

        _valueMin: function() {
            return this.options.min;
        },

        _valueMax: function() {
            return this.options.max;
        },

        _refreshTick: function() {
            this._createTicks();
        },

        _refreshValue: function() {

            var lastValPercent, valPercent, value, valueMin, valueMax,
                oRange = this.options.range,
                o = this.options,
                that = this,
                animate = (!this._animateOff) ? o.animate : false,
                _set = {};

            if (this.options.values && this.options.values.length) {
                this.handles.each(function(i) {
                    valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
                    _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                    $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
                    if (that.options.range === true) {
                        if (that.orientation === "horizontal") {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                    left: valPercent + "%"
                                }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({
                                    width: (valPercent - lastValPercent) + "%"
                                }, {
                                    queue: false,
                                    duration: o.animate
                                });
                            }
                        } else {
                            if (i === 0) {
                                that.range.stop(1, 1)[animate ? "animate" : "css"]({
                                    bottom: (valPercent) + "%"
                                }, o.animate);
                            }
                            if (i === 1) {
                                that.range[animate ? "animate" : "css"]({
                                    height: (valPercent - lastValPercent) + "%"
                                }, {
                                    queue: false,
                                    duration: o.animate
                                });
                            }
                        }
                    }
                    lastValPercent = valPercent;
                });
            } else { //end if
                value = this.value();
                valueMin = this._valueMin();
                valueMax = this._valueMax();
                valPercent = (valueMax !== valueMin) ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;

                _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
                this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);

                if (oRange === "min" && this.orientation === "horizontal") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        width: valPercent + "%"
                    }, o.animate);
                }
                if (oRange === "max" && this.orientation === "horizontal") {
                    this.range[animate ? "animate" : "css"]({
                        width: (100 - valPercent) + "%"
                    }, {
                        queue: false,
                        duration: o.animate
                    });
                }
                if (oRange === "min" && this.orientation === "vertical") {
                    this.range.stop(1, 1)[animate ? "animate" : "css"]({
                        height: valPercent + "%"
                    }, o.animate);
                }
                if (oRange === "max" && this.orientation === "vertical") {
                    this.range[animate ? "animate" : "css"]({
                        height: (100 - valPercent) + "%"
                    }, {
                        queue: false,
                        duration: o.animate
                    });
                }
            } //end else
        },

        _handleEvents: {
            /***
             * 键盘按键
             * @param event
             */
            keydown: function(event) {
                var allowed, curVal, newVal, step,
                    index = $(event.target).data("ui-slider-handle-index");

                switch (event.keyCode) {
                    case $.ui.keyCode.HOME:
                    case $.ui.keyCode.END:
                    case $.ui.keyCode.PAGE_UP:
                    case $.ui.keyCode.PAGE_DOWN:
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        event.preventDefault();
                        if (!this._keySliding) {
                            this._keySliding = true;
                            $(event.target).addClass("ui-state-active");
                            allowed = this._start(event, index);
                            if (allowed === false) {
                                return;
                            }
                        }
                        break;
                }

                step = this.options.step;
                if (this.options.values && this.options.values.length) {
                    curVal = newVal = this.values(index);
                } else {
                    curVal = newVal = this.value();
                }

                switch (event.keyCode) {
                    case $.ui.keyCode.HOME:
                        newVal = this._valueMin();
                        break;
                    case $.ui.keyCode.END:
                        newVal = this._valueMax();
                        break;
                    case $.ui.keyCode.PAGE_UP:
                        newVal = this._trimAlignValue(curVal + ((this._valueMax() - this._valueMin()) / numPages));
                        break;
                    case $.ui.keyCode.PAGE_DOWN:
                        newVal = this._trimAlignValue(curVal - ((this._valueMax() - this._valueMin()) / numPages));
                        break;
                    case $.ui.keyCode.UP:
                    case $.ui.keyCode.RIGHT:
                        if (curVal === this._valueMax()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal + step);
                        break;
                    case $.ui.keyCode.DOWN:
                    case $.ui.keyCode.LEFT:
                        if (curVal === this._valueMin()) {
                            return;
                        }
                        newVal = this._trimAlignValue(curVal - step);
                        break;
                }

                this._slide(event, index, newVal);
            }, //end keydown

            click: function(event) {
                event.preventDefault();
            },

            keyup: function(event) {
                    var index = $(event.target).data("ui-slider-handle-index");

                    if (this._keySliding) {
                        this._keySliding = false;
                        this._stop(event, index);
                        this._change(event, index);
                        $(event.target).removeClass("ui-state-active");
                    }
                } //end keyup

        } // end _handleEvents Object

    });

});

/**
 * Spinner
 * @class  fish.desktop.widget.Spinner
 * @extends fish.desktop.widget
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.mouse.js
 *  jquery.ui.widget.js
 */

! function(factory) {
    if (typeof define === "function" && define.amd) {
        define('fish.spinner', ['jquery.mousewheel'], factory);
    } else {
        factory();
    }
}(function() {
    'use strict';

    var lastActive,
        SPIN_TEMPLATE = '<div class="input-group ui-spinner"></div>',
        BUTTON_TEMPLATE = '<span class="input-group-addon btn-group-vertical btn-group-stepper">'
            + '<button type="button" class="btn btn-stepper js-increase" tabindex="-1">'
            + '<span class="glyphicon glyphicon-triangle-top"></span>'
            + '<span class="sr-only">Increase</span>'
            + '</button>'
            + '<button type="button" class="btn btn-stepper" tabindex="-1">'
            + '<span class="glyphicon glyphicon-triangle-bottom"></span>'
            + '<span class="sr-only">Decrease</span>'
            + '</button>'
            + '</span>';

    function modifier(fn) {
        return function() {
            var previous = this.element.val();
            fn.apply(this, arguments);
            this._refresh();
            if (previous !== this.element.val()) {
                this._trigger("change");
            }
        };
    }

    $.widget("ui.spinner", {
        defaultElement: "<input>",
        /**
         * 事件的前缀,对于一般的jqueryui控件来说,默认是控件名;这里指定的事情前缀是简写spin
         * @cfg {String} widgetEventPrefix='spin'
         */
        widgetEventPrefix: "spin",
        options: {
            /**
             * @cfg {Boolean} incremental 控制当按钮持续按下时的行为,也可以是Function
             */
            incremental: true,
            /**
             * @cfg {Number} max 可选的最大数值
             */
            max: null,
            /**
             * @cfg {Number} min 可选的最小数值
             */
            min: null,
            /*
             * The number of steps to take when paging via the pageUp/pageDown methods.
             * @type {Number} page
             */
            page: 10,
            /**
             * @cfg {Number} step 每次点击上下箭头时数值变化步长
             */
            step: 1,
            /**
             * Triggered when the value of the spinner has changed and the input is no longer focused.
             * @event change
             */
            change: null,
            /**
             * Triggered during increment/decrement (to determine direction of spin compare current value with ui.value).  
             * Can be canceled, preventing the value from being updated.
             * 等事件名跟前缀名一致的时候,是不需要再加上前缀名的
             * <pre>
             *   $(this.element).on("spin",function(){});
             * </pre>
             * @event spin
             */
            spin: null,
            /**
             * Triggered before a spin. Can be canceled, preventing the spin from occurring.
             * @event start
             */
            start: null,
            /**
             * Triggered after a spin.
             * @event stop
             */
            stop: null
        },

        _create: function() {

            // handle string values that need to be parsed
            this._setOption("max", this.options.max);
            this._setOption("min", this.options.min);
            this._setOption("step", this.options.step);

            // Only format if there is a value, prevents the field from being marked
            // as invalid in Firefox, see #9573.
            if (this.value() !== "") {
                // Format the value, but don't constrain.
                this._value(this.element.val(), true);
            }

            this._draw();
            this._on(this._events);
            this._refresh();

        },

        _getCreateOptions: function() {
            var options = {},
                element = this.element;

            $.each(["min", "max", "step"], function(i, option) {
                var value = element.attr(option);
                if (value !== undefined && value.length) {
                    options[option] = value;
                }
            });

            return options;
        },
        _events: {
            keydown: function(event) {
                if (this._start(event) && this._keydown(event)) {
                    event.preventDefault();
                }
            },

            keyup: "_stop",

            focus: function() {
                this.previous = this.element.val();
                this.uiSpinner.addClass('focus');
            },

            blur: function(event) {
                this.uiSpinner.removeClass('focus');

                if (this.cancelBlur) {
                    delete this.cancelBlur;
                    return;
                }

                this._stop();
                this._refresh();
                if (this.previous !== this.element.val()) {
                    this._trigger("change", event);
                }
            },

            "mousewheel .form-control:focus": function(event, delta) { //#25
                if (!delta) {
                    return;
                }
                if (!this.spinning && !this._start(event)) {
                    return false;
                }
                this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
                clearTimeout(this.mousewheelTimer);
                this.mousewheelTimer = this._delay(function() {
                    if (this.spinning) {
                        this._stop(event);
                    }
                }, 100);
                event.preventDefault();
            },

            "mousedown .btn-stepper": function(event) {
                var previous;

                // We never want the buttons to have focus; whenever the user is
                // interacting with the spinner, the focus should be on the input.
                // If the input is focused then this.previous is properly set from
                // when the input first received focus. If the input is not focused
                // then we need to set this.previous based on the value before spinning.
                previous = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val();

                function checkFocus() {
                    var isActive = this.element[0] === this.document[0].activeElement;
                    if (!isActive) {
                        this.element.focus();
                        this.previous = previous;
                        // support: IE
                        // IE sets focus asynchronously, so we need to check if focus
                        // moved off of the input because the user clicked on the button.
                        this._delay(function() {
                            this.previous = previous;
                        });
                    }
                }

                // ensure focus is on (or stays on) the text field
                event.preventDefault();
                checkFocus.call(this);

                // support: IE
                // IE doesn't prevent moving focus even with event.preventDefault()
                // so we set a flag to know when we should ignore the blur event
                // and check (again) if focus moved off of the input.
                this.cancelBlur = true;
                this._delay(function() {
                    delete this.cancelBlur;
                    checkFocus.call(this);
                });

                if (this._start(event) === false) {
                    return;
                }

                this._repeat(null, $(event.currentTarget).hasClass("js-increase") ? 1 : -1, event);
            },

            "mouseup .btn-stepper": "_stop",

            "mouseenter .btn-stepper": function(event) {
                // button will add ui-state-active if mouse was down while mouseleave and kept down
                if (!$(event.currentTarget).hasClass("ui-state-active")) {
                    return;
                }

                if (this._start(event) === false) {
                    return false;
                }
                this._repeat(null, $(event.currentTarget).hasClass("js-increase") ? 1 : -1, event);
            },
            // TODO: do we really want to consider this a stop?
            // shouldn't we just stop the repeater and wait until mouseup before
            // we trigger the stop event?
            "mouseleave .btn-stepper": "_stop"
        },

        _draw: function() {
            var options = this.options,
                that = this;
            var uiSpinner = this.uiSpinner = this.element
                .attr("autocomplete", "off")
                .wrap(SPIN_TEMPLATE)
                .parent()
                .append(BUTTON_TEMPLATE);

            this.element.attr("role", "spinbutton");

            this.buttons = uiSpinner.find(".btn-stepper");

            // disable spinner if element was already disabled
            if (this.options.disabled) {
                this.disable();
            }
        },

        _keydown: function(event) {
            var options = this.options,
                keyCode = $.ui.keyCode;

            switch (event.keyCode) {
                case keyCode.UP:
                    this._repeat(null, 1, event);
                    return true;
                case keyCode.DOWN:
                    this._repeat(null, -1, event);
                    return true;
                case keyCode.PAGE_UP:
                    this._repeat(null, options.page, event);
                    return true;
                case keyCode.PAGE_DOWN:
                    this._repeat(null, -options.page, event);
                    return true;
            }

            return false;
        },

        _start: function(event) {
            if (!this.spinning && this._trigger("start", event) === false) {
                return false;
            }

            if (!this.counter) {
                this.counter = 1;
            }
            this.spinning = true;
            return true;
        },

        _repeat: function(i, steps, event) {
            i = i || 500;

            clearTimeout(this.timer);
            this.timer = this._delay(function() {
                this._repeat(40, steps, event);
            }, i);

            this._spin(steps * this.options.step, event);
        },

        _spin: function(step, event) {
            var value = this.value() || 0;

            if (!this.counter) {
                this.counter = 1;
            }

            value = this._adjustValue(value + step * this._increment(this.counter));

            if (!this.spinning || this._trigger("spin", event, {
                    value: value
                }) !== false) {
                this._value(value);
                this.counter++;
            }
        },

        _increment: function(i) {
            var incremental = this.options.incremental;
            if (incremental) {
                return $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1);
            }
            return 1;
        },

        _precision: function() {
            var precision = this._precisionOf(this.options.step);
            if (this.options.min !== null) {
                precision = Math.max(precision, this._precisionOf(this.options.min));
            }
            return precision;
        },

        _precisionOf: function(num) {
            var str = num.toString(),
                decimal = str.indexOf(".");
            return decimal === -1 ? 0 : str.length - decimal - 1;
        },

        _adjustValue: function(value) {
            var base, aboveMin,
                options = this.options;

            // make sure we're at a valid step
            // - find out where we are relative to the base (min or 0)
            base = options.min !== null ? options.min : 0;
            aboveMin = value - base;
            // - round to the nearest step
            aboveMin = Math.round(aboveMin / options.step) * options.step;
            // - rounding is based on 0, so adjust back to our base
            value = base + aboveMin;

            // fix precision from bad JS floating point math
            value = parseFloat(value.toFixed(this._precision()));

            // clamp the value
            if (options.max !== null && value > options.max) {
                return options.max;
            }
            if (options.min !== null && value < options.min) {
                return options.min;
            }

            return value;
        },

        _stop: function(event) {
            if (!this.spinning) {
                return;
            }

            clearTimeout(this.timer);
            clearTimeout(this.mousewheelTimer);
            this.counter = 0;
            this.spinning = false;
            this._trigger("stop", event);
        },

        _setOption: function(key, value) {
            if (key === "max" || key === "min" || key === "step") {
                if (typeof value === "string") {
                    value = this._parse(value);
                }
            }

            this._super(key, value);

            if (key === "disabled") {
                if (value) {
                    this.element.prop("disabled", true);
                    this.buttons.prop("disabled", true);
                } else {
                    this.element.prop("disabled", false);
                    this.buttons.prop("disabled", false);
                }
            }
        },

        _setOptions: modifier(function(options) {
            this._super(options);
            this._value(this.element.val());
        }),

        _parse: function(val) {
            if (typeof val === "string" && val !== "") {
                val = +val;
            }
            return val === "" || isNaN(val) ? null : val;
        },

        _refresh: function() {
            this.element.attr({
                "aria-valuemin": this.options.min,
                "aria-valuemax": this.options.max,
                // TODO: what should we do with values that can't be parsed?
                "aria-valuenow": this._parse(this.element.val())
            });
        },

        // update the value without triggering change
        _value: function(value, allowAny) {
            var parsed;
            if (value !== "") {
                parsed = this._parse(value);
                if (parsed !== null) {
                    if (!allowAny) {
                        parsed = this._adjustValue(parsed);
                    }
                }
            }
            this.element.val(parsed);
            this._refresh();
        },

        _destroy: function() {
            this.element.prop("disabled", false)
                .removeAttr("autocomplete")
                .removeAttr("role")
                .removeAttr("aria-valuemin")
                .removeAttr("aria-valuemax")
                .removeAttr("aria-valuenow");
            this.uiSpinner.replaceWith(this.element);
        },

        stepUp: modifier(function(steps) {
            this._stepUp(steps);
        }),
        _stepUp: function(steps) {
            if (this._start()) {
                this._spin((steps || 1) * this.options.step);
                this._stop();
            }
        },

        stepDown: modifier(function(steps) {
            this._stepDown(steps);
        }),
        _stepDown: function(steps) {
            if (this._start()) {
                this._spin((steps || 1) * -this.options.step);
                this._stop();
            }
        },

        pageUp: modifier(function(pages) {
            this._stepUp((pages || 1) * this.options.page);
        }),

        pageDown: modifier(function(pages) {
            this._stepDown((pages || 1) * this.options.page);
        }),

        /**
         * 取(设)值
         * @method value
         * @param newValue
         * @returns {*}
         */
        value: function(newVal) {

            if (!arguments.length) {
                return this._parse(this.element.val());
            }
            modifier(this._value).call(this, newVal);
        },

        widget: function() {
            return this.uiSpinner;
        }
    });



});

/**
 * Splitter
 * @class  fish.desktop.widget.Splitter
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.mouse.js
 *  jquery.ui.widget.js
 */

! function(factory) {
    if (typeof define === "function" && define.amd) {
        define('fish.splitter', ['fish.resize'], factory);
    } else {
        factory();
    }
}(function() {
    'use strict';

    var pxUnitsRegex = /^\d+(\.\d+)?px$/i,
        percentageUnitsRegex = /^\d+(\.\d+)?%$/i,
        NS = ".splitter";

    $.widget("ui.splitter", $.ui.mouse, {
        /**
         * 事件的前缀,对于一般的jqueryui控件来说,默认是控件名;这里指定的事情前缀是简写split
         * @cfg {String} widgetEventPrefix='split'
         */
        widgetEventPrefix: "split",

        options: {
            /**
             * @cfg {String} [orientation="horizontal"] 设置水平展开还是垂直展开  horizontal/vertical
             */
            orientation: "horizontal",
            /**
             * pane的属性集合,每一个pane一般都有属性collapsible是否能折叠、size大小
             * @cfg {Array} panes
             * <pre>
             * [{ collapsible: true, size: "290px" }]
             * </pre>
             */
            panes: [],
            /**
             * 闭合pane时触发的事件
             * @event collapse
             * @param {Object} e event对象
             * @param {Element} target 操作对象
             */
            /**
             * 展开pane时触发的事件
             * @event expand
             * @param {Object} e event对象
             * @param {Element} target 操作对象
             */
            /**
             * 拖拽pane分割线时触发的事件
             * @event resize
             * @param {Object} e event对象,e.position为分割线的最终位置(水平方向为left属性+width、垂直方向为top属性+height)
             */
            /**
             * 任意pane大小改变时触发的事件
             * @event layoutChange
             */
        },
        _create: function() {

            var isHorizontal = this.options.orientation.toLowerCase() != "vertical";
            this.orientation = isHorizontal ? "horizontal" : "vertical";
            if (isHorizontal) {
                this.sizingProperty = "width";
                this.sizingDomProperty = "outerWidth";
                this.alternateSizingProperty = "height";
                this.positioningProperty = "left";
                this.mousePositioningProperty = "pageX";
            } else {
                this.sizingProperty = "height";
                this.sizingDomProperty = "outerHeight";
                this.alternateSizingProperty = "width";
                this.positioningProperty = "top";
                this.mousePositioningProperty = "pageY";
            }
            this.id = this.element.attr("id");
            if (!this.id) {
                this.element.uniqueId();
                this.id = this.element.attr("id");
            }
            //初始化splitter中的各个面板(div)
            this._initPanes();

            this._mouseInit();

            //window变化以后，也要重新排布panel
            //由于父层resize会触发子层的resize操作,而子层控件创建时也监听了window的变化;因此window变化会导致子层触发多次,这里特殊处理一下
            $(window).on("debouncedresize." + this.id + NS, $.proxy(this._waitResize, this));
        },
        _initPanes: function() {
            var panesConfig = this.options.panes || [];
            var that = this;

            this.element.addClass("ui-splitter")
                .children("div") //目前布局只支持div;默认处理div类型的子节点
                .each(function(i, pane) {
                    // if (pane.nodeName.toLowerCase() != "script") {
                    that._initPane(pane, panesConfig[i]);
                    // }
                });

            this._waitResize(false);
        },

        _initPane: function(pane, config) {
            pane = $(pane)
                .attr("role", "group")
                .addClass("ui-pane");

            pane.data("pane", config ? config : {})
                .toggleClass("ui-scrollable", config ? config.scrollable !== false : true);

            // this.ajaxRequest(pane);
        },

        //创建延迟函数来解决子层调用多次的问题
        _waitResize: function(flag) {
            var that = this;
            if(flag === false ){
                that._resize.call(that);
            }else{
                if (!that.waitResize) {
                    that.waitResize = true;
                    that._delay(function() {
                        that._resize.call(that);
                        that.waitResize = false;
                    }, 30);
                }
            }
            //如果splitter内部嵌套有splitter，则需要触发splitter内部splitter的resize
            $(that.element).find(".ui-splitter").each(function(index, element) {
                var child = $.data(element, "ui-splitter");
                child._waitResize(false);
            });

        },

        _resize: function() {
            var that = this,
                element = that.element,
                panes = element.children(".ui-pane"),
                splitBars = element.children(".ui-splitbar"),
                splitBarsCount = splitBars.length,
                totalSize = element[that.sizingProperty]();

            if (splitBarsCount === 0) {
                splitBarsCount = panes.length - 1;
                panes.slice(0, splitBarsCount)
                    .after("<div tabindex='0' class='ui-splitbar'/>");

                that._updateSplitBars();
                splitBars = element.children(".ui-splitbar");
            } else {
                that._updateSplitBars();
            }

            //这里是要从总的宽度(高度)中减掉splitbar宽度(高度)
            //splitbar是position absolute的，也就是说totalSize中并没有包含splitBar的宽度(高度)
            //减去是为了能在排列panel的时候，准确设置panel的宽度,使splitbar不挡住panel
            splitBars.each(function() {
                totalSize -= $(this)[that.sizingDomProperty]();
            });

            var sizedPanesWidth = 0,
                sizedPanesCount = 0,
                freeSizedPanes = $();

            panes.css({
                position: "absolute",
                top: 0
            })[that.sizingProperty](function() {
                var config = $(this).data("pane") || {},
                    size;

                if (config.collapsed) {
                    size = 0;
                    $(this).css("overflow", "hidden");
                } else if (isFluid(config.size)) {
                    freeSizedPanes = freeSizedPanes.add(this);
                    return;
                } else { // sized in px/%, not collapsed
                    size = parseInt(config.size, 10);

                    if (isPercentageSize(config.size)) {
                        size = Math.floor(size * totalSize / 100);
                    }
                }

                sizedPanesCount++;
                sizedPanesWidth += size;

                return size;
            });

            totalSize -= sizedPanesWidth; //从totalSize中再减去已经确定了size的pane

            var freeSizePanesCount = freeSizedPanes.length,
                freeSizePaneWidth = Math.floor(totalSize / freeSizePanesCount);

            freeSizedPanes.slice(0, freeSizePanesCount - 1)
                .css(that.sizingProperty, freeSizePaneWidth) //平均分宽度
                .end()
                .eq(freeSizePanesCount - 1) //最后一个由总size减去之前的各个size之和
                .css(that.sizingProperty, totalSize - (freeSizePanesCount - 1) * freeSizePaneWidth);

            var sum = 0;
            if (freeSizePanesCount === 0) {
                //当所有panel的宽度(高度)都设置了，这个时候最有一个没有折叠的panel就需要把所有的宽度都
                //包含进去(因为可能存在配置里面设置的宽度和实际的宽度存在偏差)
                var lastNonCollapsedPane = panes.filter(function() {
                    return !(($(this).data("pane") || {}).collapsed);
                }).last();

                //当最后一个panel先收起来，然后拖动前一个panel的边框改变大小，再对最后一个panel进行展开的操作
                //这个时候，totalSize就会小于0(因为前一个panel在当前panel折叠的时候变大了)，此时需要对前一个panel的大小进行调整
                if (totalSize < 0 && lastNonCollapsedPane[0] == panes.last()[0]) {
                    var last2ndpanel = panes.eq(-2);
                    last2ndpanel[that.sizingProperty](totalSize + last2ndpanel[that.sizingDomProperty]());
                } else {
                    lastNonCollapsedPane[that.sizingProperty](totalSize + lastNonCollapsedPane[that.sizingDomProperty]());
                }
            }

            //这个地方的children包含splitbar
            element.children("div")
                .css(that.alternateSizingProperty, element[that.alternateSizingProperty]())
                .each(function(i, child) {
                    // if (child.tagName.toLowerCase() != "script") {
                    $(child).css(that.positioningProperty, Math.floor(sum) + "px");
                    sum += $(child)[that.sizingDomProperty]();
                    // }
                });

            that._detachEvents();
            that._attachEvents();

            that._trigger("layoutChange");
        },
        _updateSplitBars: function() {
            var that = this;
            this.element.children(".ui-splitbar").each(function() {
                var splitbar = $(this),
                    previousPane = splitbar.prev(".ui-pane").data("pane"),
                    nextPane = splitbar.next(".ui-pane").data("pane");
                that._updateSplitBar(splitbar, previousPane, nextPane);
            });
        },

        _updateSplitBar: function(splitbar, previousPane, nextPane) {
            var catIconIf = function(iconType, condition) {
                    return condition ? "<div class='ui-icon " + iconType + "' />" : "";
                },
                orientation = this.orientation,
                draggable = (previousPane.resizable !== false) && (nextPane.resizable !== false),
                prevCollapsible = previousPane.collapsible,
                prevCollapsed = previousPane.collapsed,
                nextCollapsible = nextPane.collapsible,
                nextCollapsed = nextPane.collapsed;

            splitbar.addClass("ui-splitbar ui-splitbar-" + orientation) // ui-state-default 
                .attr("role", "separator")
                .attr("aria-expanded", !(prevCollapsed || nextCollapsed))
                .removeClass("ui-splitbar-" + orientation + "-hover")
                .toggleClass("ui-splitbar-draggable-" + orientation,
                    draggable && !prevCollapsed && !nextCollapsed)
                .toggleClass("ui-splitbar-static-" + orientation, !draggable && !prevCollapsible && !nextCollapsible)
                .html(
                    catIconIf("ui-collapse-prev", prevCollapsible && !prevCollapsed && !nextCollapsed) + catIconIf("ui-expand-prev", prevCollapsible && prevCollapsed && !nextCollapsed) + catIconIf("ui-resize-handle", draggable) + catIconIf("ui-collapse-next", nextCollapsible && !nextCollapsed && !prevCollapsed) + catIconIf("ui-expand-next", nextCollapsible && nextCollapsed && !prevCollapsed));
        },
        _attachEvents: function() {
            var that = this,
                orientation = that.orientation;

            // do not use delegated events to increase performance of nested elements
            that.element.children(".ui-splitbar-draggable-" + orientation)
                .on("mousedown" + NS, function(e) {
                    e.currentTarget.focus();
                })
                .on("focus" + NS, function(e) {
                    $(e.currentTarget).addClass("ui-state-focused");
                })
                .on("blur" + NS, function(e) {
                    $(e.currentTarget).removeClass("ui-state-focused");
                })
                .on("mouseenter" + NS, function() {
                    $(this).addClass("ui-splitbar-" + orientation + "-hover");
                })
                .on("mouseleave" + NS, function() {
                    $(this).removeClass("ui-splitbar-" + orientation + "-hover");
                })
                .on("mousedown" + NS, function() {
                    that._panes().append("<div class='ui-splitter-overlay ui-overlay' />");
                })
                .on("mouseup" + NS, function() {
                    that._panes().children(".ui-splitter-overlay").remove();
                })
                .end()
                .children(".ui-splitbar")
                .on("dblclick" + NS, $.proxy(that._togglePane, that))
                .children(".ui-collapse-next, .ui-collapse-prev").on("click" + NS, that._arrowClick("collapse")).end()
                .children(".ui-expand-next, .ui-expand-prev").on("click" + NS, that._arrowClick("expand")).end()
                .end();
        },

        _detachEvents: function() {
            var that = this;

            that.element.children(".ui-splitbar-draggable-" + that.orientation).off(NS).end()
                .children(".ui-splitbar").off("dblclick" + NS)
                .children(".ui-collapse-next, .ui-collapse-prev, .ui-expand-next, .ui-expand-prev").off(NS);
        },

        // _triggerAction: function(type, pane) {
        //     this[type](pane[0]);
        //     this._trigger(type, null, pane[0]);
        // },

        _togglePane: function(e) {
            var that = this,
                target = $(e.target),
                arrow;

            if (target.closest(".ui-splitter")[0] != that.element[0]) {
                return;
            }

            arrow = target.children(".ui-icon:not(.ui-resize-handle)");

            if (arrow.length !== 1) {
                return;
            }

            if (arrow.is(".ui-collapse-prev")) {
                this["collapse"](target.prev());
            } else if (arrow.is(".ui-collapse-next")) {
                this["collapse"](target.next());
            } else if (arrow.is(".ui-expand-prev")) {
                this["expand"](target.prev());
            } else if (arrow.is(".ui-expand-next")) {
                this["expand"](target.next());
            }
        },
        /**
         * @method toggle
         * 原来的panle如果是展开的，则收起指定的panel；反之则展开panel
         * @param{selector} pane  传入一个选择器，表示要操作的panel
         * @param{boolean} triggerCallback  是否要触发回调，不传入的时候默认触发回调
         */
        toggle: function(pane, triggerCallback, expand) {
            var that = this,
                paneConfig,
                triggerType;

            pane = that.element.find(pane);
            paneConfig = pane.data("pane");

            if (!expand && !paneConfig.collapsible) {
                return;
            }

            if (arguments.length < 3) {
                expand = paneConfig.collapsed === undefined ? false : paneConfig.collapsed;
            }

            paneConfig.collapsed = !expand;
            triggerType = paneConfig.collapsed ? "collapse" : "expand";
            if (paneConfig.collapsed) {
                pane.css("overflow", "hidden");
            } else {
                pane.css("overflow", "");
            }

            that._waitResize(false);

            if (triggerCallback != false) {
                that._trigger(triggerType, null, pane[0]);
            }
        },
        /**
         * @method collapse
         * 收起指定的panel
         * @param{selector} pane  传入一个选择器，表示要操作的panel
         * @param{boolean} triggerCallback  是否要触发回调，默认触发;如果指定的panel已经是收起的，再次调用的时候，不会触发回调
         */
        collapse: function(pane, triggerCallback) {
            triggerCallback = triggerCallback === undefined ? true : triggerCallback;
            this.toggle(pane, triggerCallback, false);
        },
        /**
         * @method expand
         * 展开指定的panel
         * @param{selector} pane  传入一个选择器，表示要操作的panel
         * @param{boolean} triggerCallback  是否要触发回调，默认触发;如果指定的panel已经是收起的，再次调用的时候，不会触发回调
         */
        expand: function(pane, triggerCallback) {
            triggerCallback = triggerCallback === undefined ? true : triggerCallback;
            this.toggle(pane, triggerCallback, true);
        },
        _arrowClick: function(arrowType) {
            var that = this;

            return function(e) {
                var target = $(e.target),
                    pane;

                if (target.closest(".ui-splitter")[0] != that.element[0]) {
                    return;
                }

                if (target.is(".ui-" + arrowType + "-prev")) {
                    pane = target.parent().prev();
                } else {
                    pane = target.parent().next();
                }
                that[arrowType](pane);
            };
        },
        _panes: function() {
            return this.element.children(".ui-pane");
        },

        _mouseCapture: function(e) {
            var mouseCapture = false,
                $target = $(e.target);

            if ($(e.target).is(".ui-splitbar") || $(e.target).is(".ui-resize-handle")) {
                mouseCapture = true;
            }
            if ($target.is('.ui-splitbar-static-vertical') || $target.is('.ui-splitbar-static-horizontal')) {
                mouseCapture = false;
            }

            return mouseCapture;
        },
        _mouseStart: function(e) {
            var that = this;
            var splitbar = that.splitbar = $(e.target).is(".ui-resize-handle") ? $(e.target).parent() : $(e.target);

            //这里取的position是相对于上层元素的position，没有取相对于document的位置偏移(offset)
            that._initialElementPosition = splitbar.position()[that.positioningProperty];
            that._initialMousePosition = e[that.mousePositioningProperty];

            //创建显示拖动位置的div
            //创建拖动时候的提示框，传入的参数应该是触发鼠标start事件时候的splitbar???
            that.hint = $("<div class='ui-ghost-splitbar ui-ghost-splitbar-" + that.orientation + "' />") // ui-state-default
                .css(that.alternateSizingProperty, splitbar[that.alternateSizingProperty]());
            that.hint.css({
                    position: "absolute"
                })
                .css(that.positioningProperty, that._initialElementPosition)
                .appendTo(that.element);

            var previousPane = splitbar.prev(),
                nextPane = splitbar.next(),
                previousPaneConfig = previousPane.data("pane"),
                nextPaneConfig = nextPane.data("pane"),
                prevBoundary = parseInt(previousPane.css(that.positioningProperty), 10),
                nextBoundary = parseInt(nextPane.css(that.positioningProperty), 10) + nextPane[that.sizingDomProperty]() - splitbar[that.sizingDomProperty](),
                totalSize = parseInt(that.element[that.sizingProperty](), 10),
                toPx = function(value) {
                    var val = parseInt(value, 10);
                    return (isPixelSize(value) ? val : (totalSize * val) / 100) || 0;
                },
                prevMinSize = toPx(previousPaneConfig.min),
                prevMaxSize = toPx(previousPaneConfig.max) || nextBoundary - prevBoundary,
                nextMinSize = toPx(nextPaneConfig.min),
                nextMaxSize = toPx(nextPaneConfig.max) || nextBoundary - prevBoundary;

            that.previousPane = previousPane;
            that.nextPane = nextPane;
            that._maxPosition = Math.min(nextBoundary - nextMinSize, prevBoundary + prevMaxSize);
            that._minPosition = Math.max(prevBoundary + prevMinSize, nextBoundary - nextMaxSize);
        },

        _mouseDrag: function(e) {
            var that = this,
                maxPosition = that._maxPosition,
                minPosition = that._minPosition,

                //当前的位置=原来的位置 + 鼠标移动距离
                currentPosition = that._initialElementPosition + (e[that.mousePositioningProperty] - that._initialMousePosition),
                position;

            position = minPosition !== undefined ? Math.max(minPosition, currentPosition) : currentPosition;
            that.position = position = maxPosition !== undefined ? Math.min(maxPosition, position) : position;

            if (that.hint) {
                that.hint.toggleClass("ui-restricted-size-" + that.orientation || "", position == maxPosition || position == minPosition)
                    .css(that.positioningProperty, position);
            }

            that.resizing = true;
            that._trigger("resize", $.extend(e, {
                position: position
            }));
        },
        _mouseStop: function(e) {
            //鼠标停止拖拽，移除hint，标志位重置
            var that = this;
            if (that.hint) {
                that.hint.remove();
            }
            that.resizing = false;


            that._panes().children(".ui-splitter-overlay").remove();

            var ghostPosition = that.position,
                previousPane = that.splitbar.prev(),
                nextPane = that.splitbar.next(),
                previousPaneConfig = previousPane.data("pane"),
                nextPaneConfig = nextPane.data("pane"),
                previousPaneNewSize = ghostPosition - parseInt(previousPane.css(that.positioningProperty), 10),
                nextPaneNewSize = parseInt(nextPane.css(that.positioningProperty), 10) + nextPane[that.sizingDomProperty]() - ghostPosition - that.splitbar[that.sizingDomProperty](),
                fluidPanesCount = that.element.children(".ui-pane").filter(function() {
                    return isFluid($(this).data("pane").size);
                }).length;

            if (!isFluid(previousPaneConfig.size) || fluidPanesCount > 1) {
                if (isFluid(previousPaneConfig.size)) {
                    fluidPanesCount--;
                }

                previousPaneConfig.size = previousPaneNewSize + "px";
            }

            if (!isFluid(nextPaneConfig.size) || fluidPanesCount > 1) {
                nextPaneConfig.size = nextPaneNewSize + "px";
            }

            that._waitResize(false);
        },

        _destroy: function() {
            $(window).off("debouncedresize." + this.id + NS);
            //移除额外样式
            var $el = $(this.element);
            $el.removeClass('ui-splitter');
            $el.children('.ui-splitbar').remove();
            $el.children('.ui-pane').removeClass('ui-pane');
        }
    });

    function isPercentageSize(size) {
        return percentageUnitsRegex.test(size);
    }

    function isPixelSize(size) {
        return pxUnitsRegex.test(size) || /^\d+$/.test(size);
    }

    function isFluid(size) {
        return !isPercentageSize(size) && !isPixelSize(size);
    }
});

/**
 * 可切换状态的按钮，从Bootstrap switch 3.0.2改造而来。
 * @class fish.desktop.widget.SwitchButton
 * @extends fish.desktop.widget
 * <pre>
 //初始化控件
 $(element).switchBtn(option);
 //调用控件上的方法
 $(element).switchBtn(method);
 * </pre>
 */
! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.switchbutton', ['fish.formfield'], factory);
    } else {
        factory();
    }
}(function() {

    "use strict";

    var baseClass = "ui-switch"; //需要样式支持,此属性不允许修改

    $.widget("ui.switchbutton", {
        widgetEventPrefix: '',
        options: {
            /**
             * 默认选中
             * @cfg {Boolean} state=true
             */
            state: true,
            /**
             * 控件大小,可选large,small,mini
             * @cfg {Number} size=null
             */
            size: null,
            /**
             * 状态改变时是否有动画效果
             * @cfg {Boolean} animate=true
             */
            animate: true,
            /**
             * 是否失效
             * @cfg {Boolean} disabled=false
             */
            disabled: false,
            /**
             * 是否只读
             * @cfg {Boolean} readonly=false
             */
            readonly: false,
            /**
             * true状态的颜色
             * @cfg {String} onColor=primary
             */
            onColor: "primary",
            /**
             * false状态的颜色
             * @cfg {String} offColor=default
             */
            offColor: "default",
            /**
             * true状态的文本显示
             * @cfg {String} onText=ON
             */
            onText: "ON",
            /**
             * false状态的文本显示
             * @cfg {String} offText=OFF
             */
            offText: "OFF",
            /**
             * 空白文本显示
             * @cfg {String} labelText=""
             */
            labelText: "&nbsp;",
            /**
             * 自定义样式
             * @cfg {String} customClass
             */
            customClass: '',
            /**
             * @cfg {Boolean} radioAllOff
             */
            radioAllOff: false,
            /**
             * 状态改变时触发的事件
             * @event change
             * @param {Object} e event对象
             * @param {boolean} state 是不是选中状态
             */
            change: $.noop,
        },
        /*
         * 采用html的data属性,覆盖默认值;优先级仅次于初始化控件的options属性
         */
        _getCreateOptions: function() {
            this.$element = this.element;
            return {
                state: this.$element.is(":checked"),
                size: this.$element.data("size"),
                animate: this.$element.data("animate"),
                disabled: this.$element.is(":disabled"),
                readonly: this.$element.is("[readonly]"),
                onColor: this.$element.data("on-color"),
                offColor: this.$element.data("off-color"),
                onText: this.$element.data("on-text"),
                offText: this.$element.data("off-text"),
                labelText: this.$element.data("label-text"),
                customClass: this.$element.data('custom-class'),
                radioAllOff: this.$element.data("radio-all-off")
            };
        },
        _create: function() {
            //最外层容器（第一层）
            this.$wrapper = $("<div>", {
                "class": (function(_this) { //采用自执行函数计算出wrapper需要的class
                    return function() {
                        var classes = [baseClass];
                        classes.push(baseClass + (_this.options.state ? "-on" : "-off"));
                        _this.options.size ? classes.push(baseClass + "-" + _this.options.size) : "";
                        _this.options.animate ? classes.push(baseClass + "-animate") : "";
                        _this.options.disabled ? classes.push(baseClass + "-disabled") : "";
                        _this.options.readonly ? classes.push(baseClass + "-readonly") : "";
                        classes.push(_this.options.customClass);
                        return classes.join(" ");
                    };
                })(this)()
            });

            //内部容器（第二层）
            this.$container = $("<div>", {
                "class": baseClass + "-container"
            });

            //三种状态
            this.$on = $("<span>", {
                html: this.options.onText,
                "class": baseClass + "-handle-on " + baseClass + "-" + this.options.onColor
            });
            this.$off = $("<span>", {
                html: this.options.offText,
                "class": baseClass + "-handle-off " + baseClass + "-" + this.options.offColor
            });
            this.$label = $("<label>", {
                html: this.options.labelText,
                "class": baseClass + "-label"
            });

            this.$container = this.$element.wrap(this.$container).parent(); //wrap: 用... 包裹住
            this.$wrapper = this.$container.wrap(this.$wrapper).parent();
            this.$element.before(this.$on).before(this.$label).before(this.$off); // ON &nbsp; OFF
            this._elementHandlers();
            this._handleHandlers();
            this._labelHandlers();
        },
        _formHandler:function($form){//增加对form的支持
            var that=this;
            $form.on('reset.form', function(e){
                setTimeout(function(){//先执行form默认的reset行为
                    that._update();
                },0)
            }).on('clear.form', function(e){
                that._update();
            }).on('setvalue'+this.uuid+'.form', function(e,value){
                that._update();
            }).on('disable.form', function(e){
                that.disable();
            }).on('enable.form', function(e){
                that.enable();
            });
        },
        //属性取值设值全部通过父类option方法
        _setOption: function(key, value) {
            this["_" + key](value);
            this._super(key, value);
        },
        _update:function(){
            var state = this.$element.is(":checked");
            this.$element.trigger('change');
        },
        /**
         * 设置选中与否
         * @method state
         * @param {boolean} value true or false 是否选中
         * @param {boolean} skip 是否跳过不触发事件
         * @returns {*}
         */
        state: function(value, skip) {
            if (this.options.disabled || this.options.readonly) {
                return;
            }
            if (this.options.state && !this.options.radioAllOff && this.$element.is(':radio')) {
                return;
            }
            value = !!value;
            this.$element.prop("checked", value).trigger('change', skip);
        },

        /**
         * 切换状态
         * @method toggle
         * @param {boolean} skip 是否跳过不触发事件
         * @returns {*}
         */
        toggle: function(skip) {
            if (this.options.disabled || this.options.readonly) {
                return;
            }
            this.$element.prop("checked", !this.options.state).trigger('change', skip);
        },
        _state:function(value){
            return this.state(value);
        },
        //这里的value与checkbox是否打勾没有必然关系;打勾时元素的value会提交到后台,不打勾时不会提交;
        //此控件在界面操作不会影响value值;
        //正常情况下checkbox赋值,会遍历元素, 如果元素的value在参数中出现,则此checkbox打勾;
        //TODO 待验证
        value:function(value){
            if(value === undefined){
                return this.element.val();
            }else{
                this.element.val(value);
            }
        },
        /*
         * 设置控件尺寸
         * @method size
         * @param value
         * @returns {*}
         */
        _size: function(value) {
            if (this.options.size != null) {
                this.$wrapper.removeClass(baseClass + "-" + this.options.size);
            }
            if (value) {
                this.$wrapper.addClass(baseClass + "-" + value);
            }
        },

        /*
         * 设置动画效果
         * @method animate
         * @param value
         * @returns {*}
         */
        _animate: function(value) {
            value = !!value;
            this.$wrapper[value ? "addClass" : "removeClass"](baseClass + "-animate");
        },

        /*
         * 设置disabled配置项
         * @method disabled
         * @param value
         * @returns {*}
         */
        _disabled: function(value) {
            value = !!value;
            this.$wrapper[value ? "addClass" : "removeClass"](baseClass + "-disabled");
            this.$element.prop("disabled", value);
        },

        /*
         * 设置readonly配置项
         * @method readonly
         * @param value
         * @returns {*}
         */
        _readonly: function(value) {
            value = !!value;
            this.$wrapper[value ? "addClass" : "removeClass"](baseClass + "-readonly");
            this.$element.prop("readonly", value);
        },

        /*
         * 设置onColor配置项
         * @method onColor
         * @param value
         * @returns {*}
         */
        _onColor: function(value) {
            var color;
            color = this.options.onColor;
            if (color != null) {
                this.$on.removeClass(baseClass + "-" + color);
            }
            this.$on.addClass(baseClass + "-" + value);
        },

        /*
         * 设置offColor配置项
         * @method offColor
         * @param value
         * @returns {*}
         */
        _offColor: function(value) {
            var color;
            color = this.options.offColor;
            if (color != null) {
                this.$off.removeClass(baseClass + "-" + color);
            }
            this.$off.addClass(baseClass + "-" + value);
        },

        /*
         * 设置onText配置项
         * @method onText
         * @param value
         * @returns {*}
         */
        _onText: function(value) {
            this.$on.html(value);
        },

        /*
         * 设置offText配置项
         * @method offText
         * @param value
         * @returns {*}
         */
        _offText: function(value) {
            this.$off.html(value);
        },

        /*
         * 设置labelText配置项
         * @method labelText
         * @param value
         * @returns {*}
         */
        _labelText: function(value) {
            this.$label.html(value);
        },

        /*
         * 销毁
         * @method  destroy
         * @returns {*}
         */
        _destroy: function() {
            // var $form;
            // $form = this.$element.closest("form");
            // if ($form.length) {
            //     $form.off(".switchBtn").removeData("ui-switch");
            // }
            this.$container.children().not(this.$element).remove();
            this.$element.unwrap().unwrap(); //.removeData("ui-switch");//.off(".bootstrapSwitch")
            this.$element.off(); //绑定在此对象上事件必须要删除
        },

        _elementHandlers: function() {
            var _this = this;
            _this.$element.on({
                "change": function(e, skip) {
                    var checked;
                    e.preventDefault();
                    e.stopImmediatePropagation();
                    checked = _this.$element.is(":checked");
                    if (checked === _this.options.state) {
                        return;
                    }
                    _this.options.state = checked;
                    _this.$wrapper.removeClass(checked ? baseClass + "-off" : baseClass + "-on").addClass(checked ? baseClass + "-on" : baseClass + "-off");
                    if (!skip) {
                        if (_this.$element.is(":radio")) {
                            $("[name='" + (_this.$element.attr('name')) + "']").not(_this.$element).prop("checked", false).trigger("change", true);
                        }
                        _this._trigger("switchChange", e, [checked]);
                    }
                },

                /**
                 * 聚焦事件
                 * @event focus
                 */
                "focus": function(e) {
                    if (_this.options.disabled) return; //fix bug //如果灰化了则不能添加样式
                    //e.preventDefault();
                    return _this.$wrapper.addClass(baseClass + "-focused");
                },

                /**
                 * 失去焦点事件
                 * @event blur
                 */
                "blur": function(e) {
                    if (_this.options.disabled) return; //fix bug //如果灰化了则不能添加样式
                    e.preventDefault();
                    return _this.$wrapper.removeClass(baseClass + "-focused");
                },
                /**
                 *左右键
                 *@event keydown
                 */
                "keydown": function(e) {
                    if (!e.which || _this.options.disabled || _this.options.readonly) {
                        return;
                    }
                    switch (e.which) {
                        case 37: //left
                            e.preventDefault();
                            e.stopImmediatePropagation();
                            return _this.state(false);
                        case 39: //right
                            e.preventDefault();
                            e.stopImmediatePropagation();
                            return _this.state(true);
                    }
                }
            });
        },

        _handleHandlers: function() {
            var _this = this;
            this.$on.on("click", function(e) {
                e.preventDefault();
                e.stopPropagation();
                _this.state(false);
                return _this.$element.focus();
            });
            this.$off.on("click", function(e) {
                e.preventDefault();
                e.stopPropagation();
                _this.state(true);
                return _this.$element.focus();
            });
        },

        _labelHandlers: function() {
            var _this = this;

            this.$label.on({
                /**
                 * 拖拽事件
                 * @event mousemove
                 */
                "mousemove": function(e) {
                    var left, pageX, percent, right;
                    if (!_this.isLabelDragging) {
                        return;
                    }
                    e.preventDefault();
                    _this.isLabelDragged = true;
                    pageX = e.pageX || e.originalEvent.touches[0].pageX;
                    percent = ((pageX - _this.$wrapper.offset().left) / _this.$wrapper.width()) * 100;
                    left = 25;
                    right = 75;
                    if (_this.options.animate) {
                        _this.$wrapper.removeClass(baseClass + "-animate");
                    }
                    if (percent < left) {
                        percent = left;
                    } else if (percent > right) {
                        percent = right;
                    }
                    _this.$container.css("margin-left", "" + (percent - right) + "%");
                },

                /**
                 * 鼠标点下
                 * @event mousedown
                 */
                "mousedown": function(e) {
                    if (_this.isLabelDragging || _this.options.disabled || _this.options.readonly) {
                        return;
                    }
                    e.preventDefault();
                    _this.isLabelDragging = true;
                    return _this.$element.focus();
                },

                /**
                 * mouseup时进行动画切换
                 * @event mouseup
                 */
                "mouseup": function(e) {
                    if (!_this.isLabelDragging) {
                        return;
                    }
                    e.preventDefault();
                    if (_this.isLabelDragged) { //如果是拖动
                        _this.isLabelDragged = false;
                        _this.state(parseInt(_this.$container.css("margin-left"), 10) > -(_this.$container.width() / 6));
                        if (_this.options.animate) {
                            _this.$wrapper.addClass(baseClass + "-animate");
                        }
                        _this.$container.css("margin-left", "");

                    } else {
                        _this.state(!_this.options.state); //切换状态
                    }
                    return _this.isLabelDragging = false;
                },

                /**
                 * 鼠标离开事件
                 * @event mouseleave
                 */
                "mouseleave": function(e) {
                    return _this.$label.trigger("mouseup");
                }
            });

        },
    });
});

/**
 * 标签页控件，从jQuery UI Tabs 1.9.2改造而来。
 * @class fish.desktop.widget.Tabs
 * @extends fish.desktop.widget
 */

/*!
 * jQuery UI Tabs 1.9.2
 * http://jqueryui.com
 *
 * Copyright 2012 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/tabs/
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 */

! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.tabs', factory);
    } else {
        factory();
    }
}(function() {

    "use strict";

    var tabId = 0,
        rhash = /#.*$/;

    function getNextTabId() {
        return ++tabId;
    }

    function isLocal(anchor) {
        return anchor.hash.length > 1 &&
            anchor.href.replace(rhash, "") ===
            location.href.replace(rhash, "")
            // support: Safari 5.1
            // Safari 5.1 doesn't encode spaces in window.location
            // but it does encode spaces from anchors (#8777)
            .replace(/\s/g, "%20");
    }

    $.widget("ui.tabs", {
        delay: 300,
        options: {
            /**
             * 设置第几个tab为当前活动项。
             * @cfg {Number} active
             */
            active: null,
            /**
             * 是否可以折叠。
             * @cfg {Boolean} collapsible=false
             */
            collapsible: false,
            /**
             * 页签切换的事件,默认是点击;可以配置成mouseover
             * @cfg {String} event="click"
             */
            event: "click",
            /**
             * 页签panel的高度设置
             * "auto": All panels will be set to the height of the tallest panel.
             * "fill": Expand to the available height based on the tabs' parent height.
             * "content": Each panel will be only as tall as its content.
             * @cfg {String} heightStyle="content"
             */
            heightStyle: "content",
            /**
             * 标签页被激活时的回调函数。
             * @cfg {Function} activate
             */
            activate: null,
            /**
             * 标签页在激活之前的回调函数。
             * @cfg {Function} beforeActivate
             */
            beforeActivate: null,
            /**
             * 标签页在被删除之前的回调函数。
             * @cfg {Function} beforeRemove
             */
            beforeRemove: null,
            /**
             * 标签页在被删除后的回调函数。
             * @cfg {Function} remove
             */
            remove: null,
            /**
             * 标签页在被添加之后的回调函数。
             * @cfg {Function} add
             */
            add: null,
            /**
             * 分页设置,当页签数量过多时,超过一行需要设置paging属性
             * @cfg {Object} paging=false
             */
            paging: false
        },

        _create: function() {
            var that = this,
                options = this.options,
                active = options.active; //,
            // locationHash = location.hash.substring( 1 );

            this.running = false;

            // if (!this.element.hasClass("ui-init")) {
            //     console.error("please add class 'ui-init' to tabs element!!! ");
            // }

            this.element
                // .removeClass("ui-init")
                .addClass("ui-tabs")
                .toggleClass("ui-tabs-collapsible", options.collapsible)
                // Prevent users from focusing disabled tabs via click
                .delegate(".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function(event) {
                    if ($(this).is(".ui-state-disabled")) {
                        event.preventDefault();
                    }
                })
                // support: IE <9
                // Preventing the default action in mousedown doesn't prevent IE
                // from focusing the element, so if the anchor gets focused, blur.
                // We don't have to worry about focusing the previously focused
                // element since clicking on a non-focusable element should focus
                // the body anyway.
                .delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
                    if ($(this).closest("li").is(".ui-state-disabled")) {
                        this.blur();
                    }
                });

            this._processTabs();

            if (active === null) {
                // check for a tab marked active via a class
                if (active === null) {
                    active = this.tabs.index(this.tabs.filter(".ui-tabs-active"));
                }

                // no active tab, set to false
                if (active === null || active === -1) {
                    active = this.tabs.length ? 0 : false;
                }
            }

            // handle numbers: negative, out of range
            if (active !== false) {
                active = this.tabs.index(this.tabs.eq(active));
                if (active === -1) {
                    active = options.collapsible ? false : 0;
                }
            }
            options.active = active;

            // don't allow collapsible: false and active: false
            if (!options.collapsible && options.active === false && this.anchors.length) {
                options.active = 0;
            }

            // Take disabling tabs via class attribute from HTML
            // into account and update option properly.
            if ($.isArray(options.disabled)) {
                options.disabled = $.unique(options.disabled.concat(
                    $.map(this.tabs.filter(".ui-state-disabled"), function(li) {
                        return that.tabs.index(li);
                    })
                )).sort();
            }

            // check for length avoids error when initializing empty list
            if (this.options.active !== false && this.anchors.length) {
                this.active = this._findActive(this.options.active);
            } else {
                this.active = $();
            }

            this._refresh();

            if (options.canClose) {
                this._bindCloseEvent(true);
            }

        },
        //如果绑定了初始化create事件,则此方法返回的值会作为create事件的参数
        _getCreateEventData: function() {
            return {
                tab: this.active,
                panel: !this.active.length ? $() : this._getPanelForTab(this.active)
            };
        },

        _tabKeydown: function(event) {

            var focusedTab = $(this.document[0].activeElement).closest("li"),
                selectedIndex = this.tabs.index(focusedTab),
                goingForward = true;

            if (this._handlePageNav(event)) {
                return;
            }

            switch (event.keyCode) {
                case $.ui.keyCode.RIGHT:
                case $.ui.keyCode.DOWN:
                    selectedIndex++;
                    break;
                case $.ui.keyCode.UP:
                case $.ui.keyCode.LEFT:
                    goingForward = false;
                    selectedIndex--;
                    break;
                case $.ui.keyCode.END:
                    selectedIndex = this.anchors.length - 1;
                    break;
                case $.ui.keyCode.HOME:
                    selectedIndex = 0;
                    break;
                case $.ui.keyCode.SPACE:
                    // Activate only, no collapsing
                    event.preventDefault();
                    clearTimeout(this.activating);
                    this._activate(selectedIndex);
                    return;
                case $.ui.keyCode.ENTER:
                    // Toggle (cancel delayed activation, allow collapsing)
                    event.preventDefault();
                    clearTimeout(this.activating);
                    // Determine if we should collapse or activate
                    this._activate(selectedIndex === this.options.active ? false : selectedIndex);
                    return;
                default:
                    return;
            }

            // Focus the appropriate tab, based on which key was pressed
            event.preventDefault();
            clearTimeout(this.activating);
            selectedIndex = this._focusNextTab(selectedIndex, goingForward);

            // Navigating with control key will prevent automatic activation
            if (!event.ctrlKey) {
                // Update aria-selected immediately so that AT think the tab is already selected.
                // Otherwise AT may confuse the user by stating that they need to activate the tab,
                // but the tab will already be activated by the time the announcement finishes.
                focusedTab.attr("aria-selected", "false");
                this.tabs.eq(selectedIndex).attr("aria-selected", "true");

                this.activating = this._delay(function() {
                    this.option("active", selectedIndex);
                }, this.delay);
            }
        },

        _panelKeydown: function(event) {
            if (this._handlePageNav(event)) {
                return;
            }

            // Ctrl+up moves focus to the current tab
            if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
                event.preventDefault();
                this.active.focus();
            }
        },

        // Alt+page up/down moves focus to the previous/next tab (and activates)
        _handlePageNav: function(event) {
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
                this._activate(this._focusNextTab(this.options.active - 1, false));
                return true;
            }
            if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
                this._activate(this._focusNextTab(this.options.active + 1, true));
                return true;
            }
        },

        _findNextTab: function(index, goingForward) {
            var lastTabIndex = this.tabs.length - 1;

            function constrain() {
                if (index > lastTabIndex) {
                    index = 0;
                }
                if (index < 0) {
                    index = lastTabIndex;
                }
                return index;
            }

            while ($.inArray(constrain(), this.options.disabled) !== -1) {
                index = goingForward ? index + 1 : index - 1;
            }

            return index;
        },

        _focusNextTab: function(index, goingForward) {
            index = this._findNextTab(index, goingForward);
            this.tabs.eq(index).focus();
            return index;
        },

        _setOption: function(key, value) {
            if (key === "active") {
                // _activate() will handle invalid values and update this.options
                this._activate(value);
                return;
            }

            if (key === "canClose") {
                this._bindCloseEvent(value);
            }

            if (key === "disabled") {
                // don't use the widget factory's disabled handling
                this._setupDisabled(value);
                return;
            }

            this._super(key, value);

            if (key === "collapsible") {
                this.element.toggleClass("ui-tabs-collapsible", value);
                // Setting collapsible: false while collapsed; open first panel
                if (!value && this.options.active === false) {
                    this._activate(0);
                }
            }

            if (key === "event") {
                this._setupEvents(value);
            }

            if (key === "heightStyle") {
                this._setupHeightStyle(value);
            }
        },

        _tabId: function(tab) {
            return tab.attr("aria-controls") || "ui-tabs-" + getNextTabId();
        },

        _sanitizeSelector: function(hash) {
            return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
        },

        /**
         * 刷新tab页，在手动添加tab页之后可以调用此方法刷新。
         * @method refresh
         */
        refresh: function() {
            var options = this.options,
                lis = this.tablist.children(":has(a[href])");

            // get disabled tabs from class attribute from HTML
            // this will get converted to a boolean if needed in _refresh()
            options.disabled = $.map(lis.filter(".ui-state-disabled"), function(tab) {
                return lis.index(tab);
            });

            this._processTabs();

            // was collapsed or no tabs
            if (options.active === false || !this.anchors.length) {
                options.active = false;
                this.active = $();
                // was active, but active tab is gone
            } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
                // all remaining tabs are disabled
                if (this.tabs.length === options.disabled.length) {
                    options.active = false;
                    this.active = $();
                    // activate previous tab
                } else {
                    this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
                }
                // was active, active tab still exists
            } else {
                // make sure active index is correct
                options.active = this.tabs.index(this.active);
            }

            this._refresh();
        },

        _refresh: function() {
            this._setupDisabled(this.options.disabled);
            this._setupEvents(this.options.event);
            this._setupHeightStyle(this.options.heightStyle);

            this.tabs.not(this.active).attr({
                "aria-selected": "false",
                tabIndex: -1
            });
            this.panels.not(this._getPanelForTab(this.active))
                .hide()
                .attr({
                    "aria-expanded": "false",
                    "aria-hidden": "true"
                });

            // Make sure one tab is in the tab order
            if (!this.active.length) {
                this.tabs.eq(0).attr("tabIndex", 0);
            } else {
                this.active
                    .addClass("ui-tabs-active ui-state-active")
                    .attr({
                        "aria-selected": "true",
                        tabIndex: 0
                    });
                this._getPanelForTab(this.active)
                    .show()
                    .attr({
                        "aria-expanded": "true",
                        "aria-hidden": "false"
                    });
            }
            if (this.options.paging) this._paging();
        },

        _processTabs: function() {
            var that = this;

            this.tablist = this._getList()
                .addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix")
                .attr("role", "tablist");

            this.tabs = this.tablist.find("> li:has(a)") //:has(a[href])
                .addClass("ui-state-default")
                .attr({
                    role: "tab",
                    tabIndex: -1
                });

            this.anchors = this.tabs.map(function() {
                    return $("a", this)[0];
                })
                .addClass("ui-tabs-anchor")
                .attr({
                    role: "presentation",
                    tabIndex: -1
                });

            this.panels = $();

            this.anchors.each(function(i, anchor) {
                var selector, panel, panelId,
                    anchorId = $(anchor).uniqueId().attr("id"),
                    tab = $(anchor).closest("li"); //,
                // originalAriaControls = tab.attr( "aria-controls" );
                // inline tab
                if (isLocal(anchor)) {
                    selector = anchor.hash;
                    panel = that.element.find(that._sanitizeSelector(selector));
                }else{//没有hash的时候,
                    panel = that.element.children("div:eq("+i+")");
                    panelId = panel.attr("id");
                    if(!panelId){
                        panelId = that._tabId( $(anchor) );
                        panel.attr("id",panelId);
                    }
                    selector = "#"+panelId;
                    $(anchor).attr("href",selector);
                }

                if (panel.length) {
                    that.panels = that.panels.add(panel);
                }
                // if ( originalAriaControls ) {
                //  tab.data( "ui-tabs-aria-controls", originalAriaControls );
                // }
                tab.attr({
                    "aria-controls": selector.substring(1),
                    "aria-labelledby": anchorId
                });
                panel.attr("aria-labelledby", anchorId);
            });

            this.panels
                .addClass("ui-tabs-panel")
                .attr("role", "tabpanel");
        },

        // allow overriding how to find the list for rare usage scenarios (#7715)
        _getList: function() {
            return this.element.find("ol,ul").eq(0);
        },

        _createPanel: function(id) {
            return $("<div>")
                .attr("id", id)
                .addClass("ui-tabs-panel")
                .data("ui-tabs-destroy", true);
        },

        _setupDisabled: function(disabled) {
            if ($.isArray(disabled)) {
                if (!disabled.length) {
                    disabled = false;
                } else if (disabled.length === this.anchors.length) {
                    disabled = true;
                }
            }
            // disable tabs
            for (var i = 0, li;
                (li = this.tabs[i]); i++) {
                if (disabled === true || $.inArray(i, disabled) !== -1) {
                    $(li)
                        .addClass("ui-state-disabled")
                        .attr("aria-disabled", "true");
                } else {
                    $(li)
                        .removeClass("ui-state-disabled")
                        .removeAttr("aria-disabled");
                }
            }

            this.options.disabled = disabled;
        },

        _setupEvents: function(event) {
            var events = {
                click: function(event) {
                    event.preventDefault();
                }
            };
            if (event) {
                $.each(event.split(" "), function(index, eventName) {
                    events[eventName] = "_eventHandler";
                });
            }

            this._off(this.anchors.add(this.tabs).add(this.panels));
            this._on(this.anchors, events);
            this._on(this.tabs, {
                keydown: "_tabKeydown"
            });
            this._on(this.panels, {
                keydown: "_panelKeydown"
            });

            this._focusable(this.tabs);
            this._hoverable(this.tabs);
        },

        _setupHeightStyle: function(heightStyle) {
            var maxHeight, overflow,
                parent = this.element.parent();

            if (heightStyle === "fill") {
                // IE 6 treats height like minHeight, so we need to turn off overflow
                // in order to get a reliable height
                // we use the minHeight support test because we assume that only
                // browsers that don't support minHeight will treat height as minHeight
                if (!$.support.minHeight) {
                    overflow = parent.css("overflow");
                    parent.css("overflow", "hidden");
                }
                maxHeight = parent.height();
                this.element.siblings(":visible").each(function() {
                    var elem = $(this),
                        position = elem.css("position");

                    if (position === "absolute" || position === "fixed") {
                        return;
                    }
                    maxHeight -= elem.outerHeight(true);
                });
                if (overflow) {
                    parent.css("overflow", overflow);
                }

                this.element.children().not(this.panels).each(function() {
                    maxHeight -= $(this).outerHeight(true);
                });

                this.panels.each(function() {
                        $(this).height(Math.max(0, maxHeight -
                            $(this).innerHeight() + $(this).height()));
                    })
                    .css("overflow", "auto");
            } else if (heightStyle === "auto") {
                maxHeight = 0;
                this.panels.each(function() {
                    maxHeight = Math.max(maxHeight, $(this).height("").height());
                }).height(maxHeight);
            }
        },

        _eventHandler: function(event) {

            var options = this.options,
                active = this.active,
                anchor = $(event.currentTarget),
                tab = anchor.closest("li"),
                clickedIsActive = tab[0] === active[0],
                collapsing = clickedIsActive && options.collapsible,
                toShow = collapsing ? $() : this._getPanelForTab(tab),
                toHide = !active.length ? $() : this._getPanelForTab(active),
                eventData = {
                    oldTab: active,
                    oldPanel: toHide,
                    newTab: collapsing ? $() : tab,
                    newPanel: toShow
                };

            event.preventDefault();

            if (tab.hasClass("ui-state-disabled") ||
                // tab is already loading
                tab.hasClass("ui-tabs-loading") ||
                // can't switch durning an animation
                this.running ||
                // click on active header, but not collapsible
                (clickedIsActive && !options.collapsible) ||
                // allow canceling activation
                (this._trigger("beforeActivate", event, eventData) === false)) {
                // this._delay(function() {
                //  this.active.focus();
                // },10);
                return;
            }

            options.active = collapsing ? false : this.tabs.index(tab);

            this.active = clickedIsActive ? $() : tab;
            if (this.xhr) {
                this.xhr.abort();
            }

            if (!toHide.length && !toShow.length) {
                $.error("jQuery UI Tabs: Mismatching fragment identifier.");
            }

            // if ( toShow.length ) {
            //  this.load( this.tabs.index( tab ), event );
            // }
            this._toggle(event, eventData);
        },

        // handles show/hide for selecting tabs
        _toggle: function(event, eventData) {
            var that = this,
                toShow = eventData.newPanel,
                toHide = eventData.oldPanel;

            this.running = true;

            function complete() {
                that.running = false;
                that._trigger("activate", event, eventData);
            }

            function show() {
                eventData.newTab.closest("li").addClass("ui-tabs-active ui-state-active");

                if (toShow.length && that.options.show) {
                    that._show(toShow, that.options.show, complete);
                } else {
                    toShow.show();
                    complete();
                }
            }

            // start out by hiding, then showing, then completing
            if (toHide.length && this.options.hide) {
                this._hide(toHide, this.options.hide, function() {
                    eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
                    show();
                });
            } else {
                eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
                toHide.hide();
                show();
            }

            toHide.attr({
                "aria-expanded": "false",
                "aria-hidden": "true"
            });
            eventData.oldTab.attr("aria-selected", "false");
            // If we're switching tabs, remove the old tab from the tab order.
            // If we're opening from collapsed state, remove the previous tab from the tab order.
            // If we're collapsing, then keep the collapsing tab in the tab order.
            if (toShow.length && toHide.length) {
                eventData.oldTab.attr("tabIndex", -1);
            } else if (toShow.length) {
                this.tabs.filter(function() {
                        return $(this).attr("tabIndex") === 0;
                    })
                    .attr("tabIndex", -1);
            }

            toShow.attr({
                "aria-expanded": "true",
                "aria-hidden": "false"
            });
            eventData.newTab.attr({
                "aria-selected": "true",
                tabIndex: 0
            });
        },

        _activate: function(index) {
            var anchor,
                active = this._findActive(index);

            // trying to activate the already active panel
            if (active[0] === this.active[0]) {
                return;
            }

            // trying to collapse, simulate a click on the current active header
            if (!active.length) {
                active = this.active;
            }

            anchor = active.find(".ui-tabs-anchor")[0];
            this._eventHandler({
                target: anchor,
                currentTarget: anchor,
                preventDefault: $.noop
            });

            //add paging
            if (this.options.paging) {
                var that = this,
                    currentPage = that.options.currentPage,
                    pages = that.options.pages;

                // find the new page based on index of the tab selected
                for (var i in pages) {
                    var start = pages[i].start;
                    var end = pages[i].end;
                    if (index >= start && index < end) {
                        // if the the tab selected is not within the currentPage of tabs, then change pages
                        if (i != currentPage) {
                            that.tabs.hide().slice(start, end).show();

                            that._delay(function() {
                                that.active.focus();
                            });

                            currentPage = parseInt(i);
                            if (currentPage == 0) {
                                that._enableButton('next');
                                if (!that.options.cycle && start <= 0) that._disableButton('prev');
                            } else {
                                that._enableButton('prev');
                                if (!that.options.cycle && end >= that.tabs.length) that._disableButton('next');
                            }
                        }
                        break;
                    }
                }
                that.options.currentPage = currentPage;
            };

        },

        _findActive: function(index) {
            return index === false ? $() : this.tabs.eq(index);
        },

        _getIndex: function(index) {
            // meta-function to give users option to provide a href string instead of a numerical index.
            if (typeof index === "string") {
                index = this.anchors.index(this.anchors.filter("[href$='" + index + "']"));
            }

            return index;
        },

        _destroy: function() {
            if (this.xhr) {
                this.xhr.abort();
            }

            this.element.removeClass("ui-tabs ui-tabs-collapsible");

            this.tablist
                .removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix")
                .removeAttr("role");

            this.anchors
                .removeClass("ui-tabs-anchor")
                .removeAttr("role")
                .removeAttr("tabIndex")
                .removeData("href.tabs")
                .removeData("load.tabs")
                .removeUniqueId();

            this.tabs.add(this.panels).each(function() {
                if ($.data(this, "ui-tabs-destroy")) {
                    $(this).remove();
                } else {
                    $(this)
                        .removeClass("ui-state-default ui-state-active ui-state-disabled " +
                            "ui-tabs-active ui-tabs-panel")
                        .removeAttr("tabIndex")
                        .removeAttr("aria-live")
                        .removeAttr("aria-busy")
                        .removeAttr("aria-selected")
                        .removeAttr("aria-labelledby")
                        .removeAttr("aria-hidden")
                        .removeAttr("aria-expanded")
                        .removeAttr("role");
                }
            });

            this.tabs.each(function() {
                var li = $(this),
                    prev = li.data("ui-tabs-aria-controls");
                if (prev) {
                    li.attr("aria-controls", prev);
                } else {
                    li.removeAttr("aria-controls");
                }
            });

            this.panels.show();

            if (this.options.heightStyle !== "content") {
                this.panels.css("height", "");
            };

        },

        /**
         * 启用指定的tab页。
         * @param  {number} index 启用第几个标签页，从0开始计算。
         */
        enable: function(index) {
            var disabled = this.options.disabled;
            if (disabled === false) {
                return;
            }

            if (index === undefined) {
                disabled = false;
            } else {
                index = this._getIndex(index);
                if ($.isArray(disabled)) {
                    disabled = $.map(disabled, function(num) {
                        return num !== index ? num : null;
                    });
                } else {
                    disabled = $.map(this.tabs, function(li, num) {
                        return num !== index ? num : null;
                    });
                }
            }
            this._setupDisabled(disabled);
        },

        /**
         * 禁用指定的tab页。
         * @param  {number} index 启用第几个标签页，从0开始计算。
         */
        disable: function(index) {
            var disabled = this.options.disabled;
            if (disabled === true) {
                return;
            }

            if (index === undefined) {
                disabled = true;
            } else {
                index = this._getIndex(index);
                if ($.inArray(index, disabled) !== -1) {
                    return;
                }
                if ($.isArray(disabled)) {
                    disabled = $.merge([index], disabled).sort();
                } else {
                    disabled = [index];
                }
            }
            this._setupDisabled(disabled);
        },

        _getPanelForTab: function(tab) {
            var id = $(tab).attr("aria-controls");
            return this.element.find(this._sanitizeSelector("#" + id));
        }

    });

    // add/remove methods and events
    $.widget("ui.tabs", $.ui.tabs, {
        options: {
            // add: null,
            // remove: null,
            /**
             * @cfg {Boolean} canClose
             * 标签页是否可以关闭。
             */
            canClose: false,
            /**
             * @cfg {String} tabTemplate
             * tab标签的HTML模板。
             */
            tabTemplate: "<li><a href='#{href}'><span>#{label}</span></a></li>",
            /**
             * @cfg {String} tabCanCloseTemplate
             * 可关闭的tab标签的HTML模板。
             */
            tabCanCloseTemplate: "<li><a href='#{href}'>#{label}</a><button type='button' class='ui-tabs-close close' role='button'><span aria-hidden='true' title='close'>&times;<span class='sr-only'>Close</span></span></button></li>",
            /**
             * @cfg {String} panelTemplate
             * 标签页内容面板HTML模板。
             */
            panelTemplate: "<div></div>"
        },

        _ui: function(tab, panel) {
            return {
                tab: tab,
                panel: panel,
                index: this.anchors.index(tab)
            };
        },

        _createPanel: function(id) {
            return $(this.options.panelTemplate)
                .attr("id", id);
            // .addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
            // .data( "ui-tabs-destroy", true );
        },

        /**
         * 添加标签页。
         * @param {Object} o 配置项对象，此对象可以包含id, label, index ,content,active属性。
         */
        add: function(o) { //id, label, index ,content,active
            o = o || {};
            var index = o.index,
                id = o.id,
                label = o.label,
                tabContentHtml = o.content;
            if (index === undefined) {
                index = this.anchors.length;
            };
            id = id || "ui-tabs-" + getNextTabId();
            label = label || id;

            if (this.options.paging) this._pageReset();

            var doInsertAfter, panel,
                options = this.options,
                li = $((options.canClose ? options.tabCanCloseTemplate : options.tabTemplate)
                    .replace(/#\{href\}/g, "#" + id)
                    .replace(/#\{label\}/g, label));
            // id = !url.indexOf( "#" ) ?
            //  url.replace( "#", "" ) :
            //  this._tabId( li );

            // li.addClass( "ui-state-default ui-corner-top" ).data( "ui-tabs-destroy", true );
            // li.attr( "aria-controls", id );

            doInsertAfter = index >= this.tabs.length;

            // try to find an existing element before creating a new one
            panel = this.element.find("#" + id);
            if (!panel.length) {
                panel = this._createPanel(id);
                panel.append(o.content);
                if (doInsertAfter) {
                    if (index > 0) {
                        panel.insertAfter(this.panels.eq(-1));
                    } else {
                        panel.appendTo(this.element);
                    }
                } else {
                    panel.insertBefore(this.panels[index]);
                }
            }
            // panel.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" ).hide();
            panel.hide();

            if (doInsertAfter) {
                li.appendTo(this.tablist);
            } else {
                li.insertBefore(this.tabs[index]);
            }

            options.disabled = $.map(options.disabled, function(n) {
                return n >= index ? ++n : n;
            });

            this.refresh();

            if (this.tabs.length === 1 && options.active === false) {
                this.option("active", 0);
            };
            if (o.active === true) {
                this.option("active", index);
            }

            this._trigger("add", null, this._ui(this.anchors[index], this.panels[index]));
            return this;
        },
        /**
         * 删除指定的标签页。
         * @param {number} index 序号，从0开始。
         */
        remove: function(index) {

            if (this.options.paging) this._pageReset();

            index = this._getIndex(index);
            var options = this.options,
                tab = this.tabs.eq(index),
                panel = this._getPanelForTab(tab);

            if (this._trigger("beforeRemove", null, this._ui(tab, panel)) === false)
                return;

            tab.remove();
            panel.remove();

            // If selected tab was removed focus tab to the right or
            // in case the last tab was removed the tab to the left.
            // We check for more than 2 tabs, because if there are only 2,
            // then when we remove this tab, there will only be one tab left
            // so we don't need to detect which tab to activate.
            if (tab.hasClass("ui-tabs-active") && this.anchors.length > 2) {
                this._activate(index + (index + 1 < this.anchors.length ? 1 : -1));
            }

            options.disabled = $.map(
                $.grep(options.disabled, function(n) {
                    return n !== index;
                }),
                function(n) {
                    return n >= index ? --n : n;
                });

            this.refresh();

            this._trigger("remove", null, this._ui(tab.find("a")[0], panel[0]));
            return this;
        },

        /**
         * 刷新指定的标签页。
         * @param {number} index 序号，从0开始。
         * @param {Object} o 参数对象。
         */
        update: function(index, o) {
            index = this._getIndex(index);
            var options = this.options,
                tab = this.tabs.eq(index),
                panel = this._getPanelForTab(tab);

            var $span = tab.find("span");
            if (!$span.length) $span = tab.find("a");
            o.label === undefined ? "" : $span.text(o.label);
            alert(typeof o.cssprop);
            if (o.cssprop !== undefined) {
                if (typeof o.cssprop === "string") {
                    $span.addClass(o.cssprop);
                } else if (typeof o.cssprop === "object") {
                    $span.css(o.cssprop);
                }
            }
            return this;
        },
        _bindCloseEvent: function(flag) {
            var that = this;
            if (that.hasBindCloseEvent) return;
            this.element.on("click", "button.ui-tabs-close", function() {
                var index = that.tabs.index($(this).closest("li"));
                that.remove(index);
            });
            that.hasBindCloseEvent = true;
        }
    });

    //
    $.widget("ui.tabs", $.ui.tabs, {

        // change styling of next/prev buttons when disabled
        _disableButton: function(direction) {
            $('.ui-tabs-paging-' + direction, this.element).addClass('ui-tabs-paging-disabled');
        },
        _enableButton: function(direction) {
            $('.ui-tabs-paging-' + direction, this.element).removeClass('ui-tabs-paging-disabled');
        },

        // remove all paging related changes and events
        _pageReset: function() {
            // remove buttons
            $('.ui-tabs-paging-next', this.element).remove();
            $('.ui-tabs-paging-prev', this.element).remove();
            // show all tabs
            this.tabs.show();

        },

        _paging: function() {

            var opts = {
                tabsPerPage: 0, // Max number of tabs to display at one time.  0 automatically sizing. //此参数不公开
                nextButton: '&#187;', // Text displayed for next button.
                prevButton: '&#171;', // Text displayed for previous button.
                follow: true, // When clicking next button, automatically select first.  When clicking previous button automatically select last.
                cycle: false // When at end of list, next button returns to first page.  When at beginning of list previous button goes to end of list.
            };

            opts = $.extend(opts, this.options.paging);

            var that = this,
                initialized = false,
                currentPage,
                buttonWidth, containerWidth, allTabsWidth, tabWidths,
                maxPageWidth, pages, resizeTimer = null,
                windowHeight, windowWidth;

            that._pageReset();
            windowHeight = $(window).height();
            windowWidth = $(window).width();
            var allTabsWidth = 0, currentPage = 0, maxPageWidth = 0, buttonWidth = 0,
                pages = new Array(), tabWidths = new Array(), selectedTabWidths = new Array();
            containerWidth = that.element.width();

            // loops through LIs, get width of each tab when selected and unselected.
            var maxDiff = 0; // the max difference between a selected and unselected tab
            that.tabs.each(function(i) {
                if (i == that.options.active) {
                    selectedTabWidths[i] = $(this).outerWidth(true); //{ margin: true }
                    tabWidths[i] = that.tabs.eq(i).removeClass('ui-tabs-selected').outerWidth(true); //{ margin: true }
                    that.tabs.eq(i).addClass('ui-tabs-selected');
                    maxDiff = Math.min(maxDiff, Math.abs(selectedTabWidths[i] - tabWidths[i]));
                    allTabsWidth += tabWidths[i];
                } else {
                    tabWidths[i] = $(this).outerWidth(true); //{ margin: true }
                    selectedTabWidths[i] = that.tabs.eq(i).addClass('ui-tabs-selected').outerWidth(true); //{ margin: true }
                    that.tabs.eq(i).removeClass('ui-tabs-selected');
                    maxDiff = Math.max(maxDiff, Math.abs(selectedTabWidths[i] - tabWidths[i]));
                    allTabsWidth += tabWidths[i];
                }
            });

            // fix padding issues with buttons
            // TODO determine a better way to handle this
            // allTabsWidth += maxDiff + ($.browser.msie?4:0) + 9;
            allTabsWidth += maxDiff + ($.browser.msie ? 4 : 0); // + 9

            // if the width of all tables is greater than the container's width, calculate the pages
            if (allTabsWidth > containerWidth) {
                // create next button
                var li = $('<li></li>')
                    .addClass('ui-state-default ui-tabs-paging-next ui-corner-right')
                    .append($('<a href="#"></a>')
                        .click(function() {
                            if ($(this).closest('li').hasClass('ui-tabs-paging-disabled')) return false;
                            that._page('next');
                            return false;
                        })
                        .html(opts.nextButton));

                that.tabs.eq(that.tabs.length - 1).after(li);
                buttonWidth = li.outerWidth(true); //{ margin: true }


                // create prev button
                li = $('<li></li>')
                    .addClass('ui-state-default ui-tabs-paging-prev ui-corner-left')
                    .append($('<a href="#"></a>')
                        .click(function() {
                            if ($(this).closest('li').hasClass('ui-tabs-paging-disabled')) return false;
                            that._page('prev');
                            return false;
                        })
                        .html(opts.prevButton));

                that.tabs.eq(0).before(li);
                buttonWidth += li.outerWidth(true); //{ margin: true }
                // TODO determine fix for padding issues to next button
                //              buttonWidth += 19;
                var pageIndex = 0,
                    pageWidth = 0,
                    maxTabPadding = 0;
                // start calculating pageWidths
                for (var i = 0; i < tabWidths.length; i++) {
                    // if first tab of page or selected tab's padding larger than the current max, set the maxTabPadding
                    if (pageWidth == 0 || selectedTabWidths[i] - tabWidths[i] > maxTabPadding)
                        maxTabPadding = (selectedTabWidths[i] - tabWidths[i]);
                    // if first tab of page, initialize pages variable for page
                    if (pages[pageIndex] == null) {
                        pages[pageIndex] = {
                            start: i
                        };
                    } else if ((i > 0 && (i % opts.tabsPerPage) == 0) || (tabWidths[i] + pageWidth + buttonWidth) > containerWidth) { // + 12
                        if ((pageWidth + maxTabPadding) > maxPageWidth)
                            maxPageWidth = (pageWidth + maxTabPadding);
                        pageIndex++;
                        pages[pageIndex] = {
                            start: i
                        };
                        pageWidth = 0;
                    }
                    pages[pageIndex].end = i + 1;
                    pageWidth += tabWidths[i];
                    if (i == that.options.active) currentPage = pageIndex;
                }
                if ((pageWidth + maxTabPadding) > maxPageWidth)
                    maxPageWidth = (pageWidth + maxTabPadding);

                // hide all tabs then show tabs for current page
                that.tabs.hide().slice(pages[currentPage].start, pages[currentPage].end).show();
                if (currentPage == (pages.length - 1) && !opts.cycle)
                    that._disableButton('next');
                if (currentPage == 0 && !opts.cycle)
                    that._disableButton('prev');
            } else {
                that._pageReset();
            };

            that.options.currentPage = currentPage;
            that.options.pages = pages;
            that.options.cycle = opts.cycle;
            that.options.follow = opts.follow;

        },
        // handles paging forward and backward
        _page: function(direction) {
            var that = this,
                currentPage = that.options.currentPage,
                pages = that.options.pages;

            currentPage = currentPage + (direction == 'prev' ? -1 : 1);
            if ((direction == 'prev' && currentPage < 0 && that.options.cycle) ||
                (direction == 'next' && currentPage >= pages.length && !that.options.cycle))
                currentPage = pages.length - 1;
            else if ((direction == 'prev' && currentPage < 0) ||
                (direction == 'next' && currentPage >= pages.length && that.options.cycle))
                currentPage = 0;
            var start = pages[currentPage].start;
            var end = pages[currentPage].end;
            that.tabs.hide().slice(start, end).show();
            if (direction == 'prev') {
                that._enableButton('next');
                if (that.options.follow && (that.options.active < start || that.options.active > (end - 1))) that._activate(end - 1);
                if (!that.options.cycle && start <= 0) that._disableButton('prev');
            } else {
                that._enableButton('prev');
                if (that.options.follow && (that.options.active < start || that.options.active > (end - 1))) that._activate(start);
                if (!that.options.cycle && end >= that.tabs.length) that._disableButton('next');
            }
            that.options.currentPage = currentPage;
        }
    });
});

/**
 * 小提示控件，从jQuery UI Tooltip改造而来。
 * @class fish.desktop.widget.Tooltip
 * @extends fish.desktop.widget
 */

/*
 * jQuery UI Tooltip
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/tooltip/
 *
 * Depends:
 *  jquery.ui.core.js
 *  jquery.ui.widget.js
 *  jquery.ui.position.js
 */
!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.tooltip', factory);
    } else {
        factory();
    }
}(function () {
    "use strict";

    var TRANSITION_DURATION = 150;

    $.widget("ui.tooltip", {
        options: {
            animation: true,
            placement: 'top',
            template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
            trigger: 'hover',
            title: '',
            html: false,
            container: false
        },

        _create: function () {
            this.enabled = true;
            this.timeout = null;
            this.hoverState = null;
            this.showState = false;

            var triggers = this.options.trigger.split(' ');

            for (var i = triggers.length; i--;) {
                var trigger = triggers[i];

                if (trigger == 'click') {
                    this._on({
                        'click': 'toggle'
                    });
                } else if (trigger != 'manual') {
                    var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';
                    var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';
                    var events = {};
                    events[eventIn] = 'enter';
                    events[eventOut] = 'leave';
                    this._on(events);
                }
            }

            this.fixTitle();
        },

        enter: function (e) {
            if (this.hoverState == 'in') {
                return;
            }

            var that = this;
            this.hoverState = 'in';

            setTimeout(function() {
                that.show();
            }, 100);
        },

        leave: function (e) {
            if (this.hoverState == 'out') {
                return;
            }

            var that = this;
            this.hoverState = 'out';

            setTimeout(function() {
                that.hide();
            }, 100);
        },

        show: function () {
            if (this.showState || this.hoverState == 'out') return;

            if (this.hasContent() && this.enabled) {
                this._trigger('show');

                var that = this;

                var $tip = this.tip();

                var tipId = _.uniqueId(this.widgetName);

                this.setContent();
                $tip.attr('id', tipId);
                this.element.attr('aria-describedby', tipId);

                if (this.options.animation) $tip.addClass('fade');

                var placement = typeof this.options.placement == 'function' ?
                    this.options.placement.call(this, $tip[0], this.element[0]) :
                    this.options.placement;

                var autoToken = /\s?auto?\s?/i;
                var autoPlace = autoToken.test(placement);
                if (autoPlace) placement = placement.replace(autoToken, '') || 'top';

                $tip
                    .detach()
                    .css({top: 0, left: 0, display: 'block'})
                    .addClass(placement);

                this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.element);

                var pos = this.getPosition();
                var actualWidth = $tip[0].offsetWidth;
                var actualHeight = $tip[0].offsetHeight;

                if (autoPlace) {
                    var orgPlacement = placement;
                    var $container = this.options.container ? $(this.options.container) : this.element.parent();
                    var containerDim = this.getPosition($container);

                    placement = placement == 'bottom' && pos.bottom + actualHeight > containerDim.bottom ? 'top' :
                        placement == 'top' && pos.top - actualHeight < containerDim.top ? 'bottom' :
                            placement == 'right' && pos.right + actualWidth > containerDim.width ? 'left' :
                                placement == 'left' && pos.left - actualWidth < containerDim.left ? 'right' :
                                    placement;

                    $tip
                        .removeClass(orgPlacement)
                        .addClass(placement);
                }

                var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);

                this.applyPlacement(calculatedOffset, placement);

                var complete = function () {
                    that._trigger('shown');
                    that.hoverState = null;
                    that.showState = true;
                };

                $.support.transition && this.$tip.hasClass('fade') ?
                    $tip
                        .one('bsTransitionEnd', complete)
                        .emulateTransitionEnd(TRANSITION_DURATION) :
                    complete();
            }
        },

        applyPlacement: function (offset, placement) {
            var $tip = this.tip();
            var height = $tip[0].offsetHeight;

            // manually read margins because getBoundingClientRect includes difference
            var marginTop = parseInt($tip.css('margin-top'), 10);
            var marginLeft = parseInt($tip.css('margin-left'), 10);

            // we must check for NaN for ie 8/9
            if (isNaN(marginTop))  marginTop = 0;
            if (isNaN(marginLeft)) marginLeft = 0;

            offset.top = offset.top + marginTop;
            offset.left = offset.left + marginLeft;

            // $.fn.offset doesn't round pixel values
            // so we use setOffset directly with our own function B-0
            $.offset.setOffset($tip[0], $.extend({
                using: function (props) {
                    $tip.css({
                        top: Math.round(props.top),
                        left: Math.round(props.left)
                    })
                }
            }, offset), 0);

            $tip.addClass('in');

            // check to see if placing tip in new offset caused the tip to resize itself
            var actualHeight = $tip[0].offsetHeight;

            if (/top/.test(placement) && actualHeight != height) {
                offset.top = offset.top + height - actualHeight
            }

            $tip.offset(offset);
        },

        setContent: function () {
            var $tip = this.tip();
            var title = this.getTitle();

            $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);
            $tip.removeClass('fade in top bottom left right');
        },

        hide: function () {
            if (!this.showState || this.hoverState == 'in') return;

            var that = this;
            var $tip = this.tip();

            function complete() {
                that.hoverState = null;
                that.showState = false;
                $tip.detach();
                that.element
                    .removeAttr('aria-describedby');
                that._trigger('hidden');
            }

            this._trigger('hide');

            $tip.removeClass('in');

            $.support.transition && this.$tip.hasClass('fade') ?
                $tip
                    .one('bsTransitionEnd', complete)
                    .emulateTransitionEnd(TRANSITION_DURATION) :
                complete();

            return this;
        },

        fixTitle: function () {
            var $e = this.element;
            if ($e.attr('title') || typeof ($e.attr('data-original-title')) != 'string') {
                $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');
            }
        },

        hasContent: function () {
            return this.getTitle();
        },

        getPosition: function ($element) {
            $element = $element || this.element;

            var el = $element[0];
            var isBody = el.tagName == 'BODY';

            var elRect = el.getBoundingClientRect();
            if (elRect.width == null) {
                // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
                elRect = $.extend({}, elRect, {width: elRect.right - elRect.left, height: elRect.bottom - elRect.top})
            }
            var elOffset = isBody ? {top: 0, left: 0} : $element.offset();
            var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()}
            var outerDims = isBody ? {width: $(window).width(), height: $(window).height()} : null;

            return $.extend({}, elRect, scroll, outerDims, elOffset);
        },

        getCalculatedOffset: function (placement, pos, actualWidth, actualHeight) {
            var offset;
            switch (placement) {
                case 'bottom':
                    offset = {
                        top: pos.top + pos.height,
                        left: pos.left + pos.width / 2 - actualWidth / 2
                    };
                    break;
                case 'top':
                    offset = {
                        top: pos.top - actualHeight,
                        left: pos.left + pos.width / 2 - actualWidth / 2
                    };
                    break;
                case 'left':
                    offset =  {
                        top: pos.top + pos.height / 2 - actualHeight / 2,
                        left: pos.left - actualWidth
                    };
                    break;
                case 'right':
                    offset = {
                        top: pos.top + pos.height / 2 - actualHeight / 2,
                        left: pos.left + pos.width
                    };
                    break;
                case 'bottom-left':
                    offset = {
                        top: pos.top + pos.height,
                        left: pos.left + pos.width - actualWidth
                    };
                    break;
                case 'bottom-right':
                    offset = {
                        top: pos.top + pos.height,
                        left: pos.left
                    };
                    break;
                case 'top-left':
                    offset = {
                        top: pos.top - actualHeight,
                        left: pos.left + pos.width - actualWidth
                    };
                    break;
                case 'top-right':
                    offset = {
                        top: pos.top - actualHeight,
                        left: pos.left
                    };
                    break;
            }

            return offset;
        },

        getTitle: function () {
            var title;
            var $e = this.element;
            var o = this.options;

            title = $e.attr('data-original-title')
            || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);

            return title;
        },

        tip: function () {
            if (!this.$tip) {
                this.$tip = $(this.options.template);

                if (this.options.trigger.indexOf('hover') >= 0) {
                    this._on(this.$tip, {
                        'mouseenter': 'enter',
                        'mouseleave': 'leave'
                    })
                }
            }
            return this.$tip;
        },

        arrow: function () {
            return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'));
        },

        enable: function () {
            this.enabled = true;
        },

        disable: function () {
            this.enabled = false;
        },

        toggle: function (e) {
            this.tip().hasClass('in') ? this.leave(e) : this.enter(e);
        },

        _destroy: function() {
            var that = this;
            clearTimeout(this.timeout);
            this.hide();
        }
    });
});

/* ========================================================================
 * Bootstrap: transition.js v3.3.2
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2015 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
    'use strict';

    // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
    // ============================================================

    function transitionEnd() {
        var el = document.createElement('bootstrap');

        var transEndEventNames = {
            WebkitTransition: 'webkitTransitionEnd',
            MozTransition: 'transitionend',
            OTransition: 'oTransitionEnd otransitionend',
            transition: 'transitionend'
        };

        for (var name in transEndEventNames) {
            if (el.style[name] !== undefined) {
                return {end: transEndEventNames[name]};
            }
        }

        return false; // explicit for ie8 (  ._.)
    }

    // http://blog.alexmaccaw.com/css-transitions
    $.fn.emulateTransitionEnd = function (duration) {
        var called = false;
        var $el = this;
        $(this).one('bsTransitionEnd', function () {
            called = true;
        });
        var callback = function () {
            if (!called) $($el).trigger($.support.transition.end)
        };
        setTimeout(callback, duration);
        return this;
    };

    $(function () {
        $.support.transition = transitionEnd();

        if (!$.support.transition) return;

        $.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function (e) {
                if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
            }
        }
    })

}(jQuery);

/**
 * 强大的表单校验控件，来自nice Validator 0.7.3。
 * @class fish.desktop.widget.Validator
 * ##内置规则
 * ###公共定义：
 *
 * - 1. **数值范围**使用波浪线（~）表示，例如：6~（大于等于6）、~6（小于等于6）、6~16（6到16）
 * - 2. **大小比较**使用 lt（小于）、lte（小于等于）、gt（大于）、gte（大于等于）、eq（等于）表示
 * - 3. 如果某个规则可以带参数，参数要使用方括号（[]）或者圆括号（()）括起来，取决于你的习惯
 *
 *
 * <table border="1" bordercolor="#666666" cellpadding="10" style="margin-top:20px;font-size:12px;border-collapse:collapse;">
 * <thead>
 * <tr><th>规则</th>
 *     <th>参数</th>
 *     <th>描述</th>
 *     <th>例子</th>
 * </tr>
 * </thead>
 * <tbody>
 * <tr>
 *     <th>required</th>
 *     <td></td>
 *     <td>必填项</td>
 *     <td>
 * <pre>required        //不能为空
 * required(xxx)   //满足xxx规则，才验证required
 * required(not, xxx) //如果值为空，或者xxx也认为是空
 * </pre>
 *     </td>
 * </tr>
 * <tr>
 *     <th>integer</th>
 *     <td>可选，标识</td>
 *     <td>整数</td>
 *     <td>
 * <pre>integer         //请输入整数
 * integer[*]      //请输入整数
 * integer[+]      //请输入正整数
 * integer[+0]     //请输入正整数或0
 * integer[-]      //请输入负整数
 * integer[-0]     //请输入负整数或0
 * </pre>
 *     </td>
 * </tr>
 * <tr>
 *     <th>match</th>
 *     <td>可选，标识<br>必选, 另一字段名</td>
 *     <td>与另一字段匹配，两种用法：<br><br>
 *     match[name];<br>用于验证两个字段的值必须相同<br><br>
 *     match[condition, name];<br>用于比较两个字段大小
 *     </td>
 *     <td>
 * <pre>match[password]  //与password字段的值匹配
 * match[lt,money]  //小于money字段的值
 * match[lte,money] //小于等于money字段的值
 * match[eq,money]  //等于money字段的值匹配
 * match[gte,money] //大于等于money字段的值
 * match[gt,money]  //大于money字段的值
 * </pre>
 *     </td>
 * </tr>
 * <tr>
 *     <th>range</th>
 *     <td>必选，范围值</td>
 *     <td>数值范围</td>
 *     <td>
 * <pre>range[0~99]      //0到99的整数
 * range[~99]       //小于或等于99的整数
 * range[0~]        //大于或等于0的整数
 * </pre>
 * </td>
 * </tr>
 * <tr>
 *     <th>length</th>
 *     <td>必选，范围值<br>可选，是否计算真实长度</td>
 *     <td>验证字符长度</td>
 *     <td>
 * <pre>length[6~16]       //6-16个字符
 * length[6]          //6个字符
 * length[~6]         //小于6个字符
 * length[6~]         //大于6个字符
 * length[~6, true]   //小于6个字符,全角字符计算双字符
 * </pre>
 *     </td>
 * </tr>
 * <tr>
 *     <th>checked</th>
 *     <td>可选，范围值</td>
 *     <td>对于checkbox或radio<br>必须要选中多少项</td>
 *     <td>
 * <pre>checked             //必填，相当于required
 * checked[3~5]        //请选择3到5项
 * checked[3]          //请选择3项
 * checked[~5]         //请选择少于5项
 * checked[3~]         //请选择大于3项
 * </pre>
 * </td>
 * </tr>
 * <tr>
 *     <th>remote</th>
 *     <td>必选，url地址<br>可选，附带额外的字段</td>
 *     <td>远程验证</td>
 *     <td>
 * <pre>remote[path/to/server.php]
 * remote[path/to/server.php, name1, name2, ..]
 * </pre>
 *     </td>
 * </tr>
 * </tbody>
 * </table>
 */

/*! nice Validator 0.7.3
 * (c) 2012-2014 Jony Zhang <zj86@live.cn>, MIT Licensed
 * http://niceue.com/validator/
 */
/*jshint evil:true, expr:true, strict:false*/
/*global define*/

! function(factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.validator', factory)
    } else {
        factory();
    }
}(function() {

    "use strict";

    var NS = 'validator',
        CLS_NS = '.validator',

        rRules = /(!?)\s?(\w+)(?:\[\s*(.*?\]?)\s*\]|\(\s*(.*?\)?)\s*\))?\s*(;|\||&)?/g,
        rRule = /(\w+)(?:\[\s*(.*?\]?)\s*\]|\(\s*(.*?\)?)\s*\))?/,
        rDisplay = /(?:([^:;\(\[]*):)?(.*)/,
        rDoubleBytes = /[^\x00-\xff]/g,
        rPos = /^.*(top|right|bottom|left).*$/,
        rAjaxType = /(?:(post|get):)?(.+)/i,
        rUnsafe = /<|>/g,

        noop = $.noop,
        proxy = $.proxy,
        isFunction = $.isFunction,
        isArray = $.isArray,
        isString = function(s) {
            return typeof s === 'string';
        },
        isObject = function(o) {
            return o && Object.prototype.toString.call(o) === '[object Object]';
        },
        // isIE6 = !window.XMLHttpRequest,
        attr = function(el, key, value) {
            if (value !== undefined) {
                if (value === null) el.removeAttribute(key);
                else el.setAttribute(key, '' + value);
            } else {
                return el.getAttribute(key);
            }
        },
        debug = window.console || {
            log: noop,
            info: noop
        },
        submitButton,
        novalidateonce,

        defaults = {
            /**
             * @cfg {number} debug
             * 是否启用调试模式，可用值:
             * 0 || false: 关闭调试信息
             * 1 || true: 启用调试信息
             * 2: 启用调试信息，并且不论表单是否验证成功都提交表单，便于对比后端的验证
             */
            debug: 0,
            /**
             * @cfg {number} timely
             * 是否启用实时验证，可用值:
             * 0 || false: 关闭实时验证，将只在提交表单的时候进行验证
             * 1 || true: 启用实时验证，在字段失去焦点后验证该字段
             * 2: 启用实时验证，在输入的同时验证该字段
             */
            timely: 1,
            /*
             * @cfg {String} theme
             * 主题名字，用于设置一个表单验证的主题样式。zh_CN.js中配置了几个主题，可以作为参考 。
             */
            theme: 'default',
            /**
             * @cfg {String} ignore
             * 指定需要忽略验证的元素的jQuery选择器。
             */
            ignore: '',
            //stopOnError: false,
            /**
             * @cfg {Boolean} focusCleanup
             * 是否在输入框获得焦点的时候清除消息，默认清除。
             */
            focusCleanup: true,
            /**
             * @cfg {Boolean} focusInvalid
             * 是否自动让第一个出错的输入框获得的焦点，默认不获得。
             */
            focusInvalid: false,
            /**
             * @cfg {Function} invalid
             * 调用$(ele).isValid()校验时,校验失败的回调函数,回调函数的第一个参数为所有errors信息
             */
            invalid: null,
            /**
             * @cfg {String} validClass
             * 字段验证通过后自动给输入框添加的class名。
             */
            validClass: 'n-valid',
            /**
             * @cfg {String} invalidClass
             * 字段验证失败后自动给输入框添加的class名。
             */
            invalidClass: 'n-invalid',
            /**
             * @cfg {String} msgWrapper
             * 消息容器的标签名，多用于自定义主题。
             */
            msgWrapper: 'span',
            /*
             * @cfg {Function} msgMaker
             * 消息构造器，可以用来自定义消息的结构。
             */
            msgMaker: function(opt) {
                var html,
                    cls = {
                        error: 'n-error',
                        ok: 'n-ok',
                        tip: 'n-tip',
                        loading: 'n-loading'
                    }[opt.type];

                html = '<span class="msg-wrap ' + cls + '" role="alert">';
                html += opt.arrow + opt.icon + '<span class="n-msg">' + opt.msg + '</span>';
                html += '</span>';
                return html;
            },
            /*
             * @cfg {String} msgIcon
             * icon图标模板，用于自定义主题，参见local文件夹下的配置文件。
             */
            msgIcon: '<span class="n-icon"></span>',
            /*
             * @cfg {String} msgArrow
             * 小箭头模板，用于自定义主题，参见local文件夹下的配置文件。
             */
            msgArrow: '<span class="n-arrow"><b>◆</b><i>◆</i></span>',
            /**
             * @cfg {String} msgClass
             * 给消息额外添加的class名，用于自定义主题，控制消息样式。msgClass建议使用以下4个class之一，验证组件能够根据方向关键字智能识别并控制消息的显示位置，你也可以在这4个class的基础上再加上自己定义的class名，用空格隔开就可以了。
             */
            msgClass: '',
            //msgStyle: null,
            //msgShow: null,
            //msgHide: null,
            /**
             * @cfg {Boolean} showOk
             * 是否显示成功提示（注意：前提是有传ok的消息），如果设置成false在字段验证通过后将只是简单的隐藏消息。
             * 还有另一种用法：如果传递一个字符串，在验证通过后将提示这个消息，如果设置成空字符串，将只显示一个成功的图标
             */
            showOk: false,
            /**
             * @cfg {String} defaultMsg
             * 默认的错误消息，一般在全局配置里面配置一下就可以了。
             */
            defaultMsg: '{0} is not valid.',
            /**
             * @cfg {String} loadingMsg
             * 异步加载中的提示，一般在全局配置里面配置一下就可以了。
             */
            loadingMsg: 'Validating...'
        },
        themes = {
            'default': {
                formClass: 'n-default',
                msgClass: 'n-bottom'
            }
        };

    $.fn.validator = function(options) {
        var that = this,
            args = arguments;

        if (that.is(':input')) return that;
        !that.is('form') && (that = this.find('form'));
        !that.length && (that = this);
        that.each(function() {
            var cache = $(this).data('validator');
            if (cache) {
                if (isString(options)) {
                    if (options.charAt(0) === '_') return;
                    cache[options].apply(cache, Array.prototype.slice.call(args, 1));
                } else if (options) {
                    cache._reset(true);
                    cache._init(this, options);
                }
            } else {
                new Validator(this, options);
            }
        });

        return this;
    };

    /**
     * 判断某个字段是否验证通过（调用者代表表单元素的jQuery对象）。
     * @method isValid
     * @param  {Boolean} hideMsg=false 校验的时候是否只作校验不提示错误
     * @return {Boolean}
     */
    $.fn.isValid = function(hideMsg) {
        var me = getInstance(this[0]),
            ret, opt;

        if (!me) return true;
        me.checkOnly = !!hideMsg;
        opt = me.options;

        me.submiting=true;
        ret = me._multiValidate(
            this.is(':input') ? this : this.find(':verifiable'),
            function(isValid) {
                if (!isValid) {
                     if (opt.focusInvalid && !me.checkOnly) {
                         // navigate to the error element
                         me.$el.find(':input[aria-invalid="true"]:first').focus();
                     }
                    isFunction(opt['invalid']) && opt['invalid'].call(me, me.errors);
                }
                me.submiting=false;
                me.checkOnly = false;
            }
        );
        return ret;
    };

    /**
     * 取消某个字段的验证（调用者代表表单元素的jQuery对象）。
     * @method resetElement
     */
    $.fn.resetElement = function() {
        var me = getInstance(this[0]);
        me._resetElement(this);
    };

    // A faster selector than ":input:not(:submit,:button,:reset,:image,:disabled,[novalidate])"
    $.expr[":"].verifiable = function(elem) {
        var name = elem.nodeName.toLowerCase();

        return (name === 'input' && !({
                submit: 1,
                button: 1,
                reset: 1,
                image: 1
            })[elem.type] || name === 'select' || name === 'textarea') &&
            elem.disabled === false;
    };


    // Constructor for Validator
    function Validator(element, options) {
        var me = this;

        if (!me instanceof Validator) return new Validator(element, options);

        me.$el = $(element);
        me._init(element, options);
    }

    Validator.prototype = {
        _init: function(element, options) {
            var me = this,
                opt, themeOpt, dataOpt;

            // Initialization options
            if (isFunction(options)) {
                options = {
                    valid: options
                };
            }
            options = options || {};
            dataOpt = attr(element, 'data-validator-option');
            dataOpt = dataOpt && dataOpt.charAt(0) === '{' ? (new Function("return " + dataOpt))() : {};
            themeOpt = themes[options.theme || dataOpt.theme || defaults.theme];
            opt = me.options = $.extend({}, defaults, themeOpt, dataOpt, me.options, options);

            me.rules = new Rules(opt.rules, true);
            me.messages = new Messages(opt.messages, true);
            me.elements = me.elements || {};
            // me.deferred = {};
            me.errors = {};
            me.fields = {};

            // Initialization fields
            me._initFields(opt.fields);

            // Initialization group verification
            if (isArray(opt.groups)) {
                $.map(opt.groups, function(obj) {
                    if (!isString(obj.fields) || !isFunction(obj.callback)) return null;
                    obj.$elems = me.$el.find(keys2selector(obj.fields));
                    $.map(obj.fields.split(' '), function(k) {
                        me.fields[k] = me.fields[k] || {};
                        me.fields[k].group = obj;
                    });
                });
            }

            // Initialization message parameters
            me.msgOpt = {
                type: 'error',
                pos: getPos(opt.msgClass),
                wrapper: opt.msgWrapper,
                cls: opt.msgClass,
                style: opt.msgStyle,
                icon: opt.msgIcon,
                arrow: opt.msgArrow,
                show: opt.msgShow,
                hide: opt.msgHide
            };

            // Guess whether it use ajax submit
            me.isAjaxSubmit = false;
            if (opt.valid || !$.trim(attr(element, 'action'))) {
                me.isAjaxSubmit = true;
            } else {
                // if there is a "valid.form" event
                var events = $[$._data ? '_data' : 'data'](element, "events");
                if (events && events.valid &&
                    $.map(events.valid, function(e) {
                        return e.namespace.indexOf('form') !== -1 ? 1 : null;
                    }).length
                ) {
                    me.isAjaxSubmit = true;
                }
            }

            // Initialization events and make a cache
            if (!me.$el.data('validator')) {
                me.$el.data('validator', me).addClass('ui-validator ' + opt.formClass)
                    // .on('submit.validator validate.validator', proxy(me, '_submit'))
                    .on('reset.validator', proxy(me, '_reset'))
                    .on('showtip.validator', proxy(me, '_showTip'))
                    .on('focusin.validator click.validator showtip.validator', ':verifiable', proxy(me, '_focusin'))
                    .on('focusout.validator validate.validator', ':verifiable', proxy(me, '_focusout'));

                if (opt.timely >= 2) {
                    me.$el.on('keyup.validator paste.validator', ':verifiable', proxy(me, '_focusout'))
                        .on('click.validator', ':radio,:checkbox', proxy(me, '_focusout'))
                        .on('change.validator', 'select,input[type="file"]', proxy(me, '_focusout'));
                }

                // cache the novalidate attribute value
                me._novalidate = attr(element, 'novalidate');
                // Initialization is complete, stop off default HTML5 form validation
                // If use "jQuery.attr('novalidate')" in IE7 will complain: "SCRIPT3: Member not found."
                attr(element, 'novalidate', 'novalidate');
            }
        },

        _initFields: function(fields) {
            var me = this;

            // Processing field information
            if (isObject(fields)) {
                $.each(fields, function(k, v) {
                    // delete the field from settings
                    if (v === null) {
                        var el = me.elements[k];
                        if (el) me._resetElement(el, true);
                        delete me.fields[k];
                    } else {
                        me.fields[k] = isString(v) ? {
                            rule: v
                        } : v;
                    }
                });
            }

            // Parsing DOM rules
            me.$el.find(':verifiable').each(function() {
                me._parse(this);
            });
        },

        // Parsing a field
        _parse: function(el) {
            var me = this,
                field,
                key = el.name,
                dataRule = attr(el, 'data-rule');

            dataRule && attr(el, 'data-rule', null);

            // if the field has passed the key as id mode, or it doesn't has a name
            if (el.id && ('#' + el.id in me.fields) || !el.name) {
                key = '#' + el.id;
            }
            // doesn't verify a field that has neither id nor name
            if (!key) return;

            field = me.fields[key] || {};
            field.key = key;
            field.old = {};
            field.rule = field.rule || dataRule || '';
            if (!field.rule) return;

            if (field.rule.match(/match|checked/)) {
                field.must = true;
            }
            if (field.rule.indexOf('required') !== -1) {
                field.required = true;
                attr(el, 'aria-required', true);
            }
            if ('timely' in field && !field.timely || !me.options.timely) {
                attr(el, 'notimely', true);
            }
            if (isString(field.target)) {
                attr(el, 'data-target', field.target);
            }
            if (isString(field.tip)) {
                attr(el, 'data-tip', field.tip);
            }

            me.fields[key] = me._parseRule(field);
        },

        // Parsing field rules
        _parseRule: function(field) {
            var arr = rDisplay.exec(field.rule),
                opt = this.options;

            if (!arr) return;
            // current rule index
            field._i = 0;
            if (arr[1]) {
                field.display = arr[1];
            }
            if (!field.display && opt.display) {
                field.display = opt.display;
            }
            if (arr[2]) {
                field.rules = [];
                arr[2].replace(rRules, function() {
                    var args = arguments;
                    args[3] = args[3] || args[4];
                    field.rules.push({
                        not: args[1] === "!",
                        method: args[2],
                        params: args[3] ? args[3].split(', ') : undefined,
                        or: args[5] === "|"
                    });
                });
            }

            return field;
        },

        // Verify a zone
        _multiValidate: function($inputs, doneCallbacks) {
            var me = this,
                opt = me.options;

            // me.verifying = true;
            me.isValid = true;
            if (opt.ignore) $inputs = $inputs.not(opt.ignore);

            $inputs.each(function(i, el) {
                var field = me.getField(el);
                if (field) {
                    me._validate(el, field);
                    if (!me.isValid && opt.stopOnError) {
                        // stop the verification
                        return false;
                    }
                }
            });

            // Need to wait for the completion of all field validation (especially asynchronous verification)
            // $.when.apply(
            //     null,
            //     $.map(me.deferred, function(v) {
            //         return v;
            //     })
            // ).done(function() {
                doneCallbacks.call(me, me.isValid);
                // me.verifying = false;
            // });

            // If the form does not contain asynchronous validation, the return value is correct.
            // Otherwise, you should detect whether a form valid through "doneCallbacks".
            return me.isValid;
        },

        _reset: function(e) {
            var me = this;

            me.errors = {};
            if (e) {
                me.$el.find(':verifiable').each(function(i, el) {
                    me._resetElement(el);
                });
            }
        },

        _resetElement: function(el, all) {
            var opt = this.options;
            $(el).removeClass(opt.validClass + ' ' + opt.invalidClass);
            this.hideMsg(el);
            if (all) {
                attr(el, 'aria-required', null);
            }
        },

        _focusin: function(e) {
            var me = this,
                opt = me.options,
                el = e.target,
                msg;

            if (me.verifying) return;

            if (e.type !== 'showtip') {
                if (attr(el, 'data-inputstatus') === 'error') {
                    if (opt.focusCleanup) {
                        $(el).removeClass(opt.invalidClass);
                        me.hideMsg(el);
                    }
                }
            }

            msg = attr(el, 'data-tip');
            if (!msg) return;

            me.showMsg(el, {
                type: 'tip',
                msg: msg
            });
        },

        // Handle focusout/validate/keyup/click/change/paste events
        _focusout: function(e) {
            var me = this,
                opt = me.options,
                field,
                must,
                el = e.target,
                etype = e.type,
                ignoreType = {
                    click: 1,
                    change: 1,
                    paste: 1
                },
                timer = 0;

            if (!ignoreType[etype]) {
                // must be verified, if it is a manual trigger
                if (etype === 'validate') {
                    must = true;
                    //timer = 0;
                }
                // or doesn't require real-time verification, exit
                else if (attr(el, 'notimely')) return;
                // or it isn't a "keyup" event, exit
                else if (opt.timely >= 2 && etype !== 'keyup') return;

                // if the current field is ignored, exit
                if (opt.ignore && $(el).is(opt.ignore)) return;

                if (etype === 'keyup') {
                    var key = e.keyCode,
                        specialKey = {
                            8: 1, // Backspace
                            9: 1, // Tab
                            16: 1, // Shift
                            32: 1, // Space
                            46: 1 // Delete
                        };

                    // only gets focus, no verification
                    if (key === 9 && !el.value) return;

                    // do not validate, if triggered by these keys
                    if (key < 48 && !specialKey[key]) return;

                    // keyboard events, reducing the frequency of verification
                    timer = opt.timely >= 100 ? opt.timely : 500;
                }
            }

            field = me.getField(el);
            if (!field) return;

            if (timer) {
                if (field._t) clearTimeout(field._t);
                field._t = setTimeout(function() {
                    me._validate(el, field, must);
                }, timer);
            } else {
                me._validate(el, field, must);
            }
        },

        _showTip: function(e) {
            var me = this;

            if (me.$el[0] !== e.target) return;
            me.$el.find(":verifiable[data-tip]").each(function() {
                me.showMsg(this, {
                    msg: attr(this, 'data-tip'),
                    type: 'tip'
                });
            });
        },

        // Validated a field
        _validatedField: function(el, field, ret) {
            var me = this,
                opt = me.options,
                isValid = ret.isValid = field.isValid = !!ret.isValid,
                callback = isValid ? 'valid' : 'invalid';

            ret.key = field.key;
            ret.rule = field._r;
            if (isValid) {
                ret.type = 'ok';
            } else {
                if (me.submiting) {
                    me.errors[field.key] = ret.msg;
                }
                me.isValid = false;
            }
            field.old.value = el.value;
            field.old.id = el.id;
            me.elements[field.key] = ret.element = el;
            me.$el[0].isValid = isValid ? me.isFormValid() : isValid;

            // trigger callback and event
            isFunction(field[callback]) && field[callback].call(me, el, ret);
            $(el).attr('aria-invalid', isValid ? null : true)
                .removeClass(isValid ? opt.invalidClass : opt.validClass)
                .addClass(!ret.skip ? isValid ? opt.validClass : opt.invalidClass : "")
                .trigger(callback + ".field", [ret, me]);
            me.$el.triggerHandler('validation', [ret, me]);

            if (me.checkOnly) return;

            // show or hide the message
            if (field.msgMaker || opt.msgMaker) {
                me[ret.showOk || ret.msg ? 'showMsg' : 'hideMsg'](el, ret, field);
            }
        },

        // Validated a rule
        _validatedRule: function(el, field, ret, msgOpt) {
            field = field || me.getField(el);
            msgOpt = msgOpt || {};

            var me = this,
                opt = me.options,
                msg,
                rule,
                method = field._r,
                transfer,
                isValid = false;

            // use null to break validation from a field
            if (ret === null) {
                me._validatedField(el, field, {
                    isValid: true,
                    skip: true
                });
                return;
            } else if (ret === true || ret === undefined || ret === '') {
                isValid = true;
            } else if (isString(ret)) {
                msg = ret;
            } else if (isObject(ret)) {
                if (ret.error) {
                    msg = ret.error;
                } else {
                    msg = ret.ok;
                    isValid = true;
                }
            }

            if (field.rules) {
                rule = field.rules[field._i];
                if (rule.not) {
                    msg = undefined;
                    isValid = method === "required" || !isValid;
                }
                if (rule.or) {
                    if (isValid) {
                        while (field._i < field.rules.length && field.rules[field._i].or) {
                            field._i++;
                        }
                    } else {
                        transfer = true;
                    }
                }
            }

            // message analysis, and throw rule level event
            if (!transfer) {
                if (isValid) {
                    msgOpt.isValid = isValid;
                    if (opt.showOk !== false) {
                        if (!isString(msg)) {
                            if (isString(field.ok)) {
                                msg = field.ok;
                            } else if (isString(attr(el, 'data-ok'))) {
                                msg = attr(el, 'data-ok');
                            } else if (isString(opt.showOk)) {
                                msg = opt.showOk;
                            }
                        }
                        if (isString(msg)) {
                            msgOpt.showOk = isValid;
                            msgOpt.msg = msg;
                        }
                    }
                    $(el).trigger('valid.rule', [method, msgOpt.msg]);
                } else {
                    /* rule message priority:
                        1. custom field message;
                        2. custom DOM message
                        3. global defined message;
                        4. rule returned message;
                        5. default message;
                    */
                    msgOpt.msg = (getDataMsg(el, field, msg, me.messages[method]) || defaults.defaultMsg).replace('{0}', me._getDisplay(el, field.display || ''));
                    $(el).trigger('invalid.rule', [method, msgOpt.msg]);
                }
            }

            // output the debug message
            if (opt.debug) {
                debug.log('   ' + field._i + ': ' + method + ' => ' + (isValid || msgOpt.msg || isValid));
            }

            // the current rule has passed, continue to validate
            if (transfer || isValid && field._i < field.rules.length - 1) {
                field._i++;
                me._checkRule(el, field);
            }
            // field was invalid, or all fields was valid
            else {
                field._i = 0;
                me._validatedField(el, field, msgOpt);
            }
        },

        // Verify a rule form a field
        _checkRule: function(el, field) {
            var me = this,
                ret,
                old,
                key = field.key,
                rule = field.rules[field._i],
                method = rule.method,
                params = rule.params;

            // request has been sent, wait it
            // if (me.submiting && me.deferred[key]) return;
            old = field.old;
            field._r = method;

            if (!field.must && old.ret !== undefined &&
                old.rule === rule && old.id === el.id &&
                el.value && old.value === el.value) {
                // get result from cache
                ret = old.ret;
            } else {
                // get result from current rule
                ret = (getDataRule(el, method) || me.rules[method] || noop).call(me, el, params, field);
            }

            me._validatedRule(el, field, ret);
        },

        // Processing the validation
        _validate: function(el, field) {
            // doesn't validate the element that has "disabled" or "novalidate" attribute
            if (el.disabled || attr(el, 'novalidate') !== null) return;

            var me = this,
                msgOpt = {},
                group = field.group,
                ret,
                isValid = field.isValid = true;

            if (!field.rules) me._parse(el);
            if (me.options.debug) debug.info(field.key);

            // group validation
            if (group) {
                ret = group.callback.call(me, group.$elems);
                if (ret !== undefined) {
                    me.hideMsg(group.target, {}, field);
                    if (ret === true) ret = undefined;
                    else {
                        field._i = 0;
                        field._r = 'group';
                        isValid = false;
                        me.hideMsg(el, {}, field);
                        $.extend(msgOpt, group);
                    }
                }
            }
            // if the field is not required and it has a blank value
            if (isValid && !field.required && !field.must && !el.value) {
                if (attr(el, 'data-inputstatus') === 'tip') {
                    return;
                }
                if (!checkable(el)) {
                    me._validatedField(el, field, {
                        isValid: true
                    });
                    return;
                }
            }

            // if the results are out
            if (ret !== undefined) {
                me._validatedRule(el, field, ret, msgOpt);
            } else if (field.rule) {
                me._checkRule(el, field);
            }
        },

        /* Detecting whether the value of an element that matches a rule
         *
         * @interface: test
         */
        test: function(el, rule) {
            var me = this,
                ret,
                parts = rRule.exec(rule),
                method,
                params;

            if (parts) {
                method = parts[1];
                if (method in me.rules) {
                    params = parts[2] || parts[3];
                    params = params ? params.split(', ') : undefined;
                    ret = me.rules[method].call(me, el, params);
                }
            }

            return ret === true || ret === undefined || ret === null;
        },

        // Get a range of validation messages
        getRangeMsg: function(value, params, type, suffix) {
            if (!params) return;

            var me = this,
                msg = me.messages[type] || '',
                p = params[0].split('~'),
                a = p[0],
                b = p[1],
                c = 'rg',
                args = [''],
                isNumber = +value === +value;

            if (p.length === 2) {
                if (a && b) {
                    if (isNumber && value >= +a && value <= +b) return true;
                    args = args.concat(p);
                } else if (a && !b) {
                    if (isNumber && value >= +a) return true;
                    args.push(a);
                    c = 'gte';
                } else if (!a && b) {
                    if (isNumber && value <= +b) return true;
                    args.push(b);
                    c = 'lte';
                }
            } else {
                if (value === +a) return true;
                args.push(a);
                c = 'eq';
            }

            if (msg) {
                if (suffix && msg[c + suffix]) {
                    c += suffix;
                }
                args[0] = msg[c];
            }

            return me.renderMsg.apply(null, args);
        },

        /* @interface: renderMsg
         */
        renderMsg: function() {
            var args = arguments,
                tpl = args[0],
                i = args.length;

            if (!tpl) return;

            while (--i) {
                tpl = tpl.replace('{' + i + '}', args[i]);
            }

            return tpl;
        },

        _getDisplay: function(el, str) {
            return !isString(str) ? isFunction(str) ? str.call(this, el) : '' : str;
        },

        _getMsgOpt: function(obj) {
            return $.extend({}, this.msgOpt, isString(obj) ? {
                msg: obj
            } : obj);
        },

        _getMsgDOM: function(el, msgOpt) {
            var $el = $(el),
                $msgbox, datafor, tgt;

            if ($el.is(':input')) {
                tgt = msgOpt.target || attr(el, 'data-target');
                if (tgt) {
                    tgt = isFunction(tgt) ? tgt.call(this, el) : this.$el.find(tgt);
                    if (tgt.length) {
                        if (tgt.is(':input')) {
                            el = tgt.get(0);
                        } else {
                            $msgbox = tgt;
                        }
                    }
                }
                if (!$msgbox) {
                    datafor = !checkable(el) && el.id ? el.id : el.name;
                    $msgbox = this.$el.find(msgOpt.wrapper + '.msg-box' + '[for="' + datafor + '"]');
                }
            } else {
                $msgbox = $el;
            }

            if (!$msgbox.length) {
                $el = this.$el.find(tgt || el);
                $msgbox = $('<' + msgOpt.wrapper + '>').attr({
                    'class': 'msg-box' + (msgOpt.cls ? ' ' + msgOpt.cls : ''),
                    'style': msgOpt.style || '',
                    'for': datafor
                });
                if (checkable(el)) {
                    var $parent = $el.parent();
                    $msgbox[!msgOpt.pos || msgOpt.pos === 'right' ? 'insertAfter' : 'insertBefore']($parent.is('label') ? $parent : $el);
                    // $msgbox.appendTo($parent.is('label') ? $parent.parent() : $parent);
                } else {
                    $msgbox[!msgOpt.pos || msgOpt.pos === 'right' ? 'insertAfter' : 'insertBefore']($el);
                }
            }

            return $msgbox;
        },

        /* @interface: showMsg
         */
        showMsg: function(el, msgOpt, /*INTERNAL*/ field) {
            var me = this,
                opt = me.options,
                msgMaker;
            msgOpt = me._getMsgOpt(msgOpt);
            if (!msgOpt.msg && !msgOpt.showOk) return;
            el = $(el).get(0);

            if ($(el).is(':verifiable')) {
                // mark message status
                attr(el, 'data-inputstatus', msgOpt.type);
                field = field || me.getField(el);
                if (field) {
                    msgOpt.style = field.msgStyle || msgOpt.style;
                    msgOpt.cls = field.msgClass || msgOpt.cls;
                    msgOpt.wrapper = field.msgWrapper || msgOpt.wrapper;
                    msgOpt.target = field.target || opt.target;
                }
            }
            if (!(msgMaker = (field || {}).msgMaker || opt.msgMaker)) return;

            var $msgbox = me._getMsgDOM(el, msgOpt),
                cls = $msgbox[0].className;

            !rPos.test(cls) && $msgbox.addClass(msgOpt.cls);
            // if (isIE6 && msgOpt.pos === 'bottom') {
            //     $msgbox[0].style.marginTop = $(el).outerHeight() + 'px';
            // }
            $msgbox.html(msgMaker.call(me, msgOpt))[0].style.display = '';

            isFunction(msgOpt.show) && msgOpt.show.call(me, $msgbox, msgOpt.type);
        },

        /* @interface: hideMsg
         */
        hideMsg: function(el, msgOpt, /*INTERNAL*/ field) {
            var me = this,
                opt = me.options;

            el = $(el).get(0);
            msgOpt = me._getMsgOpt(msgOpt);
            if ($(el).is(':verifiable')) {
                attr(el, 'data-inputstatus', null);
                attr(el, 'aria-invalid', null);
                field = field || me.getField(el);
                if (field) {
                    msgOpt.wrapper = field.msgWrapper || msgOpt.wrapper;
                    msgOpt.target = field.target || opt.target;
                }
            }

            var $msgbox = me._getMsgDOM(el, msgOpt);
            if (!$msgbox.length) return;

            if (isFunction(msgOpt.hide)) {
                msgOpt.hide.call(me, $msgbox, msgOpt.type);
            } else {
                $msgbox[0].style.display = 'none';
            }
        },

        /* @interface: mapMsg
         */
        mapMsg: function(obj) {
            var me = this;

            $.each(obj, function(name, msg) {
                var el = me.elements[name] || me.$el.find(':input[name="' + name + '"]')[0];
                me.showMsg(el, msg);
            });
        },

        /* @interface: setMsg
         */
        setMsg: function(obj) {
            new Messages(obj, this.messages);
        },

        /* @interface: setRule
         */
        setRule: function(obj) {
            new Rules(obj, this.rules);
            $.map(this.fields, function(field) {
                field.old = {};
            });
        },

        // Get field information
        getField: function(el) {
            var me = this,
                key;

            if (el.id && '#' + el.id in me.fields || !el.name) {
                key = '#' + el.id;
            } else {
                key = el.name;
            }
            if (attr(el, 'data-rule')) me._parse(el);

            return me.fields[key];
        },

        /* @interface: setField
         */
        setField: function(key, obj) {
            var fields = {};

            // update this field
            if (isString(key)) {
                fields[key] = obj;
            }
            // update fields
            else if (isObject(key)) {
                fields = key;
            }

            this._initFields(fields);
        },


        isFormValid: function() {
            var fields = this.fields;
            for (var k in fields) {
                if (!fields[k].isValid) {
                    return fields[k].isValid;
                }
            }
            return true;
        },

        /**
         * 调用该方法后，会清除表单中已经显示的验证消息。
         * @method cleanUp
         */
        cleanUp: function() {
            this._reset(1);
        },

        /**
         * 调用该方法后，会清除表单中已经显示的验证消息。
         * @method destroy
         */
        destroy: function() {
            this._reset(1);
            this.$el.off(CLS_NS).removeData(NS);
            attr(this.$el[0], 'novalidate', this._novalidate);
        }
    };


    // Rule class
    function Rules(obj, context) {
        var that = context ? context === true ? this : context : Rules.prototype;

        if (!isObject(obj)) return;

        for (var k in obj) {
            that[k] = getRule(obj[k]);
        }
    }

    // Message class
    function Messages(obj, context) {
        var that = context ? context === true ? this : context : Messages.prototype;

        if (!isObject(obj)) return;

        for (var k in obj) {
            if (!obj[k]) return;
            that[k] = obj[k];
        }
    }

    // Rule converted factory
    function getRule(fn) {
        switch ($.type(fn)) {
            case 'function':
                return fn;
            case 'array':
                return function(el) {
                    return fn[0].test(el.value) || fn[1] || false;
                };
            case 'regexp':
                return function(el) {
                    return fn.test(el.value);
                };
        }
    }

    // Convert space-separated keys to jQuery selector
    function keys2selector(keys) {
        var selector = '';

        $.map(keys.split(' '), function(k) {
            selector += ',' + (k.charAt(0) === '#' ? k : '[name="' + k + '"]');
        });

        return selector.substring(1);
    }

    // Get instance by an element
    function getInstance(el) {
        var wrap;

        if (!el || !el.tagName) return;
        switch (el.tagName) {
            case 'INPUT':
            case 'SELECT':
            case 'TEXTAREA':
            case 'BUTTON':
            case 'FIELDSET':
                wrap = el.form || $(el).closest('.ui-validator');
                break;
            case 'FORM':
                wrap = el;
                break;
            default:
                wrap = $(el).closest('.ui-validator');
        }

        return $(wrap).data(NS) || $(wrap)[NS]().data(NS);
    }

    function initByInput(e) {

        var el = e.currentTarget,
            me;
        if (!el.form || attr(el.form, 'novalidate') !== null) return;

        me = getInstance(el);
        if (me) {
            me._parse(el);
            me['_' + e.type](e);
        } else {
            attr(el, 'data-rule', null);
        }
    }

    // Get custom rules on the node
    function getDataRule(el, method) {
        var fn = $.trim(attr(el, 'data-rule-' + method));

        if (!fn) return;
        fn = (new Function("return " + fn))();
        if (fn) return getRule(fn);
    }

    // Get custom messages on the node
    function getDataMsg(el, field, ret, m) {
        var msg = field.msg,
            item = field._r;

        if (isObject(msg)) msg = msg[item];
        if (!isString(msg)) {
            msg = attr(el, 'data-msg-' + item) || attr(el, 'data-msg') || ret || (m ? isString(m) ? m : m[item] : '');
        }

        return msg;
    }

    // Get message position
    function getPos(str) {
        var pos;

        if (str) pos = rPos.exec(str);
        return pos ? pos[1] : '';
    }

    // Check whether the element is checkbox or radio
    function checkable(el) {
        return el.tagName === 'INPUT' && el.type === 'checkbox' || el.type === 'radio';
    }

    // parse date string to timestamp
    function parseDate(str) {
        return Date.parse(str.replace(/\.|\-/g, '/'));
    }


    // Global events
    // $(document)
    //     .on('focusin', ':input[data-rule]', function(e) {
    //         initByInput(e);
    //     })
        // .on('click', 'input,button', function(e) {
        //     var input = this,
        //         name = input.name;
        //     if (!input.form) return;

        //     if (input.type === 'submit') {
        //         submitButton = input;
        //         if (attr(input, 'novalidate') !== null) {
        //             novalidateonce = true;
        //         }
        //     } else if (name && checkable(input)) {
        //         var elem = input.form.elements[name];
        //         if (elem.length) elem = elem[0];
        //         if (attr(elem, 'data-rule')) {
        //             initByInput(e);
        //         }
        //     }
        // })
        // .on('submit validate', 'form', function(e) {
        //     if (attr(this, 'novalidate') !== null) return;

        //     var $form = $(this),
        //         me;

        //     if (!$form.data('validator')) {
        //         me = $form.validator().data('validator');
        //         if (!$.isEmptyObject(me.fields)) {
        //             me._submit(e);
        //         } else {
        //             attr(this, 'novalidate', 'novalidate');
        //             $form.off('.validator').removeData('validator');
        //         }
        //     }
        // });

    // Built-in rules (global)
    new Rules({
        required: function(element, params) {
            var val = $.trim(element.value),
                isValid = true;

            if (params) {
                if (params.length === 1) {
                    if (!val && !this.test(element, params[0])) {
                        attr(element, 'aria-required', null);
                        return null;
                    } else {
                        attr(element, 'aria-required', true);
                    }
                } else if (params[0] === 'not') {
                    $.map(params.slice(1), function(v) {
                        if (val === $.trim(v)) {
                            isValid = false;
                        }
                    });
                }
            }
            return isValid && !!val;
        },

        integer: function(element, params) {
            var re, z = '0|',
                p = '[1-9]\\d*',
                key = params ? params[0] : '*';

            switch (key) {
                case '+':
                    re = p;
                    break;
                case '-':
                    re = '-' + p;
                    break;
                case '+0':
                    re = z + p;
                    break;
                case '-0':
                    re = z + '-' + p;
                    break;
                default:
                    re = z + '-?' + p;
            }
            re = '^(?:' + re + ')$';
            return new RegExp(re).test(element.value) || this.messages.integer[key];
        },

        match: function(element, params, field) {
            if (!params) return;
            var me = this,
                a, b,
                key, msg, type = 'eq',
                selector2, elem2, field2;
            if (params.length === 1) {
                key = params[0];
            } else {
                type = params[0];
                key = params[1];
            }
            selector2 = key.charAt(0) === '#' ? key : ':input[name="' + key + '"]';
            elem2 = me.$el.find(selector2)[0];
            // If the compared field is not exist
            if (!elem2) return;
            field2 = me.getField(elem2);
            a = element.value;
            b = elem2.value;

            if (!field._match) {
                me.$el.on('valid.field' + CLS_NS, selector2, function() {
                    $(element).trigger('validate');
                });
                field._match = field2._match = 1;
            }

            // If both fields are blank
            if (!field.required && a === "" && b === "") {
                return null;
            }

            if (params[2]) {
                if (params[2] === 'date') {
                    a = parseDate(a);
                    b = parseDate(b);
                } else if (params[2] === 'time') {
                    a = +a.replace(':', '');
                    b = +b.replace(':', '');
                }
            }

            // If the compared field is incorrect, we only ensure that this field is correct.
            if (type !== "eq" && !isNaN(+a) && isNaN(+b)) {
                return true;
            }

            msg = me.messages.match[type].replace('{1}', me._getDisplay(element, field2.display || key));

            switch (type) {
                case 'lt':
                    return (+a < +b) || msg;
                case 'lte':
                    return (+a <= +b) || msg;
                case 'gte':
                    return (+a >= +b) || msg;
                case 'gt':
                    return (+a > +b) || msg;
                case 'neq':
                    return (a !== b) || msg;
                default:
                    return (a === b) || msg;
            }
        },

        range: function(element, params) {
            return this.getRangeMsg(+element.value, params, 'range');
        },

        checked: function(element, params, field) {
            if (!checkable(element)) return;

            var me = this,
                elem, count;

            count = me.$el.find('input[name="' + element.name + '"]').filter(function() {
                var el = this;
                if (!elem && checkable(el)) elem = el;
                return !el.disabled && el.checked && $(el).is(':visible');
            }).length;

            if (params) {
                return me.getRangeMsg(count, params, 'checked');
            } else {
                return !!count || getDataMsg(elem, field, '') || me.messages.required;
            }
        },

        length: function(element, params) {
            var value = element.value,
                len = (params[1] ? value.replace(rDoubleBytes, 'xx') : value).length;

            return this.getRangeMsg(len, params, 'length', (params[1] ? '_2' : ''));
        },

        remote: function(element, params) {
            if (!params) return;

            var me = this,
                arr = rAjaxType.exec(params[0]),
                url = arr[2],
                type = (arr[1] || 'POST').toUpperCase(),
                search,
                data = {};

            data[element.name] = element.value;
            // There are extra fields
            if (params[1]) {
                $.map(params.slice(1), function(name) {
                    var arr = name.split(':'),
                        selector;
                    name = $.trim(arr[0]);
                    selector = $.trim(arr[1] || '') || name;
                    data[name] = me.$el.find(selector.charAt(0) === '#' ? selector : ':input[name="' + selector + '"]').val();
                });
            }
            data = $.param(data);

            if (type === 'POST') {
                search = url.indexOf('?');
                if (search !== -1) {
                    data += '&' + url.substring(search + 1, url.length);
                    url = url.substring(0, search);
                }
            }

            // Asynchronous validation need to return jqXHR objects
            return $.ajax({
                url: url,
                type: type,
                data: data,
                cache: false
            });
        },

        filter: function(element, params) {
            element.value = element.value.replace(params ? (new RegExp("[" + params[0] + "]", "gm")) : rUnsafe, '');
        }
    });

    Validator.config = function(obj) {
        $.each(obj, function(k, o) {
            if (k === 'rules') {
                new Rules(o);
            } else if (k === 'messages') {
                new Messages(o);
            } else {
                defaults[k] = o;
            }
        });
    };

    // Validator.setTheme = function(name, obj) {
    //     if (isObject(name)) {
    //         $.each(name, function(i, o) {
    //             themes[i] = o;
    //         });
    //     } else if (isString(name) && isObject(obj)) {
    //         themes[name] = obj;
    //     }
    // };

    $.validator = Validator;
    // add i18n
    Validator.config({
        "messages": fish.getResource("validator.msg"),
        "rules": fish.getResource("validator.rules")
    });

    /**
     *每次验证完一个字段，都会触发该事件，此事件需要绑定在form上面，利用此事件可以实时监测表单的验证结果。
     *@event validation
     */

    /**
     *表单验证成功，同options中valid。
     *@event valid-form
     */

    /**
     *表单验证失败，同options中invalid。
     *@event invalid-form
     */

    /**
     *字段验证成功。
     *@event valid-field
     */

    /**
     *字段验证失败。
     *@event invalid-field
     */

    /**
     *字段规则验证成功。
     *@event valid-rule
     */

    /**
     *字段规则验证失败。
     *@event invalid-rule
     */
});

/**
 * @class  fish.desktop.widget.Popover
 * @extends fish.desktop.widget.Tooltip
 */
!function (factory) {
    if (typeof define === 'function' && define.amd) {
        define('fish.popover', ["fish.tooltip"], factory);
    } else {
        factory();
    }
}(function () {
    $.widget("ui.popover", $.ui.tooltip, {
        options: {
            placement: 'bottom',
            trigger: 'click',
            content: '',
            template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
        },

        setContent: function () {
            var $tip = this.tip();
            var title = this.getTitle();
            var content = this.getContent();

            $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);
            $tip.find('.popover-content').children().detach().end()[ // we use append for html objects to maintain js events
                this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'
                ](content);

            $tip.removeClass('fade top bottom left right in');

            // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
            // this manually by checking the contents.
            if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide();
        },

        hasContent: function () {
            return this.getTitle() || this.getContent();
        },

        getContent: function () {
            var $e = this.element;
            var o = this.options;

            return $e.attr('data-content')
                || (typeof o.content == 'function' ?
                    o.content.call($e[0]) :
                    o.content);
        },

        arrow: function () {
            return (this.$arrow = this.$arrow || this.tip().find('.arrow'));
        }
    });
});

/*
 * JQuery zTree core v3.5.17
 * http://zTree.me/
 *
 * Copyright (c) 2010 Hunter.z
 *
 * Licensed same as jquery - MIT License
 * http://www.opensource.org/licenses/mit-license.php
 *
 * email: hunter.z@263.net
 * Date: 2014-05-08
 */

/**
 * @class fish.desktop.widget.tree
 * 树插件
 */

(function(factory){
	if (typeof define === "function" && define.amd) {
		define('fish.tree',['jquery'], factory);
  	} else {
    	factory(jQuery);
	}
}(function($){


	var settings = {}, roots = {}, caches = {},
	//default consts of core
	_consts = {
		className: {
			BUTTON: "button",
			LEVEL: "level",
			ICO_LOADING: "ico_loading",
			SWITCH: "switch"
		},
		event: {
			NODECREATED: "ztree_nodeCreated",
			CLICK: "ztree_click",
			EXPAND: "ztree_expand",
			COLLAPSE: "ztree_collapse",
			ASYNC_SUCCESS: "ztree_async_success",
			ASYNC_ERROR: "ztree_async_error",
			REMOVE: "ztree_remove"
		},
		id: {
			A: "_a",
			ICON: "_ico",
			SPAN: "_span",
			SWITCH: "_switch",
			UL: "_ul"
		},
		line: {
			ROOT: "root",
			ROOTS: "roots",
			CENTER: "center",
			BOTTOM: "bottom",
			NOLINE: "noline",
			LINE: "line"
		},
		folder: {
			OPEN: "open",
			CLOSE: "close",
			DOCU: "docu"
		},
		node: {
			CURSELECTED: "curSelectedNode"
		}
	},
	//default setting of core
	_setting = {
		treeId: "",
		treeObj: null,
		/**
		 * @cfg {Object} view 页面展示相关的配置
		 * @cfg {Function} view.addDiyDom 用于在节点上固定显示用户自定义控件;函数有两个入参，依次是treeId和节点的数据
		 * @cfg {Boolean} [view.autoCancelSelected=true] 点击节点时，按下 Ctrl 或 Cmd 键是否允许取消选择操作。true / false 分别表示 支持 / 不支持 配合 Ctrl 或 Cmd 键进行取消节点选择的操作
		 * @cfg {Boolean} [view.dblClickExpand=true] 双击节点时，是否自动展开父节点的标识
		 * @cfg {Object} view.fontCss 个性化文字样式，只针对 zTree 在节点上显示的A对象，例如：{color:"#ff0011", background:"blue"} 
		 * @cfg {Boolean} [view.nameIsHTML=false] 设置 name 属性是否支持 HTML 脚本
		 * @cfg {Boolean} [view.selectedMulti=true] 设置是否允许同时选中多个节点。
		 * @cfg {Boolean} [view.showIcon=true] 设置 是否显示节点的图标。也可以传入一个函数，返回true或者false。函数有两个入参，第一个是tree的id，第二个是节点的数据
		 * @cfg {Boolean} [view.showLine=true]  设置 是否显示节点之间的连线。
		 * @cfg {Boolean} [view.showTitle=true] 设置 是否显示节点的 title 提示信息(即节点 DOM 的 title 属性)。
		 * true / false 分别表示 显示 / 隐藏 提示信息
		 * 如果 options.view.showTitle = true & options.data.key.title = '',tree 会自动使用 options.data.key.name 指定的节点名称当做 title
		 * showTitle 也可以传入一个函数，通过函数的返回值确定某个节点是否应该显示title，函数有两个入参，第一个是tree的id，第二个是节点的数据 
		 * @cfg {Boolean} [view.txtSelectedEnable=false] 设置 是否允许可以选择 tree DOM 内的文本,默认不可选择
		 */	
		view: {
			addDiyDom: null,
			autoCancelSelected: true,
			dblClickExpand: true,
			expandSpeed: "fast",
			fontCss: {},
			nameIsHTML: false,
			selectedMulti: true,
			showIcon: true,
			showLine: true,
			showTitle: true,
			txtSelectedEnable: false
		},
		/**
		 * @cfg {Object} data 数据相关的配置
		 * @cfg {Object} data.key 数据相关的键值
		 * @cfg {String} [data.key.children="children"] 节点数据中保存子节点数据的属性名称。
		 * @cfg {String} [data.key.name="name"]  节点数据保存节点名称的属性名称,
		 * @cfg {String} [data.key.title=""]  节点数据保存节点提示信息的属性名称。[options.view.showTitle = true 时生效];如果设置为 "" ，则自动与 options.data.key.name 保持一致，避免用户反复设置
		 * @cfg {String} [data.key.url="url"]  节点数据保存节点链接的目标 URL 的属性名称。特殊用途：当后台数据只能生成 url 属性，又不想实现点击节点跳转的功能时，可以直接修改此属性为其他不存在的属性名称
		 *
		 * @cfg {Object} data.simpleData tree使用简单数据格式时相关的设置
		 * @cfg {String} [data.simpleData.enable=false] 设置加载数据、增加节点时传入的数据是否是简单格式，默认为false；如果设置为 true，请务必设置 setting.data.simpleData 内的其他参数: idKey / pIdKey / rootPId，并且让数据满足父子关系。
		 * @cfg {String} [data.simpleData.idKey=id] 节点数据中保存唯一标识的属性名称。[data.simpleData.enable = true 时生效]默认值："id" 
		 * @cfg {String} [data.simpleData.pIdKey=pId] 节点数据中保存其父节点唯一标识的属性名称。[data.simpleData.enable = true 时生效]默认值："pId"
		 * @cfg {String} [data.simpleData.rootPId=null] 用于修正根节点父节点数据，即 pIdKey 指定的属性值。[data.simpleData.enable = true 时生效]默认值：null
		 *
		 * @cfg {Object} [data.keep]
		 * @cfg {Boolean} [data.keep.leaf=false] 节点叶子节点属性锁，是否始终保持 isParent = false;如果设置为 true，则所有 isParent = false 的节点，都无法添加子节点。
		 * @cfg {Boolean} [data.keep.parent=true] 节点父节点属性锁，是否始终保持 isParent = true;如果设置为 true，则所有 isParent = true 的节点，即使该节点的子节点被全部删除或移走，依旧保持父节点状态
		 */
		data: {
			key: {
				children: "children",
				name: "name",
				title: "",
				url: "url"
			},
			simpleData: {
				enable: false,
				idKey: "id",
				pIdKey: "pId",
				rootPId: null
			},
			keep: {
				parent: false,
				leaf: false
			}
		},
		async: {
			enable: false,
			contentType: "application/x-www-form-urlencoded",
			type: "post",
			dataType: "text",
			url: "",
			autoParam: [],
			otherParam: [],
			dataFilter: null
		},
		/**
		 * @cfg {Object} callback 回调函数的配置
		 * @cfg {Function} callback.beforeClick 用于捕获单击节点之前的事件回调函数，并且根据返回值确定是否允许单击操作。函数的参数说明：
		 *		treeNode 被单击的节点 JSON 数据对象
		 *		clickFlag 	节点被点击后的选中操作类型，详细看下表		
		 *		
		 *		clickFlag	selectedMulti	autoCancelSelected && event.ctrlKey / metaKey	isSelected	选中操作
		 *		1				true					false									false	普通选中
		 *		1				true					false									true	普通选中
		 *		2				true					true									false	追加选中
		 *		0				true					true									true	取消选中
		 *		1				false					false									false	普通选中
		 *		1				false					false									true	普通选中
		 *		1				false					true									false	普通选中
		 *		0				false					true									true	取消选中
		 *
		 *		返回值是 true / false
		 *		如果返回 false，tree将不会选中节点，也无法触发 onClick 事件回调函数
		 *      
		 * @cfg {Function} callback.beforeDblClick 用于捕获 tree 上鼠标双击之前的事件回调函数，并且根据返回值确定触发 onDblClick 事件回调函数. Function 参数说明
		 *		treeNode 被单击的节点 JSON 数据对象			 *  	
		 *		返回值是 true / false
		 *		如果返回 false，将仅仅无法触发 onDblClick 事件回调函数，对其他操作无任何影响
		 *		此事件回调函数对双击节点展开功能无任何影响，如果需要设置请参考 view.dblClickExpand 属性
		 *
		 * @cfg {Function} callback.beforeRightClick 用于捕获 tree 上鼠标右键点击之前的事件回调函数，并且根据返回值确定触发 onRightClick 事件回调函数.参数是treeNode
		 * @cfg {Function} callback.beforeMouseDown 
		 * @cfg {Function} callback.beforeMouseUp beforeMouseUp和beforeMouseDown分别用于捕获 tree 上鼠标按键松开之前的事件回调函数，并且根据返回值确定触发 onMouseUp/onMouseDown 事件回调函数。参数是treeId和treeNode(如果不在节点上，这个参数为null)；返回值为true/false
		 * @cfg {Function} callback.beforeExpand 用用于捕获父节点展开之前的事件回调函数，并且根据返回值确定是否允许展开操作。参数是treeNode；返回值为true/false
		 * @cfg {Function} callback.beforeExpand 用用于捕获父节点展开之前的事件回调函数，并且根据返回值确定是否允许展开操作。参数是treeNode；返回值为true/false
		 * @cfg {Function} callback.beforeCollapse 用于捕获父节点折叠之前的事件回调函数，并且根据返回值确定是否允许折叠操作。参数是treeNode；返回值为true/false
		 * @cfg {Function} callback.beforeRemove 用于捕获节点被删除之前的事件回调函数，并且根据返回值确定是否允许删除操作。参数是treeNode；返回值为true/false
		 *
		 * @cfg {Function} callback.onNodeCreated	用于捕获节点生成 DOM 后的事件回调函数。函数参数是:event、treeNode(节点数据)
		 * @cfg {Function} callback.onClick 用于捕获节点被点击的事件回调函数，函数参数
		 *      event 	event对象
		 *      treeNode  被点击的节点 JSON 数据对象
		 *      clickFlagNumber  节点被点击后的选中操作类型，详细看下表		
		 *      
		 *      clickFlag	selectedMulti	autoCancelSelected&&event.ctrlKey / metaKey	isSelected	选中操作
		 *      	1			true				false									false	普通选中
		 *      	1			true				false									true	普通选中
		 *      	2			true				true									false	追加选中
		 *      	0			true				true									true	取消选中
		 *      	1			false				false									false	普通选中
		 *      	1			false				false									true	普通选中
		 *      	1			false				true									false	普通选中
		 *      	0			false				true									true	取消选中
		 * @cfg {Function} callback.onDblClick  用于捕获 tree 上鼠标双击之后的事件回调函数，函数的参数是event、treeNode
		 * @cfg {Function} callback.onRightClick 用于捕获 tree 上鼠标右键点击之后的事件回调函数，函数的参数是event、treeNode
		 * @cfg {Function} callback.onMouseDown 用于捕获  tree上鼠标按键按下后的事件回调函数，函数的参数是event、treeNode
		 * @cfg {Function} callback.onMouseUp 	用于捕获  tree上鼠标按键松开后的事件回调函数,函数的参数是event、treeNode
		 * @cfg {Function} callback.onExpand	用于捕获节点被展开的事件回调函数,函数的参数是event、treeNode
		 * @cfg {Function} callback.onCollapse  用于捕获节点被折叠的事件回调函数,函数的参数是event、treeNode
		 * @cfg {Function} callback.onRemove	用于捕获删除节点之后的事件回调函数,函数的参数是event、treeNode
		 */
		callback: {
			beforeAsync:null,
			beforeClick:null,
			beforeDblClick:null,
			beforeRightClick:null,
			beforeMouseDown:null,
			beforeMouseUp:null,
			beforeExpand:null,
			beforeCollapse:null,
			beforeRemove:null,

			onAsyncError:null,
			onAsyncSuccess:null,
			onNodeCreated:null,
			onClick:null,
			onDblClick:null,
			onRightClick:null,
			onMouseDown:null,
			onMouseUp:null,
			onExpand:null,
			onCollapse:null,
			onRemove:null
		}
	},
	//default root of core
	//zTree use root to save full data
	_initRoot = function (setting) {
		var r = data.getRoot(setting);
		if (!r) {
			r = {};
			data.setRoot(setting, r);
		}
		r[setting.data.key.children] = [];
		r.expandTriggerFlag = false;
		r.curSelectedList = [];
		r.noSelection = true;
		r.createdNodes = [];
		r.zId = 0;
		r._ver = (new Date()).getTime();
	},
	//default cache of core
	_initCache = function(setting) {
		var c = data.getCache(setting);
		if (!c) {
			c = {};
			data.setCache(setting, c);
		}
		c.nodes = [];
		c.doms = [];
	},
	//default bindEvent of core
	_bindEvent = function(setting) {
		var o = setting.treeObj,
		c = consts.event;
		o.bind(c.NODECREATED, function (event, treeId, node) {
			tools.apply(setting.callback.onNodeCreated, [event, treeId, node]);
		});

		o.bind(c.CLICK, function (event, srcEvent, treeId, node, clickFlag) {
			tools.apply(setting.callback.onClick, [srcEvent, treeId, node, clickFlag]);
		});

		o.bind(c.EXPAND, function (event, treeId, node) {
			tools.apply(setting.callback.onExpand, [event, treeId, node]);
		});

		o.bind(c.COLLAPSE, function (event, treeId, node) {
			tools.apply(setting.callback.onCollapse, [event, treeId, node]);
		});

		o.bind(c.ASYNC_SUCCESS, function (event, treeId, node, msg) {
			tools.apply(setting.callback.onAsyncSuccess, [event, treeId, node, msg]);
		});

		o.bind(c.ASYNC_ERROR, function (event, treeId, node, XMLHttpRequest, textStatus, errorThrown) {
			tools.apply(setting.callback.onAsyncError, [event, treeId, node, XMLHttpRequest, textStatus, errorThrown]);
		});

		o.bind(c.REMOVE, function (event, treeId, treeNode) {
			tools.apply(setting.callback.onRemove, [event, treeId, treeNode]);
		});
	},
	_unbindEvent = function(setting) {
		var o = setting.treeObj,
		c = consts.event;
		o.unbind(c.NODECREATED)
		.unbind(c.CLICK)
		.unbind(c.EXPAND)
		.unbind(c.COLLAPSE)
		.unbind(c.ASYNC_SUCCESS)
		.unbind(c.ASYNC_ERROR)
		.unbind(c.REMOVE);
	},
	//default event proxy of core
	_eventProxy = function(event) {
		var target = event.target,
		setting = data.getSetting(event.data.treeId),
		tId = "", node = null,
		nodeEventType = "", treeEventType = "",
		nodeEventCallback = null, treeEventCallback = null,
		tmp = null;

		if (tools.eqs(event.type, "mousedown")) {
			treeEventType = "mousedown";
		} else if (tools.eqs(event.type, "mouseup")) {
			treeEventType = "mouseup";
		} else if (tools.eqs(event.type, "contextmenu")) {
			treeEventType = "contextmenu";
		} else if (tools.eqs(event.type, "click")) {
			if (tools.eqs(target.tagName, "span") && target.getAttribute("treeNode"+ consts.id.SWITCH) !== null) {
				tId = tools.getNodeMainDom(target).id;
				nodeEventType = "switchNode";
			} else {
				tmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);
				if (tmp) {
					tId = tools.getNodeMainDom(tmp).id;
					nodeEventType = "clickNode";
				}
			}
		} else if (tools.eqs(event.type, "dblclick")) {
			treeEventType = "dblclick";
			tmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);
			if (tmp) {
				tId = tools.getNodeMainDom(tmp).id;
				nodeEventType = "switchNode";
			}
		}
		if (treeEventType.length > 0 && tId.length == 0) {
			tmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);
			if (tmp) {tId = tools.getNodeMainDom(tmp).id;}
		}
		// event to node
		if (tId.length>0) {
			node = data.getNodeCache(setting, tId);
			switch (nodeEventType) {
				case "switchNode" :
					if (!node.isParent) {
						nodeEventType = "";
					} else if (tools.eqs(event.type, "click")
						|| (tools.eqs(event.type, "dblclick") && tools.apply(setting.view.dblClickExpand, [setting.treeId, node], setting.view.dblClickExpand))) {
						nodeEventCallback = handler.onSwitchNode;
					} else {
						nodeEventType = "";
					}
					break;
				case "clickNode" :
					nodeEventCallback = handler.onClickNode;
					break;
			}
		}
		// event to zTree
		switch (treeEventType) {
			case "mousedown" :
				treeEventCallback = handler.onZTreeMousedown;
				break;
			case "mouseup" :
				treeEventCallback = handler.onZTreeMouseup;
				break;
			case "dblclick" :
				treeEventCallback = handler.onZTreeDblclick;
				break;
			case "contextmenu" :
				treeEventCallback = handler.onZTreeContextmenu;
				break;
		}
		var proxyResult = {
			stop: false,
			node: node,
			nodeEventType: nodeEventType,
			nodeEventCallback: nodeEventCallback,
			treeEventType: treeEventType,
			treeEventCallback: treeEventCallback
		};
		return proxyResult
	},
	//default init node of core
	_initNode = function(setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {
		if (!n) return;
		var r = data.getRoot(setting),
		childKey = setting.data.key.children;
		n.level = level;
		n.tId = setting.treeId + "_" + (++r.zId);
		n.parentTId = parentNode ? parentNode.tId : null;
		n.open = (typeof n.open == "string") ? tools.eqs(n.open, "true") : !!n.open;
		if (n[childKey] && n[childKey].length > 0) {
			n.isParent = true;
			n.zAsync = true;
		} else {
			n.isParent = (typeof n.isParent == "string") ? tools.eqs(n.isParent, "true") : !!n.isParent;
			n.open = (n.isParent && !setting.async.enable) ? n.open : false;
			n.zAsync = !n.isParent;
		}
		n.isFirstNode = isFirstNode;
		n.isLastNode = isLastNode;
		n.getParentNode = function() {return data.getNodeCache(setting, n.parentTId);};
		n.getPreNode = function() {return data.getPreNode(setting, n);};
		n.getNextNode = function() {return data.getNextNode(setting, n);};
		n.isAjaxing = false;
		data.fixPIdKeyValue(setting, n);
	},
	_init = {
		bind: [_bindEvent],
		unbind: [_unbindEvent],
		caches: [_initCache],
		nodes: [_initNode],
		proxys: [_eventProxy],
		roots: [_initRoot],
		beforeA: [],
		afterA: [],
		innerBeforeA: [],
		innerAfterA: [],
		zTreeTools: []
	},
	//method of operate data
	data = {
		addNodeCache: function(setting, node) {
			data.getCache(setting).nodes[data.getNodeCacheId(node.tId)] = node;
		},
		getNodeCacheId: function(tId) {
			return tId.substring(tId.lastIndexOf("_")+1);
		},
		addAfterA: function(afterA) {
			_init.afterA.push(afterA);
		},
		addBeforeA: function(beforeA) {
			_init.beforeA.push(beforeA);
		},
		addInnerAfterA: function(innerAfterA) {
			_init.innerAfterA.push(innerAfterA);
		},
		addInnerBeforeA: function(innerBeforeA) {
			_init.innerBeforeA.push(innerBeforeA);
		},
		addInitBind: function(bindEvent) {
			_init.bind.push(bindEvent);
		},
		addInitUnBind: function(unbindEvent) {
			_init.unbind.push(unbindEvent);
		},
		addInitCache: function(initCache) {
			_init.caches.push(initCache);
		},
		addInitNode: function(initNode) {
			_init.nodes.push(initNode);
		},
		addInitProxy: function(initProxy, isFirst) {
			if (!!isFirst) {
				_init.proxys.splice(0,0,initProxy);
			} else {
				_init.proxys.push(initProxy);
			}
		},
		addInitRoot: function(initRoot) {
			_init.roots.push(initRoot);
		},
		addNodesData: function(setting, parentNode, nodes) {
			var childKey = setting.data.key.children;
			if (!parentNode[childKey]) parentNode[childKey] = [];
			if (parentNode[childKey].length > 0) {
				parentNode[childKey][parentNode[childKey].length - 1].isLastNode = false;
				view.setNodeLineIcos(setting, parentNode[childKey][parentNode[childKey].length - 1]);
			}
			parentNode.isParent = true;
			parentNode[childKey] = parentNode[childKey].concat(nodes);
		},
		addSelectedNode: function(setting, node) {
			var root = data.getRoot(setting);
			if (!data.isSelectedNode(setting, node)) {
				root.curSelectedList.push(node);
			}
		},
		addCreatedNode: function(setting, node) {
			if (!!setting.callback.onNodeCreated || !!setting.view.addDiyDom) {
				var root = data.getRoot(setting);
				root.createdNodes.push(node);
			}
		},
		addZTreeTools: function(zTreeTools) {
			_init.zTreeTools.push(zTreeTools);
		},
		exSetting: function(s) {
			$.extend(true, _setting, s);
		},
		fixPIdKeyValue: function(setting, node) {
			if (setting.data.simpleData.enable) {
				node[setting.data.simpleData.pIdKey] = node.parentTId ? node.getParentNode()[setting.data.simpleData.idKey] : setting.data.simpleData.rootPId;
			}
		},
		getAfterA: function(setting, node, array) {
			for (var i=0, j=_init.afterA.length; i<j; i++) {
				_init.afterA[i].apply(this, arguments);
			}
		},
		getBeforeA: function(setting, node, array) {
			for (var i=0, j=_init.beforeA.length; i<j; i++) {
				_init.beforeA[i].apply(this, arguments);
			}
		},
		getInnerAfterA: function(setting, node, array) {
			for (var i=0, j=_init.innerAfterA.length; i<j; i++) {
				_init.innerAfterA[i].apply(this, arguments);
			}
		},
		getInnerBeforeA: function(setting, node, array) {
			for (var i=0, j=_init.innerBeforeA.length; i<j; i++) {
				_init.innerBeforeA[i].apply(this, arguments);
			}
		},
		getCache: function(setting) {
			return caches[setting.treeId];
		},
		getNextNode: function(setting, node) {
			if (!node) return null;
			var childKey = setting.data.key.children,
			p = node.parentTId ? node.getParentNode() : data.getRoot(setting);
			for (var i=0, l=p[childKey].length-1; i<=l; i++) {
				if (p[childKey][i] === node) {
					return (i==l ? null : p[childKey][i+1]);
				}
			}
			return null;
		},
		getNodeByParam: function(setting, nodes, key, value) {
			if (!nodes || !key) return null;
			var childKey = setting.data.key.children;
			for (var i = 0, l = nodes.length; i < l; i++) {
				if (nodes[i][key] == value) {
					return nodes[i];
				}
				var tmp = data.getNodeByParam(setting, nodes[i][childKey], key, value);
				if (tmp) return tmp;
			}
			return null;
		},
		getNodeCache: function(setting, tId) {
			if (!tId) return null;
			var n = caches[setting.treeId].nodes[data.getNodeCacheId(tId)];
			return n ? n : null;
		},
		getNodeName: function(setting, node) {
			var nameKey = setting.data.key.name;
			return "" + node[nameKey];
		},
		getNodeTitle: function(setting, node) {
			var t = setting.data.key.title === "" ? setting.data.key.name : setting.data.key.title;
			return "" + node[t];
		},
		getNodes: function(setting) {
			return data.getRoot(setting)[setting.data.key.children];
		},
		getNodesByParam: function(setting, nodes, key, value) {
			if (!nodes || !key) return [];
			var childKey = setting.data.key.children,
			result = [];
			for (var i = 0, l = nodes.length; i < l; i++) {
				if (nodes[i][key] == value) {
					result.push(nodes[i]);
				}
				result = result.concat(data.getNodesByParam(setting, nodes[i][childKey], key, value));
			}
			return result;
		},
		getNodesByParamFuzzy: function(setting, nodes, key, value) {
			if (!nodes || !key) return [];
			var childKey = setting.data.key.children,
			result = [];
			value = value.toLowerCase();
			for (var i = 0, l = nodes.length; i < l; i++) {
				if (typeof nodes[i][key] == "string" && nodes[i][key].toLowerCase().indexOf(value)>-1) {
					result.push(nodes[i]);
				}
				result = result.concat(data.getNodesByParamFuzzy(setting, nodes[i][childKey], key, value));
			}
			return result;
		},
		getNodesByFilter: function(setting, nodes, filter, isSingle, invokeParam) {
			if (!nodes) return (isSingle ? null : []);
			var childKey = setting.data.key.children,
			result = isSingle ? null : [];
			for (var i = 0, l = nodes.length; i < l; i++) {
				if (tools.apply(filter, [nodes[i], invokeParam], false)) {
					if (isSingle) {return nodes[i];}
					result.push(nodes[i]);
				}
				var tmpResult = data.getNodesByFilter(setting, nodes[i][childKey], filter, isSingle, invokeParam);
				if (isSingle && !!tmpResult) {return tmpResult;}
				result = isSingle ? tmpResult : result.concat(tmpResult);
			}
			return result;
		},
		getPreNode: function(setting, node) {
			if (!node) return null;
			var childKey = setting.data.key.children,
			p = node.parentTId ? node.getParentNode() : data.getRoot(setting);
			for (var i=0, l=p[childKey].length; i<l; i++) {
				if (p[childKey][i] === node) {
					return (i==0 ? null : p[childKey][i-1]);
				}
			}
			return null;
		},
		getRoot: function(setting) {
			return setting ? roots[setting.treeId] : null;
		},
		getRoots: function() {
			return roots;
		},
		getSetting: function(treeId) {
			return settings[treeId];
		},
		getSettings: function() {
			return settings;
		},
		getZTreeTools: function(treeId) {
			var r = this.getRoot(this.getSetting(treeId));
			return r ? r.treeTools : null;
		},
		initCache: function(setting) {
			for (var i=0, j=_init.caches.length; i<j; i++) {
				_init.caches[i].apply(this, arguments);
			}
		},
		initNode: function(setting, level, node, parentNode, preNode, nextNode) {
			for (var i=0, j=_init.nodes.length; i<j; i++) {
				_init.nodes[i].apply(this, arguments);
			}
		},
		initRoot: function(setting) {
			for (var i=0, j=_init.roots.length; i<j; i++) {
				_init.roots[i].apply(this, arguments);
			}
		},
		isSelectedNode: function(setting, node) {
			var root = data.getRoot(setting);
			for (var i=0, j=root.curSelectedList.length; i<j; i++) {
				if(node === root.curSelectedList[i]) return true;
			}
			return false;
		},
		removeNodeCache: function(setting, node) {
			var childKey = setting.data.key.children;
			if (node[childKey]) {
				for (var i=0, l=node[childKey].length; i<l; i++) {
					arguments.callee(setting, node[childKey][i]);
				}
			}
			data.getCache(setting).nodes[data.getNodeCacheId(node.tId)] = null;
		},
		removeSelectedNode: function(setting, node) {
			var root = data.getRoot(setting);
			for (var i=0, j=root.curSelectedList.length; i<j; i++) {
				if(node === root.curSelectedList[i] || !data.getNodeCache(setting, root.curSelectedList[i].tId)) {
					root.curSelectedList.splice(i, 1);
					i--;j--;
				}
			}
		},
		setCache: function(setting, cache) {
			caches[setting.treeId] = cache;
		},
		setRoot: function(setting, root) {
			roots[setting.treeId] = root;
		},
		setZTreeTools: function(setting, zTreeTools) {
			for (var i=0, j=_init.zTreeTools.length; i<j; i++) {
				_init.zTreeTools[i].apply(this, arguments);
			}
		},
		transformToArrayFormat: function (setting, nodes) {
			if (!nodes) return [];
			var childKey = setting.data.key.children,
			r = [];
			if (tools.isArray(nodes)) {
				for (var i=0, l=nodes.length; i<l; i++) {
					r.push(nodes[i]);
					if (nodes[i][childKey])
						r = r.concat(data.transformToArrayFormat(setting, nodes[i][childKey]));
				}
			} else {
				r.push(nodes);
				if (nodes[childKey])
					r = r.concat(data.transformToArrayFormat(setting, nodes[childKey]));
			}
			return r;
		},
		transformTozTreeFormat: function(setting, sNodes) {
			var i,l,
			key = setting.data.simpleData.idKey,
			parentKey = setting.data.simpleData.pIdKey,
			childKey = setting.data.key.children;
			if (!key || key=="" || !sNodes) return [];

			if (tools.isArray(sNodes)) {
				var r = [];
				var tmpMap = [];
				for (i=0, l=sNodes.length; i<l; i++) {
					tmpMap[sNodes[i][key]] = sNodes[i];
				}
				for (i=0, l=sNodes.length; i<l; i++) {
					if (tmpMap[sNodes[i][parentKey]] && sNodes[i][key] != sNodes[i][parentKey]) {
						if (!tmpMap[sNodes[i][parentKey]][childKey])
							tmpMap[sNodes[i][parentKey]][childKey] = [];
						tmpMap[sNodes[i][parentKey]][childKey].push(sNodes[i]);
					} else {
						r.push(sNodes[i]);
					}
				}
				return r;
			}else {
				return [sNodes];
			}
		}
	},
	//method of event proxy
	event = {
		bindEvent: function(setting) {
			for (var i=0, j=_init.bind.length; i<j; i++) {
				_init.bind[i].apply(this, arguments);
			}
		},
		unbindEvent: function(setting) {
			for (var i=0, j=_init.unbind.length; i<j; i++) {
				_init.unbind[i].apply(this, arguments);
			}
		},
		bindTree: function(setting) {
			var eventParam = {
				treeId: setting.treeId
			},
			o = setting.treeObj;
			if (!setting.view.txtSelectedEnable) {
				// for can't select text
				o.bind('selectstart', function(e){
					var node
					var n = e.originalEvent.srcElement.nodeName.toLowerCase();
					return (n === "input" || n === "textarea" );
				}).css({
					"-moz-user-select":"-moz-none"
				});
			}
			o.bind('click', eventParam, event.proxy);
			o.bind('dblclick', eventParam, event.proxy);
			o.bind('mouseover', eventParam, event.proxy);
			o.bind('mouseout', eventParam, event.proxy);
			o.bind('mousedown', eventParam, event.proxy);
			o.bind('mouseup', eventParam, event.proxy);
			o.bind('contextmenu', eventParam, event.proxy);
		},
		unbindTree: function(setting) {
			var o = setting.treeObj;
			o.unbind('click', event.proxy)
			.unbind('dblclick', event.proxy)
			.unbind('mouseover', event.proxy)
			.unbind('mouseout', event.proxy)
			.unbind('mousedown', event.proxy)
			.unbind('mouseup', event.proxy)
			.unbind('contextmenu', event.proxy);
		},
		doProxy: function(e) {
			var results = [];
			for (var i=0, j=_init.proxys.length; i<j; i++) {
				var proxyResult = _init.proxys[i].apply(this, arguments);
				results.push(proxyResult);
				if (proxyResult.stop) {
					break;
				}
			}
			return results;
		},
		proxy: function(e) {
			var setting = data.getSetting(e.data.treeId);
			if (!tools.uCanDo(setting, e)) return true;
			var results = event.doProxy(e),
			r = true, x = false;
			for (var i=0, l=results.length; i<l; i++) {
				var proxyResult = results[i];
				if (proxyResult.nodeEventCallback) {
					x = true;
					r = proxyResult.nodeEventCallback.apply(proxyResult, [e, proxyResult.node]) && r;
				}
				if (proxyResult.treeEventCallback) {
					x = true;
					r = proxyResult.treeEventCallback.apply(proxyResult, [e, proxyResult.node]) && r;
				}
			}
			return r;
		}
	},
	//method of event handler
	handler = {
		onSwitchNode: function (event, node) {
			var setting = data.getSetting(event.data.treeId);
			if (node.open) {
				if (tools.apply(setting.callback.beforeCollapse, [setting.treeId, node], true) == false) return true;
				data.getRoot(setting).expandTriggerFlag = true;
				view.switchNode(setting, node);
			} else {
				if (tools.apply(setting.callback.beforeExpand, [setting.treeId, node], true) == false) return true;
				data.getRoot(setting).expandTriggerFlag = true;
				view.switchNode(setting, node);
			}
			return true;
		},
		onClickNode: function (event, node) {
			var setting = data.getSetting(event.data.treeId),
			clickFlag = ( (setting.view.autoCancelSelected && (event.ctrlKey || event.metaKey)) && data.isSelectedNode(setting, node)) ? 0 : (setting.view.autoCancelSelected && (event.ctrlKey || event.metaKey) && setting.view.selectedMulti) ? 2 : 1;
			if (tools.apply(setting.callback.beforeClick, [setting.treeId, node, clickFlag], true) == false) return true;
			if (clickFlag === 0) {
				view.cancelPreSelectedNode(setting, node);
			} else {
				view.selectNode(setting, node, clickFlag === 2);
			}
			setting.treeObj.trigger(consts.event.CLICK, [event, setting.treeId, node, clickFlag]);
			return true;
		},
		onZTreeMousedown: function(event, node) {
			var setting = data.getSetting(event.data.treeId);
			if (tools.apply(setting.callback.beforeMouseDown, [setting.treeId, node], true)) {
				tools.apply(setting.callback.onMouseDown, [event, setting.treeId, node]);
			}
			return true;
		},
		onZTreeMouseup: function(event, node) {
			var setting = data.getSetting(event.data.treeId);
			if (tools.apply(setting.callback.beforeMouseUp, [setting.treeId, node], true)) {
				tools.apply(setting.callback.onMouseUp, [event, setting.treeId, node]);
			}
			return true;
		},
		onZTreeDblclick: function(event, node) {
			var setting = data.getSetting(event.data.treeId);
			if (tools.apply(setting.callback.beforeDblClick, [setting.treeId, node], true)) {
				tools.apply(setting.callback.onDblClick, [event, setting.treeId, node]);
			}
			return true;
		},
		onZTreeContextmenu: function(event, node) {
			var setting = data.getSetting(event.data.treeId);
			if (tools.apply(setting.callback.beforeRightClick, [setting.treeId, node], true)) {
				tools.apply(setting.callback.onRightClick, [event, setting.treeId, node]);
			}
			return (typeof setting.callback.onRightClick) != "function";
		}
	},
	//method of tools for zTree
	tools = {
		apply: function(fun, param, defaultValue) {
			if ((typeof fun) == "function") {
				//判断如果参数为treeId,则去掉
				param = param?param:[];
				for(var i=0;i<param.length;i++){
					if($.type(param[i]) === 'string' && $("#"+param[i]).length>0){
						//如果参数是字符串,并且存在于dom中,标识为treeId
						var srcObj = $("#"+param[i])[0];
						param.splice(i,1);
						return fun.apply(srcObj, param);
					}
				}
				//
				return fun.apply(zt, param?param:[]);
			}
			return defaultValue;
		},
		canAsync: function(setting, node) {
			var childKey = setting.data.key.children;
			return (setting.async.enable && node && node.isParent && !(node.zAsync || (node[childKey] && node[childKey].length > 0)));
		},
		clone: function (obj){
			if (obj === null) return null;
			var o = tools.isArray(obj) ? [] : {};
			for(var i in obj){
				o[i] = (obj[i] instanceof Date) ? new Date(obj[i].getTime()) : (typeof obj[i] === "object" ? arguments.callee(obj[i]) : obj[i]);
			}
			return o;
		},
		eqs: function(str1, str2) {
			return str1.toLowerCase() === str2.toLowerCase();
		},
		isArray: function(arr) {
			return Object.prototype.toString.apply(arr) === "[object Array]";
		},
		$: function(node, exp, setting) {
			if (!!exp && typeof exp != "string") {
				setting = exp;
				exp = "";
			}
			if (typeof node == "string") {
				return $(node, setting ? setting.treeObj.get(0).ownerDocument : null);
			} else {
				return $("#" + node.tId + exp, setting ? setting.treeObj : null);
			}
		},
		getMDom: function (setting, curDom, targetExpr) {
			if (!curDom) return null;
			while (curDom && curDom.id !== setting.treeId) {
				for (var i=0, l=targetExpr.length; curDom.tagName && i<l; i++) {
					if (tools.eqs(curDom.tagName, targetExpr[i].tagName) && curDom.getAttribute(targetExpr[i].attrName) !== null) {
						return curDom;
					}
				}
				curDom = curDom.parentNode;
			}
			return null;
		},
		getNodeMainDom:function(target) {
			return ($(target).parent("li").get(0) || $(target).parentsUntil("li").parent().get(0));
		},
		isChildOrSelf: function(dom, parentId) {
			return ( $(dom).closest("#" + parentId).length> 0 );
		},
		uCanDo: function(setting, e) {
			return true;
		}
	},
	//method of operate ztree dom
	view = {
		addNodes: function(setting, parentNode, newNodes, isSilent) {
			if (setting.data.keep.leaf && parentNode && !parentNode.isParent) {
				return;
			}
			if (!tools.isArray(newNodes)) {
				newNodes = [newNodes];
			}
			if (setting.data.simpleData.enable) {
				newNodes = data.transformTozTreeFormat(setting, newNodes);
			}
			if (parentNode) {
				var target_switchObj = $$(parentNode, consts.id.SWITCH, setting),
				target_icoObj = $$(parentNode, consts.id.ICON, setting),
				target_ulObj = $$(parentNode, consts.id.UL, setting);

				if (!parentNode.open) {
					view.replaceSwitchClass(parentNode, target_switchObj, consts.folder.CLOSE);
					view.replaceIcoClass(parentNode, target_icoObj, consts.folder.CLOSE);
					parentNode.open = false;
					target_ulObj.css({
						"display": "none"
					});
				}

				data.addNodesData(setting, parentNode, newNodes);
				view.createNodes(setting, parentNode.level + 1, newNodes, parentNode);
				if (!isSilent) {
					view.expandCollapseParentNode(setting, parentNode, true);
				}
			} else {
				data.addNodesData(setting, data.getRoot(setting), newNodes);
				view.createNodes(setting, 0, newNodes, null);
			}
		},
		appendNodes: function(setting, level, nodes, parentNode, initFlag, openFlag) {
			if (!nodes) return [];
			var html = [],
			childKey = setting.data.key.children;
			for (var i = 0, l = nodes.length; i < l; i++) {
				var node = nodes[i];
				if (initFlag) {
					var tmpPNode = (parentNode) ? parentNode: data.getRoot(setting),
					tmpPChild = tmpPNode[childKey],
					isFirstNode = ((tmpPChild.length == nodes.length) && (i == 0)),
					isLastNode = (i == (nodes.length - 1));
					data.initNode(setting, level, node, parentNode, isFirstNode, isLastNode, openFlag);
					data.addNodeCache(setting, node);
				}

				var childHtml = [];
				if (node[childKey] && node[childKey].length > 0) {
					//make child html first, because checkType
					childHtml = view.appendNodes(setting, level + 1, node[childKey], node, initFlag, openFlag && node.open);
				}
				if (openFlag) {

					view.makeDOMNodeMainBefore(html, setting, node);
					view.makeDOMNodeLine(html, setting, node);
					data.getBeforeA(setting, node, html);
					view.makeDOMNodeNameBefore(html, setting, node);
					data.getInnerBeforeA(setting, node, html);
					view.makeDOMNodeIcon(html, setting, node);
					data.getInnerAfterA(setting, node, html);
					view.makeDOMNodeNameAfter(html, setting, node);
					data.getAfterA(setting, node, html);
					if (node.isParent && node.open) {
						view.makeUlHtml(setting, node, html, childHtml.join(''));
					}
					view.makeDOMNodeMainAfter(html, setting, node);
					data.addCreatedNode(setting, node);
				}
			}
			return html;
		},
		appendParentULDom: function(setting, node) {
			var html = [],
			nObj = $$(node, setting);
			if (!nObj.get(0) && !!node.parentTId) {
				view.appendParentULDom(setting, node.getParentNode());
				nObj = $$(node, setting);
			}
			var ulObj = $$(node, consts.id.UL, setting);
			if (ulObj.get(0)) {
				ulObj.remove();
			}
			var childKey = setting.data.key.children,
			childHtml = view.appendNodes(setting, node.level+1, node[childKey], node, false, true);
			view.makeUlHtml(setting, node, html, childHtml.join(''));
			nObj.append(html.join(''));
		},
		asyncNode: function(setting, node, isSilent, callback) {
			var i, l;
			if (node && !node.isParent) {
				tools.apply(callback);
				return false;
			} else if (node && node.isAjaxing) {
				return false;
			} else if (tools.apply(setting.callback.beforeAsync, [setting.treeId, node], true) == false) {
				tools.apply(callback);
				return false;
			}
			if (node) {
				node.isAjaxing = true;
				var icoObj = $$(node, consts.id.ICON, setting);
				icoObj.attr({"style":"", "class":consts.className.BUTTON + " " + consts.className.ICO_LOADING});
			}

			var tmpParam = {};
			for (i = 0, l = setting.async.autoParam.length; node && i < l; i++) {
				var pKey = setting.async.autoParam[i].split("="), spKey = pKey;
				if (pKey.length>1) {
					spKey = pKey[1];
					pKey = pKey[0];
				}
				tmpParam[spKey] = node[pKey];
			}
			if (tools.isArray(setting.async.otherParam)) {
				for (i = 0, l = setting.async.otherParam.length; i < l; i += 2) {
					tmpParam[setting.async.otherParam[i]] = setting.async.otherParam[i + 1];
				}
			} else {
				for (var p in setting.async.otherParam) {
					tmpParam[p] = setting.async.otherParam[p];
				}
			}

			var _tmpV = data.getRoot(setting)._ver;
			$.ajax({
				contentType: setting.async.contentType,
                cache: false,
				type: setting.async.type,
				url: tools.apply(setting.async.url, [setting.treeId, node], setting.async.url),
				data: tmpParam,
				dataType: setting.async.dataType,
				success: function(msg) {
					if (_tmpV != data.getRoot(setting)._ver) {
						return;
					}
					var newNodes = [];
					try {
						if (!msg || msg.length == 0) {
							newNodes = [];
						} else if (typeof msg == "string") {
							newNodes = eval("(" + msg + ")");
						} else {
							newNodes = msg;
						}
					} catch(err) {
						newNodes = msg;
					}

					if (node) {
						node.isAjaxing = null;
						node.zAsync = true;
					}
					view.setNodeLineIcos(setting, node);
					if (newNodes && newNodes !== "") {
						newNodes = tools.apply(setting.async.dataFilter, [setting.treeId, node, newNodes], newNodes);
						view.addNodes(setting, node, !!newNodes ? tools.clone(newNodes) : [], !!isSilent);
					} else {
						view.addNodes(setting, node, [], !!isSilent);
					}
					setting.treeObj.trigger(consts.event.ASYNC_SUCCESS, [setting.treeId, node, msg]);
					tools.apply(callback);
				},
				error: function(XMLHttpRequest, textStatus, errorThrown) {
					if (_tmpV != data.getRoot(setting)._ver) {
						return;
					}
					if (node) node.isAjaxing = null;
					view.setNodeLineIcos(setting, node);
					setting.treeObj.trigger(consts.event.ASYNC_ERROR, [setting.treeId, node, XMLHttpRequest, textStatus, errorThrown]);
				}
			});
			return true;
		},
		cancelPreSelectedNode: function (setting, node) {
			var list = data.getRoot(setting).curSelectedList;
			for (var i=0, j=list.length-1; j>=i; j--) {
				if (!node || node === list[j]) {
					$$(list[j], consts.id.A, setting).removeClass(consts.node.CURSELECTED);
					if (node) {
						data.removeSelectedNode(setting, node);
						break;
					}
				}
			}
			if (!node) data.getRoot(setting).curSelectedList = [];
		},
		createNodeCallback: function(setting) {
			if (!!setting.callback.onNodeCreated || !!setting.view.addDiyDom) {
				var root = data.getRoot(setting);
				while (root.createdNodes.length>0) {
					var node = root.createdNodes.shift();
					tools.apply(setting.view.addDiyDom, [setting.treeId, node]);
					if (!!setting.callback.onNodeCreated) {
						setting.treeObj.trigger(consts.event.NODECREATED, [setting.treeId, node]);
					}
				}
			}
		},
		createNodes: function(setting, level, nodes, parentNode) {
			if (!nodes || nodes.length == 0) return;
			var root = data.getRoot(setting),
			childKey = setting.data.key.children,
			openFlag = !parentNode || parentNode.open || !!$$(parentNode[childKey][0], setting).get(0);
			root.createdNodes = [];
			var zTreeHtml = view.appendNodes(setting, level, nodes, parentNode, true, openFlag);
			if (!parentNode) {
				setting.treeObj.append(zTreeHtml.join(''));
			} else {
				var ulObj = $$(parentNode, consts.id.UL, setting);
				if (ulObj.get(0)) {
					ulObj.append(zTreeHtml.join(''));
				}
			}
			view.createNodeCallback(setting);
		},
		destroy: function(setting) {
			if (!setting) return;
			data.initCache(setting);
			data.initRoot(setting);
			event.unbindTree(setting);
			event.unbindEvent(setting);
			setting.treeObj.empty();
			delete settings[setting.treeId];
		},
		expandCollapseNode: function(setting, node, expandFlag, animateFlag, callback) {
			var root = data.getRoot(setting),
			childKey = setting.data.key.children;
			if (!node) {
				tools.apply(callback, []);
				return;
			}
			if (root.expandTriggerFlag) {
				var _callback = callback;
				callback = function(){
					if (_callback) _callback();
					if (node.open) {
						setting.treeObj.trigger(consts.event.EXPAND, [setting.treeId, node]);
					} else {
						setting.treeObj.trigger(consts.event.COLLAPSE, [setting.treeId, node]);
					}
				};
				root.expandTriggerFlag = false;
			}
			if (!node.open && node.isParent && ((!$$(node, consts.id.UL, setting).get(0)) || (node[childKey] && node[childKey].length>0 && !$$(node[childKey][0], setting).get(0)))) {
				view.appendParentULDom(setting, node);
				view.createNodeCallback(setting);
			}
			if (node.open == expandFlag) {
				tools.apply(callback, []);
				return;
			}
			var ulObj = $$(node, consts.id.UL, setting),
			switchObj = $$(node, consts.id.SWITCH, setting),
			icoObj = $$(node, consts.id.ICON, setting);

			if (node.isParent) {
				node.open = !node.open;
				if (node.iconOpen && node.iconClose) {
					icoObj.attr("style", view.makeNodeIcoStyle(setting, node));
				}

				if (node.open) {
					view.replaceSwitchClass(node, switchObj, consts.folder.OPEN);
					view.replaceIcoClass(node, icoObj, consts.folder.OPEN);
					if (animateFlag == false || setting.view.expandSpeed == "") {
						ulObj.show();
						tools.apply(callback, []);
					} else {
						if (node[childKey] && node[childKey].length > 0) {
							ulObj.slideDown(setting.view.expandSpeed, callback);
						} else {
							ulObj.show();
							tools.apply(callback, []);
						}
					}
				} else {
					view.replaceSwitchClass(node, switchObj, consts.folder.CLOSE);
					view.replaceIcoClass(node, icoObj, consts.folder.CLOSE);
					if (animateFlag == false || setting.view.expandSpeed == "" || !(node[childKey] && node[childKey].length > 0)) {
						ulObj.hide();
						tools.apply(callback, []);
					} else {
						ulObj.slideUp(setting.view.expandSpeed, callback);
					}
				}
			} else {
				tools.apply(callback, []);
			}
		},
		expandCollapseParentNode: function(setting, node, expandFlag, animateFlag, callback) {
			if (!node) return;
			if (!node.parentTId) {
				view.expandCollapseNode(setting, node, expandFlag, animateFlag, callback);
				return;
			} else {
				view.expandCollapseNode(setting, node, expandFlag, animateFlag);
			}
			if (node.parentTId) {
				view.expandCollapseParentNode(setting, node.getParentNode(), expandFlag, animateFlag, callback);
			}
		},
		expandCollapseSonNode: function(setting, node, expandFlag, animateFlag, callback) {
			var root = data.getRoot(setting),
			childKey = setting.data.key.children,
			treeNodes = (node) ? node[childKey]: root[childKey],
			selfAnimateSign = (node) ? false : animateFlag,
			expandTriggerFlag = data.getRoot(setting).expandTriggerFlag;
			data.getRoot(setting).expandTriggerFlag = false;
			if (treeNodes) {
				for (var i = 0, l = treeNodes.length; i < l; i++) {
					if (treeNodes[i]) view.expandCollapseSonNode(setting, treeNodes[i], expandFlag, selfAnimateSign);
				}
			}
			data.getRoot(setting).expandTriggerFlag = expandTriggerFlag;
			view.expandCollapseNode(setting, node, expandFlag, animateFlag, callback );
		},
		makeDOMNodeIcon: function(html, setting, node) {
			var nameStr = data.getNodeName(setting, node),
			name = setting.view.nameIsHTML ? nameStr : nameStr.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
			html.push("<span id='", node.tId, consts.id.ICON,
				"' title='' treeNode", consts.id.ICON," class='", view.makeNodeIcoClass(setting, node),
				"' style='", view.makeNodeIcoStyle(setting, node), "'></span><span id='", node.tId, consts.id.SPAN,
				"'>",name,"</span>");
		},
		makeDOMNodeLine: function(html, setting, node) {
			html.push("<span id='", node.tId, consts.id.SWITCH,	"' title='' class='", view.makeNodeLineClass(setting, node), "' treeNode", consts.id.SWITCH,"></span>");
		},
		makeDOMNodeMainAfter: function(html, setting, node) {
			html.push("</li>");
		},
		makeDOMNodeMainBefore: function(html, setting, node) {
			html.push("<li id='", node.tId, "' class='", consts.className.LEVEL, node.level,"' tabindex='0' hidefocus='true' treenode>");
		},
		makeDOMNodeNameAfter: function(html, setting, node) {
			html.push("</a>");
		},
		makeDOMNodeNameBefore: function(html, setting, node) {
			var title = data.getNodeTitle(setting, node),
			url = view.makeNodeUrl(setting, node),
			fontcss = view.makeNodeFontCss(setting, node),
			fontStyle = [];
			for (var f in fontcss) {
				fontStyle.push(f, ":", fontcss[f], ";");
			}
			html.push("<a id='", node.tId, consts.id.A, "' class='", consts.className.LEVEL, node.level,"' treeNode", consts.id.A," onclick=\"", (node.click || ''),
				"\" ", ((url != null && url.length > 0) ? "href='" + url + "'" : ""), " target='",view.makeNodeTarget(node),"' style='", fontStyle.join(''),
				"'");
			if (tools.apply(setting.view.showTitle, [setting.treeId, node], setting.view.showTitle) && title) {html.push("title='", title.replace(/'/g,"&#39;").replace(/</g,'&lt;').replace(/>/g,'&gt;'),"'");}
			html.push(">");
		},
		makeNodeFontCss: function(setting, node) {
			var fontCss = tools.apply(setting.view.fontCss, [setting.treeId, node], setting.view.fontCss);
			return (fontCss && ((typeof fontCss) != "function")) ? fontCss : {};
		},
		makeNodeIcoClass: function(setting, node) {
			var icoCss = ["ico"];
			if (!node.isAjaxing) {
				icoCss[0] = (node.iconSkin ? node.iconSkin + "_" : "") + icoCss[0];
				if (node.isParent) {
					icoCss.push(node.open ? consts.folder.OPEN : consts.folder.CLOSE);
				} else {
					icoCss.push(consts.folder.DOCU);
				}
			}
			return consts.className.BUTTON + " " + icoCss.join('_');
		},
		makeNodeIcoStyle: function(setting, node) {
			var icoStyle = [];
			if (!node.isAjaxing) {
				var icon = (node.isParent && node.iconOpen && node.iconClose) ? (node.open ? node.iconOpen : node.iconClose) : node.icon;
				if (icon) icoStyle.push("background:url(", icon, ") 0 0 no-repeat;");
				if (setting.view.showIcon == false || !tools.apply(setting.view.showIcon, [setting.treeId, node], true)) {
					icoStyle.push("width:0px;height:0px;");
				}
			}
			return icoStyle.join('');
		},
		makeNodeLineClass: function(setting, node) {
			var lineClass = [];
			if (setting.view.showLine) {
				if (node.level == 0 && node.isFirstNode && node.isLastNode) {
					lineClass.push(consts.line.ROOT);
				} else if (node.level == 0 && node.isFirstNode) {
					lineClass.push(consts.line.ROOTS);
				} else if (node.isLastNode) {
					lineClass.push(consts.line.BOTTOM);
				} else {
					lineClass.push(consts.line.CENTER);
				}
			} else {
				lineClass.push(consts.line.NOLINE);
			}
			if (node.isParent) {
				lineClass.push(node.open ? consts.folder.OPEN : consts.folder.CLOSE);
			} else {
				lineClass.push(consts.folder.DOCU);
			}
			return view.makeNodeLineClassEx(node) + lineClass.join('_');
		},
		makeNodeLineClassEx: function(node) {
			return consts.className.BUTTON + " " + consts.className.LEVEL + node.level + " " + consts.className.SWITCH + " ";
		},
		makeNodeTarget: function(node) {
			return (node.target || "_blank");
		},
		makeNodeUrl: function(setting, node) {
			var urlKey = setting.data.key.url;
			return node[urlKey] ? node[urlKey] : null;
		},
		makeUlHtml: function(setting, node, html, content) {
			html.push("<ul id='", node.tId, consts.id.UL, "' class='", consts.className.LEVEL, node.level, " ", view.makeUlLineClass(setting, node), "' style='display:", (node.open ? "block": "none"),"'>");
			html.push(content);
			html.push("</ul>");
		},
		makeUlLineClass: function(setting, node) {
			return ((setting.view.showLine && !node.isLastNode) ? consts.line.LINE : "");
		},
		removeChildNodes: function(setting, node) {
			if (!node) return;
			var childKey = setting.data.key.children,
			nodes = node[childKey];
			if (!nodes) return;

			for (var i = 0, l = nodes.length; i < l; i++) {
				data.removeNodeCache(setting, nodes[i]);
			}
			data.removeSelectedNode(setting);
			delete node[childKey];

			if (!setting.data.keep.parent) {
				node.isParent = false;
				node.open = false;
				var tmp_switchObj = $$(node, consts.id.SWITCH, setting),
				tmp_icoObj = $$(node, consts.id.ICON, setting);
				view.replaceSwitchClass(node, tmp_switchObj, consts.folder.DOCU);
				view.replaceIcoClass(node, tmp_icoObj, consts.folder.DOCU);
				$$(node, consts.id.UL, setting).remove();
			} else {
				$$(node, consts.id.UL, setting).empty();
			}
		},
		setFirstNode: function(setting, parentNode) {
			var childKey = setting.data.key.children, childLength = parentNode[childKey].length;
			if ( childLength > 0) {
				parentNode[childKey][0].isFirstNode = true;
			}
		},
		setLastNode: function(setting, parentNode) {
			var childKey = setting.data.key.children, childLength = parentNode[childKey].length;
			if ( childLength > 0) {
				parentNode[childKey][childLength - 1].isLastNode = true;
			}
		},
		removeNode: function(setting, node) {
			var root = data.getRoot(setting),
			childKey = setting.data.key.children,
			parentNode = (node.parentTId) ? node.getParentNode() : root;

			node.isFirstNode = false;
			node.isLastNode = false;
			node.getPreNode = function() {return null;};
			node.getNextNode = function() {return null;};

			if (!data.getNodeCache(setting, node.tId)) {
				return;
			}

			$$(node, setting).remove();
			data.removeNodeCache(setting, node);
			data.removeSelectedNode(setting, node);

			for (var i = 0, l = parentNode[childKey].length; i < l; i++) {
				if (parentNode[childKey][i].tId == node.tId) {
					parentNode[childKey].splice(i, 1);
					break;
				}
			}
			view.setFirstNode(setting, parentNode);
			view.setLastNode(setting, parentNode);

			var tmp_ulObj,tmp_switchObj,tmp_icoObj,
			childLength = parentNode[childKey].length;

			//repair nodes old parent
			if (!setting.data.keep.parent && childLength == 0) {
				//old parentNode has no child nodes
				parentNode.isParent = false;
				parentNode.open = false;
				tmp_ulObj = $$(parentNode, consts.id.UL, setting);
				tmp_switchObj = $$(parentNode, consts.id.SWITCH, setting);
				tmp_icoObj = $$(parentNode, consts.id.ICON, setting);
				view.replaceSwitchClass(parentNode, tmp_switchObj, consts.folder.DOCU);
				view.replaceIcoClass(parentNode, tmp_icoObj, consts.folder.DOCU);
				tmp_ulObj.css("display", "none");

			} else if (setting.view.showLine && childLength > 0) {
				//old parentNode has child nodes
				var newLast = parentNode[childKey][childLength - 1];
				tmp_ulObj = $$(newLast, consts.id.UL, setting);
				tmp_switchObj = $$(newLast, consts.id.SWITCH, setting);
				tmp_icoObj = $$(newLast, consts.id.ICON, setting);
				if (parentNode == root) {
					if (parentNode[childKey].length == 1) {
						//node was root, and ztree has only one root after move node
						view.replaceSwitchClass(newLast, tmp_switchObj, consts.line.ROOT);
					} else {
						var tmp_first_switchObj = $$(parentNode[childKey][0], consts.id.SWITCH, setting);
						view.replaceSwitchClass(parentNode[childKey][0], tmp_first_switchObj, consts.line.ROOTS);
						view.replaceSwitchClass(newLast, tmp_switchObj, consts.line.BOTTOM);
					}
				} else {
					view.replaceSwitchClass(newLast, tmp_switchObj, consts.line.BOTTOM);
				}
				tmp_ulObj.removeClass(consts.line.LINE);
			}
		},
		replaceIcoClass: function(node, obj, newName) {
			if (!obj || node.isAjaxing) return;
			var tmpName = obj.attr("class");
			if (tmpName == undefined) return;
			var tmpList = tmpName.split("_");
			switch (newName) {
				case consts.folder.OPEN:
				case consts.folder.CLOSE:
				case consts.folder.DOCU:
					tmpList[tmpList.length-1] = newName;
					break;
			}
			obj.attr("class", tmpList.join("_"));
		},
		replaceSwitchClass: function(node, obj, newName) {
			if (!obj) return;
			var tmpName = obj.attr("class");
			if (tmpName == undefined) return;
			var tmpList = tmpName.split("_");
			switch (newName) {
				case consts.line.ROOT:
				case consts.line.ROOTS:
				case consts.line.CENTER:
				case consts.line.BOTTOM:
				case consts.line.NOLINE:
					tmpList[0] = view.makeNodeLineClassEx(node) + newName;
					break;
				case consts.folder.OPEN:
				case consts.folder.CLOSE:
				case consts.folder.DOCU:
					tmpList[1] = newName;
					break;
			}
			obj.attr("class", tmpList.join("_"));
			if (newName !== consts.folder.DOCU) {
				obj.removeAttr("disabled");
			} else {
				obj.attr("disabled", "disabled");
			}
		},
		selectNode: function(setting, node, addFlag) {
			if (!addFlag) {
				view.cancelPreSelectedNode(setting);
			}
			$$(node, consts.id.A, setting).addClass(consts.node.CURSELECTED);
			data.addSelectedNode(setting, node);
		},
		setNodeFontCss: function(setting, treeNode) {
			var aObj = $$(treeNode, consts.id.A, setting),
			fontCss = view.makeNodeFontCss(setting, treeNode);
			if (fontCss) {
				aObj.css(fontCss);
			}
		},
		setNodeLineIcos: function(setting, node) {
			if (!node) return;
			var switchObj = $$(node, consts.id.SWITCH, setting),
			ulObj = $$(node, consts.id.UL, setting),
			icoObj = $$(node, consts.id.ICON, setting),
			ulLine = view.makeUlLineClass(setting, node);
			if (ulLine.length==0) {
				ulObj.removeClass(consts.line.LINE);
			} else {
				ulObj.addClass(ulLine);
			}
			switchObj.attr("class", view.makeNodeLineClass(setting, node));
			if (node.isParent) {
				switchObj.removeAttr("disabled");
			} else {
				switchObj.attr("disabled", "disabled");
			}
			icoObj.removeAttr("style");
			icoObj.attr("style", view.makeNodeIcoStyle(setting, node));
			icoObj.attr("class", view.makeNodeIcoClass(setting, node));
		},
		setNodeName: function(setting, node) {
			var title = data.getNodeTitle(setting, node),
			nObj = $$(node, consts.id.SPAN, setting);
			nObj.empty();
			if (setting.view.nameIsHTML) {
				nObj.html(data.getNodeName(setting, node));
			} else {
				nObj.text(data.getNodeName(setting, node));
			}
			if (tools.apply(setting.view.showTitle, [setting.treeId, node], setting.view.showTitle)) {
				var aObj = $$(node, consts.id.A, setting);
				aObj.attr("title", !title ? "" : title);
			}
		},
		setNodeTarget: function(setting, node) {
			var aObj = $$(node, consts.id.A, setting);
			aObj.attr("target", view.makeNodeTarget(node));
		},
		setNodeUrl: function(setting, node) {
			var aObj = $$(node, consts.id.A, setting),
			url = view.makeNodeUrl(setting, node);
			if (url == null || url.length == 0) {
				aObj.removeAttr("href");
			} else {
				aObj.attr("href", url);
			}
		},
		switchNode: function(setting, node) {
			if (node.open || !tools.canAsync(setting, node)) {
				view.expandCollapseNode(setting, node, !node.open);
			} else if (setting.async.enable) {
				if (!view.asyncNode(setting, node)) {
					view.expandCollapseNode(setting, node, !node.open);
					return;
				}
			} else if (node) {
				view.expandCollapseNode(setting, node, !node.open);
			}
		}
	};
	// zTree defind
	$.fn.zTree = {
		consts : _consts,
		_z : {
			tools: tools,
			view: view,
			event: event,
			data: data
		},
		getZTreeObj: function(treeId) {
			var o = data.getZTreeTools(treeId);
			return o ? o : null;
		},
		destroy: function(treeId) {
			if (!!treeId && treeId.length > 0) {
				view.destroy(data.getSetting(treeId));
			} else {
				for(var s in settings) {
					view.destroy(settings[s]);
				}
			}
		},
		init: function(obj, zSetting, zNodes) {
			var setting = tools.clone(_setting);
			$.extend(true, setting, zSetting);
			setting.treeId = obj.attr("id");
			setting.treeObj = obj;
			setting.treeObj.empty();
			settings[setting.treeId] = setting;
			//For some older browser,(e.g., ie6)
			if(typeof document.body.style.maxHeight === "undefined") {
				setting.view.expandSpeed = "";
			}
			data.initRoot(setting);
			var root = data.getRoot(setting),
			childKey = setting.data.key.children;
			zNodes = zNodes ? tools.clone(tools.isArray(zNodes)? zNodes : [zNodes]) : [];
			if (setting.data.simpleData.enable) {
				root[childKey] = data.transformTozTreeFormat(setting, zNodes);
			} else {
				root[childKey] = zNodes;
			}

			data.initCache(setting);
			event.unbindTree(setting);
			event.bindTree(setting);
			event.unbindEvent(setting);
			event.bindEvent(setting);

			var zTreeTools = {
				setting : setting,
				/**
			     * @method addNodes
			     * 添加节点 
			     * @param {Object}  parentNode 指定的父节点，如果增加根节点，请设置 parentNode 为 null 即可。请务必保证此节点数据对象 是 Tree 内部的数据对象
			     * @param {Array}  newNodes   需要增加的节点数据 JSON 对象集合，数据只需要满足 zTree 的节点数据必需的属性即可;增加一个节点的时候，可以不使用数组
			     * @param {Boolean} isSilent   设定增加节点后是否自动展开父节点。isSilent = true 时，不展开父节点,其他值或缺省状态都自动展开
			     * @return {Array}  返回Tree 最终添加的节点数据集合
			     */
				addNodes : function(parentNode, newNodes, isSilent) {
					if (!newNodes) return null;
					if (!parentNode) parentNode = null;
					if (parentNode && !parentNode.isParent && setting.data.keep.leaf) return null;
					var xNewNodes = tools.clone(tools.isArray(newNodes)? newNodes: [newNodes]);
					function addCallback() {
						view.addNodes(setting, parentNode, xNewNodes, (isSilent==true));
					}

					if (tools.canAsync(setting, parentNode)) {
						view.asyncNode(setting, parentNode, isSilent, addCallback);
					} else {
						addCallback();
					}
					return xNewNodes;
				},
				/**
				 * @method cancelSelectedNode
				 * 取消节点的选中状态。
				 * @param  {Object} [node] 需要取消选中状态的节点。
				 */
				cancelSelectedNode : function(node) {
					view.cancelPreSelectedNode(setting, node);
				},
				/**
				 * @method  destroy
				 * 销毁tree对象
				 */
				destroy : function() {
					view.destroy(setting);
				},
				/**
				 * @method expandAll
				 * 展开 / 折叠 全部节点
				 * 此方法不会触发 beforeExpand / onExpand 和 beforeCollapse / onCollapse 事件回调函数。
				 * @param  {Boolean} expandFlag expandFlag = true 表示 展开 全部节点;expandFlag = false 表示 折叠 全部节点
				 * @return {Boolean}  true 表示 展开 全部节点;false 表示 折叠 全部节点;null 表示 不存在任何父节点
				 */
				expandAll : function(expandFlag) {
					expandFlag = !!expandFlag;
					view.expandCollapseSonNode(setting, null, expandFlag, true);
					return expandFlag;
				},
				/**
				 * @method expandNode
				 * 展开 / 折叠 指定的节点,可以触发 beforeExpand / onExpand 或 beforeCollapse / onCollapse 事件回调函数。
				 * @param  {Object} node 需要 展开 / 折叠 的节点数据
				 * @param  {Boolean} [expandFlag] expandFlag = true 表示展开节点 expandFlag = false 表示折叠节点；省略此参数，则根据对此节点的展开状态进行 toggle 切换
				 * @param  {Boolean} [sonSign = false] sonSign = true表示全部子孙节点进行与expandFlag相同的操作,sonSign = false 表示只影响此节点，对于其子孙节点无任何影响;
				 * @param  {Boolean} [focus = true] focus = true 表示 展开 / 折叠 操作后，通过设置焦点保证此焦点进入可视区域内,focus = false 表示 展开 / 折叠 操作后，不设置任何焦点
				 * @param  {Boolean} [callbackFlag = false] callbackFlag = true 表示执行此方法时触发 beforeExpand / onExpand 或 beforeCollapse / onCollapse 事件回调函数 ;callbackFlag = false 表示执行此方法时不触发事件回调函数
				 * @return {Boolean} 返回值表示最终实际操作情况:true 表示 展开 节点;false 表示 折叠 节点;null 表示 不是父节点
				 */
				expandNode : function(node, expandFlag, sonSign, focus, callbackFlag) {
					if (!node || !node.isParent) return null;
					if (expandFlag !== true && expandFlag !== false) {
						expandFlag = !node.open;
					}
					callbackFlag = !!callbackFlag;

					if (callbackFlag && expandFlag && (tools.apply(setting.callback.beforeExpand, [setting.treeId, node], true) == false)) {
						return null;
					} else if (callbackFlag && !expandFlag && (tools.apply(setting.callback.beforeCollapse, [setting.treeId, node], true) == false)) {
						return null;
					}
					if (expandFlag && node.parentTId) {
						view.expandCollapseParentNode(setting, node.getParentNode(), expandFlag, false);
					}
					if (expandFlag === node.open && !sonSign) {
						return null;
					}

					data.getRoot(setting).expandTriggerFlag = callbackFlag;
					if (!tools.canAsync(setting, node) && sonSign) {
						view.expandCollapseSonNode(setting, node, expandFlag, true, function() {
							if (focus !== false) {try{$$(node, setting).focus().blur();}catch(e){}}
						});
					} else {
						node.open = !expandFlag;
						view.switchNode(this.setting, node);
						if (focus !== false) {try{$$(node, setting).focus().blur();}catch(e){}}
					}
					return expandFlag;
				},
				/**
				 * @method getNodes
				 * 获取 zTree 的全部节点数据
				 * @return {Array} 全部节点数据
				 */
				getNodes : function() {
					return data.getNodes(setting);
				},
				/**
				 * @method getNodeByParam
				 * 根据节点数据的属性搜索，获取条件完全匹配的节点数据 JSON 对象
				 * @param  {String} key 需要精确匹配的属性名称
				 * @param  value 需要精确匹配的属性值，可以是任何类型，只要保证与 key 指定的属性值保持一致即可
				 * @param  {Object} [parentNode] 搜索范围，指定在某个父节点下的子节点中进行搜索,忽略此参数，表示在全部节点中搜索
				 * @return {Object} 匹配精确搜索的节点数据
				 *					1、如无结果，返回 null
				 *					2、如有多个节点满足查询条件，只返回第一个匹配到的节点
				 */
				getNodeByParam : function(key, value, parentNode) {
					if (!key) return null;
					return data.getNodeByParam(setting, parentNode?parentNode[setting.data.key.children]:data.getNodes(setting), key, value);
				},
				/**
				 * @method getNodeByTId
				 * 根据 zTree 的唯一标识 tId 快速获取节点 JSON 数据对象,通过内部的 cache 获取，不需要遍历节点
				 * @param  {String} tId 节点在 zTree 内的唯一标识 tId
				 * @return {Object}     tId 对应的节点 JSON 数据对象
				 */
				getNodeByTId : function(tId) {
					return data.getNodeCache(setting, tId);
				},
				/**
				 * @method getNodesByParam
				 * 根据节点数据的属性搜索，获取条件完全匹配的节点数据 JSON 对象集合
				 * @param  {String} key        需要精确匹配的属性名称
				 * @param  value      需要精确匹配的属性值，可以是任何类型，只要保证与 key 指定的属性值保持一致即可
				 * @param  {Object} [parentNode] 可以指定在某个父节点下的子节点中搜索,忽略此参数，表示在全部节点中搜索
				 * @return {Array}       匹配精确搜索的节点数据集合,如无结果，返回 [ ]
				 */
				getNodesByParam : function(key, value, parentNode) {
					if (!key) return null;
					return data.getNodesByParam(setting, parentNode?parentNode[setting.data.key.children]:data.getNodes(setting), key, value);
				},
				/**
				 * @method getNodesByParamFuzzy
				 * 根据节点数据的属性搜索，获取条件模糊匹配的节点数据 JSON 对象集合
				 * @param  {String} key        需要模糊匹配的属性名称
				 * @param  value      需要模糊匹配的属性值,模糊匹配只能针对 String 类型的数据
				 * @param  {Object} [parentNode] 可以指定在某个父节点下的子节点中搜索,忽略此参数，表示在全部节点中搜索
				 * @return {Array}       匹配精确搜索的节点数据集合,如无结果，返回 [ ]
				 */
				getNodesByParamFuzzy : function(key, value, parentNode) {
					if (!key) return null;
					return data.getNodesByParamFuzzy(setting, parentNode?parentNode[setting.data.key.children]:data.getNodes(setting), key, value);
				},
				/**
				 * @method  getNodesByFilter
				 * 根据自定义规则搜索节点数据 JSON 对象集合 或 单个节点数据
				 * @param  {Function}  filter     自定义过滤器函数 function filter(node) {...},filter 参数：node (节点数据 JSON)filter 返回值：boolean (true 表示符合搜索条件；false 表示不符合搜索条件)
				 * @param  {Boolean} [isSingle=false]    true 表示只查找单个节点,false表示查找节点集合
				 * @param  {Object}  [parentNode]  可以指定在某个父节点下的子节点中搜索,忽略此参数，表示在全部节点中搜索
				 * @param  {Object} [invokeParam] 用户自定义的数据对象，用于 filter 中进行计算
				 * @return isSingle = true 返回 第一个找到的节点数据 JSON，无结果时返回 null;isSingle = false 返回 节点数据集合 Array(JSON)，无结果时返回 [ ]
				 */
				getNodesByFilter: function(filter, isSingle, parentNode, invokeParam) {
					isSingle = !!isSingle;
					if (!filter || (typeof filter != "function")) return (isSingle ? null : []);
					return data.getNodesByFilter(setting, parentNode?parentNode[setting.data.key.children]:data.getNodes(setting), filter, isSingle, invokeParam);
				},
				/**
				 * @method getNodeIndex
				 * 获取某节点在同级节点中的序号（从0开始）
				 * @param  {Object} node 需要查询顺序的节点 JSON 数据对象
				 * @return {Number}      返回值从 0 开始计数,如果不存在该节点数据，返回 -1
				 */
				getNodeIndex : function(node) {
					if (!node) return null;
					var childKey = setting.data.key.children,
					parentNode = (node.parentTId) ? node.getParentNode() : data.getRoot(setting);
					for (var i=0, l = parentNode[childKey].length; i < l; i++) {
						if (parentNode[childKey][i] == node) return i;
					}
					return -1;
				},
				/**
				 * @method getSelectedNodes
				 * 获取 zTree 当前被选中的节点数据集合
				 * @return {Array} 当前被选中的节点数据集合
				 */
				getSelectedNodes : function() {
					var r = [], list = data.getRoot(setting).curSelectedList;
					for (var i=0, l=list.length; i<l; i++) {
						r.push(list[i]);
					}
					return r;
				},
				/**
				 * @method isSelectedNode
				 * 判断传入的节点当前是否被选中
				 * @param  {Object}  node 节点数据
				 * @return {Boolean}      如果传入的节点当前是被选中的，返回true；否则返回false
				 */
				isSelectedNode : function(node) {
					return data.isSelectedNode(setting, node);
				},
				reAsyncChildNodes : function(parentNode, reloadType, isSilent) {
					if (!this.setting.async.enable) return;
					var isRoot = !parentNode;
					if (isRoot) {
						parentNode = data.getRoot(setting);
					}
					if (reloadType=="refresh") {
						var childKey = this.setting.data.key.children;
						for (var i = 0, l = parentNode[childKey] ? parentNode[childKey].length : 0; i < l; i++) {
							data.removeNodeCache(setting, parentNode[childKey][i]);
						}
						data.removeSelectedNode(setting);
						parentNode[childKey] = [];
						if (isRoot) {
							this.setting.treeObj.empty();
						} else {
							var ulObj = $$(parentNode, consts.id.UL, setting);
							ulObj.empty();
						}
					}
					view.asyncNode(this.setting, isRoot? null:parentNode, !!isSilent);
				},
				/**
				 * @method refresh
				 * 刷新tree,会清空dom结构，根据数据和配置项重新构建；没有特殊必要，尽量不要使用此方法。单个节点更新请使用 updateNode 方法
				 */
				refresh : function() {
					this.setting.treeObj.empty();
					var root = data.getRoot(setting),
					nodes = root[setting.data.key.children]
					data.initRoot(setting);
					root[setting.data.key.children] = nodes
					data.initCache(setting);
					view.createNodes(setting, 0, root[setting.data.key.children]);
				},
				/**
				 * @method removeChildNodes
				 * 清空某父节点的子节点。  
				 * 1、清空子节点后，父节点会自动变为叶子节点，如需要父节点保持父节点状态，请设置 setting.data.keep.parent 属性。
				 * 2、请勿用此方法清空根节点，如果需要清空根节点,使用$treeDom.tree('option','fNodes',nodesData)
				 * 3、此方法不会触发任何事件回调函数。   
				 * @param  {Object} node 需要清空子节点的父节点数据
				 * @return {Array}      将该父节点的子节点数据返回，如果不存在则返回 null
				 */
				removeChildNodes : function(node) {
					if (!node) return null;
					var childKey = setting.data.key.children,
					nodes = node[childKey];
					view.removeChildNodes(setting, node);
					return nodes ? nodes : null;
				},
				/**
				 * @method removeNode 
				 * 删除节点,删除节点可以触发 beforeRemove / onRemove 事件回调函数
				 * @param  {Object} node         需要被删除的节点数据
				 * @param  {Boolean} callbackFlag  表示执行此方法时触发 beforeRemove & onRemove 事件回调函数
				 */
				removeNode : function(node, callbackFlag) {
					if (!node) return;
					callbackFlag = !!callbackFlag;
					if (callbackFlag && tools.apply(setting.callback.beforeRemove, [setting.treeId, node], true) == false) return;
					view.removeNode(setting, node);
					if (callbackFlag) {
						this.setting.treeObj.trigger(consts.event.REMOVE, [setting.treeId, node]);
					}
				},
				/**
				 * @method selectNode
				 * 选中指定节点
				 * @param  {Object} node 需要被选中的节点数据(请务必保证此节点数据对象 是fish.tree内部的数据对象)
				 * @param  {Boolean} [addFlag] 	addFlag = true 表示追加选中，会出现多点同时被选中的情况
				 * 								addFlag = false 表示单独选中，原先被选中的节点会被取消选中状态
				 *								setting.view.selectedMulti = false 时，此参数无效，始终进行单独选中
				 */
				selectNode : function(node, addFlag) {
					if (!node) return;
					if (tools.uCanDo(setting)) {
						addFlag = setting.view.selectedMulti && addFlag;
						if (node.parentTId) {
							view.expandCollapseParentNode(setting, node.getParentNode(), true, false, function() {
								try{$$(node, setting).focus().blur();}catch(e){}
							});
						} else {
							try{$$(node, setting).focus().blur();}catch(e){}
						}
						view.selectNode(setting, node, addFlag);
					}
				},
				/**
				 * @method transformTozTreeNodes
				 * 将简单 Array 格式数据转换为 zTree 使用的标准 JSON 嵌套数据格式。		
				 * 使用此方法，请务必设置节点唯一标识属性名称 setting.data.simpleData.idKey 和 父节点唯一标识属性名称 setting.data.simpleData.pIdKey，并且让数据满足父子关系。 
				 * @param  {Array} simpleNodes 需要被转换的简单 Array 格式数据 或 某个单独的数据对象
				 * @return         tree使用的标准数据，子节点都存在于父节点数据的 children 属性中
				 */
				transformTozTreeNodes : function(simpleNodes) {
					return data.transformTozTreeFormat(setting, simpleNodes);
				},
				/**
				 * @method transformToArray
				 * 将 tree使用的标准 JSON 嵌套格式的数据转换为简单 Array 格式。(免去用户自行编写递归遍历全部节点的麻烦)
				 * @param  {Array} nodes 需要被转换的 tree 节点数据对象集合 或 某个单独节点的数据对象
				 * @return 将 tree 使用的标准 JSON 嵌套格式的数据转换为简单 Array 格式
				 */
				transformToArray : function(nodes) {
					return data.transformToArrayFormat(setting, nodes);
				},
				/**
				 * @method updateNode
				 * 更新某节点数据，主要用于该节点显示属性的更新。
				 * 1、可针对 name、target、 url、icon、 iconSkin、checked、nocheck 等这几个用于显示效果的参数进行更新，其他用于 zTreeNodes 的参数请不要随意更新，对于展开节点，还请调用 expandNode方法，因此请勿随意修改 open 属性。
				 * 2、用此方法修改 checked 勾选状态不会触发 beforeCheck / onCheck 事件回调函数。
				 * @param  {Object} node          指定需要更新的节点 JSON 数据,请务必保证此节点数据对象 是 zTree 内部的数据对象
				 * @param  checkTypeFlag [description]
				 */
				updateNode : function(node, checkTypeFlag) {
					if (!node) return;
					var nObj = $$(node, setting);
					if (nObj.get(0) && tools.uCanDo(setting)) {
						view.setNodeName(setting, node);
						view.setNodeTarget(setting, node);
						view.setNodeUrl(setting, node);
						view.setNodeLineIcos(setting, node);
						view.setNodeFontCss(setting, node);
					}
				}
			}
			root.treeTools = zTreeTools;
			data.setZTreeTools(setting, zTreeTools);

			if (root[childKey] && root[childKey].length > 0) {
				view.createNodes(setting, 0, root[childKey]);
			} else if (setting.async.enable && setting.async.url && setting.async.url !== '') {
				view.asyncNode(setting);
			}
			return zTreeTools;
		}
	};

	var zt = $.fn.zTree,
	$$ = tools.$,
	consts = zt.consts;




	$.widget("ui.tree",{
		widgetEventPrefix: "tree",
	    options: _setting,
	    _create: function() {
	    	var zTreeTools = $.fn.zTree.init(this.element, this.options, this.options.fNodes);
	    	$.extend(true, $.ui.tree.prototype, zTreeTools);
	    },
	    /**
		 * @method reloadData 刷新数据源
		 * @param {Array} data 需要增加的节点数据 JSON 对象集合
		 * @return {Array} 返回Tree最终的节点数据集合
		 */
		reloadData: function(data) {
			var nodes = this.getNodes();

			while (nodes.length) {
				this.removeNode(nodes[0]);
			}

			return this.addNodes(null, data);
		}
	});











}));
/*
 * JQuery zTree excheck v3.5.17
 * http://zTree.me/
 *
 * Copyright (c) 2010 Hunter.z
 *
 * Licensed same as jquery - MIT License
 * http://www.opensource.org/licenses/mit-license.php
 *
 * email: hunter.z@263.net
 * Date: 2014-05-08
 */
/**
 * @class fish.desktop.widget.tree
 */
(function(factory) {
	if (typeof define === "function" && define.amd) {
		define('fish.tree.excheck',['jquery','fish.tree'], factory);
  	} else {
    	factory(jQuery);
	}
}(function($){
	//default consts of excheck
	var _consts = {
		event: {
			CHECK: "ztree_check"
		},
		id: {
			CHECK: "_check"
		},
		checkbox: {
			STYLE: "checkbox",
			DEFAULT: "chk",
			DISABLED: "disable",
			FALSE: "false",
			TRUE: "true",
			FULL: "full",
			PART: "part",
			FOCUS: "focus"
		},
		radio: {
			STYLE: "radio",
			TYPE_ALL: "all",
			TYPE_LEVEL: "level"
		}
	},
	//default setting of excheck
	_setting = {
        /**
		 * @cfg {Object} check 节点选中操作相关的配置项
		 * @cfg {Boolean} check.enable 设置 zTree 的节点上是否显示 checkbox / radio;默认值false
		 * @cfg {Boolean} check.autoCheckTrigger 设置自动关联勾选时是否触发 beforeCheck / onCheck 事件回调函数。[check.enable = true 且 check.chkStyle = "checkbox" 时生效]  
		 *      1、如果设置 setting.check.chkboxType = { "Y": "", "N": "" }，将不会有任何自动关联勾选的操作。	
		 *      2、如果开启触发，对于节点较多的树将会影响性能，因为所有被联动勾选的操作都会触发事件回调函数，请根据需要决定是否使用此功能。
		 * @cfg {String} check.chkStyle 勾选框类型(checkbox 或 radio）[check.enable = true 时生效],默认值："checkbox"
		 * @cfg {Object} check.chkboxType 勾选 checkbox 对于父子节点的关联关系。[check.enable = true 且 check.chkStyle = "checkbox" 时生效] 默认值：{ "Y": "ps", "N": "ps" }
		 *      Y 属性定义 checkbox 被勾选后的情况； 	
		 *      N 属性定义 checkbox 取消勾选后的情况； 
		 *      "p" 表示操作会影响父级节点； 
		 *      "s" 表示操作会影响子级节点。
		 *      请注意大小写，不要改变
		 * @cfg {Boolean} check.nocheckInherit 当父节点设置 nocheck = true 时，设置子节点是否自动继承 nocheck = true [check.enable = true 时生效]
		 * @cfg {Boolean} check.chkDisabledInherit  当父节点设置 chkDisabled = true 时，设置子节点是否自动继承 chkDisabled = true 。
		 */
		check: {
			enable: false,
			autoCheckTrigger: false,
			chkStyle: _consts.checkbox.STYLE,
			nocheckInherit: false,
			chkDisabledInherit: false,
			radioType: _consts.radio.TYPE_LEVEL,
			chkboxType: {
				"Y": "ps",
				"N": "ps"
			}
		},
		/*
		 * @cfg {Object} data 数据相关的配置
		 */
		data: {
			key: {
				checked: "checked"
			}
		},
		/*
		 * @cfg {Object} callback 回调函数的配置
		 */
		callback: {
			beforeCheck:null,
			onCheck:null
		}
	},
	//default root of excheck
	_initRoot = function (setting) {
		var r = data.getRoot(setting);
		r.radioCheckedList = [];
	},
	//default cache of excheck
	_initCache = function(treeId) {},
	//default bind event of excheck
	_bindEvent = function(setting) {
		var o = setting.treeObj,
		c = consts.event;
		o.bind(c.CHECK, function (event, srcEvent, treeId, node) {
			event.srcEvent = srcEvent;
			tools.apply(setting.callback.onCheck, [event, treeId, node]);
		});
	},
	_unbindEvent = function(setting) {
		var o = setting.treeObj,
		c = consts.event;
		o.unbind(c.CHECK);
	},
	//default event proxy of excheck
	_eventProxy = function(e) {
		var target = e.target,
		setting = data.getSetting(e.data.treeId),
		tId = "", node = null,
		nodeEventType = "", treeEventType = "",
		nodeEventCallback = null, treeEventCallback = null;

		if (tools.eqs(e.type, "mouseover")) {
			if (setting.check.enable && tools.eqs(target.tagName, "span") && target.getAttribute("treeNode"+ consts.id.CHECK) !== null) {
				tId = tools.getNodeMainDom(target).id;
				nodeEventType = "mouseoverCheck";
			}
		} else if (tools.eqs(e.type, "mouseout")) {
			if (setting.check.enable && tools.eqs(target.tagName, "span") && target.getAttribute("treeNode"+ consts.id.CHECK) !== null) {
				tId = tools.getNodeMainDom(target).id;
				nodeEventType = "mouseoutCheck";
			}
		} else if (tools.eqs(e.type, "click")) {
			if (setting.check.enable && tools.eqs(target.tagName, "span") && target.getAttribute("treeNode"+ consts.id.CHECK) !== null) {
				tId = tools.getNodeMainDom(target).id;
				nodeEventType = "checkNode";
			}
		}
		if (tId.length>0) {
			node = data.getNodeCache(setting, tId);
			switch (nodeEventType) {
				case "checkNode" :
					nodeEventCallback = _handler.onCheckNode;
					break;
				case "mouseoverCheck" :
					nodeEventCallback = _handler.onMouseoverCheck;
					break;
				case "mouseoutCheck" :
					nodeEventCallback = _handler.onMouseoutCheck;
					break;
			}
		}
		var proxyResult = {
			stop: nodeEventType === "checkNode",
			node: node,
			nodeEventType: nodeEventType,
			nodeEventCallback: nodeEventCallback,
			treeEventType: treeEventType,
			treeEventCallback: treeEventCallback
		};
		return proxyResult
	},
	//default init node of excheck
	_initNode = function(setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {
		if (!n) return;
		var checkedKey = setting.data.key.checked;
		if (typeof n[checkedKey] == "string") n[checkedKey] = tools.eqs(n[checkedKey], "true");
		n[checkedKey] = !!n[checkedKey];
		n.checkedOld = n[checkedKey];
		if (typeof n.nocheck == "string") n.nocheck = tools.eqs(n.nocheck, "true");
		n.nocheck = !!n.nocheck || (setting.check.nocheckInherit && parentNode && !!parentNode.nocheck);
		if (typeof n.chkDisabled == "string") n.chkDisabled = tools.eqs(n.chkDisabled, "true");
		n.chkDisabled = !!n.chkDisabled || (setting.check.chkDisabledInherit && parentNode && !!parentNode.chkDisabled);
		if (typeof n.halfCheck == "string") n.halfCheck = tools.eqs(n.halfCheck, "true");
		n.halfCheck = !!n.halfCheck;
		n.check_Child_State = -1;
		n.check_Focus = false;
		n.getCheckStatus = function() {return data.getCheckStatus(setting, n);};

		if (setting.check.chkStyle == consts.radio.STYLE && setting.check.radioType == consts.radio.TYPE_ALL && n[checkedKey] ) {
			var r = data.getRoot(setting);
			r.radioCheckedList.push(n);
		}
	},
	//add dom for check
	_beforeA = function(setting, node, html) {
		var checkedKey = setting.data.key.checked;
		if (setting.check.enable) {
			data.makeChkFlag(setting, node);
			html.push("<span ID='", node.tId, consts.id.CHECK, "' class='", view.makeChkClass(setting, node), "' treeNode", consts.id.CHECK, (node.nocheck === true?" style='display:none;'":""),"></span>");
		}
	},
	//update zTreeObj, add method of check
	_zTreeTools = function(setting, zTreeTools) {
		/**
		 * @method checkNode
		 * 勾选 或 取消勾选 单个节点。[setting.check.enable = true 时有效];checkNode() 方法可以触发 beforeCheck / onCheck 事件回调函数
		 * @param  {Object} node   需要勾选 或 取消勾选 的节点数据;请务必保证此节点数据对象 是 zTree 内部的数据对象
		 * @param  {Boolean} [checked]     true 表示勾选节点; false 表示节点取消勾选;如果省略参数，则根据对此节点的勾选状态进行 toggle 切换;不影响 treeNode.nochecked = true 的节点。
		 * @param  {Boolean} [checkTypeFlag] true 表示按照 setting.check.chkboxType 属性进行父子节点的勾选联动操作;false 表示只修改此节点勾选状态，无任何勾选联动操作;checkTypeFlag = false 且 treeNode.checked = checked 时，不会触发回调函数，直接返回
		 *                                 不影响父子节点中 treeNode.nochecked = true 的节点。
		 * @param  {Boolean} [callbackFlag=false]   true 表示执行此方法时触发 beforeCheck & onCheck 事件回调函数;false表示不触发回调
		 */
		zTreeTools.checkNode = function(node, checked, checkTypeFlag, callbackFlag) {
			var checkedKey = this.setting.data.key.checked;
			if (node.chkDisabled === true) return;
			if (checked !== true && checked !== false) {
				checked = !node[checkedKey];
			}
			callbackFlag = !!callbackFlag;

			if (node[checkedKey] === checked && !checkTypeFlag) {
				return;
			} else if (callbackFlag && tools.apply(this.setting.callback.beforeCheck, [this.setting.treeId, node], true) == false) {
				return;
			}
			if (tools.uCanDo(this.setting) && this.setting.check.enable && node.nocheck !== true) {
				node[checkedKey] = checked;
				var checkObj = $$(node, consts.id.CHECK, this.setting);
				if (checkTypeFlag || this.setting.check.chkStyle === consts.radio.STYLE) view.checkNodeRelation(this.setting, node);
				view.setChkClass(this.setting, checkObj, node);
				view.repairParentChkClassWithSelf(this.setting, node);
				if (callbackFlag) {
					this.setting.treeObj.trigger(consts.event.CHECK, [null, this.setting.treeId, node]);
				}
			}
		}
		/**
		 * @method checkAllNodes
		 * 勾选 或 取消勾选 全部节点。[check.enable = true 且 check.chkStyle = "checkbox" 时有效]
		 * @param  {Boolean} [checked=true] true 表示勾选全部节点;false 表示全部节点取消勾选;不会影响 treeNode.nochecked = true 的节点。不会影响未加载的节点
		 */
		zTreeTools.checkAllNodes = function(checked) {
			view.repairAllChk(this.setting, !!checked);
		}
		/**
		 * @method getCheckedNodes
		 * 获取输入框被勾选 或 未勾选的节点集合。[check.enable = true 时有效]
		 * @param  {Boolean} [checked=true]  true 表示获取 被勾选 的节点集合;false 表示获取 未勾选 的节点集合
		 * @return {Array}         返回全部符合要求的节点集合 Array
		 */
		zTreeTools.getCheckedNodes = function(checked) {
			var childKey = this.setting.data.key.children;
			checked = (checked !== false);
			return data.getTreeCheckedNodes(this.setting, data.getRoot(this.setting)[childKey], checked);
		}
		/**
		 * @method getChangeCheckedNodes
		 * 获取获取输入框勾选状态被改变的节点集合（与原始数据 checkedOld 对比）。[check.enable = true 时有效]
		 * @return {Array} 返回全部勾选状态被改变的节点集合 Array
		 */
		zTreeTools.getChangeCheckedNodes = function() {
			var childKey = this.setting.data.key.children;
			return data.getTreeChangeCheckedNodes(this.setting, data.getRoot(this.setting)[childKey]);
		}
		/**
		 * @method setChkDisabled
		 * 禁用 或 解禁 某个节点的 checkbox / radio [check.enable = true 时有效]
		 * 1、节点的 checkbox / radio 被禁用后，无法勾选或取消勾选，但能够影响父节点的半选状态
		 * 2、请不要直接修改已加载节点的 treeNode.chkDisabled 属性。
		 * @param {Object} node  需要禁用 或 解禁 checkbox / radio 的节点数据,请务必保证此节点数据对象 是 zTree 内部的数据对象 
		 * @param {Boolean} [disabled=false]   true 表示禁用 checkbox / radio;false表示解禁； 不影响 treeNode.nochecked = true 的节点。
		 * @param {Boolean} [inheritParent=false]   true 表示全部父节点进行同样的操作,false 表示不影响父节点
		 * @param {Boolean} [inheritChildren=false]  true 表示全部子节点进行同样的操作,false 表示不影响子节点
		 */
		zTreeTools.setChkDisabled = function(node, disabled, inheritParent, inheritChildren) {
			disabled = !!disabled;
			inheritParent = !!inheritParent;
			inheritChildren = !!inheritChildren;
			view.repairSonChkDisabled(this.setting, node, disabled, inheritChildren);
			view.repairParentChkDisabled(this.setting, node.getParentNode(), disabled, inheritParent);
		}

		var _updateNode = zTreeTools.updateNode;
		zTreeTools.updateNode = function(node, checkTypeFlag) {
			if (_updateNode) _updateNode.apply(zTreeTools, arguments);
			if (!node || !this.setting.check.enable) return;
			var nObj = $$(node, this.setting);
			if (nObj.get(0) && tools.uCanDo(this.setting)) {
				var checkObj = $$(node, consts.id.CHECK, this.setting);
				if (checkTypeFlag == true || this.setting.check.chkStyle === consts.radio.STYLE) view.checkNodeRelation(this.setting, node);
				view.setChkClass(this.setting, checkObj, node);
				view.repairParentChkClassWithSelf(this.setting, node);
			}
		}
	},
	//method of operate data
	_data = {
		getRadioCheckedList: function(setting) {
			var checkedList = data.getRoot(setting).radioCheckedList;
			for (var i=0, j=checkedList.length; i<j; i++) {
				if(!data.getNodeCache(setting, checkedList[i].tId)) {
					checkedList.splice(i, 1);
					i--; j--;
				}
			}
			return checkedList;
		},
		getCheckStatus: function(setting, node) {
			if (!setting.check.enable || node.nocheck || node.chkDisabled) return null;
			var checkedKey = setting.data.key.checked,
			r = {
				checked: node[checkedKey],
				half: node.halfCheck ? node.halfCheck : (setting.check.chkStyle == consts.radio.STYLE ? (node.check_Child_State === 2) : (node[checkedKey] ? (node.check_Child_State > -1 && node.check_Child_State < 2) : (node.check_Child_State > 0)))
			};
			return r;
		},
		getTreeCheckedNodes: function(setting, nodes, checked, results) {
			if (!nodes) return [];
			var childKey = setting.data.key.children,
			checkedKey = setting.data.key.checked,
			onlyOne = (checked && setting.check.chkStyle == consts.radio.STYLE && setting.check.radioType == consts.radio.TYPE_ALL);
			results = !results ? [] : results;
			for (var i = 0, l = nodes.length; i < l; i++) {
				if (nodes[i].nocheck !== true && nodes[i].chkDisabled !== true && nodes[i][checkedKey] == checked) {
					results.push(nodes[i]);
					if(onlyOne) {
						break;
					}
				}
				data.getTreeCheckedNodes(setting, nodes[i][childKey], checked, results);
				if(onlyOne && results.length > 0) {
					break;
				}
			}
			return results;
		},
		getTreeChangeCheckedNodes: function(setting, nodes, results) {
			if (!nodes) return [];
			var childKey = setting.data.key.children,
			checkedKey = setting.data.key.checked;
			results = !results ? [] : results;
			for (var i = 0, l = nodes.length; i < l; i++) {
				if (nodes[i].nocheck !== true && nodes[i].chkDisabled !== true && nodes[i][checkedKey] != nodes[i].checkedOld) {
					results.push(nodes[i]);
				}
				data.getTreeChangeCheckedNodes(setting, nodes[i][childKey], results);
			}
			return results;
		},
		makeChkFlag: function(setting, node) {
			if (!node) return;
			var childKey = setting.data.key.children,
			checkedKey = setting.data.key.checked,
			chkFlag = -1;
			if (node[childKey]) {
				for (var i = 0, l = node[childKey].length; i < l; i++) {
					var cNode = node[childKey][i];
					var tmp = -1;
					if (setting.check.chkStyle == consts.radio.STYLE) {
						if (cNode.nocheck === true || cNode.chkDisabled === true) {
							tmp = cNode.check_Child_State;
						} else if (cNode.halfCheck === true) {
							tmp = 2;
						} else if (cNode[checkedKey]) {
							tmp = 2;
						} else {
							tmp = cNode.check_Child_State > 0 ? 2:0;
						}
						if (tmp == 2) {
							chkFlag = 2; break;
						} else if (tmp == 0){
							chkFlag = 0;
						}
					} else if (setting.check.chkStyle == consts.checkbox.STYLE) {
						if (cNode.nocheck === true || cNode.chkDisabled === true) {
							tmp = cNode.check_Child_State;
						} else if (cNode.halfCheck === true) {
							tmp = 1;
						} else if (cNode[checkedKey] ) {
							tmp = (cNode.check_Child_State === -1 || cNode.check_Child_State === 2) ? 2 : 1;
						} else {
							tmp = (cNode.check_Child_State > 0) ? 1 : 0;
						}
						if (tmp === 1) {
							chkFlag = 1; break;
						} else if (tmp === 2 && chkFlag > -1 && i > 0 && tmp !== chkFlag) {
							chkFlag = 1; break;
						} else if (chkFlag === 2 && tmp > -1 && tmp < 2) {
							chkFlag = 1; break;
						} else if (tmp > -1) {
							chkFlag = tmp;
						}
					}
				}
			}
			node.check_Child_State = chkFlag;
		}
	},
	//method of event proxy
	_event = {

	},
	//method of event handler
	_handler = {
		onCheckNode: function (event, node) {
			if (node.chkDisabled === true) return false;
			var setting = data.getSetting(event.data.treeId),
			checkedKey = setting.data.key.checked;
			if (tools.apply(setting.callback.beforeCheck, [setting.treeId, node], true) == false) return true;
			node[checkedKey] = !node[checkedKey];
			view.checkNodeRelation(setting, node);
			var checkObj = $$(node, consts.id.CHECK, setting);
			view.setChkClass(setting, checkObj, node);
			view.repairParentChkClassWithSelf(setting, node);
			setting.treeObj.trigger(consts.event.CHECK, [event, setting.treeId, node]);
			return true;
		},
		onMouseoverCheck: function(event, node) {
			if (node.chkDisabled === true) return false;
			var setting = data.getSetting(event.data.treeId),
			checkObj = $$(node, consts.id.CHECK, setting);
			node.check_Focus = true;
			view.setChkClass(setting, checkObj, node);
			return true;
		},
		onMouseoutCheck: function(event, node) {
			if (node.chkDisabled === true) return false;
			var setting = data.getSetting(event.data.treeId),
			checkObj = $$(node, consts.id.CHECK, setting);
			node.check_Focus = false;
			view.setChkClass(setting, checkObj, node);
			return true;
		}
	},
	//method of tools for zTree
	_tools = {

	},
	//method of operate ztree dom
	_view = {
		checkNodeRelation: function(setting, node) {
			var pNode, i, l,
			childKey = setting.data.key.children,
			checkedKey = setting.data.key.checked,
			r = consts.radio;
			if (setting.check.chkStyle == r.STYLE) {
				var checkedList = data.getRadioCheckedList(setting);
				if (node[checkedKey]) {
					if (setting.check.radioType == r.TYPE_ALL) {
						for (i = checkedList.length-1; i >= 0; i--) {
							pNode = checkedList[i];
							if (pNode[checkedKey] && pNode != node) {
								pNode[checkedKey] = false;
								checkedList.splice(i, 1);

								view.setChkClass(setting, $$(pNode, consts.id.CHECK, setting), pNode);
								if (pNode.parentTId != node.parentTId) {
									view.repairParentChkClassWithSelf(setting, pNode);
								}
							}
						}
						checkedList.push(node);
					} else {
						var parentNode = (node.parentTId) ? node.getParentNode() : data.getRoot(setting);
						for (i = 0, l = parentNode[childKey].length; i < l; i++) {
							pNode = parentNode[childKey][i];
							if (pNode[checkedKey] && pNode != node) {
								pNode[checkedKey] = false;
								view.setChkClass(setting, $$(pNode, consts.id.CHECK, setting), pNode);
							}
						}
					}
				} else if (setting.check.radioType == r.TYPE_ALL) {
					for (i = 0, l = checkedList.length; i < l; i++) {
						if (node == checkedList[i]) {
							checkedList.splice(i, 1);
							break;
						}
					}
				}

			} else {
				if (node[checkedKey] && (!node[childKey] || node[childKey].length==0 || setting.check.chkboxType.Y.indexOf("s") > -1)) {
					view.setSonNodeCheckBox(setting, node, true);
				}
				if (!node[checkedKey] && (!node[childKey] || node[childKey].length==0 || setting.check.chkboxType.N.indexOf("s") > -1)) {
					view.setSonNodeCheckBox(setting, node, false);
				}
				if (node[checkedKey] && setting.check.chkboxType.Y.indexOf("p") > -1) {
					view.setParentNodeCheckBox(setting, node, true);
				}
				if (!node[checkedKey] && setting.check.chkboxType.N.indexOf("p") > -1) {
					view.setParentNodeCheckBox(setting, node, false);
				}
			}
		},
		makeChkClass: function(setting, node) {
			var checkedKey = setting.data.key.checked,
			c = consts.checkbox, r = consts.radio,
			fullStyle = "";
			if (node.chkDisabled === true) {
				fullStyle = c.DISABLED;
			} else if (node.halfCheck) {
				fullStyle = c.PART;
			} else if (setting.check.chkStyle == r.STYLE) {
				fullStyle = (node.check_Child_State < 1)? c.FULL:c.PART;
			} else {
				fullStyle = node[checkedKey] ? ((node.check_Child_State === 2 || node.check_Child_State === -1) ? c.FULL:c.PART) : ((node.check_Child_State < 1)? c.FULL:c.PART);
			}
			var chkName = setting.check.chkStyle + "_" + (node[checkedKey] ? c.TRUE : c.FALSE) + "_" + fullStyle;
			chkName = (node.check_Focus && node.chkDisabled !== true) ? chkName + "_" + c.FOCUS : chkName;
			return consts.className.BUTTON + " " + c.DEFAULT + " " + chkName;
		},
		repairAllChk: function(setting, checked) {
			if (setting.check.enable && setting.check.chkStyle === consts.checkbox.STYLE) {
				var checkedKey = setting.data.key.checked,
				childKey = setting.data.key.children,
				root = data.getRoot(setting);
				for (var i = 0, l = root[childKey].length; i<l ; i++) {
					var node = root[childKey][i];
					if (node.nocheck !== true && node.chkDisabled !== true) {
						node[checkedKey] = checked;
					}
					view.setSonNodeCheckBox(setting, node, checked);
				}
			}
		},
		repairChkClass: function(setting, node) {
			if (!node) return;
			data.makeChkFlag(setting, node);
			if (node.nocheck !== true) {
				var checkObj = $$(node, consts.id.CHECK, setting);
				view.setChkClass(setting, checkObj, node);
			}
		},
		repairParentChkClass: function(setting, node) {
			if (!node || !node.parentTId) return;
			var pNode = node.getParentNode();
			view.repairChkClass(setting, pNode);
			view.repairParentChkClass(setting, pNode);
		},
		repairParentChkClassWithSelf: function(setting, node) {
			if (!node) return;
			var childKey = setting.data.key.children;
			if (node[childKey] && node[childKey].length > 0) {
				view.repairParentChkClass(setting, node[childKey][0]);
			} else {
				view.repairParentChkClass(setting, node);
			}
		},
		repairSonChkDisabled: function(setting, node, chkDisabled, inherit) {
			if (!node) return;
			var childKey = setting.data.key.children;
			if (node.chkDisabled != chkDisabled) {
				node.chkDisabled = chkDisabled;
			}
			view.repairChkClass(setting, node);
			if (node[childKey] && inherit) {
				for (var i = 0, l = node[childKey].length; i < l; i++) {
					var sNode = node[childKey][i];
					view.repairSonChkDisabled(setting, sNode, chkDisabled, inherit);
				}
			}
		},
		repairParentChkDisabled: function(setting, node, chkDisabled, inherit) {
			if (!node) return;
			if (node.chkDisabled != chkDisabled && inherit) {
				node.chkDisabled = chkDisabled;
			}
			view.repairChkClass(setting, node);
			view.repairParentChkDisabled(setting, node.getParentNode(), chkDisabled, inherit);
		},
		setChkClass: function(setting, obj, node) {
			if (!obj) return;
			if (node.nocheck === true) {
				obj.hide();
			} else {
				obj.show();
			}
            obj.attr('class', view.makeChkClass(setting, node));
		},
		setParentNodeCheckBox: function(setting, node, value, srcNode) {
			var childKey = setting.data.key.children,
			checkedKey = setting.data.key.checked,
			checkObj = $$(node, consts.id.CHECK, setting);
			if (!srcNode) srcNode = node;
			data.makeChkFlag(setting, node);
			if (node.nocheck !== true && node.chkDisabled !== true) {
				node[checkedKey] = value;
				view.setChkClass(setting, checkObj, node);
				if (setting.check.autoCheckTrigger && node != srcNode) {
					setting.treeObj.trigger(consts.event.CHECK, [null, setting.treeId, node]);
				}
			}
			if (node.parentTId) {
				var pSign = true;
				if (!value) {
					var pNodes = node.getParentNode()[childKey];
					for (var i = 0, l = pNodes.length; i < l; i++) {
						if ((pNodes[i].nocheck !== true && pNodes[i].chkDisabled !== true && pNodes[i][checkedKey])
						|| ((pNodes[i].nocheck === true || pNodes[i].chkDisabled === true) && pNodes[i].check_Child_State > 0)) {
							pSign = false;
							break;
						}
					}
				}
				if (pSign) {
					view.setParentNodeCheckBox(setting, node.getParentNode(), value, srcNode);
				}
			}
		},
		setSonNodeCheckBox: function(setting, node, value, srcNode) {
			if (!node) return;
			var childKey = setting.data.key.children,
			checkedKey = setting.data.key.checked,
			checkObj = $$(node, consts.id.CHECK, setting);
			if (!srcNode) srcNode = node;

			var hasDisable = false;
			if (node[childKey]) {
				for (var i = 0, l = node[childKey].length; i < l && node.chkDisabled !== true; i++) {
					var sNode = node[childKey][i];
					view.setSonNodeCheckBox(setting, sNode, value, srcNode);
					if (sNode.chkDisabled === true) hasDisable = true;
				}
			}

			if (node != data.getRoot(setting) && node.chkDisabled !== true) {
				if (hasDisable && node.nocheck !== true) {
					data.makeChkFlag(setting, node);
				}
				if (node.nocheck !== true && node.chkDisabled !== true) {
					node[checkedKey] = value;
					if (!hasDisable) node.check_Child_State = (node[childKey] && node[childKey].length > 0) ? (value ? 2 : 0) : -1;
				} else {
					node.check_Child_State = -1;
				}
				view.setChkClass(setting, checkObj, node);
				if (setting.check.autoCheckTrigger && node != srcNode && node.nocheck !== true && node.chkDisabled !== true) {
					setting.treeObj.trigger(consts.event.CHECK, [null, setting.treeId, node]);
				}
			}

		}
	},

	_z = {
		tools: _tools,
		view: _view,
		event: _event,
		data: _data
	};
	$.extend(true, $.fn.zTree.consts, _consts);
	$.extend(true, $.fn.zTree._z, _z);

	var zt = $.fn.zTree,
	tools = zt._z.tools,
	consts = zt.consts,
	view = zt._z.view,
	data = zt._z.data,
	event = zt._z.event,
	$$ = tools.$;

	data.exSetting(_setting);
	data.addInitBind(_bindEvent);
	data.addInitUnBind(_unbindEvent);
	data.addInitCache(_initCache);
	data.addInitNode(_initNode);
	data.addInitProxy(_eventProxy, true);
	data.addInitRoot(_initRoot);
	data.addBeforeA(_beforeA);
	data.addZTreeTools(_zTreeTools);

	var _createNodes = view.createNodes;
	view.createNodes = function(setting, level, nodes, parentNode) {
		if (_createNodes) _createNodes.apply(view, arguments);
		if (!nodes) return;
		view.repairParentChkClassWithSelf(setting, parentNode);
	}
	var _removeNode = view.removeNode;
	view.removeNode = function(setting, node) {
		var parentNode = node.getParentNode();
		if (_removeNode) _removeNode.apply(view, arguments);
		if (!node || !parentNode) return;
		view.repairChkClass(setting, parentNode);
		view.repairParentChkClass(setting, parentNode);
	}

	var _appendNodes = view.appendNodes;
	view.appendNodes = function(setting, level, nodes, parentNode, initFlag, openFlag) {
		var html = "";
		if (_appendNodes) {
			html = _appendNodes.apply(view, arguments);
		}
		if (parentNode) {
			data.makeChkFlag(setting, parentNode);
		}
		return html;
	}
}));
/*
 * JQuery zTree exedit v3.5.17
 * http://zTree.me/
 *
 * Copyright (c) 2010 Hunter.z
 *
 * Licensed same as jquery - MIT License
 * http://www.opensource.org/licenses/mit-license.php
 *
 * email: hunter.z@263.net
 * Date: 2014-05-08
 */
/**
 * @class fish.desktop.widget.tree
 */
(function(factory) {
	if (typeof define === "function" && define.amd) {
		define('fish.tree.excedit',['jquery','fish.tree'], factory);
  	} else {
    	factory(jQuery);
	}
}(function($){
	//default consts of exedit
	var _consts = {
		event: {
			DRAG: "ztree_drag",
			DROP: "ztree_drop",
			RENAME: "ztree_rename",
			DRAGMOVE:"ztree_dragmove"
		},
		id: {
			EDIT: "_edit",
			INPUT: "_input",
			REMOVE: "_remove"
		},
		move: {
			TYPE_INNER: "inner",
			TYPE_PREV: "prev",
			TYPE_NEXT: "next"
		},
		node: {
			CURSELECTED_EDIT: "curSelectedNode_Edit",
			TMPTARGET_TREE: "tmpTargetzTree",
			TMPTARGET_NODE: "tmpTargetNode"
		}
	},
	//default setting of exedit
	_setting = {
		/**
		 * @cfg {Object} edit 节点选中操作相关的配置项
		 */
		edit: {
			enable: false,
			editNameSelectAll: false,
			showRemoveBtn: true,
			showRenameBtn: true,
			removeTitle: "remove",
			renameTitle: "rename",
			drag: {
				autoExpandTrigger: false,
				isCopy: true,
				isMove: true,
				prev: true,
				next: true,
				inner: true,
				minMoveSize: 5,
				borderMax: 10,
				borderMin: -5,
				maxShowNodeNum: 5,
				autoOpenTime: 500
			}
		},
		/*
		 * @cfg {Object} view 页面展示相关的配置
		 */
		view: {
			addHoverDom: null,
			removeHoverDom: null
		},
		/*
		 * @cfg {Object} callback 回调函数的配置
		 */
		callback: {
			beforeDrag:null,
			beforeDragOpen:null,
			beforeDrop:null,
			beforeEditName:null,
			beforeRename:null,
			onDrag:null,
			onDragMove:null,
			onDrop:null,
			onRename:null
		}
	},
	//default root of exedit
	_initRoot = function (setting) {
		var r = data.getRoot(setting), rs = data.getRoots();
		r.curEditNode = null;
		r.curEditInput = null;
		r.curHoverNode = null;
		r.dragFlag = 0;
		r.dragNodeShowBefore = [];
		r.dragMaskList = new Array();
		rs.showHoverDom = true;
	},
	//default cache of exedit
	_initCache = function(treeId) {},
	//default bind event of exedit
	_bindEvent = function(setting) {
		var o = setting.treeObj;
		var c = consts.event;
		o.bind(c.RENAME, function (event, treeId, treeNode, isCancel) {
			tools.apply(setting.callback.onRename, [event, treeId, treeNode, isCancel]);
		});

		o.bind(c.DRAG, function (event, srcEvent, treeId, treeNodes) {
			tools.apply(setting.callback.onDrag, [srcEvent, treeId, treeNodes]);
		});

		o.bind(c.DRAGMOVE,function(event, srcEvent, treeId, treeNodes){
			tools.apply(setting.callback.onDragMove,[srcEvent, treeId, treeNodes]);
		});

		o.bind(c.DROP, function (event, srcEvent, treeId, treeNodes, targetNode, moveType, isCopy) {
			tools.apply(setting.callback.onDrop, [srcEvent, treeId, treeNodes, targetNode, moveType, isCopy]);
		});
	},
	_unbindEvent = function(setting) {
		var o = setting.treeObj;
		var c = consts.event;
		o.unbind(c.RENAME);
		o.unbind(c.DRAG);
		o.unbind(c.DRAGMOVE);
		o.unbind(c.DROP);
	},
	//default event proxy of exedit
	_eventProxy = function(e) {
		var target = e.target,
		setting = data.getSetting(e.data.treeId),
		relatedTarget = e.relatedTarget,
		tId = "", node = null,
		nodeEventType = "", treeEventType = "",
		nodeEventCallback = null, treeEventCallback = null,
		tmp = null;

		if (tools.eqs(e.type, "mouseover")) {
			tmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);
			if (tmp) {
				tId = tools.getNodeMainDom(tmp).id;
				nodeEventType = "hoverOverNode";
			}
		} else if (tools.eqs(e.type, "mouseout")) {
			tmp = tools.getMDom(setting, relatedTarget, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);
			if (!tmp) {
				tId = "remove";
				nodeEventType = "hoverOutNode";
			}
		} else if (tools.eqs(e.type, "mousedown")) {
			tmp = tools.getMDom(setting, target, [{tagName:"a", attrName:"treeNode"+consts.id.A}]);
			if (tmp) {
				tId = tools.getNodeMainDom(tmp).id;
				nodeEventType = "mousedownNode";
			}
		}
		if (tId.length>0) {
			node = data.getNodeCache(setting, tId);
			switch (nodeEventType) {
				case "mousedownNode" :
					nodeEventCallback = _handler.onMousedownNode;
					break;
				case "hoverOverNode" :
					nodeEventCallback = _handler.onHoverOverNode;
					break;
				case "hoverOutNode" :
					nodeEventCallback = _handler.onHoverOutNode;
					break;
			}
		}
		var proxyResult = {
			stop: false,
			node: node,
			nodeEventType: nodeEventType,
			nodeEventCallback: nodeEventCallback,
			treeEventType: treeEventType,
			treeEventCallback: treeEventCallback
		};
		return proxyResult
	},
	//default init node of exedit
	_initNode = function(setting, level, n, parentNode, isFirstNode, isLastNode, openFlag) {
		if (!n) return;
		n.isHover = false;
		n.editNameFlag = false;
	},
	//update zTreeObj, add method of edit
	_zTreeTools = function(setting, zTreeTools) {
		/**
		 * @method cancelEditName
		 * Cancel the edit name status. Can restore the original name, and can also force assigned to a new name.
		 * @param  {String} newName Re given a new name . If this parameter is omitted, then restore the original name.
		 */
		zTreeTools.cancelEditName = function(newName) {
			var root = data.getRoot(this.setting);
			if (!root.curEditNode) return;
			view.cancelCurEditNode(this.setting, newName?newName:null, true);
		}
		/**
		 * Copy the node
		 * @method copyNode
		 * @param  {Object}  targetNode JSON data object of the node which will be target.
		 * @param  {Object}  node       JSON data object of the node which will be copied.
		 * @param  {String}  moveType   Copied to the target node's relative position.
		 *  "inner" means: to be taregetNode's child node.
		 *	"prev" means: to be taregetNode's previous sibling node.
		 *	"next" means: to be taregetNode's next sibling node.
		 * @param  {Boolean} isSilent   After copy the node, whether to automatically expand its parent node.isSilent = true means: don't expand its parent node.isSilent = false or omit this parameter means: expand its parent node.
		 * @return {Object}             return the new node in zTree.Note: the node data JSON object in the return value is not equal to the treeNode.
		 */
		zTreeTools.copyNode = function(targetNode, node, moveType, isSilent) {
			if (!node) return null;
			if (targetNode && !targetNode.isParent && this.setting.data.keep.leaf && moveType === consts.move.TYPE_INNER) return null;
			var _this = this,
				newNode = tools.clone(node);
			if (!targetNode) {
				targetNode = null;
				moveType = consts.move.TYPE_INNER;
			}
			if (moveType == consts.move.TYPE_INNER) {
				function copyCallback() {
					view.addNodes(_this.setting, targetNode, [newNode], isSilent);
				}

				if (tools.canAsync(this.setting, targetNode)) {
					view.asyncNode(this.setting, targetNode, isSilent, copyCallback);
				} else {
					copyCallback();
				}
			} else {
				view.addNodes(this.setting, targetNode.parentNode, [newNode], isSilent);
				view.moveNode(this.setting, targetNode, newNode, moveType, false, isSilent);
			}
			return newNode;
		}
		/**
		 * Start editing the node's name.
		 * @method editName
		 * @param  {Object} node JSON data object of the node which will be editing name.Please ensure that this data object is an internal node data object in zTree.
		 */
		zTreeTools.editName = function(node) {
			if (!node || !node.tId || node !== data.getNodeCache(this.setting, node.tId)) return;
			if (node.parentTId) view.expandCollapseParentNode(this.setting, node.getParentNode(), true);
			view.editNode(this.setting, node)
		}
		/**
		 * Move the node
		 * @method moveNode
		 * @param  {Object}  targetNode JSON data object of the node which will be target.
		 * @param  {Object}  node       JSON data object of the node which will be moved.
		 * @param  {String}  moveType   Copied to the target node's relative position.
		 *  "inner" means: to be taregetNode's child node.
		 *	"prev" means: to be taregetNode's previous sibling node.
		 *	"next" means: to be taregetNode's next sibling node.
		 * @param  {Boolean} isSilent   After move the node, whether to automatically expand its parent node.isSilent = true means: don't expand its parent node.isSilent = false or omit this parameter means: expand its parent node.
		 * @return {Object}             return the node which be moved, it is same as the 'treeNode' parameter.
		 */
		zTreeTools.moveNode = function(targetNode, node, moveType, isSilent) {
			if (!node) return node;
			if (targetNode && !targetNode.isParent && this.setting.data.keep.leaf && moveType === consts.move.TYPE_INNER) {
				return null;
			} else if (targetNode && ((node.parentTId == targetNode.tId && moveType == consts.move.TYPE_INNER) || $$(node, this.setting).find("#" + targetNode.tId).length > 0)) {
				return null;
			} else if (!targetNode) {
				targetNode = null;
			}
			var _this = this;
			function moveCallback() {
				view.moveNode(_this.setting, targetNode, node, moveType, false, isSilent);
			}
			if (tools.canAsync(this.setting, targetNode) && moveType === consts.move.TYPE_INNER) {
				view.asyncNode(this.setting, targetNode, isSilent, moveCallback);
			} else {
				moveCallback();
			}
			return node;
		}
		/**
		 * Edit mode and normal mode switch.
		 * @method setEditable
		 * @param {Boolean} editable true means: set zTree to edit mode.false means: set zTree to normal mode.
		 */
		zTreeTools.setEditable = function(editable) {
			this.setting.edit.enable = editable;
			return this.refresh();
		}
	},
	//method of operate data
	_data = {
		setSonNodeLevel: function(setting, parentNode, node) {
			if (!node) return;
			var childKey = setting.data.key.children;
			node.level = (parentNode)? parentNode.level + 1 : 0;
			if (!node[childKey]) return;
			for (var i = 0, l = node[childKey].length; i < l; i++) {
				if (node[childKey][i]) data.setSonNodeLevel(setting, node, node[childKey][i]);
			}
		}
	},
	//method of event proxy
	_event = {

	},
	//method of event handler
	_handler = {
		onHoverOverNode: function(event, node) {
			var setting = data.getSetting(event.data.treeId),
			root = data.getRoot(setting);
			if (root.curHoverNode != node) {
				_handler.onHoverOutNode(event);
			}
			root.curHoverNode = node;
			view.addHoverDom(setting, node);
		},
		onHoverOutNode: function(event, node) {
			var setting = data.getSetting(event.data.treeId),
			root = data.getRoot(setting);
			if (root.curHoverNode && !data.isSelectedNode(setting, root.curHoverNode)) {
				view.removeTreeDom(setting, root.curHoverNode);
				root.curHoverNode = null;
			}
		},
		onMousedownNode: function(eventMouseDown, _node) {
			var i,l,
			setting = data.getSetting(eventMouseDown.data.treeId),
			root = data.getRoot(setting), roots = data.getRoots();
			//right click can't drag & drop
			if (eventMouseDown.button == 2 || !setting.edit.enable || (!setting.edit.drag.isCopy && !setting.edit.drag.isMove)) return true;

			//input of edit node name can't drag & drop
			var target = eventMouseDown.target,
			_nodes = data.getRoot(setting).curSelectedList,
			nodes = [];
			if (!data.isSelectedNode(setting, _node)) {
				nodes = [_node];
			} else {
				for (i=0, l=_nodes.length; i<l; i++) {
					if (_nodes[i].editNameFlag && tools.eqs(target.tagName, "input") && target.getAttribute("treeNode"+consts.id.INPUT) !== null) {
						return true;
					}
					nodes.push(_nodes[i]);
					if (nodes[0].parentTId !== _nodes[i].parentTId) {
						nodes = [_node];
						break;
					}
				}
			}

			view.editNodeBlur = true;
			view.cancelCurEditNode(setting);

			var doc = $(setting.treeObj.get(0).ownerDocument),
			body = $(setting.treeObj.get(0).ownerDocument.body), curNode, tmpArrow, tmpTarget,
			isOtherTree = false,
			targetSetting = setting,
			sourceSetting = setting,
			preNode, nextNode,
			preTmpTargetNodeId = null,
			preTmpMoveType = null,
			tmpTargetNodeId = null,
			moveType = consts.move.TYPE_INNER,
			mouseDownX = eventMouseDown.clientX,
			mouseDownY = eventMouseDown.clientY,
			startTime = (new Date()).getTime();

			if (tools.uCanDo(setting)) {
				doc.bind("mousemove", _docMouseMove);
			}
			function _docMouseMove(event) {
				//avoid start drag after click node
				if (root.dragFlag == 0 && Math.abs(mouseDownX - event.clientX) < setting.edit.drag.minMoveSize
					&& Math.abs(mouseDownY - event.clientY) < setting.edit.drag.minMoveSize) {
					return true;
				}
				var i, l, tmpNode, tmpDom, tmpNodes,
				childKey = setting.data.key.children;
				body.css("cursor", "pointer");

				if (root.dragFlag == 0) {
					if (tools.apply(setting.callback.beforeDrag, [setting.treeId, nodes], true) == false) {
						_docMouseUp(event);
						return true;
					}

					for (i=0, l=nodes.length; i<l; i++) {
						if (i==0) {
							root.dragNodeShowBefore = [];
						}
						tmpNode = nodes[i];
						if (tmpNode.isParent && tmpNode.open) {
							view.expandCollapseNode(setting, tmpNode, !tmpNode.open);
							root.dragNodeShowBefore[tmpNode.tId] = true;
						} else {
							root.dragNodeShowBefore[tmpNode.tId] = false;
						}
					}

					root.dragFlag = 1;
					roots.showHoverDom = false;
					tools.showIfameMask(setting, true);

					//sort
					var isOrder = true, lastIndex = -1;
					if (nodes.length>1) {
						var pNodes = nodes[0].parentTId ? nodes[0].getParentNode()[childKey] : data.getNodes(setting);
						tmpNodes = [];
						for (i=0, l=pNodes.length; i<l; i++) {
							if (root.dragNodeShowBefore[pNodes[i].tId] !== undefined) {
								if (isOrder && lastIndex > -1 && (lastIndex+1) !== i) {
									isOrder = false;
								}
								tmpNodes.push(pNodes[i]);
								lastIndex = i;
							}
							if (nodes.length === tmpNodes.length) {
								nodes = tmpNodes;
								break;
							}
						}
					}
					if (isOrder) {
						preNode = nodes[0].getPreNode();
						nextNode = nodes[nodes.length-1].getNextNode();
					}

					//set node in selected
					curNode = $$("<ul class='zTreeDragUL'></ul>", setting);
					for (i=0, l=nodes.length; i<l; i++) {
						tmpNode = nodes[i];
						tmpNode.editNameFlag = false;
						view.selectNode(setting, tmpNode, i>0);
						view.removeTreeDom(setting, tmpNode);

						if (i > setting.edit.drag.maxShowNodeNum-1) {
							continue;
						}

						tmpDom = $$("<li id='"+ tmpNode.tId +"_tmp'></li>", setting);
						tmpDom.append($$(tmpNode, consts.id.A, setting).clone());
						tmpDom.css("padding", "0");
						tmpDom.children("#" + tmpNode.tId + consts.id.A).removeClass(consts.node.CURSELECTED);
						curNode.append(tmpDom);
						if (i == setting.edit.drag.maxShowNodeNum-1) {
							tmpDom = $$("<li id='"+ tmpNode.tId +"_moretmp'><a>  ...  </a></li>", setting);
							curNode.append(tmpDom);
						}
					}
					curNode.attr("id", nodes[0].tId + consts.id.UL + "_tmp");
					curNode.addClass(setting.treeObj.attr("class"));
					curNode.appendTo(body);

					tmpArrow = $$("<span class='tmpzTreeMove_arrow'></span>", setting);
					tmpArrow.attr("id", "zTreeMove_arrow_tmp");
					tmpArrow.appendTo(body);

					setting.treeObj.trigger(consts.event.DRAG, [event, setting.treeId, nodes]);
				}

				if (root.dragFlag == 1) {
					if (tmpTarget && tmpArrow.attr("id") == event.target.id && tmpTargetNodeId && (event.clientX + doc.scrollLeft()+2) > ($("#" + tmpTargetNodeId + consts.id.A, tmpTarget).offset().left)) {
						var xT = $("#" + tmpTargetNodeId + consts.id.A, tmpTarget);
						event.target = (xT.length > 0) ? xT.get(0) : event.target;
					} else if (tmpTarget) {
						tmpTarget.removeClass(consts.node.TMPTARGET_TREE);
						if (tmpTargetNodeId) $("#" + tmpTargetNodeId + consts.id.A, tmpTarget).removeClass(consts.node.TMPTARGET_NODE + "_" + consts.move.TYPE_PREV)
							.removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_NEXT).removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_INNER);
					}
					tmpTarget = null;
					tmpTargetNodeId = null;

					//judge drag & drop in multi ztree
					isOtherTree = false;
					targetSetting = setting;
					var settings = data.getSettings();
					for (var s in settings) {
						if (settings[s].treeId && settings[s].edit.enable && settings[s].treeId != setting.treeId
							&& (event.target.id == settings[s].treeId || $(event.target).parents("#" + settings[s].treeId).length>0)) {
							isOtherTree = true;
							targetSetting = settings[s];
						}
					}

					var docScrollTop = doc.scrollTop(),
					docScrollLeft = doc.scrollLeft(),
					treeOffset = targetSetting.treeObj.offset(),
					scrollHeight = targetSetting.treeObj.get(0).scrollHeight,
					scrollWidth = targetSetting.treeObj.get(0).scrollWidth,
					dTop = (event.clientY + docScrollTop - treeOffset.top),
					dBottom = (targetSetting.treeObj.height() + treeOffset.top - event.clientY - docScrollTop),
					dLeft = (event.clientX + docScrollLeft - treeOffset.left),
					dRight = (targetSetting.treeObj.width() + treeOffset.left - event.clientX - docScrollLeft),
					isTop = (dTop < setting.edit.drag.borderMax && dTop > setting.edit.drag.borderMin),
					isBottom = (dBottom < setting.edit.drag.borderMax && dBottom > setting.edit.drag.borderMin),
					isLeft = (dLeft < setting.edit.drag.borderMax && dLeft > setting.edit.drag.borderMin),
					isRight = (dRight < setting.edit.drag.borderMax && dRight > setting.edit.drag.borderMin),
					isTreeInner = dTop > setting.edit.drag.borderMin && dBottom > setting.edit.drag.borderMin && dLeft > setting.edit.drag.borderMin && dRight > setting.edit.drag.borderMin,
					isTreeTop = (isTop && targetSetting.treeObj.scrollTop() <= 0),
					isTreeBottom = (isBottom && (targetSetting.treeObj.scrollTop() + targetSetting.treeObj.height()+10) >= scrollHeight),
					isTreeLeft = (isLeft && targetSetting.treeObj.scrollLeft() <= 0),
					isTreeRight = (isRight && (targetSetting.treeObj.scrollLeft() + targetSetting.treeObj.width()+10) >= scrollWidth);

					if (event.target && tools.isChildOrSelf(event.target, targetSetting.treeId)) {
						//get node <li> dom
						var targetObj = event.target;
						while (targetObj && targetObj.tagName && !tools.eqs(targetObj.tagName, "li") && targetObj.id != targetSetting.treeId) {
							targetObj = targetObj.parentNode;
						}

						var canMove = true;
						//don't move to self or children of self
						for (i=0, l=nodes.length; i<l; i++) {
							tmpNode = nodes[i];
							if (targetObj.id === tmpNode.tId) {
								canMove = false;
								break;
							} else if ($$(tmpNode, setting).find("#" + targetObj.id).length > 0) {
								canMove = false;
								break;
							}
						}
						if (canMove && event.target && tools.isChildOrSelf(event.target, targetObj.id + consts.id.A)) {
							tmpTarget = $(targetObj);
							tmpTargetNodeId = targetObj.id;
						}
					}

					//the mouse must be in zTree
					tmpNode = nodes[0];
					if (isTreeInner && tools.isChildOrSelf(event.target, targetSetting.treeId)) {
						//judge mouse move in root of ztree
						if (!tmpTarget && (event.target.id == targetSetting.treeId || isTreeTop || isTreeBottom || isTreeLeft || isTreeRight) && (isOtherTree || (!isOtherTree && tmpNode.parentTId))) {
							tmpTarget = targetSetting.treeObj;
						}
						//auto scroll top
						if (isTop) {
							targetSetting.treeObj.scrollTop(targetSetting.treeObj.scrollTop()-10);
						} else if (isBottom)  {
							targetSetting.treeObj.scrollTop(targetSetting.treeObj.scrollTop()+10);
						}
						if (isLeft) {
							targetSetting.treeObj.scrollLeft(targetSetting.treeObj.scrollLeft()-10);
						} else if (isRight) {
							targetSetting.treeObj.scrollLeft(targetSetting.treeObj.scrollLeft()+10);
						}
						//auto scroll left
						if (tmpTarget && tmpTarget != targetSetting.treeObj && tmpTarget.offset().left < targetSetting.treeObj.offset().left) {
							targetSetting.treeObj.scrollLeft(targetSetting.treeObj.scrollLeft()+ tmpTarget.offset().left - targetSetting.treeObj.offset().left);
						}
					}

					curNode.css({
						"top": (event.clientY + docScrollTop + 3) + "px",
						"left": (event.clientX + docScrollLeft + 3) + "px"
					});

					var dX = 0;
					var dY = 0;
					if (tmpTarget && tmpTarget.attr("id")!=targetSetting.treeId) {
						var tmpTargetNode = tmpTargetNodeId == null ? null: data.getNodeCache(targetSetting, tmpTargetNodeId),
						isCopy = ((event.ctrlKey || event.metaKey) && setting.edit.drag.isMove && setting.edit.drag.isCopy) || (!setting.edit.drag.isMove && setting.edit.drag.isCopy),
						isPrev = !!(preNode && tmpTargetNodeId === preNode.tId),
						isNext = !!(nextNode && tmpTargetNodeId === nextNode.tId),
						isInner = (tmpNode.parentTId && tmpNode.parentTId == tmpTargetNodeId),
						canPrev = (isCopy || !isNext) && tools.apply(targetSetting.edit.drag.prev, [targetSetting.treeId, nodes, tmpTargetNode], !!targetSetting.edit.drag.prev),
						canNext = (isCopy || !isPrev) && tools.apply(targetSetting.edit.drag.next, [targetSetting.treeId, nodes, tmpTargetNode], !!targetSetting.edit.drag.next),
						canInner = (isCopy || !isInner) && !(targetSetting.data.keep.leaf && !tmpTargetNode.isParent) && tools.apply(targetSetting.edit.drag.inner, [targetSetting.treeId, nodes, tmpTargetNode], !!targetSetting.edit.drag.inner);
						if (!canPrev && !canNext && !canInner) {
							tmpTarget = null;
							tmpTargetNodeId = "";
							moveType = consts.move.TYPE_INNER;
							tmpArrow.css({
								"display":"none"
							});
							if (window.zTreeMoveTimer) {
								clearTimeout(window.zTreeMoveTimer);
								window.zTreeMoveTargetNodeTId = null
							}
						} else {
							var tmpTargetA = $("#" + tmpTargetNodeId + consts.id.A, tmpTarget),
							tmpNextA = tmpTargetNode.isLastNode ? null : $("#" + tmpTargetNode.getNextNode().tId + consts.id.A, tmpTarget.next()),
							tmpTop = tmpTargetA.offset().top,
							tmpLeft = tmpTargetA.offset().left,
							prevPercent = canPrev ? (canInner ? 0.25 : (canNext ? 0.5 : 1) ) : -1,
							nextPercent = canNext ? (canInner ? 0.75 : (canPrev ? 0.5 : 0) ) : -1,
							dY_percent = (event.clientY + docScrollTop - tmpTop)/tmpTargetA.height();
							if ((prevPercent==1 ||dY_percent<=prevPercent && dY_percent>=-.2) && canPrev) {
								dX = 1 - tmpArrow.width();
								dY = tmpTop - tmpArrow.height()/2;
								moveType = consts.move.TYPE_PREV;
							} else if ((nextPercent==0 || dY_percent>=nextPercent && dY_percent<=1.2) && canNext) {
								dX = 1 - tmpArrow.width();
								dY = (tmpNextA == null || (tmpTargetNode.isParent && tmpTargetNode.open)) ? (tmpTop + tmpTargetA.height() - tmpArrow.height()/2) : (tmpNextA.offset().top - tmpArrow.height()/2);
								moveType = consts.move.TYPE_NEXT;
							}else {
								dX = 5 - tmpArrow.width();
								dY = tmpTop;
								moveType = consts.move.TYPE_INNER;
							}
							tmpArrow.css({
								"display":"block",
								"top": dY + "px",
								"left": (tmpLeft + dX) + "px"
							});
							tmpTargetA.addClass(consts.node.TMPTARGET_NODE + "_" + moveType);

							if (preTmpTargetNodeId != tmpTargetNodeId || preTmpMoveType != moveType) {
								startTime = (new Date()).getTime();
							}
							if (tmpTargetNode && tmpTargetNode.isParent && moveType == consts.move.TYPE_INNER) {
								var startTimer = true;
								if (window.zTreeMoveTimer && window.zTreeMoveTargetNodeTId !== tmpTargetNode.tId) {
									clearTimeout(window.zTreeMoveTimer);
									window.zTreeMoveTargetNodeTId = null;
								}else if (window.zTreeMoveTimer && window.zTreeMoveTargetNodeTId === tmpTargetNode.tId) {
									startTimer = false;
								}
								if (startTimer) {
									window.zTreeMoveTimer = setTimeout(function() {
										if (moveType != consts.move.TYPE_INNER) return;
										if (tmpTargetNode && tmpTargetNode.isParent && !tmpTargetNode.open && (new Date()).getTime() - startTime > targetSetting.edit.drag.autoOpenTime
											&& tools.apply(targetSetting.callback.beforeDragOpen, [targetSetting.treeId, tmpTargetNode], true)) {
											view.switchNode(targetSetting, tmpTargetNode);
											if (targetSetting.edit.drag.autoExpandTrigger) {
												targetSetting.treeObj.trigger(consts.event.EXPAND, [targetSetting.treeId, tmpTargetNode]);
											}
										}
									}, targetSetting.edit.drag.autoOpenTime+50);
									window.zTreeMoveTargetNodeTId = tmpTargetNode.tId;
								}
							}
						}
					} else {
						moveType = consts.move.TYPE_INNER;
						if (tmpTarget && tools.apply(targetSetting.edit.drag.inner, [targetSetting.treeId, nodes, null], !!targetSetting.edit.drag.inner)) {
							tmpTarget.addClass(consts.node.TMPTARGET_TREE);
						} else {
							tmpTarget = null;
						}
						tmpArrow.css({
							"display":"none"
						});
						if (window.zTreeMoveTimer) {
							clearTimeout(window.zTreeMoveTimer);
							window.zTreeMoveTargetNodeTId = null;
						}
					}
					preTmpTargetNodeId = tmpTargetNodeId;
					preTmpMoveType = moveType;

					setting.treeObj.trigger(consts.event.DRAGMOVE, [event, setting.treeId, nodes]);
				}
				return false;
			}

			doc.bind("mouseup", _docMouseUp);
			function _docMouseUp(event) {
				if (window.zTreeMoveTimer) {
					clearTimeout(window.zTreeMoveTimer);
					window.zTreeMoveTargetNodeTId = null;
				}
				preTmpTargetNodeId = null;
				preTmpMoveType = null;
				doc.unbind("mousemove", _docMouseMove);
				doc.unbind("mouseup", _docMouseUp);
				doc.unbind("selectstart", _docSelect);
				body.css("cursor", "auto");
				if (tmpTarget) {
					tmpTarget.removeClass(consts.node.TMPTARGET_TREE);
					if (tmpTargetNodeId) $("#" + tmpTargetNodeId + consts.id.A, tmpTarget).removeClass(consts.node.TMPTARGET_NODE + "_" + consts.move.TYPE_PREV)
							.removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_NEXT).removeClass(consts.node.TMPTARGET_NODE + "_" + _consts.move.TYPE_INNER);
				}
				tools.showIfameMask(setting, false);

				roots.showHoverDom = true;
				if (root.dragFlag == 0) return;
				root.dragFlag = 0;

				var i, l, tmpNode;
				for (i=0, l=nodes.length; i<l; i++) {
					tmpNode = nodes[i];
					if (tmpNode.isParent && root.dragNodeShowBefore[tmpNode.tId] && !tmpNode.open) {
						view.expandCollapseNode(setting, tmpNode, !tmpNode.open);
						delete root.dragNodeShowBefore[tmpNode.tId];
					}
				}

				if (curNode) curNode.remove();
				if (tmpArrow) tmpArrow.remove();

				var isCopy = ((event.ctrlKey || event.metaKey) && setting.edit.drag.isMove && setting.edit.drag.isCopy) || (!setting.edit.drag.isMove && setting.edit.drag.isCopy);
				if (!isCopy && tmpTarget && tmpTargetNodeId && nodes[0].parentTId && tmpTargetNodeId==nodes[0].parentTId && moveType == consts.move.TYPE_INNER) {
					tmpTarget = null;
				}
				if (tmpTarget) {
					var dragTargetNode = tmpTargetNodeId == null ? null: data.getNodeCache(targetSetting, tmpTargetNodeId);
					if (tools.apply(setting.callback.beforeDrop, [targetSetting.treeId, nodes, dragTargetNode, moveType, isCopy], true) == false) {
						view.selectNodes(sourceSetting, nodes);
						return;
					}
					var newNodes = isCopy ? tools.clone(nodes) : nodes;

					function dropCallback() {
						if (isOtherTree) {
							if (!isCopy) {
								for(var i=0, l=nodes.length; i<l; i++) {
									view.removeNode(setting, nodes[i]);
								}
							}
							if (moveType == consts.move.TYPE_INNER) {
								view.addNodes(targetSetting, dragTargetNode, newNodes);
							} else {
								view.addNodes(targetSetting, dragTargetNode.getParentNode(), newNodes);
								if (moveType == consts.move.TYPE_PREV) {
									for (i=0, l=newNodes.length; i<l; i++) {
										view.moveNode(targetSetting, dragTargetNode, newNodes[i], moveType, false);
									}
								} else {
									for (i=-1, l=newNodes.length-1; i<l; l--) {
										view.moveNode(targetSetting, dragTargetNode, newNodes[l], moveType, false);
									}
								}
							}
						} else {
							if (isCopy && moveType == consts.move.TYPE_INNER) {
								view.addNodes(targetSetting, dragTargetNode, newNodes);
							} else {
								if (isCopy) {
									view.addNodes(targetSetting, dragTargetNode.getParentNode(), newNodes);
								}
								if (moveType != consts.move.TYPE_NEXT) {
									for (i=0, l=newNodes.length; i<l; i++) {
										view.moveNode(targetSetting, dragTargetNode, newNodes[i], moveType, false);
									}
								} else {
									for (i=-1, l=newNodes.length-1; i<l; l--) {
										view.moveNode(targetSetting, dragTargetNode, newNodes[l], moveType, false);
									}
								}
							}
						}
						view.selectNodes(targetSetting, newNodes);
						$$(newNodes[0], setting).focus().blur();

						setting.treeObj.trigger(consts.event.DROP, [event, targetSetting.treeId, newNodes, dragTargetNode, moveType, isCopy]);
					}

					if (moveType == consts.move.TYPE_INNER && tools.canAsync(targetSetting, dragTargetNode)) {
						view.asyncNode(targetSetting, dragTargetNode, false, dropCallback);
					} else {
						dropCallback();
					}

				} else {
					view.selectNodes(sourceSetting, nodes);
					setting.treeObj.trigger(consts.event.DROP, [event, setting.treeId, nodes, null, null, null]);
				}
			}

			doc.bind("selectstart", _docSelect);
			function _docSelect() {
				return false;
			}

			//Avoid FireFox's Bug
			//If zTree Div CSS set 'overflow', so drag node outside of zTree, and event.target is error.
			if(eventMouseDown.preventDefault) {
				eventMouseDown.preventDefault();
			}
			return true;
		}
	},
	//method of tools for zTree
	_tools = {
		getAbs: function (obj) {
			var oRect = obj.getBoundingClientRect(),
			scrollTop = document.body.scrollTop+document.documentElement.scrollTop,
			scrollLeft = document.body.scrollLeft+document.documentElement.scrollLeft;
			return [oRect.left+scrollLeft,oRect.top+scrollTop];
		},
		inputFocus: function(inputObj) {
			if (inputObj.get(0)) {
				inputObj.focus();
				tools.setCursorPosition(inputObj.get(0), inputObj.val().length);
			}
		},
		inputSelect: function(inputObj) {
			if (inputObj.get(0)) {
				inputObj.focus();
				inputObj.select();
			}
		},
		setCursorPosition: function(obj, pos){
			if(obj.setSelectionRange) {
				obj.focus();
				obj.setSelectionRange(pos,pos);
			} else if (obj.createTextRange) {
				var range = obj.createTextRange();
				range.collapse(true);
				range.moveEnd('character', pos);
				range.moveStart('character', pos);
				range.select();
			}
		},
		showIfameMask: function(setting, showSign) {
			var root = data.getRoot(setting);
			//clear full mask
			while (root.dragMaskList.length > 0) {
				root.dragMaskList[0].remove();
				root.dragMaskList.shift();
			}
			if (showSign) {
				//show mask
				var iframeList = $$("iframe", setting);
				for (var i = 0, l = iframeList.length; i < l; i++) {
					var obj = iframeList.get(i),
					r = tools.getAbs(obj),
					dragMask = $$("<div id='zTreeMask_" + i + "' class='zTreeMask' style='top:" + r[1] + "px; left:" + r[0] + "px; width:" + obj.offsetWidth + "px; height:" + obj.offsetHeight + "px;'></div>", setting);
					dragMask.appendTo($$("body", setting));
					root.dragMaskList.push(dragMask);
				}
			}
		}
	},
	//method of operate ztree dom
	_view = {
		addEditBtn: function(setting, node) {
			if (node.editNameFlag || $$(node, consts.id.EDIT, setting).length > 0) {
				return;
			}
			if (!tools.apply(setting.edit.showRenameBtn, [setting.treeId, node], setting.edit.showRenameBtn)) {
				return;
			}
			var aObj = $$(node, consts.id.A, setting),
			editStr = "<span class='" + consts.className.BUTTON + " edit' id='" + node.tId + consts.id.EDIT + "' title='"+tools.apply(setting.edit.renameTitle, [setting.treeId, node], setting.edit.renameTitle)+"' treeNode"+consts.id.EDIT+" style='display:none;'></span>";
			aObj.append(editStr);

			$$(node, consts.id.EDIT, setting).bind('click',
				function() {
					if (!tools.uCanDo(setting) || tools.apply(setting.callback.beforeEditName, [setting.treeId, node], true) == false) return false;
					view.editNode(setting, node);
					return false;
				}
				).show();
		},
		addRemoveBtn: function(setting, node) {
			if (node.editNameFlag || $$(node, consts.id.REMOVE, setting).length > 0) {
				return;
			}
			if (!tools.apply(setting.edit.showRemoveBtn, [setting.treeId, node], setting.edit.showRemoveBtn)) {
				return;
			}
			var aObj = $$(node, consts.id.A, setting),
			removeStr = "<span class='" + consts.className.BUTTON + " remove' id='" + node.tId + consts.id.REMOVE + "' title='"+tools.apply(setting.edit.removeTitle, [setting.treeId, node], setting.edit.removeTitle)+"' treeNode"+consts.id.REMOVE+" style='display:none;'></span>";
			aObj.append(removeStr);

			$$(node, consts.id.REMOVE, setting).bind('click',
				function() {
					if (!tools.uCanDo(setting) || tools.apply(setting.callback.beforeRemove, [setting.treeId, node], true) == false) return false;
					view.removeNode(setting, node);
					setting.treeObj.trigger(consts.event.REMOVE, [setting.treeId, node]);
					return false;
				}
				).bind('mousedown',
				function(eventMouseDown) {
					return true;
				}
				).show();
		},
		addHoverDom: function(setting, node) {
			if (data.getRoots().showHoverDom) {
				node.isHover = true;
				if (setting.edit.enable) {
					view.addEditBtn(setting, node);
					view.addRemoveBtn(setting, node);
				}
				tools.apply(setting.view.addHoverDom, [setting.treeId, node]);
			}
		},
		cancelCurEditNode: function (setting, forceName, isCancel) {
			var root = data.getRoot(setting),
			nameKey = setting.data.key.name,
			node = root.curEditNode;

			if (node) {
				var inputObj = root.curEditInput,
				newName = forceName ? forceName:(isCancel ? node[nameKey]: inputObj.val());
				if (tools.apply(setting.callback.beforeRename, [setting.treeId, node, newName, isCancel], true) === false) {
					return false;
				} else {
					node[nameKey] = newName;
					setting.treeObj.trigger(consts.event.RENAME, [setting.treeId, node, isCancel]);
				}
				var aObj = $$(node, consts.id.A, setting);
				aObj.removeClass(consts.node.CURSELECTED_EDIT);
				inputObj.unbind();
				view.setNodeName(setting, node);
				node.editNameFlag = false;
				root.curEditNode = null;
				root.curEditInput = null;
				view.selectNode(setting, node, false);
			}
			root.noSelection = true;
			return true;
		},
		editNode: function(setting, node) {
			var root = data.getRoot(setting);
			view.editNodeBlur = false;
			if (data.isSelectedNode(setting, node) && root.curEditNode == node && node.editNameFlag) {
				setTimeout(function() {tools.inputFocus(root.curEditInput);}, 0);
				return;
			}
			var nameKey = setting.data.key.name;
			node.editNameFlag = true;
			view.removeTreeDom(setting, node);
			view.cancelCurEditNode(setting);
			view.selectNode(setting, node, false);
			$$(node, consts.id.SPAN, setting).html("<input type=text class='rename' id='" + node.tId + consts.id.INPUT + "' treeNode" + consts.id.INPUT + " >");
			var inputObj = $$(node, consts.id.INPUT, setting);
			inputObj.attr("value", node[nameKey]);
			if (setting.edit.editNameSelectAll) {
				tools.inputSelect(inputObj);
			} else {
				tools.inputFocus(inputObj);
			}

			inputObj.bind('blur', function(event) {
				if (!view.editNodeBlur) {
					view.cancelCurEditNode(setting);
				}
			}).bind('keydown', function(event) {
				if (event.keyCode=="13") {
					view.editNodeBlur = true;
					view.cancelCurEditNode(setting);
				} else if (event.keyCode=="27") {
					view.cancelCurEditNode(setting, null, true);
				}
			}).bind('click', function(event) {
				return false;
			}).bind('dblclick', function(event) {
				return false;
			});

			$$(node, consts.id.A, setting).addClass(consts.node.CURSELECTED_EDIT);
			root.curEditInput = inputObj;
			root.noSelection = false;
			root.curEditNode = node;
		},
		moveNode: function(setting, targetNode, node, moveType, animateFlag, isSilent) {
			var root = data.getRoot(setting),
			childKey = setting.data.key.children;
			if (targetNode == node) return;
			if (setting.data.keep.leaf && targetNode && !targetNode.isParent && moveType == consts.move.TYPE_INNER) return;
			var oldParentNode = (node.parentTId ? node.getParentNode(): root),
			targetNodeIsRoot = (targetNode === null || targetNode == root);
			if (targetNodeIsRoot && targetNode === null) targetNode = root;
			if (targetNodeIsRoot) moveType = consts.move.TYPE_INNER;
			var targetParentNode = (targetNode.parentTId ? targetNode.getParentNode() : root);

			if (moveType != consts.move.TYPE_PREV && moveType != consts.move.TYPE_NEXT) {
				moveType = consts.move.TYPE_INNER;
			}

			if (moveType == consts.move.TYPE_INNER) {
				if (targetNodeIsRoot) {
					//parentTId of root node is null
					node.parentTId = null;
				} else {
					if (!targetNode.isParent) {
						targetNode.isParent = true;
						targetNode.open = !!targetNode.open;
						view.setNodeLineIcos(setting, targetNode);
					}
					node.parentTId = targetNode.tId;
				}
			}

			//move node Dom
			var targetObj, target_ulObj;
			if (targetNodeIsRoot) {
				targetObj = setting.treeObj;
				target_ulObj = targetObj;
			} else {
				if (!isSilent && moveType == consts.move.TYPE_INNER) {
					view.expandCollapseNode(setting, targetNode, true, false);
				} else if (!isSilent) {
					view.expandCollapseNode(setting, targetNode.getParentNode(), true, false);
				}
				targetObj = $$(targetNode, setting);
				target_ulObj = $$(targetNode, consts.id.UL, setting);
				if (!!targetObj.get(0) && !target_ulObj.get(0)) {
					var ulstr = [];
					view.makeUlHtml(setting, targetNode, ulstr, '');
					targetObj.append(ulstr.join(''));
				}
				target_ulObj = $$(targetNode, consts.id.UL, setting);
			}
			var nodeDom = $$(node, setting);
			if (!nodeDom.get(0)) {
				nodeDom = view.appendNodes(setting, node.level, [node], null, false, true).join('');
			} else if (!targetObj.get(0)) {
				nodeDom.remove();
			}
			if (target_ulObj.get(0) && moveType == consts.move.TYPE_INNER) {
				target_ulObj.append(nodeDom);
			} else if (targetObj.get(0) && moveType == consts.move.TYPE_PREV) {
				targetObj.before(nodeDom);
			} else if (targetObj.get(0) && moveType == consts.move.TYPE_NEXT) {
				targetObj.after(nodeDom);
			}

			//repair the data after move
			var i,l,
			tmpSrcIndex = -1,
			tmpTargetIndex = 0,
			oldNeighbor = null,
			newNeighbor = null,
			oldLevel = node.level;
			if (node.isFirstNode) {
				tmpSrcIndex = 0;
				if (oldParentNode[childKey].length > 1 ) {
					oldNeighbor = oldParentNode[childKey][1];
					oldNeighbor.isFirstNode = true;
				}
			} else if (node.isLastNode) {
				tmpSrcIndex = oldParentNode[childKey].length -1;
				oldNeighbor = oldParentNode[childKey][tmpSrcIndex - 1];
				oldNeighbor.isLastNode = true;
			} else {
				for (i = 0, l = oldParentNode[childKey].length; i < l; i++) {
					if (oldParentNode[childKey][i].tId == node.tId) {
						tmpSrcIndex = i;
						break;
					}
				}
			}
			if (tmpSrcIndex >= 0) {
				oldParentNode[childKey].splice(tmpSrcIndex, 1);
			}
			if (moveType != consts.move.TYPE_INNER) {
				for (i = 0, l = targetParentNode[childKey].length; i < l; i++) {
					if (targetParentNode[childKey][i].tId == targetNode.tId) tmpTargetIndex = i;
				}
			}
			if (moveType == consts.move.TYPE_INNER) {
				if (!targetNode[childKey]) targetNode[childKey] = new Array();
				if (targetNode[childKey].length > 0) {
					newNeighbor = targetNode[childKey][targetNode[childKey].length - 1];
					newNeighbor.isLastNode = false;
				}
				targetNode[childKey].splice(targetNode[childKey].length, 0, node);
				node.isLastNode = true;
				node.isFirstNode = (targetNode[childKey].length == 1);
			} else if (targetNode.isFirstNode && moveType == consts.move.TYPE_PREV) {
				targetParentNode[childKey].splice(tmpTargetIndex, 0, node);
				newNeighbor = targetNode;
				newNeighbor.isFirstNode = false;
				node.parentTId = targetNode.parentTId;
				node.isFirstNode = true;
				node.isLastNode = false;

			} else if (targetNode.isLastNode && moveType == consts.move.TYPE_NEXT) {
				targetParentNode[childKey].splice(tmpTargetIndex + 1, 0, node);
				newNeighbor = targetNode;
				newNeighbor.isLastNode = false;
				node.parentTId = targetNode.parentTId;
				node.isFirstNode = false;
				node.isLastNode = true;

			} else {
				if (moveType == consts.move.TYPE_PREV) {
					targetParentNode[childKey].splice(tmpTargetIndex, 0, node);
				} else {
					targetParentNode[childKey].splice(tmpTargetIndex + 1, 0, node);
				}
				node.parentTId = targetNode.parentTId;
				node.isFirstNode = false;
				node.isLastNode = false;
			}
			data.fixPIdKeyValue(setting, node);
			data.setSonNodeLevel(setting, node.getParentNode(), node);

			//repair node what been moved
			view.setNodeLineIcos(setting, node);
			view.repairNodeLevelClass(setting, node, oldLevel)

			//repair node's old parentNode dom
			if (!setting.data.keep.parent && oldParentNode[childKey].length < 1) {
				//old parentNode has no child nodes
				oldParentNode.isParent = false;
				oldParentNode.open = false;
				var tmp_ulObj = $$(oldParentNode, consts.id.UL, setting),
				tmp_switchObj = $$(oldParentNode, consts.id.SWITCH, setting),
				tmp_icoObj = $$(oldParentNode, consts.id.ICON, setting);
				view.replaceSwitchClass(oldParentNode, tmp_switchObj, consts.folder.DOCU);
				view.replaceIcoClass(oldParentNode, tmp_icoObj, consts.folder.DOCU);
				tmp_ulObj.css("display", "none");

			} else if (oldNeighbor) {
				//old neigbor node
				view.setNodeLineIcos(setting, oldNeighbor);
			}

			//new neigbor node
			if (newNeighbor) {
				view.setNodeLineIcos(setting, newNeighbor);
			}

			//repair checkbox / radio
			if (!!setting.check && setting.check.enable && view.repairChkClass) {
				view.repairChkClass(setting, oldParentNode);
				view.repairParentChkClassWithSelf(setting, oldParentNode);
				if (oldParentNode != node.parent)
					view.repairParentChkClassWithSelf(setting, node);
			}

			//expand parents after move
			if (!isSilent) {
				view.expandCollapseParentNode(setting, node.getParentNode(), true, animateFlag);
			}
		},
		removeEditBtn: function(setting, node) {
			$$(node, consts.id.EDIT, setting).unbind().remove();
		},
		removeRemoveBtn: function(setting, node) {
			$$(node, consts.id.REMOVE, setting).unbind().remove();
		},
		removeTreeDom: function(setting, node) {
			node.isHover = false;
			view.removeEditBtn(setting, node);
			view.removeRemoveBtn(setting, node);
			tools.apply(setting.view.removeHoverDom, [setting.treeId, node]);
		},
		repairNodeLevelClass: function(setting, node, oldLevel) {
			if (oldLevel === node.level) return;
			var liObj = $$(node, setting),
			aObj = $$(node, consts.id.A, setting),
			ulObj = $$(node, consts.id.UL, setting),
			oldClass = consts.className.LEVEL + oldLevel,
			newClass = consts.className.LEVEL + node.level;
			liObj.removeClass(oldClass);
			liObj.addClass(newClass);
			aObj.removeClass(oldClass);
			aObj.addClass(newClass);
			ulObj.removeClass(oldClass);
			ulObj.addClass(newClass);
		},
		selectNodes : function(setting, nodes) {
			for (var i=0, l=nodes.length; i<l; i++) {
				view.selectNode(setting, nodes[i], i>0);
			}
		}
	},

	_z = {
		tools: _tools,
		view: _view,
		event: _event,
		data: _data
	};
	$.extend(true, $.fn.zTree.consts, _consts);
	$.extend(true, $.fn.zTree._z, _z);

	var zt = $.fn.zTree,
	tools = zt._z.tools,
	consts = zt.consts,
	view = zt._z.view,
	data = zt._z.data,
	event = zt._z.event,
	$$ = tools.$;

	data.exSetting(_setting);
	data.addInitBind(_bindEvent);
	data.addInitUnBind(_unbindEvent);
	data.addInitCache(_initCache);
	data.addInitNode(_initNode);
	data.addInitProxy(_eventProxy);
	data.addInitRoot(_initRoot);
	data.addZTreeTools(_zTreeTools);

	var _cancelPreSelectedNode = view.cancelPreSelectedNode;
	view.cancelPreSelectedNode = function (setting, node) {
		var list = data.getRoot(setting).curSelectedList;
		for (var i=0, j=list.length; i<j; i++) {
			if (!node || node === list[i]) {
				view.removeTreeDom(setting, list[i]);
				if (node) break;
			}
		}
		if (_cancelPreSelectedNode) _cancelPreSelectedNode.apply(view, arguments);
	}

	var _createNodes = view.createNodes;
	view.createNodes = function(setting, level, nodes, parentNode) {
		if (_createNodes) {
			_createNodes.apply(view, arguments);
		}
		if (!nodes) return;
		if (view.repairParentChkClassWithSelf) {
			view.repairParentChkClassWithSelf(setting, parentNode);
		}
	}

	var _makeNodeUrl = view.makeNodeUrl;
	view.makeNodeUrl = function(setting, node) {
		return setting.edit.enable ? null : (_makeNodeUrl.apply(view, arguments));
	}

	var _removeNode = view.removeNode;
	view.removeNode = function(setting, node) {
		var root = data.getRoot(setting);
		if (root.curEditNode === node) root.curEditNode = null;
		if (_removeNode) {
			_removeNode.apply(view, arguments);
		}
	}

	var _selectNode = view.selectNode;
	view.selectNode = function(setting, node, addFlag) {
		var root = data.getRoot(setting);
		if (data.isSelectedNode(setting, node) && root.curEditNode == node && node.editNameFlag) {
			return false;
		}
		if (_selectNode) _selectNode.apply(view, arguments);
		view.addHoverDom(setting, node);
		return true;
	}

	var _uCanDo = tools.uCanDo;
	tools.uCanDo = function(setting, e) {
		var root = data.getRoot(setting);
		if (e && (tools.eqs(e.type, "mouseover") || tools.eqs(e.type, "mouseout") || tools.eqs(e.type, "mousedown") || tools.eqs(e.type, "mouseup"))) {
			return true;
		}
		if (root.curEditNode) {
			view.editNodeBlur = false;
			root.curEditInput.focus();
		}
		return (!root.curEditNode) && (_uCanDo ? _uCanDo.apply(view, arguments) : true);
	}
}));